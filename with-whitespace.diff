Executing section Default...

.travis.yml
|  12| ••#•Create•two•diff•files,•and•upload•to•https://clbin.com
|    | [NORMAL] InvalidLinkBear:
|    | Broken link - unable to connect to https://clbin.com (HTTP Error: 404)

.travis.yml
|  17| ••-•cat•sans-whitespace.diff•|•curl•-F•'clbin=<-'•https://clbin.com
|    | [NORMAL] InvalidLinkBear:
|    | Broken link - unable to connect to https://clbin.com (HTTP Error: 404)

.travis.yml
|  19| ••-•cat•with-whitespace.diff•|•curl•-F•'clbin=<-'•https://clbin.com
|    | [NORMAL] InvalidLinkBear:
|    | Broken link - unable to connect to https://clbin.com (HTTP Error: 404)

.travis.yml
|  20| ••#•Upload•logs•to•https://clbin.com
|    | [NORMAL] InvalidLinkBear:
|    | Broken link - unable to connect to https://clbin.com (HTTP Error: 404)

.travis.yml
|  21| ••-•cat•coala-ci.log•|•curl•-F•'clbin=<-'•https://clbin.com
|    | [NORMAL] InvalidLinkBear:
|    | Broken link - unable to connect to https://clbin.com (HTTP Error: 404)
Executing section c++...
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-image.cpp
|    |++++| /app/C++/rotate-image.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: A list of lists of integers
|   8|   9|      * @return: Void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-image.cpp
|    |++++| /app/C++/rotate-image.cpp
|   7|   7|      * @param matrix: A list of lists of integers
|   8|   8|      * @return: Void
|   9|   9|      */
|  10|    |-    void rotate(vector<vector<int>> &matrix) {
|  11|    |-        const int n = matrix.size();
|  12|    |-        for (int i = 0; i < n / 2; ++i) {
|  13|    |-            for (int j = i; j < n - 1 - i; ++j) {
|  14|    |-                int tmp = matrix[i][j];
|  15|    |-                matrix[i][j] = matrix[n - 1 - j][i];
|  16|    |-                matrix[n - 1- j][i] = matrix[n - 1 - i][n - 1 - j];
|  17|    |-                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
|  18|    |-                matrix[j][n - 1 - i] = tmp;
|  19|    |-            }
|  20|    |-        }
|    |  10|+    void rotate (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        const int n = matrix.size ();
|    |  13|+        for (int i = 0; i < n / 2; ++i)
|    |  14|+          {
|    |  15|+              for (int j = i; j < n - 1 - i; ++j)
|    |  16|+                {
|    |  17|+                    int tmp = matrix[i][j];
|    |  18|+                      matrix[i][j] = matrix[n - 1 - j][i];
|    |  19|+                      matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
|    |  20|+                      matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
|    |  21|+                      matrix[j][n - 1 - i] = tmp;
|    |  22|+                }
|    |  23|+          }
|  21|  24|     }
|  22|  25| };
|  23|  26| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-image.cpp
|    |++++| /app/C++/rotate-image.cpp
|  21|  21|     }
|  22|  22| };
|  23|  23| 
|  24|    |-class Solution2 {
|  25|    |-public:
|    |  24|+class Solution2
|    |  25|+{
|    |  26|+  public:
|  26|  27|     /**
|  27|  28|      * @param matrix: A list of lists of integers
|  28|  29|      * @return: Void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-image.cpp
|    |++++| /app/C++/rotate-image.cpp
|  27|  27|      * @param matrix: A list of lists of integers
|  28|  28|      * @return: Void
|  29|  29|      */
|  30|    |-    void rotate(vector<vector<int>> &matrix) {
|  31|    |-        const int n = matrix.size();
|    |  30|+    void rotate (vector < vector < int >>&matrix)
|    |  31|+    {
|    |  32|+        const int n = matrix.size ();
|  32|  33|         // Anti-diagonal mirror.
|  33|    |-        for (int i = 0; i < n; ++i) {
|  34|    |-            for (int j = 0; j < n - i; ++j) {
|  35|    |-                swap(matrix[i][j], matrix[n - 1 - j][n - 1 - i]);
|  36|    |-            }
|  37|    |-        }
|    |  34|+        for (int i = 0; i < n; ++i)
|    |  35|+          {
|    |  36|+              for (int j = 0; j < n - i; ++j)
|    |  37|+                {
|    |  38|+                    swap (matrix[i][j], matrix[n - 1 - j][n - 1 - i]);
|    |  39|+                }
|    |  40|+          }
|  38|  41|         // Horizontal mirror.
|  39|    |-        for (int i = 0; i < n / 2; ++i) {
|  40|    |-            for (int j = 0; j < n; ++j) {
|  41|    |-                swap(matrix[i][j], matrix[n - 1 - i][j]);
|  42|    |-            }
|  43|    |-        }
|    |  42|+        for (int i = 0; i < n / 2; ++i)
|    |  43|+          {
|    |  44|+              for (int j = 0; j < n; ++j)
|    |  45|+                {
|    |  46|+                    swap (matrix[i][j], matrix[n - 1 - i][j]);
|    |  47|+                }
|    |  48|+          }
|  44|  49|     }
|  45|  50| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|   4| // Hash solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums1 an integer array
|   9|  10|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|   9|   9|      * @param nums2 an integer array
|  10|  10|      * @return an integer array
|  11|  11|      */
|  12|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  13|    |-        if (nums1.size() > nums2.size()) {
|  14|    |-            return intersection(nums2, nums1);
|  15|    |-        }
|    |  12|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  13|+    {
|    |  14|+        if (nums1.size () > nums2.size ())
|    |  15|+          {
|    |  16|+              return intersection (nums2, nums1);
|    |  17|+          }
|  16|  18| 
|  17|    |-        unordered_map<int, int> lookup;
|  18|    |-        for (const auto& i : nums1) {
|  19|    |-            ++lookup[i];
|  20|    |-        }
|    |  19|+        unordered_map < int, int >lookup;
|    |  20|+      for (const auto & i:nums1)
|    |  21|+          {
|    |  22|+              ++lookup[i];
|    |  23|+          }
|  21|  24| 
|  22|    |-        vector<int> result;
|  23|    |-        for (const auto& i : nums2) {
|  24|    |-            if (lookup[i] > 0) {
|  25|    |-                result.emplace_back(i);
|  26|    |-                --lookup[i];
|  27|    |-            }
|  28|    |-        }
|    |  25|+        vector < int >result;
|    |  26|+      for (const auto & i:nums2)
|    |  27|+          {
|    |  28|+              if (lookup[i] > 0)
|    |  29|+                {
|    |  30|+                    result.emplace_back (i);
|    |  31|+                    --lookup[i];
|    |  32|+                }
|    |  33|+          }
|  29|  34| 
|  30|  35|         return result;
|  31|  36|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  30|  30|         return result;
|  31|  31|     }
|  32|  32| };
|  33|    |-
|  34|  33| 
|  35|  34| // Time:  O(max(m, n) * log(max(m, n)))
|  36|  35| // Space: O(1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  35|  35| // Time:  O(max(m, n) * log(max(m, n)))
|  36|  36| // Space: O(1)
|  37|  37| // Binary search solution.
|  38|    |-class Solution2 {
|  39|    |-public:
|    |  38|+class Solution2
|    |  39|+{
|    |  40|+  public:
|  40|  41|     /**
|  41|  42|      * @param nums1 an integer array
|  42|  43|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  42|  42|      * @param nums2 an integer array
|  43|  43|      * @return an integer array
|  44|  44|      */
|  45|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  46|    |-        if (nums1.size() > nums2.size()) {
|  47|    |-            return intersection(nums2, nums1);
|  48|    |-        }
|    |  45|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  46|+    {
|    |  47|+        if (nums1.size () > nums2.size ())
|    |  48|+          {
|    |  49|+              return intersection (nums2, nums1);
|    |  50|+          }
|  49|  51| 
|  50|    |-        sort(nums1.begin(), nums1.end());
|  51|    |-        sort(nums2.begin(), nums2.end());
|    |  52|+        sort (nums1.begin (), nums1.end ());
|    |  53|+        sort (nums2.begin (), nums2.end ());
|  52|  54| 
|  53|    |-        vector<int> result;
|  54|    |-        auto it = nums2.cbegin();
|  55|    |-        for (const auto& i : nums1) {
|  56|    |-            it = lower_bound(it, nums2.cend(), i);
|  57|    |-            if (it != nums2.end() && *it == i) {
|  58|    |-                result.emplace_back(*it++);
|  59|    |-            }
|  60|    |-        }
|  61|    |-        
|    |  55|+        vector < int >result;
|    |  56|+        auto it = nums2.cbegin ();
|    |  57|+      for (const auto & i:nums1)
|    |  58|+          {
|    |  59|+              it = lower_bound (it, nums2.cend (), i);
|    |  60|+              if (it != nums2.end () && *it == i)
|    |  61|+                {
|    |  62|+                    result.emplace_back (*it++);
|    |  63|+                }
|    |  64|+          }
|    |  65|+
|  62|  66|         return result;
|  63|  67|     }
|  64|  68| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  63|  63|     }
|  64|  64| };
|  65|  65| 
|  66|    |-
|  67|  66| // Time:  O(max(m, n) * log(max(m, n)))
|  68|  67| // Space: O(1)
|  69|  68| // Two pointers solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  67|  67| // Time:  O(max(m, n) * log(max(m, n)))
|  68|  68| // Space: O(1)
|  69|  69| // Two pointers solution.
|  70|    |-class Solution3 {
|  71|    |-public:
|    |  70|+class Solution3
|    |  71|+{
|    |  72|+  public:
|  72|  73|     /**
|  73|  74|      * @param nums1 an integer array
|  74|  75|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays-ii.cpp
|    |++++| /app/C++/intersection-of-two-arrays-ii.cpp
|  74|  74|      * @param nums2 an integer array
|  75|  75|      * @return an integer array
|  76|  76|      */
|  77|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  78|    |-        vector<int> result;
|  79|    |-        sort(nums1.begin(), nums1.end());
|  80|    |-        sort(nums2.begin(), nums2.end());
|  81|    |-        auto it1 = nums1.cbegin(), it2 = nums2.cbegin();
|  82|    |-        while (it1 != nums1.cend() && it2 != nums2.cend()) {
|  83|    |-            if (*it1 < *it2) {
|  84|    |-                ++it1;
|  85|    |-            } else if (*it1 > *it2) {
|  86|    |-                ++it2;
|  87|    |-            } else {
|  88|    |-                result.emplace_back(*it1);
|  89|    |-                ++it1, ++it2;
|  90|    |-            }
|  91|    |-        }
|    |  77|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  78|+    {
|    |  79|+        vector < int >result;
|    |  80|+          sort (nums1.begin (), nums1.end ());
|    |  81|+          sort (nums2.begin (), nums2.end ());
|    |  82|+        auto it1 = nums1.cbegin (), it2 = nums2.cbegin ();
|    |  83|+        while (it1 != nums1.cend () && it2 != nums2.cend ())
|    |  84|+          {
|    |  85|+              if (*it1 < *it2)
|    |  86|+                {
|    |  87|+                    ++it1;
|    |  88|+                }
|    |  89|+              else if (*it1 > *it2)
|    |  90|+                {
|    |  91|+                    ++it2;
|    |  92|+                }
|    |  93|+              else
|    |  94|+                {
|    |  95|+                    result.emplace_back (*it1);
|    |  96|+                    ++it1, ++it2;
|    |  97|+                }
|    |  98|+          }
|  92|  99|         return result;
|  93| 100|     }
|  94| 101| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-list.cpp
|    |++++| /app/C++/flatten-list.cpp
|  21|  21|  *     const vector<NestedInteger> &getList() const;
|  22|  22|  * };
|  23|  23|  */
|  24|    |-class Solution {
|  25|    |-public:
|    |  24|+class Solution
|    |  25|+{
|    |  26|+  public:
|  26|  27|     // @param nestedList a list of NestedInteger
|  27|  28|     // @return a list of integer
|  28|  29|     vector<int> flatten(vector<NestedInteger> &nestedList) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-list.cpp
|    |++++| /app/C++/flatten-list.cpp
|  25|  25| public:
|  26|  26|     // @param nestedList a list of NestedInteger
|  27|  27|     // @return a list of integer
|  28|    |-    vector<int> flatten(vector<NestedInteger> &nestedList) {
|  29|    |-        vector<int> result;
|  30|    |-        for (const auto& node : nestedList)
|  31|    |-            if (node.isInteger()) {
|  32|    |-                result.emplace_back(node.getInteger());
|  33|    |-            } else {
|  34|    |-                vector<NestedInteger> sub_list = node.getList();
|  35|    |-                auto temp = flatten(sub_list);
|  36|    |-                result.insert(result.end(), temp.begin(), temp.end());
|  37|    |-            }
|    |  28|+    vector < int >flatten (vector < NestedInteger > &nestedList)
|    |  29|+    {
|    |  30|+        vector < int >result;
|    |  31|+        for (const auto & node:nestedList)
|    |  32|+            if (node.isInteger ())
|    |  33|+              {
|    |  34|+                  result.emplace_back (node.getInteger ());
|    |  35|+              }
|    |  36|+            else
|    |  37|+              {
|    |  38|+                  vector < NestedInteger > sub_list = node.getList ();
|    |  39|+                  auto temp = flatten (sub_list);
|    |  40|+                  result.insert (result.end (), temp.begin (), temp.end ());
|    |  41|+              }
|  38|  42| 
|  39|  43|         return result;
|  40|  44|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-list.cpp
|    |++++| /app/C++/rotate-list.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head: the list
|  16|  17|      * @param k: rotate to the right k places
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-list.cpp
|    |++++| /app/C++/rotate-list.cpp
|  16|  16|      * @param k: rotate to the right k places
|  17|  17|      * @return: the list after rotation
|  18|  18|      */
|  19|    |-    ListNode *rotateRight(ListNode *head, int k) {
|  20|    |-        if (head == nullptr || head->next == nullptr) {
|  21|    |-            return head;
|  22|    |-        }
|    |  19|+    ListNode * rotateRight (ListNode * head, int k)
|    |  20|+    {
|    |  21|+        if (head == nullptr || head->next == nullptr)
|    |  22|+          {
|    |  23|+              return head;
|    |  24|+          }
|  23|  25| 
|  24|  26|         int n = 1;
|  25|  27|         ListNode *cur = head;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-list.cpp
|    |++++| /app/C++/rotate-list.cpp
|  23|  23| 
|  24|  24|         int n = 1;
|  25|  25|         ListNode *cur = head;
|  26|    |-        for (; cur->next; cur = cur->next) {
|  27|    |-            ++n;
|  28|    |-        }
|    |  26|+        for (; cur->next; cur = cur->next)
|    |  27|+          {
|    |  28|+              ++n;
|    |  29|+          }
|  29|  30|         cur->next = head;
|  30|  31| 
|  31|  32|         ListNode *tail = cur;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-list.cpp
|    |++++| /app/C++/rotate-list.cpp
|  31|  31|         ListNode *tail = cur;
|  32|  32|         k = n - k % n;
|  33|  33|         cur = head;
|  34|    |-        for (int i = 0; i < k; cur = cur->next, ++i) {
|  35|    |-            tail = cur;
|  36|    |-        }
|    |  34|+        for (int i = 0; i < k; cur = cur->next, ++i)
|    |  35|+          {
|    |  36|+              tail = cur;
|    |  37|+          }
|  37|  38| 
|  38|  39|         tail->next = nullptr;
|  39|  40|         return cur; 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-list.cpp
|    |++++| /app/C++/rotate-list.cpp
|  36|  36|         }
|  37|  37| 
|  38|  38|         tail->next = nullptr;
|  39|    |-        return cur; 
|    |  39|+        return cur;
|  40|  40|     }
|  41|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-connected-component-in-the-undirected-graph.cpp
|    |++++| /app/C++/find-the-connected-component-in-the-undirected-graph.cpp
|   9|   9|  *     UndirectedGraphNode(int x) : label(x) {};
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param nodes a array of Undirected graph node
|  16|  17|      * @return a connected set of a Undirected graph
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-connected-component-in-the-undirected-graph.cpp
|    |++++| /app/C++/find-the-connected-component-in-the-undirected-graph.cpp
|  15|  15|      * @param nodes a array of Undirected graph node
|  16|  16|      * @return a connected set of a Undirected graph
|  17|  17|      */
|  18|    |-    vector<vector<int>> connectedSet(vector<UndirectedGraphNode*>& nodes) {
|  19|    |-        vector<vector<int>> components;
|  20|    |-        queue<UndirectedGraphNode*> q;
|  21|    |-        unordered_set<UndirectedGraphNode*> visited;
|    |  18|+    vector < vector < int >>connectedSet (vector <
|    |  19|+                                          UndirectedGraphNode * >&nodes)
|    |  20|+    {
|    |  21|+        vector < vector < int >>components;
|    |  22|+          queue < UndirectedGraphNode * >q;
|    |  23|+          unordered_set < UndirectedGraphNode * >visited;
|  22|  24| 
|  23|    |-        for (const auto& node : nodes) {
|  24|    |-            if (visited.find(node) == visited.end()) {
|  25|    |-                visited.emplace(node);
|  26|    |-                q.emplace(node);
|    |  25|+        for (const auto & node:nodes)
|    |  26|+          {
|    |  27|+              if (visited.find (node) == visited.end ())
|    |  28|+                {
|    |  29|+                    visited.emplace (node);
|    |  30|+                    q.emplace (node);
|  27|  31| 
|  28|    |-                vector<int> component;
|  29|    |-                while (!q.empty()) {
|  30|    |-                    auto node = q.front();
|  31|    |-                    q.pop();
|  32|    |-                    component.emplace_back(node->label);
|  33|    |-                    for (const auto& n : node->neighbors) {
|  34|    |-                        if (visited.find(n) == visited.end()) {
|  35|    |-                            visited.emplace(n);
|  36|    |-                            q.emplace(n);
|  37|    |-                        }
|  38|    |-                    }
|    |  32|+                    vector < int >component;
|    |  33|+                    while (!q.empty ())
|    |  34|+                      {
|    |  35|+                          auto node = q.front ();
|    |  36|+                            q.pop ();
|    |  37|+                            component.emplace_back (node->label);
|    |  38|+                          for (const auto & n:node->neighbors)
|    |  39|+                            {
|    |  40|+                                if (visited.find (n) == visited.end ())
|    |  41|+                                  {
|    |  42|+                                      visited.emplace (n);
|    |  43|+                                      q.emplace (n);
|    |  44|+                                  }
|    |  45|+                            }
|    |  46|+                      }
|    |  47|+                    // Sort component.
|    |  48|+                    sort (component.begin (), component.end ());
|    |  49|+                    components.emplace_back (move (component));
|  39|  50|                 }
|  40|    |-                // Sort component.
|  41|    |-                sort(component.begin(), component.end());
|  42|    |-                components.emplace_back(move(component));
|  43|    |-            }
|  44|    |-        }
|    |  51|+          }
|  45|  52| 
|  46|  53|         return components;
|  47|  54|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-and-say.cpp
|    |++++| /app/C++/count-and-say.cpp
|   1|   1| // Time:  O(n * 2^n)
|   2|   2| // Space: O(2^n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n the nth
|   8|   9|      * @return the nth sequence
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-and-say.cpp
|    |++++| /app/C++/count-and-say.cpp
|   7|   7|      * @param n the nth
|   8|   8|      * @return the nth sequence
|   9|   9|      */
|  10|    |-    string countAndSay(int n) {
|  11|    |-        string seq{"1"};
|  12|    |-        for (int i = 0; i < n - 1; ++i) {
|  13|    |-            seq = getNext(seq);
|  14|    |-        }
|    |  10|+    string countAndSay (int n)
|    |  11|+    {
|    |  12|+        string seq
|    |  13|+        {
|    |  14|+        "1"};
|    |  15|+        for (int i = 0; i < n - 1; ++i)
|    |  16|+          {
|    |  17|+              seq = getNext (seq);
|    |  18|+          }
|  15|  19|         return seq;
|  16|  20|     }
|  17|  21| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-and-say.cpp
|    |++++| /app/C++/count-and-say.cpp
|  15|  15|         return seq;
|  16|  16|     }
|  17|  17| 
|  18|    |-    string getNext(const string& seq) {
|  19|    |-        stringstream  next_seq;
|  20|    |-        for (int i = 0; i < seq.length(); ++i) {
|  21|    |-            int cnt = 1;
|  22|    |-            while (i < seq.length() - 1 && seq[i] == seq[i + 1]) {
|  23|    |-                ++cnt, ++i;
|  24|    |-            }
|  25|    |-            next_seq << cnt << seq[i];
|  26|    |-        }
|  27|    |-        return next_seq.str();
|    |  18|+    string getNext (const string & seq)
|    |  19|+    {
|    |  20|+        stringstream next_seq;
|    |  21|+        for (int i = 0; i < seq.length (); ++i)
|    |  22|+          {
|    |  23|+              int cnt = 1;
|    |  24|+              while (i < seq.length () - 1 && seq[i] == seq[i + 1])
|    |  25|+                {
|    |  26|+                    ++cnt, ++i;
|    |  27|+                }
|    |  28|+              next_seq << cnt << seq[i];
|    |  29|+          }
|    |  30|+        return next_seq.str ();
|  28|  31|     }
|  29|  32| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-interval.cpp
|    |++++| /app/C++/insert-interval.cpp
|  10|  10|  *         this->end = end;
|  11|  11|  *     }
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * Insert newInterval into intervals.
|  17|  18|      * @param intervals: Sorted interval list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-interval.cpp
|    |++++| /app/C++/insert-interval.cpp
|  18|  18|      * @param newInterval: new interval.
|  19|  19|      * @return: A new interval list.
|  20|  20|      */
|  21|    |-    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
|    |  21|+    vector < Interval > insert (vector < Interval > &intervals,
|    |  22|+                                Interval newInterval)
|    |  23|+    {
|  22|  24|         size_t i = 0;
|  23|    |-        vector<Interval> result;
|    |  25|+          vector < Interval > result;
|  24|  26|         // Insert intervals appeared before newInterval.
|  25|    |-        while (i < intervals.size() && newInterval.start > intervals[i].end) {
|  26|    |-            result.emplace_back(intervals[i++]);
|  27|    |-        }
|    |  27|+        while (i < intervals.size () && newInterval.start > intervals[i].end)
|    |  28|+          {
|    |  29|+              result.emplace_back (intervals[i++]);
|    |  30|+          }
|  28|  31| 
|  29|  32|         // Merge intervals that overlap with newInterval.
|  30|  33|         while (i < intervals.size() && newInterval.end >= intervals[i].start) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-interval.cpp
|    |++++| /app/C++/insert-interval.cpp
|  27|  27|         }
|  28|  28| 
|  29|  29|         // Merge intervals that overlap with newInterval.
|  30|    |-        while (i < intervals.size() && newInterval.end >= intervals[i].start) {
|  31|    |-            newInterval = {min(newInterval.start, intervals[i].start),
|  32|    |-                max(newInterval.end, intervals[i].end)};
|  33|    |-            ++i;
|  34|    |-        }
|  35|    |-        result.emplace_back(newInterval);
|    |  30|+        while (i < intervals.size () && newInterval.end >= intervals[i].start)
|    |  31|+          {
|    |  32|+              newInterval =
|    |  33|+              {
|    |  34|+              min (newInterval.start, intervals[i].start),
|    |  35|+                      max (newInterval.end, intervals[i].end)};
|    |  36|+              ++i;
|    |  37|+          }
|    |  38|+        result.emplace_back (newInterval);
|  36|  39| 
|  37|  40|         // Insert intervals appearing after newInterval.
|  38|  41|         result.insert(result.end(), intervals.cbegin() + i, intervals.cend());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-interval.cpp
|    |++++| /app/C++/insert-interval.cpp
|  35|  35|         result.emplace_back(newInterval);
|  36|  36| 
|  37|  37|         // Insert intervals appearing after newInterval.
|  38|    |-        result.insert(result.end(), intervals.cbegin() + i, intervals.cend());
|    |  38|+        result.insert (result.end (), intervals.cbegin () + i,
|    |  39|+                       intervals.cend ());
|  39|  40|         return result;
|  40|  41|     }
|  41|  42| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rehashing.cpp
|    |++++| /app/C++/rehashing.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param hashTable: A list of The first node of linked list
|  20|  21|      * @return: A list of The first node of linked list which have twice size
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rehashing.cpp
|    |++++| /app/C++/rehashing.cpp
|  19|  19|      * @param hashTable: A list of The first node of linked list
|  20|  20|      * @return: A list of The first node of linked list which have twice size
|  21|  21|      */
|  22|    |-    vector<ListNode*> rehashing(vector<ListNode*> hashTable) {
|  23|    |-        const int old_size = hashTable.size();
|    |  22|+    vector < ListNode * >rehashing (vector < ListNode * >hashTable)
|    |  23|+    {
|    |  24|+        const int old_size = hashTable.size ();
|  24|  25|         const int new_size = old_size * 2;
|  25|    |-        if (old_size == 0) {
|  26|    |-            return hashTable;
|  27|    |-        }
|  28|    |-        vector<ListNode*> rehashTable(new_size, nullptr);
|  29|    |-        for (int i = 0; i < old_size; ++i) {
|  30|    |-            if (hashTable[i] != nullptr) {
|  31|    |-                rehash(hashTable, rehashTable, i);
|  32|    |-            }
|  33|    |-        }
|    |  26|+        if (old_size == 0)
|    |  27|+          {
|    |  28|+              return hashTable;
|    |  29|+          }
|    |  30|+        vector < ListNode * >rehashTable (new_size, nullptr);
|    |  31|+        for (int i = 0; i < old_size; ++i)
|    |  32|+          {
|    |  33|+              if (hashTable[i] != nullptr)
|    |  34|+                {
|    |  35|+                    rehash (hashTable, rehashTable, i);
|    |  36|+                }
|    |  37|+          }
|  34|  38|         return rehashTable;
|  35|  39|     }
|  36|  40| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rehashing.cpp
|    |++++| /app/C++/rehashing.cpp
|  34|  34|         return rehashTable;
|  35|  35|     }
|  36|  36| 
|  37|    |-    void rehash(vector<ListNode*>& hashTable, vector<ListNode*>& rehashTable, int i) {
|  38|    |-        const int new_size = rehashTable.size();
|    |  37|+    void rehash (vector < ListNode * >&hashTable,
|    |  38|+                 vector < ListNode * >&rehashTable, int i)
|    |  39|+    {
|    |  40|+        const int new_size = rehashTable.size ();
|  39|  41|         ListNode *curr = hashTable[i];
|  40|    |-        while (curr != nullptr) {
|  41|    |-            int val = curr->val;
|  42|    |-            int new_pos = (val % new_size + new_size) % new_size;
|  43|    |-            if (rehashTable[new_pos] == nullptr) {
|  44|    |-                rehashTable[new_pos] = new ListNode(val);
|  45|    |-            }
|  46|    |-            else {
|  47|    |-                ListNode *tmp = rehashTable[new_pos];
|  48|    |-                while (tmp->next != nullptr) {
|  49|    |-                    tmp = tmp->next;
|    |  42|+        while (curr != nullptr)
|    |  43|+          {
|    |  44|+              int val = curr->val;
|    |  45|+              int new_pos = (val % new_size + new_size) % new_size;
|    |  46|+              if (rehashTable[new_pos] == nullptr)
|    |  47|+                {
|    |  48|+                    rehashTable[new_pos] = new ListNode (val);
|  50|  49|                 }
|  51|    |-                tmp->next = new ListNode(val);
|  52|    |-            }
|  53|    |-            curr = curr->next;
|  54|    |-        }
|    |  50|+              else
|    |  51|+                {
|    |  52|+                    ListNode *tmp = rehashTable[new_pos];
|    |  53|+                    while (tmp->next != nullptr)
|    |  54|+                      {
|    |  55|+                          tmp = tmp->next;
|    |  56|+                      }
|    |  57|+                    tmp->next = new ListNode (val);
|    |  58|+                }
|    |  59|+              curr = curr->next;
|    |  60|+          }
|  55|  61|     }
|  56|  62| };
|  57|  63| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rehashing.cpp
|    |++++| /app/C++/rehashing.cpp
|  54|  54|         }
|  55|  55|     }
|  56|  56| };
|  57|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|     /**
|   6|   7|      *@param A : an integer sorted array
|   7|   8|      *@param target :  an integer to be inserted
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|   7|   7|      *@param target :  an integer to be inserted
|   8|   8|      *return : a list of length 2, [index1, index2]
|   9|   9|      */
|  10|    |-public:
|  11|    |-    vector<int> searchRange(vector<int> &A, int target) {
|  12|    |-        const auto start = lower_bound(A.cbegin(), A.cend(), target);
|  13|    |-        const auto end = upper_bound(A.cbegin(), A.cend(), target);
|  14|    |-        if (start != A.cend() && *start == target) {
|  15|    |-            return {start - A.cbegin(), end - A.cbegin() - 1};
|  16|    |-        }
|  17|    |-        return {-1, -1};
|    |  10|+  public:
|    |  11|+    vector < int >searchRange (vector < int >&A, int target)
|    |  12|+    {
|    |  13|+        const auto start = lower_bound (A.cbegin (), A.cend (), target);
|    |  14|+        const auto end = upper_bound (A.cbegin (), A.cend (), target);
|    |  15|+        if (start != A.cend () && *start == target)
|    |  16|+          {
|    |  17|+              return
|    |  18|+              {
|    |  19|+              start - A.cbegin (), end - A.cbegin () - 1};
|    |  20|+          }
|    |  21|+        return
|    |  22|+        {
|    |  23|+        -1, -1};
|  18|  24|     }
|  19|  25| };
|  20|  26| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|  18|  18|     }
|  19|  19| };
|  20|  20| 
|  21|    |-class Solution2 {
|    |  21|+class Solution2
|    |  22|+{
|  22|  23|     /**
|  23|  24|      *@param A : an integer sorted array
|  24|  25|      *@param target :  an integer to be inserted
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|  24|  24|      *@param target :  an integer to be inserted
|  25|  25|      *return : a list of length 2, [index1, index2]
|  26|  26|      */
|  27|    |-public:
|  28|    |-    vector<int> searchRange(vector<int> &A, int target) {
|  29|    |-        const int begin = lower_bound(A, target);
|  30|    |-        const int end = upper_bound(A, target);
|    |  27|+  public:
|    |  28|+    vector < int >searchRange (vector < int >&A, int target)
|    |  29|+    {
|    |  30|+        const int begin = lower_bound (A, target);
|    |  31|+        const int end = upper_bound (A, target);
|  31|  32| 
|  32|    |-        if (begin < A.size() && A[begin] == target)
|  33|    |-            return {begin, end - 1};
|    |  33|+        if (begin < A.size () && A[begin] == target)
|    |  34|+            return
|    |  35|+          {
|    |  36|+          begin, end - 1};
|  34|  37| 
|  35|    |-        return {-1, -1};
|    |  38|+        return
|    |  39|+        {
|    |  40|+        -1, -1};
|  36|  41|     }
|  37|  42| 
|  38|  43| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|  35|  35|         return {-1, -1};
|  36|  36|     }
|  37|  37| 
|  38|    |-private:
|  39|    |-    int lower_bound(vector<int> &A, int target) {
|    |  38|+  private:
|    |  39|+    int lower_bound (vector < int >&A, int target)
|    |  40|+    {
|  40|  41|         int left = 0;
|  41|    |-        int right = A.size();
|    |  42|+        int right = A.size ();
|  42|  43|         // Find min left s.t. A[left] >= target.
|  43|    |-        while (left < right) {
|  44|    |-            int mid = left + (right - left) / 2;
|  45|    |-            if (A[mid] >= target) {
|  46|    |-                right = mid;
|  47|    |-            } else {
|  48|    |-                left = mid + 1;
|  49|    |-            }
|  50|    |-        }
|    |  44|+        while (left < right)
|    |  45|+          {
|    |  46|+              int mid = left + (right - left) / 2;
|    |  47|+              if (A[mid] >= target)
|    |  48|+                {
|    |  49|+                    right = mid;
|    |  50|+                }
|    |  51|+              else
|    |  52|+                {
|    |  53|+                    left = mid + 1;
|    |  54|+                }
|    |  55|+          }
|  51|  56|         return left;
|  52|  57|     }
|  53|  58| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|  51|  51|         return left;
|  52|  52|     }
|  53|  53| 
|  54|    |-    int upper_bound(vector<int> &A, int target) {
|    |  54|+    int upper_bound (vector < int >&A, int target)
|    |  55|+    {
|  55|  56|         int left = 0;
|  56|    |-        int right = A.size();
|    |  57|+        int right = A.size ();
|  57|  58|         // Find min left s.t. A[left] > target.
|  58|    |-        while (left < right) {
|  59|    |-            int mid = left + (right - left) / 2;
|  60|    |-            if (A[mid] > target) {
|  61|    |-                right = mid;
|  62|    |-            } else {
|  63|    |-                left = mid + 1;
|  64|    |-            }
|  65|    |-        }
|    |  59|+        while (left < right)
|    |  60|+          {
|    |  61|+              int mid = left + (right - left) / 2;
|    |  62|+              if (A[mid] > target)
|    |  63|+                {
|    |  64|+                    right = mid;
|    |  65|+                }
|    |  66|+              else
|    |  67|+                {
|    |  68|+                    left = mid + 1;
|    |  69|+                }
|    |  70|+          }
|  66|  71|         return left;
|  67|  72|     }
|  68|  73| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-for-a-range.cpp
|    |++++| /app/C++/search-for-a-range.cpp
|  66|  66|         return left;
|  67|  67|     }
|  68|  68| };
|  69|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gas-station.cpp
|    |++++| /app/C++/gas-station.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Greedy solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param gas: a vector of integers
|   9|  10|      * @param cost: a vector of integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gas-station.cpp
|    |++++| /app/C++/gas-station.cpp
|   9|   9|      * @param cost: a vector of integers
|  10|  10|      * @return: an integer
|  11|  11|      */
|  12|    |-    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
|    |  12|+    int canCompleteCircuit (vector < int >&gas, vector < int >&cost)
|    |  13|+    {
|  13|  14|         int current_sum = 0;
|  14|  15|         int total_sum = 0;
|  15|  16|         int start = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gas-station.cpp
|    |++++| /app/C++/gas-station.cpp
|  13|  13|         int current_sum = 0;
|  14|  14|         int total_sum = 0;
|  15|  15|         int start = 0;
|  16|    |-        for (int i = 0; i < gas.size(); ++i) {
|  17|    |-            current_sum += gas[i] - cost[i];
|  18|    |-            total_sum += gas[i] - cost[i];
|  19|    |-            if (current_sum < 0) {
|  20|    |-                // It means any gas station in range [start, i] cannot be start.
|  21|    |-                current_sum = 0;
|  22|    |-                start = i + 1;
|  23|    |-            }
|  24|    |-        }
|    |  16|+        for (int i = 0; i < gas.size (); ++i)
|    |  17|+          {
|    |  18|+              current_sum += gas[i] - cost[i];
|    |  19|+              total_sum += gas[i] - cost[i];
|    |  20|+              if (current_sum < 0)
|    |  21|+                {
|    |  22|+                    // It means any gas station in range [start, i] cannot be start.
|    |  23|+                    current_sum = 0;
|    |  24|+                    start = i + 1;
|    |  25|+                }
|    |  26|+          }
|  25|  27| 
|  26|  28|         // Check if solution exists, i.e. sum(gas) >= sum(cost).
|  27|  29|         if (total_sum >= 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gas-station.cpp
|    |++++| /app/C++/gas-station.cpp
|  24|  24|         }
|  25|  25| 
|  26|  26|         // Check if solution exists, i.e. sum(gas) >= sum(cost).
|  27|    |-        if (total_sum >= 0) {
|  28|    |-            // 1. route of [start, len(gas) - 1] must be positive
|  29|    |-            // 2. route of [0, start - 1] must be negative
|  30|    |-            // 3. sum(gas) >= sum(cost), so 1 + 2 >= 0
|  31|    |-            // According to the above, start is the gas station we want.
|  32|    |-            return start;
|  33|    |-        }
|    |  27|+        if (total_sum >= 0)
|    |  28|+          {
|    |  29|+              // 1. route of [start, len(gas) - 1] must be positive
|    |  30|+              // 2. route of [0, start - 1] must be negative
|    |  31|+              // 3. sum(gas) >= sum(cost), so 1 + 2 >= 0
|    |  32|+              // According to the above, start is the gas station we want.
|    |  33|+              return start;
|    |  34|+          }
|  34|  35| 
|  35|  36|         return -1;
|  36|  37|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game-ii.cpp
|    |++++| /app/C++/jump-game-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: A list of lists of integers
|   8|   9|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game-ii.cpp
|    |++++| /app/C++/jump-game-ii.cpp
|   7|   7|      * @param A: A list of lists of integers
|   8|   8|      * @return: An integer
|   9|   9|      */
|  10|    |-    int jump(vector<int> A) {
|    |  10|+    int jump (vector < int >A)
|    |  11|+    {
|  11|  12|         int jump_count = 0;
|  12|  13|         int reachable = 0;
|  13|  14|         int curr_reachable = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game-ii.cpp
|    |++++| /app/C++/jump-game-ii.cpp
|  11|  11|         int jump_count = 0;
|  12|  12|         int reachable = 0;
|  13|  13|         int curr_reachable = 0;
|  14|    |-        for (int i = 0; i < A.size(); ++i) {
|  15|    |-            if (i > reachable) {
|  16|    |-                return -1;
|  17|    |-            }
|  18|    |-            if (i > curr_reachable) {
|  19|    |-                // current jumps are not enough,
|  20|    |-                // jump one more step, which enlarges curr_reachable to reachable.
|  21|    |-                curr_reachable = reachable;
|  22|    |-                ++jump_count;
|  23|    |-            }
|  24|    |-            reachable = max(reachable, i + A[i]);
|  25|    |-        }
|    |  14|+        for (int i = 0; i < A.size (); ++i)
|    |  15|+          {
|    |  16|+              if (i > reachable)
|    |  17|+                {
|    |  18|+                    return -1;
|    |  19|+                }
|    |  20|+              if (i > curr_reachable)
|    |  21|+                {
|    |  22|+                    // current jumps are not enough,
|    |  23|+                    // jump one more step, which enlarges curr_reachable to reachable.
|    |  24|+                    curr_reachable = reachable;
|    |  25|+                    ++jump_count;
|    |  26|+                }
|    |  27|+              reachable = max (reachable, i + A[i]);
|    |  28|+          }
|  26|  29| 
|  27|  30|         return jump_count;
|  28|  31|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game-ii.cpp
|    |++++| /app/C++/jump-game-ii.cpp
|  27|  27|         return jump_count;
|  28|  28|     }
|  29|  29| };
|  30|    |-
|  31|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-list.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: head node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-list.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-list.cpp
|  19|  19|      * @param head: The first node of linked list.
|  20|  20|      * @return: head node
|  21|  21|      */
|  22|    |-    ListNode *deleteDuplicates(ListNode *head) {
|    |  22|+    ListNode * deleteDuplicates (ListNode * head)
|    |  23|+    {
|  23|  24|         auto iter = head;
|  24|    |-        while (iter) {
|  25|    |-            auto runner = iter->next;
|  26|    |-            while (runner && runner->val == iter->val) {
|  27|    |-                runner = runner->next;
|  28|    |-            }
|  29|    |-            iter->next = runner;
|  30|    |-            iter = runner;
|  31|    |-        }
|    |  25|+        while (iter)
|    |  26|+          {
|    |  27|+              auto runner = iter->next;
|    |  28|+              while (runner && runner->val == iter->val)
|    |  29|+                {
|    |  30|+                    runner = runner->next;
|    |  31|+                }
|    |  32|+              iter->next = runner;
|    |  33|+              iter = runner;
|    |  34|+          }
|  32|  35|         return head;
|  33|  36|     }
|  34|  37| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/balanced-binary-tree.cpp
|    |++++| /app/C++/balanced-binary-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: True if this Binary tree is Balanced, or false.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/balanced-binary-tree.cpp
|    |++++| /app/C++/balanced-binary-tree.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: True if this Binary tree is Balanced, or false.
|  21|  21|      */
|  22|    |-    bool isBalanced(TreeNode *root) {
|  23|    |-        return isBalancedRecu(root).first;
|    |  22|+    bool isBalanced (TreeNode * root)
|    |  23|+    {
|    |  24|+        return isBalancedRecu (root).first;
|  24|  25|     }
|  25|  26| 
|  26|  27|     pair<bool, int> isBalancedRecu(TreeNode *root) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/balanced-binary-tree.cpp
|    |++++| /app/C++/balanced-binary-tree.cpp
|  23|  23|         return isBalancedRecu(root).first;
|  24|  24|     }
|  25|  25| 
|  26|    |-    pair<bool, int> isBalancedRecu(TreeNode *root) {
|  27|    |-        if (root == nullptr) {
|  28|    |-            return {true, 0};
|  29|    |-        }
|    |  26|+    pair < bool, int >isBalancedRecu (TreeNode * root)
|    |  27|+    {
|    |  28|+        if (root == nullptr)
|    |  29|+          {
|    |  30|+              return
|    |  31|+              {
|    |  32|+              true, 0};
|    |  33|+          }
|  30|  34| 
|  31|    |-        pair<bool, int> left = isBalancedRecu(root->left);
|  32|    |-        pair<bool, int> right =  isBalancedRecu(root->right);
|    |  35|+        pair < bool, int >left = isBalancedRecu (root->left);
|    |  36|+        pair < bool, int >right = isBalancedRecu (root->right);
|  33|  37| 
|  34|    |-        if (left.first && right.first && abs(left.second - right.second) <= 1) {
|  35|    |-            return {true, max(left.second, right.second) + 1};
|  36|    |-        }
|  37|    |-        else {
|  38|    |-            return {false, 0};
|  39|    |-        }
|    |  38|+        if (left.first && right.first && abs (left.second - right.second) <= 1)
|    |  39|+          {
|    |  40|+              return
|    |  41|+              {
|    |  42|+              true, max (left.second, right.second) + 1};
|    |  43|+          }
|    |  44|+        else
|    |  45|+          {
|    |  46|+              return
|    |  47|+              {
|    |  48|+              false, 0};
|    |  49|+          }
|  40|  50|     }
|  41|  51| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sliding-window-median.cpp
|    |++++| /app/C++/sliding-window-median.cpp
|   4|   4| #include <vector>
|   5|   5| #include <set>
|   6|   6| 
|   7|    |-class Solution {
|   8|    |-public:
|    |   7|+class Solution
|    |   8|+{
|    |   9|+  public:
|   9|  10|     /**
|  10|  11|      * @param nums: A list of integers.
|  11|  12|      * @return: The median of the element inside the window at each moving
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sliding-window-median.cpp
|    |++++| /app/C++/sliding-window-median.cpp
|  10|  10|      * @param nums: A list of integers.
|  11|  11|      * @return: The median of the element inside the window at each moving
|  12|  12|      */
|  13|    |-    vector<int> medianSlidingWindow(vector<int> &nums, int k) {
|    |  13|+    vector < int >medianSlidingWindow (vector < int >&nums, int k)
|    |  14|+    {
|  14|  15|         // min_bst stores the larger half seen so far.
|  15|    |-        multiset<int, less<int>> min_bst;
|    |  16|+        multiset < int, less < int >>min_bst;
|  16|  17|         // max_bst stores the smaller half seen so far.
|  17|    |-        multiset<int, greater<int>> max_bst;
|    |  18|+          multiset < int, greater < int >>max_bst;
|  18|  19| 
|  19|    |-        vector<int> ans;
|  20|    |-        for (int i = 0; i < nums.size(); ++i) {
|  21|    |-            if (i >= k) {
|  22|    |-                // Remove the element outside the window.
|  23|    |-                if (max_bst.find(nums[i - k]) != max_bst.cend()) {
|  24|    |-                    max_bst.erase(max_bst.find(nums[i - k]));
|  25|    |-                } else {
|  26|    |-                    min_bst.erase(min_bst.find(nums[i - k]));
|    |  20|+          vector < int >ans;
|    |  21|+        for (int i = 0; i < nums.size (); ++i)
|    |  22|+          {
|    |  23|+              if (i >= k)
|    |  24|+                {
|    |  25|+                    // Remove the element outside the window.
|    |  26|+                    if (max_bst.find (nums[i - k]) != max_bst.cend ())
|    |  27|+                      {
|    |  28|+                          max_bst.erase (max_bst.find (nums[i - k]));
|    |  29|+                      }
|    |  30|+                    else
|    |  31|+                      {
|    |  32|+                          min_bst.erase (min_bst.find (nums[i - k]));
|    |  33|+                      }
|  27|  34|                 }
|  28|    |-            }
|  29|  35| 
|  30|    |-            // Balance smaller half and larger half.
|  31|    |-            if (max_bst.empty() || nums[i] > *max_bst.cbegin()) {
|  32|    |-                min_bst.emplace(nums[i]);
|  33|    |-                if (min_bst.size() > max_bst.size() + 1) {
|  34|    |-                    max_bst.emplace(*min_bst.cbegin());
|  35|    |-                    min_bst.erase(min_bst.cbegin());
|    |  36|+              // Balance smaller half and larger half.
|    |  37|+              if (max_bst.empty () || nums[i] > *max_bst.cbegin ())
|    |  38|+                {
|    |  39|+                    min_bst.emplace (nums[i]);
|    |  40|+                    if (min_bst.size () > max_bst.size () + 1)
|    |  41|+                      {
|    |  42|+                          max_bst.emplace (*min_bst.cbegin ());
|    |  43|+                          min_bst.erase (min_bst.cbegin ());
|    |  44|+                      }
|  36|  45|                 }
|  37|    |-            } else {
|  38|    |-                max_bst.emplace(nums[i]);
|  39|    |-                if (max_bst.size() > min_bst.size()) {
|  40|    |-                    min_bst.emplace(*max_bst.cbegin());
|  41|    |-                    max_bst.erase(max_bst.cbegin());
|    |  46|+              else
|    |  47|+                {
|    |  48|+                    max_bst.emplace (nums[i]);
|    |  49|+                    if (max_bst.size () > min_bst.size ())
|    |  50|+                      {
|    |  51|+                          min_bst.emplace (*max_bst.cbegin ());
|    |  52|+                          max_bst.erase (max_bst.cbegin ());
|    |  53|+                      }
|  42|  54|                 }
|  43|    |-            }
|  44|  55| 
|  45|    |-            // If window is full, get the median from 2 BST.
|  46|    |-            if (i >= k - 1) {
|  47|    |-                ans.emplace_back(min_bst.size() == max_bst.size() ?
|  48|    |-                                 *max_bst.cbegin() : *min_bst.cbegin());
|  49|    |-            }
|  50|    |-        }
|    |  56|+              // If window is full, get the median from 2 BST.
|    |  57|+              if (i >= k - 1)
|    |  58|+                {
|    |  59|+                    ans.emplace_back (min_bst.size () == max_bst.size ()?
|    |  60|+                                      *max_bst.cbegin () : *min_bst.cbegin ());
|    |  61|+                }
|    |  62|+          }
|  51|  63| 
|  52|  64|         return ans;
|  53|  65|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sliding-window-median.cpp
|    |++++| /app/C++/sliding-window-median.cpp
|  52|  52|         return ans;
|  53|  53|     }
|  54|  54| };
|  55|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle.cpp
|    |++++| /app/C++/triangle.cpp
|   4|   4| #include <algorithm>
|   5|   5| #include <vector>
|   6|   6| 
|   7|    |-using std::min;
|   8|    |-using std::vector;
|    |   7|+using
|    |   8|+    std::min;
|    |   9|+using
|    |  10|+    std::vector;
|   9|  11| 
|  10|    |-class Solution {
|  11|    |-    public:
|    |  12|+class
|    |  13|+    Solution
|    |  14|+{
|    |  15|+  public:
|  12|  16|         /**
|  13|  17|          * @param triangle: a list of lists of integers.
|  14|  18|          * @return: An integer, minimum path sum.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle.cpp
|    |++++| /app/C++/triangle.cpp
|  13|  13|          * @param triangle: a list of lists of integers.
|  14|  14|          * @return: An integer, minimum path sum.
|  15|  15|          */
|  16|    |-        int minimumTotal(vector<vector<int>> &triangle) {
|  17|    |-            // for empty input
|  18|    |-            if (triangle.empty()) {
|  19|    |-                return 0;
|  20|    |-            }
|    |  16|+    int
|    |  17|+    minimumTotal (vector < vector < int >>&triangle)
|    |  18|+    {
|    |  19|+        // for empty input
|    |  20|+        if (triangle.empty ())
|    |  21|+          {
|    |  22|+              return 0;
|    |  23|+          }
|  21|  24| 
|  22|    |-            // Stores the minimum path sum of triangle[i - 1].
|  23|    |-            vector<int> prev_row(triangle.front());
|  24|    |-            for (size_t i = 1; i < triangle.size(); ++i) {
|  25|    |-                // Stores the minimum path sum of triangle[i].
|  26|    |-                vector<int> curr_row(triangle[i]);
|  27|    |-                curr_row.front() += prev_row.front();  // For the first element.
|  28|    |-                for (size_t j = 1; j < curr_row.size() - 1; ++j) {
|  29|    |-                    curr_row[j] += min(prev_row[j - 1], prev_row[j]);
|    |  25|+        // Stores the minimum path sum of triangle[i - 1].
|    |  26|+        vector < int >
|    |  27|+        prev_row (triangle.front ());
|    |  28|+        for (size_t i = 1; i < triangle.size (); ++i)
|    |  29|+          {
|    |  30|+              // Stores the minimum path sum of triangle[i].
|    |  31|+              vector < int >
|    |  32|+              curr_row (triangle[i]);
|    |  33|+              curr_row.front () += prev_row.front ();   // For the first element.
|    |  34|+              for (size_t j = 1; j < curr_row.size () - 1; ++j)
|    |  35|+                {
|    |  36|+                    curr_row[j] += min (prev_row[j - 1], prev_row[j]);
|  30|  37|                 }
|  31|    |-                curr_row.back() += prev_row.back();  // For the last element.
|    |  38|+              curr_row.back () += prev_row.back (); // For the last element.
|  32|  39| 
|  33|    |-                prev_row.swap(curr_row);
|  34|    |-            }
|  35|    |-            return *min_element(prev_row.cbegin(), prev_row.cend());
|  36|    |-        }
|    |  40|+              prev_row.swap (curr_row);
|    |  41|+          }
|    |  42|+        return *min_element (prev_row.cbegin (), prev_row.cend ());
|    |  43|+    }
|  37|  44| };
|  38|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-array-by-odd-and-even.cpp
|    |++++| /app/C++/partition-array-by-odd-and-even.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: a vector of integers
|   8|   9|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-array-by-odd-and-even.cpp
|    |++++| /app/C++/partition-array-by-odd-and-even.cpp
|   7|   7|      * @param nums: a vector of integers
|   8|   8|      * @return: nothing
|   9|   9|      */
|  10|    |-    void partitionArray(vector<int> &nums) {
|  11|    |-        for (int left = 0, right = nums.size() - 1; left <= right;) {
|  12|    |-            if (nums[left] % 2 == 1) {
|  13|    |-                ++left;
|  14|    |-            } else if  (nums[right] % 2 == 0) {
|  15|    |-                --right;
|  16|    |-            } else {
|  17|    |-               swap(nums[left++], nums[right--]);
|  18|    |-            }
|  19|    |-        }
|    |  10|+    void partitionArray (vector < int >&nums)
|    |  11|+    {
|    |  12|+        for (int left = 0, right = nums.size () - 1; left <= right;)
|    |  13|+          {
|    |  14|+              if (nums[left] % 2 == 1)
|    |  15|+                {
|    |  16|+                    ++left;
|    |  17|+                }
|    |  18|+              else if (nums[right] % 2 == 0)
|    |  19|+                {
|    |  20|+                    --right;
|    |  21|+                }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    swap (nums[left++], nums[right--]);
|    |  25|+                }
|    |  26|+          }
|  20|  27|     }
|  21|  28| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-positive-and-negative-numbers.cpp
|    |++++| /app/C++/interleaving-positive-and-negative-numbers.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An integer array.
|   8|   9|      * @return: void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-positive-and-negative-numbers.cpp
|    |++++| /app/C++/interleaving-positive-and-negative-numbers.cpp
|   7|   7|      * @param A: An integer array.
|   8|   8|      * @return: void
|   9|   9|      */
|  10|    |-    void rerange(vector<int> &A) {
|  11|    |-        int n = A.size();
|    |  10|+    void rerange (vector < int >&A)
|    |  11|+    {
|    |  12|+        int n = A.size ();
|  12|  13| 
|  13|  14|         // by default, start with negative in output array
|  14|  15|         int expectPostive = false;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-positive-and-negative-numbers.cpp
|    |++++| /app/C++/interleaving-positive-and-negative-numbers.cpp
|  13|  13|         // by default, start with negative in output array
|  14|  14|         int expectPostive = false;
|  15|  15|         int postiveCount = 0;
|  16|    |-        for (const auto& k : A)  {
|  17|    |-            postiveCount += k > 0? 1 : 0;
|  18|    |-        }
|    |  16|+        for (const auto & k:A)
|    |  17|+          {
|    |  18|+              postiveCount += k > 0 ? 1 : 0;
|    |  19|+          }
|  19|  20| 
|  20|  21|         // if there are more postive than negative, start with postive
|  21|  22|         if (2 * postiveCount > n) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-positive-and-negative-numbers.cpp
|    |++++| /app/C++/interleaving-positive-and-negative-numbers.cpp
|  18|  18|         }
|  19|  19| 
|  20|  20|         // if there are more postive than negative, start with postive
|  21|    |-        if (2 * postiveCount > n) {
|  22|    |-            expectPostive = true;
|  23|    |-        }
|    |  21|+        if (2 * postiveCount > n)
|    |  22|+          {
|    |  23|+              expectPostive = true;
|    |  24|+          }
|  24|  25| 
|  25|  26|         int pos = 0, neg = 0;
|  26|  27|         int i = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-positive-and-negative-numbers.cpp
|    |++++| /app/C++/interleaving-positive-and-negative-numbers.cpp
|  25|  25|         int pos = 0, neg = 0;
|  26|  26|         int i = 0;
|  27|  27| 
|  28|    |-        while (pos < n && neg < n) {
|  29|    |-            // A[pos] is the next negative
|  30|    |-            while (pos < n && A[pos] > 0) {
|  31|    |-                ++pos;
|  32|    |-            }
|  33|    |-            // A[pos] is the next postive
|  34|    |-            while (neg < n && A[neg] < 0) {
|  35|    |-                ++neg;
|  36|    |-            }
|    |  28|+        while (pos < n && neg < n)
|    |  29|+          {
|    |  30|+              // A[pos] is the next negative
|    |  31|+              while (pos < n && A[pos] > 0)
|    |  32|+                {
|    |  33|+                    ++pos;
|    |  34|+                }
|    |  35|+              // A[pos] is the next postive
|    |  36|+              while (neg < n && A[neg] < 0)
|    |  37|+                {
|    |  38|+                    ++neg;
|    |  39|+                }
|  37|  40| 
|  38|    |-            if (expectPostive && A[i] < 0) {
|  39|    |-                swap(A[i], A[neg]);
|  40|    |-            }
|    |  41|+              if (expectPostive && A[i] < 0)
|    |  42|+                {
|    |  43|+                    swap (A[i], A[neg]);
|    |  44|+                }
|  41|  45| 
|  42|    |-            if (!expectPostive && A[i] > 0) {
|  43|    |-                swap(A[i], A[pos]);
|  44|    |-            }
|    |  46|+              if (!expectPostive && A[i] > 0)
|    |  47|+                {
|    |  48|+                    swap (A[i], A[pos]);
|    |  49|+                }
|  45|  50| 
|  46|    |-            if (i == pos) {
|  47|    |-                ++pos;
|  48|    |-            }
|  49|    |-            if (i == neg) {
|  50|    |-                ++neg;
|  51|    |-            }
|    |  51|+              if (i == pos)
|    |  52|+                {
|    |  53|+                    ++pos;
|    |  54|+                }
|    |  55|+              if (i == neg)
|    |  56|+                {
|    |  57|+                    ++neg;
|    |  58|+                }
|  52|  59| 
|  53|    |-            expectPostive = !expectPostive;
|  54|    |-            ++i;
|  55|    |-        }
|    |  60|+              expectPostive = !expectPostive;
|    |  61|+              ++i;
|    |  62|+          }
|  56|  63|     }
|  57|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|   1|   1| // Time:  O(max(m, n) * log(min(m, n)))
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A, B: Two integer arrays.
|   8|   9|      * @return: Their smallest difference.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|   7|   7|      * @param A, B: Two integer arrays.
|   8|   8|      * @return: Their smallest difference.
|   9|   9|      */
|  10|    |-    int smallestDifference(vector<int> &A, vector<int> &B) {
|  11|    |-        if (A.size() > B.size()) {
|  12|    |-            return smallestDifference(B, A);
|  13|    |-        }
|  14|    |-        sort(A.begin(), A.end());
|    |  10|+    int smallestDifference (vector < int >&A, vector < int >&B)
|    |  11|+    {
|    |  12|+        if (A.size () > B.size ())
|    |  13|+          {
|    |  14|+              return smallestDifference (B, A);
|    |  15|+          }
|    |  16|+        sort (A.begin (), A.end ());
|  15|  17| 
|  16|    |-        int min_diff = numeric_limits<int>::max();
|  17|    |-        for (const auto& b : B) {
|  18|    |-            auto it = lower_bound(A.cbegin(), A.cend(), b);
|  19|    |-            if (it != A.cend()) {
|  20|    |-                min_diff = min(min_diff, *it - b);
|  21|    |-            }
|  22|    |-            if (it != A.cbegin()) {
|  23|    |-                --it;
|  24|    |-                min_diff = min(min_diff, b - *it);
|  25|    |-            }
|  26|    |-        }
|    |  18|+        int min_diff = numeric_limits < int >::max ();
|    |  19|+      for (const auto & b:B)
|    |  20|+          {
|    |  21|+              auto it = lower_bound (A.cbegin (), A.cend (), b);
|    |  22|+              if (it != A.cend ())
|    |  23|+                {
|    |  24|+                    min_diff = min (min_diff, *it - b);
|    |  25|+                }
|    |  26|+              if (it != A.cbegin ())
|    |  27|+                {
|    |  28|+                    --it;
|    |  29|+                    min_diff = min (min_diff, b - *it);
|    |  30|+                }
|    |  31|+          }
|  27|  32| 
|  28|  33|         return min_diff;
|  29|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|  31|  31| 
|  32|  32| // Time:  O(nlogn)
|  33|  33| // Space: O(1)
|  34|    |-class Solution2 {
|  35|    |-public:
|    |  34|+class Solution2
|    |  35|+{
|    |  36|+  public:
|  36|  37|     /**
|  37|  38|      * @param A, B: Two integer arrays.
|  38|  39|      * @return: Their smallest difference.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|  37|  37|      * @param A, B: Two integer arrays.
|  38|  38|      * @return: Their smallest difference.
|  39|  39|      */
|  40|    |-    int smallestDifference(vector<int> &A, vector<int> &B) {
|  41|    |-        sort(A.begin(), A.end());
|  42|    |-        sort(B.begin(), B.end());
|    |  40|+    int smallestDifference (vector < int >&A, vector < int >&B)
|    |  41|+    {
|    |  42|+        sort (A.begin (), A.end ());
|    |  43|+        sort (B.begin (), B.end ());
|  43|  44| 
|  44|  45|         int i = 0;
|  45|  46|         int j = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|  43|  43| 
|  44|  44|         int i = 0;
|  45|  45|         int j = 0;
|  46|    |-        int min_diff = numeric_limits<int>::max();
|    |  46|+        int min_diff = numeric_limits < int >::max ();
|  47|  47| 
|  48|    |-        while (i < A.size() && j < B.size()) {
|  49|    |-            min_diff = min(min_diff, abs(A[i] - B[j]));
|  50|    |-            A[i] < B[j] ? ++i : ++j;
|  51|    |-        }
|    |  48|+        while (i < A.size () && j < B.size ())
|    |  49|+          {
|    |  50|+              min_diff = min (min_diff, abs (A[i] - B[j]));
|    |  51|+              A[i] < B[j] ? ++i : ++j;
|    |  52|+          }
|  52|  53| 
|  53|  54|         return min_diff;
|  54|  55|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/the-smallest-difference.cpp
|    |++++| /app/C++/the-smallest-difference.cpp
|  53|  53|         return min_diff;
|  54|  54|     }
|  55|  55| };
|  56|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|   1|   1| // Time:  O(nlogp), p is total pages.
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param pages: a vector of integers
|   8|   9|      * @param k: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|   8|   8|      * @param k: an integer
|   9|   9|      * @return: an integer
|  10|  10|      */
|  11|    |-    int copyBooks(vector<int> &pages, int k) {
|  12|    |-        if (k >= pages.size()) {
|  13|    |-            return *max_element(pages.cbegin(), pages.cend());
|  14|    |-        }
|    |  11|+    int copyBooks (vector < int >&pages, int k)
|    |  12|+    {
|    |  13|+        if (k >= pages.size ())
|    |  14|+          {
|    |  15|+              return *max_element (pages.cbegin (), pages.cend ());
|    |  16|+          }
|  15|  17| 
|  16|  18|         int sum = 0;
|  17|  19|         for (const auto& page : pages) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|  14|  14|         }
|  15|  15| 
|  16|  16|         int sum = 0;
|  17|    |-        for (const auto& page : pages) {
|  18|    |-            sum += page;
|  19|    |-        }
|  20|    |-        int average = sum / k;   // Lower bound.
|  21|    |-        return binarySearch(pages, k, average, sum);
|    |  17|+      for (const auto & page:pages)
|    |  18|+          {
|    |  19|+              sum += page;
|    |  20|+          }
|    |  21|+        int average = sum / k;  // Lower bound.
|    |  22|+        return binarySearch (pages, k, average, sum);
|  22|  23|     }
|  23|  24| 
|  24|  25|     int binarySearch(const vector<int> &pages,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|  21|  21|         return binarySearch(pages, k, average, sum);
|  22|  22|     }
|  23|  23| 
|  24|    |-    int binarySearch(const vector<int> &pages,
|  25|    |-                     const int k, int left, int right) {
|  26|    |-        while (left <= right) {
|  27|    |-            const auto mid = left + (right - left) / 2;
|  28|    |-            if (valid(pages, k, mid)) {
|  29|    |-                right = mid - 1;
|  30|    |-            } else {
|  31|    |-                left = mid + 1;
|  32|    |-            }
|  33|    |-        }
|    |  24|+    int binarySearch (const vector < int >&pages,
|    |  25|+                      const int k, int left, int right)
|    |  26|+    {
|    |  27|+        while (left <= right)
|    |  28|+          {
|    |  29|+              const auto mid = left + (right - left) / 2;
|    |  30|+              if (valid (pages, k, mid))
|    |  31|+                {
|    |  32|+                    right = mid - 1;
|    |  33|+                }
|    |  34|+              else
|    |  35|+                {
|    |  36|+                    left = mid + 1;
|    |  37|+                }
|    |  38|+          }
|  34|  39|         return left;
|  35|  40|     }
|  36|  41| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|  35|  35|     }
|  36|  36| 
|  37|  37|     // Check whether everyone copying at most x pages works or not. 
|  38|    |-    bool valid(const vector<int> &pages, const int k, const int x) {
|    |  38|+    bool valid (const vector < int >&pages, const int k, const int x)
|    |  39|+    {
|  39|  40|         int sum = 0;
|  40|  41|         int people = 0;
|  41|  42|         for (int i = 0; i < pages.size() && people < k; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-books.cpp
|    |++++| /app/C++/copy-books.cpp
|  38|  38|     bool valid(const vector<int> &pages, const int k, const int x) {
|  39|  39|         int sum = 0;
|  40|  40|         int people = 0;
|  41|    |-        for (int i = 0; i < pages.size() && people < k; ++i) {
|  42|    |-            if (sum + pages[i] > x) {
|  43|    |-                sum = 0;
|  44|    |-                ++people;
|  45|    |-            }
|  46|    |-            sum += pages[i];
|  47|    |-        }
|  48|    |-        return  people < k && sum <= x;
|    |  41|+        for (int i = 0; i < pages.size () && people < k; ++i)
|    |  42|+          {
|    |  43|+              if (sum + pages[i] > x)
|    |  44|+                {
|    |  45|+                    sum = 0;
|    |  46|+                    ++people;
|    |  47|+                }
|    |  48|+              sum += pages[i];
|    |  49|+          }
|    |  50|+        return people < k && sum <= x;
|  49|  51|     }
|  50|  52| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wiggle-sort.cpp
|    |++++| /app/C++/wiggle-sort.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums a list of integer
|   8|   9|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wiggle-sort.cpp
|    |++++| /app/C++/wiggle-sort.cpp
|   6|   6|     /**
|   7|   7|      * @param nums a list of integer
|   8|   8|      * @return void
|   9|    |-     */  
|  10|    |-    void wiggleSort(vector<int>& nums) {
|  11|    |-        for (int i = 1; i < nums.size(); ++i) {
|  12|    |-            if (((i % 2) && nums[i] < nums[i - 1]) ||
|  13|    |-                (!(i % 2) && nums[i] > nums[i - 1])) {
|  14|    |-                // Swap unordered elements.
|  15|    |-                swap(nums[i], nums[i - 1]);
|  16|    |-            }
|  17|    |-        }
|    |   9|+     */
|    |  10|+    void wiggleSort (vector < int >&nums)
|    |  11|+    {
|    |  12|+        for (int i = 1; i < nums.size (); ++i)
|    |  13|+          {
|    |  14|+              if (((i % 2) && nums[i] < nums[i - 1]) ||
|    |  15|+                  (!(i % 2) && nums[i] > nums[i - 1]))
|    |  16|+                {
|    |  17|+                    // Swap unordered elements.
|    |  18|+                    swap (nums[i], nums[i - 1]);
|    |  19|+                }
|    |  20|+          }
|  18|  21|     }
|  19|  22| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/super-ugly-number.cpp
|    |++++| /app/C++/super-ugly-number.cpp
|   2|   2| // Space: O(n + k)
|   3|   3| 
|   4|   4| // Heap solution. (308ms)
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param n a positive integer
|   9|  10|      * @param primes the given prime list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/super-ugly-number.cpp
|    |++++| /app/C++/super-ugly-number.cpp
|   9|   9|      * @param primes the given prime list
|  10|  10|      * @return the nth super ugly number
|  11|  11|      */
|  12|    |-    int nthSuperUglyNumber(int n, vector<int>& primes) {
|  13|    |-        priority_queue<pair<int, int>,
|  14|    |-                       vector<pair<int, int>>,
|  15|    |-                       greater<pair<int, int>>> heap;
|  16|    |-        vector<int> uglies(n), idx(primes.size()), ugly_by_last_prime(n);
|  17|    |-        uglies[0] = 1;
|    |  12|+    int nthSuperUglyNumber (int n, vector < int >&primes)
|    |  13|+    {
|    |  14|+        priority_queue < pair < int, int >,
|    |  15|+            vector < pair < int, int >>, greater < pair < int, int >>>heap;
|    |  16|+          vector < int >uglies (n), idx (primes.size ()),
|    |  17|+            ugly_by_last_prime (n);
|    |  18|+          uglies[0] = 1;
|  18|  19| 
|  19|    |-        for (int i = 0; i < primes.size(); ++i) {
|  20|    |-            heap.emplace(primes[i], i);
|  21|    |-        }
|  22|    |-        for (int i = 1; i < n; ++i) {
|  23|    |-            int k;
|  24|    |-            tie(uglies[i], k) = heap.top();
|  25|    |-            heap.pop();
|  26|    |-            ugly_by_last_prime[i] = k;
|  27|    |-            while (ugly_by_last_prime[++idx[k]] > k);  // worst time: O(k)
|  28|    |-            heap.emplace(uglies[idx[k]] * primes[k], k);
|  29|    |-        }
|    |  20|+        for (int i = 0; i < primes.size (); ++i)
|    |  21|+          {
|    |  22|+              heap.emplace (primes[i], i);
|    |  23|+          }
|    |  24|+        for (int i = 1; i < n; ++i)
|    |  25|+          {
|    |  26|+              int k;
|    |  27|+              tie (uglies[i], k) = heap.top ();
|    |  28|+              heap.pop ();
|    |  29|+              ugly_by_last_prime[i] = k;
|    |  30|+              while (ugly_by_last_prime[++idx[k]] > k) ;    // worst time: O(k)
|    |  31|+              heap.emplace (uglies[idx[k]] * primes[k], k);
|    |  32|+          }
|  30|  33|         return uglies[n - 1];
|  31|  34|     }
|  32|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-words-in-a-string.cpp
|    |++++| /app/C++/reverse-words-in-a-string.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s : A string
|   8|   9|      * @return : A string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-words-in-a-string.cpp
|    |++++| /app/C++/reverse-words-in-a-string.cpp
|   7|   7|      * @param s : A string
|   8|   8|      * @return : A string
|   9|   9|      */
|  10|    |-    string reverseWords(string s) {
|    |  10|+    string reverseWords (string s)
|    |  11|+    {
|  11|  12|         // Reverse the whole string first.
|  12|    |-        reverse(s.begin(), s.end());
|    |  13|+        reverse (s.begin (), s.end ());
|  13|  14| 
|  14|  15|         size_t begin = 0, end = 0, len = 0;
|  15|  16|         while ((begin = s.find_first_not_of(" ", end)) != string::npos) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-words-in-a-string.cpp
|    |++++| /app/C++/reverse-words-in-a-string.cpp
|  12|  12|         reverse(s.begin(), s.end());
|  13|  13| 
|  14|  14|         size_t begin = 0, end = 0, len = 0;
|  15|    |-        while ((begin = s.find_first_not_of(" ", end)) != string::npos) {
|  16|    |-            if ((end = s.find(" ", begin)) == string::npos) {
|  17|    |-                end = s.length();
|  18|    |-            }
|  19|    |-            // Reverse each word in the string.
|  20|    |-            reverse(s.begin() + begin, s.begin() + end);
|    |  15|+        while ((begin = s.find_first_not_of (" ", end)) != string::npos)
|    |  16|+          {
|    |  17|+              if ((end = s.find (" ", begin)) == string::npos)
|    |  18|+                {
|    |  19|+                    end = s.length ();
|    |  20|+                }
|    |  21|+              // Reverse each word in the string.
|    |  22|+              reverse (s.begin () + begin, s.begin () + end);
|  21|  23| 
|  22|    |-            // Shift the word to avoid extra space.
|  23|    |-            move(s.begin() + begin, s.begin() + end, s.begin() + len);
|  24|    |-            len += end - begin;
|  25|    |-            s[len++] = ' ';
|  26|    |-        }
|  27|    |-        s.resize(len ? len - 1 : 0);
|    |  24|+              // Shift the word to avoid extra space.
|    |  25|+              move (s.begin () + begin, s.begin () + end, s.begin () + len);
|    |  26|+              len += end - begin;
|    |  27|+              s[len++] = ' ';
|    |  28|+          }
|    |  29|+        s.resize (len ? len - 1 : 0);
|  28|  30|         return s;
|  29|  31|     }
|  30|  32| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum-ii.cpp
|    |++++| /app/C++/continuous-subarray-sum-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer array
|   8|   9|      * @return  A list of integers includes the index of
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum-ii.cpp
|    |++++| /app/C++/continuous-subarray-sum-ii.cpp
|   8|   8|      * @return  A list of integers includes the index of
|   9|   9|      *          the first number and the index of the last number
|  10|  10|      */
|  11|    |-    vector<int> continuousSubarraySumII(vector<int>& A) {
|  12|    |-        vector<int> result{-1, -1};
|  13|    |-        int max_sum = numeric_limits<int>::min();
|    |  11|+    vector < int >continuousSubarraySumII (vector < int >&A)
|    |  12|+    {
|    |  13|+        vector < int >result
|    |  14|+        {
|    |  15|+        -1, -1};
|    |  16|+        int max_sum = numeric_limits < int >::min ();
|  14|  17|         int total = 0;
|  15|  18| 
|  16|  19|         // Non-circular subarray.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum-ii.cpp
|    |++++| /app/C++/continuous-subarray-sum-ii.cpp
|  16|  16|         // Non-circular subarray.
|  17|  17|         int sum = 0;
|  18|  18|         int start = 0, end = 0;
|  19|    |-        for (int i = 0; i < A.size(); ++i) {
|  20|    |-            total += A[i];
|  21|    |-            if (sum < 0) {
|  22|    |-                sum = A[i];
|  23|    |-                start = end = i;
|  24|    |-            } else {
|  25|    |-                sum += A[i];
|  26|    |-                end = i;
|  27|    |-            }
|  28|    |-            if (sum >= max_sum) {
|  29|    |-                max_sum = sum;
|  30|    |-                result[0] = start;
|  31|    |-                result[1] = end;
|  32|    |-            }
|  33|    |-        }
|    |  19|+        for (int i = 0; i < A.size (); ++i)
|    |  20|+          {
|    |  21|+              total += A[i];
|    |  22|+              if (sum < 0)
|    |  23|+                {
|    |  24|+                    sum = A[i];
|    |  25|+                    start = end = i;
|    |  26|+                }
|    |  27|+              else
|    |  28|+                {
|    |  29|+                    sum += A[i];
|    |  30|+                    end = i;
|    |  31|+                }
|    |  32|+              if (sum >= max_sum)
|    |  33|+                {
|    |  34|+                    max_sum = sum;
|    |  35|+                    result[0] = start;
|    |  36|+                    result[1] = end;
|    |  37|+                }
|    |  38|+          }
|  34|  39| 
|  35|  40|         // Circular subarray.
|  36|  41|         sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum-ii.cpp
|    |++++| /app/C++/continuous-subarray-sum-ii.cpp
|  35|  35|         // Circular subarray.
|  36|  36|         sum = 0;
|  37|  37|         start = 0, end = -1;
|  38|    |-        for (int i = 0; i < A.size(); ++i) {
|  39|    |-            if (sum > 0) {
|  40|    |-                sum = A[i];
|  41|    |-                start = end = i;
|  42|    |-            } else {
|  43|    |-                sum += A[i];
|  44|    |-                end = i;
|  45|    |-            }
|  46|    |-            if (total - sum > max_sum && !(start == 0 && end == A.size() - 1)) {
|  47|    |-                max_sum = total - sum;
|  48|    |-                result[0] = (end + 1) % A.size();
|  49|    |-                result[1] = (start - 1) % A.size();
|  50|    |-            }
|  51|    |-        }
|    |  38|+        for (int i = 0; i < A.size (); ++i)
|    |  39|+          {
|    |  40|+              if (sum > 0)
|    |  41|+                {
|    |  42|+                    sum = A[i];
|    |  43|+                    start = end = i;
|    |  44|+                }
|    |  45|+              else
|    |  46|+                {
|    |  47|+                    sum += A[i];
|    |  48|+                    end = i;
|    |  49|+                }
|    |  50|+              if (total - sum > max_sum
|    |  51|+                  && !(start == 0 && end == A.size () - 1))
|    |  52|+                {
|    |  53|+                    max_sum = total - sum;
|    |  54|+                    result[0] = (end + 1) % A.size ();
|    |  55|+                    result[1] = (start - 1) % A.size ();
|    |  56|+                }
|    |  57|+          }
|  52|  58| 
|  53|  59|         return result;
|  54|  60|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-number.cpp
|    |++++| /app/C++/largest-number.cpp
|   1|   1| // Time:  O(nlogn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param num: A list of non negative integers
|   8|   9|      *@return: A string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-number.cpp
|    |++++| /app/C++/largest-number.cpp
|   7|   7|      *@param num: A list of non negative integers
|   8|   8|      *@return: A string
|   9|   9|      */
|  10|    |-    string largestNumber(vector<int> &num) {
|    |  10|+    string largestNumber (vector < int >&num)
|    |  11|+    {
|  11|  12|         // sort numbers
|  12|    |-        sort(num.begin(), num.end(), [](const int &i, const int &j) {
|  13|    |-            return to_string(i) + to_string(j) > to_string(j) + to_string(i);
|  14|    |-        });
|    |  13|+        sort (num.begin (), num.end (),[](const int &i, const int &j)
|    |  14|+              {
|    |  15|+              return to_string (i) + to_string (j) >
|    |  16|+              to_string (j) + to_string (i);}
|    |  17|+        );
|  15|  18| 
|  16|  19|         // combine the numbers
|  17|  20|         string max_num;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-number.cpp
|    |++++| /app/C++/largest-number.cpp
|  15|  15| 
|  16|  16|         // combine the numbers
|  17|  17|         string max_num;
|  18|    |-        for (const auto& i : num) {
|  19|    |-            max_num.append(to_string(i));
|  20|    |-        }
|    |  18|+      for (const auto & i:num)
|    |  19|+          {
|    |  20|+              max_num.append (to_string (i));
|    |  21|+          }
|  21|  22| 
|  22|  23|         // special case: start with zero (e.g. [0, 0])
|  23|  24|         if (!max_num.empty() && max_num[0] == '0')  {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-number.cpp
|    |++++| /app/C++/largest-number.cpp
|  20|  20|         }
|  21|  21| 
|  22|  22|         // special case: start with zero (e.g. [0, 0])
|  23|    |-        if (!max_num.empty() && max_num[0] == '0')  {
|  24|    |-            return "0";
|  25|    |-        }
|    |  23|+        if (!max_num.empty () && max_num[0] == '0')
|    |  24|+          {
|    |  25|+              return "0";
|    |  26|+          }
|  26|  27| 
|  27|  28|         return max_num;
|  28|  29|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fibonacci.cpp
|    |++++| /app/C++/fibonacci.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution{
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: an integer
|   8|   9|      * @return an integer f(n)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fibonacci.cpp
|    |++++| /app/C++/fibonacci.cpp
|   7|   7|      * @param n: an integer
|   8|   8|      * @return an integer f(n)
|   9|   9|      */
|  10|    |-    int fibonacci(int n) {
|  11|    |-        if (n <= 1) {
|  12|    |-            return n;
|  13|    |-        }
|    |  10|+    int fibonacci (int n)
|    |  11|+    {
|    |  12|+        if (n <= 1)
|    |  13|+          {
|    |  14|+              return n;
|    |  15|+          }
|  14|  16| 
|  15|  17|         int n_i = 1, n_i_1 = 1, n_i_2 = 0;
|  16|  18|         for (int i = 2; i < n; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fibonacci.cpp
|    |++++| /app/C++/fibonacci.cpp
|  13|  13|         }
|  14|  14| 
|  15|  15|         int n_i = 1, n_i_1 = 1, n_i_2 = 0;
|  16|    |-        for (int i = 2; i < n; ++i) {
|  17|    |-            n_i = n_i_1 + n_i_2;
|  18|    |-            n_i_2 = n_i_1;
|  19|    |-            n_i_1 = n_i;
|  20|    |-        }
|    |  16|+        for (int i = 2; i < n; ++i)
|    |  17|+          {
|    |  18|+              n_i = n_i_1 + n_i_2;
|    |  19|+              n_i_2 = n_i_1;
|    |  20|+              n_i_1 = n_i;
|    |  21|+          }
|  21|  22| 
|  22|  23|         return n_i;
|  23|  24|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fibonacci.cpp
|    |++++| /app/C++/fibonacci.cpp
|  22|  22|         return n_i;
|  23|  23|     }
|  24|  24| };
|  25|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands-ii.cpp
|    |++++| /app/C++/number-of-islands-ii.cpp
|  11|  11|  * };
|  12|  12|  */
|  13|  13| 
|  14|    |-class Solution {
|  15|    |-public:
|    |  14|+class Solution
|    |  15|+{
|    |  16|+  public:
|  16|  17|     /**
|  17|  18|      * @param n an integer
|  18|  19|      * @param m an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands-ii.cpp
|    |++++| /app/C++/number-of-islands-ii.cpp
|  19|  19|      * @param operators an array of point
|  20|  20|      * @return an integer array
|  21|  21|      */
|  22|    |-    vector<int> numIslands2(int n, int m, vector<Point>& operators) {
|  23|    |-        vector<int> numbers;
|    |  22|+    vector < int >numIslands2 (int n, int m, vector < Point > &operators)
|    |  23|+    {
|    |  24|+        vector < int >numbers;
|  24|  25|         int number = 0;
|  25|    |-        const vector<pair<int, int>> directions{{0, -1}, {0, 1},
|  26|    |-                                                {-1, 0}, {1, 0}};
|  27|    |-        unordered_map<int, int> set;
|  28|    |-        for (const auto& oper : operators) {
|  29|    |-            const auto& node = make_pair(oper.x, oper.y);
|  30|    |-            set[node_id(node, m)] = node_id(node, m);
|  31|    |-            ++number;
|    |  26|+        const vector < pair < int, int >>directions
|    |  27|+        {
|    |  28|+            {
|    |  29|+            0, -1},
|    |  30|+            {
|    |  31|+            0, 1},
|    |  32|+            {
|    |  33|+            -1, 0},
|    |  34|+            {
|    |  35|+        1, 0}};
|    |  36|+        unordered_map < int, int >set;
|    |  37|+      for (const auto & oper:operators)
|    |  38|+          {
|    |  39|+              const auto & node = make_pair (oper.x, oper.y);
|    |  40|+              set[node_id (node, m)] = node_id (node, m);
|    |  41|+              ++number;
|  32|  42| 
|  33|    |-            for (const auto& d : directions) {
|  34|    |-                const auto& neighbor = make_pair(oper.x + d.first,
|  35|    |-                                                 oper.y + d.second);
|  36|    |-                if (neighbor.first >= 0 && neighbor.first < n &&
|  37|    |-                    neighbor.second >= 0 && neighbor.second < m &&
|  38|    |-                    set.find(node_id(neighbor, m)) != set.end()) {
|  39|    |-                    if (find_set(node_id(node, m), &set) != 
|  40|    |-                        find_set(node_id(neighbor, m), &set)) {
|  41|    |-                        // Merge different islands.
|  42|    |-                        union_set(&set, node_id(node, m), node_id(neighbor, m));
|  43|    |-                        --number;
|  44|    |-                    }
|    |  43|+            for (const auto & d:directions)
|    |  44|+                {
|    |  45|+                    const auto & neighbor = make_pair (oper.x + d.first,
|    |  46|+                                                       oper.y + d.second);
|    |  47|+                    if (neighbor.first >= 0 && neighbor.first < n &&
|    |  48|+                        neighbor.second >= 0 && neighbor.second < m &&
|    |  49|+                        set.find (node_id (neighbor, m)) != set.end ())
|    |  50|+                      {
|    |  51|+                          if (find_set (node_id (node, m), &set) !=
|    |  52|+                              find_set (node_id (neighbor, m), &set))
|    |  53|+                            {
|    |  54|+                                // Merge different islands.
|    |  55|+                                union_set (&set, node_id (node, m),
|    |  56|+                                           node_id (neighbor, m));
|    |  57|+                                --number;
|    |  58|+                            }
|    |  59|+                      }
|  45|  60|                 }
|  46|    |-            }
|  47|    |-            numbers.emplace_back(number);
|  48|    |-        }
|    |  61|+              numbers.emplace_back (number);
|    |  62|+          }
|  49|  63| 
|  50|  64|         return numbers;
|  51|  65|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands-ii.cpp
|    |++++| /app/C++/number-of-islands-ii.cpp
|  50|  50|         return numbers;
|  51|  51|     }
|  52|  52| 
|  53|    |-    int node_id(const pair<int, int>& node, const int m) {
|    |  53|+    int node_id (const pair < int, int >&node, const int m)
|    |  54|+    {
|  54|  55|         return node.first * m + node.second;
|  55|  56|     }
|  56|  57| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands-ii.cpp
|    |++++| /app/C++/number-of-islands-ii.cpp
|  54|  54|         return node.first * m + node.second;
|  55|  55|     }
|  56|  56| 
|  57|    |-    int find_set(int x, unordered_map<int, int> *set) {
|  58|    |-       if ((*set)[x] != x) {
|  59|    |-           (*set)[x] = find_set((*set)[x], set);  // path compression.
|  60|    |-       }
|  61|    |-       return (*set)[x];
|    |  57|+    int find_set (int x, unordered_map < int, int >*set)
|    |  58|+    {
|    |  59|+        if ((*set)[x] != x)
|    |  60|+          {
|    |  61|+              (*set)[x] = find_set ((*set)[x], set);    // path compression.
|    |  62|+          }
|    |  63|+        return (*set)[x];
|  62|  64|     }
|  63|  65| 
|  64|  66|     void union_set(unordered_map<int, int> *set, const int x, const int y) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands-ii.cpp
|    |++++| /app/C++/number-of-islands-ii.cpp
|  61|  61|        return (*set)[x];
|  62|  62|     }
|  63|  63| 
|  64|    |-    void union_set(unordered_map<int, int> *set, const int x, const int y) {
|  65|    |-        int x_root = find_set(x, set), y_root = find_set(y, set);
|  66|    |-        (*set)[min(x_root, y_root)] = max(x_root, y_root);
|    |  64|+    void union_set (unordered_map < int, int >*set, const int x, const int y)
|    |  65|+    {
|    |  66|+        int x_root = find_set (x, set), y_root = find_set (y, set);
|    |  67|+        (*set)[min (x_root, y_root)] = max (x_root, y_root);
|  67|  68|     }
|  68|  69| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sliding-window-maximum.cpp
|    |++++| /app/C++/sliding-window-maximum.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers.
|   8|   9|      * @return: The maximum number inside the window at each moving.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sliding-window-maximum.cpp
|    |++++| /app/C++/sliding-window-maximum.cpp
|   7|   7|      * @param nums: A list of integers.
|   8|   8|      * @return: The maximum number inside the window at each moving.
|   9|   9|      */
|  10|    |-    vector<int> maxSlidingWindow(vector<int> &nums, int k) {
|  11|    |-        deque<int> dq;
|  12|    |-        vector<int> max_numbers;
|    |  10|+    vector < int >maxSlidingWindow (vector < int >&nums, int k)
|    |  11|+    {
|    |  12|+        deque < int >dq;
|    |  13|+          vector < int >max_numbers;
|  13|  14| 
|  14|    |-        for (int i = 0; i < nums.size(); ++i) {
|  15|    |-            while ((!dq.empty() && nums[i] > nums[dq.back()])) {
|  16|    |-                dq.pop_back();
|  17|    |-            } 
|  18|    |-            dq.emplace_back(i);
|  19|    |-            if (i >= k  && dq.front() == i - k) {
|  20|    |-                dq.pop_front();
|  21|    |-            }
|  22|    |-            if (i >= k - 1) {
|  23|    |-                max_numbers.emplace_back(nums[dq.front()]);
|  24|    |-            }
|  25|    |-        }
|    |  15|+        for (int i = 0; i < nums.size (); ++i)
|    |  16|+          {
|    |  17|+              while ((!dq.empty () && nums[i] > nums[dq.back ()]))
|    |  18|+                {
|    |  19|+                    dq.pop_back ();
|    |  20|+                }
|    |  21|+              dq.emplace_back (i);
|    |  22|+              if (i >= k && dq.front () == i - k)
|    |  23|+                {
|    |  24|+                    dq.pop_front ();
|    |  25|+                }
|    |  26|+              if (i >= k - 1)
|    |  27|+                {
|    |  28|+                    max_numbers.emplace_back (nums[dq.front ()]);
|    |  29|+                }
|    |  30|+          }
|  26|  31| 
|  27|  32|         return max_numbers;
|  28|  33|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|     /** 
|   6|   7|      * param A : an integer ratated sorted array
|   7|   8|      * param target :  an integer to be searched
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array.cpp
|   7|   7|      * param target :  an integer to be searched
|   8|   8|      * return : an integer
|   9|   9|      */
|  10|    |-public:
|  11|    |-    int search(vector<int> &A, int target) {
|  12|    |-        int left = 0, right = A.size() - 1;
|    |  10|+  public:
|    |  11|+    int search (vector < int >&A, int target)
|    |  12|+    {
|    |  13|+        int left = 0, right = A.size () - 1;
|  13|  14| 
|  14|    |-        while (left <= right) {
|  15|    |-            int mid = left + (right - left) / 2;
|  16|    |-            if (A[mid] == target) {
|  17|    |-                return mid;
|  18|    |-            } else if ((A[mid] >= A[left] && A[left] <= target && target < A[mid]) ||
|  19|    |-                       (A[mid] < A[left] && !(A[mid] < target && target <= A[right]))) {
|  20|    |-                right = mid - 1;
|  21|    |-            } else {
|  22|    |-                left = mid + 1;
|  23|    |-            }
|  24|    |-        }
|    |  15|+        while (left <= right)
|    |  16|+          {
|    |  17|+              int mid = left + (right - left) / 2;
|    |  18|+              if (A[mid] == target)
|    |  19|+                {
|    |  20|+                    return mid;
|    |  21|+                }
|    |  22|+              else if ((A[mid] >= A[left] && A[left] <= target
|    |  23|+                        && target < A[mid]) || (A[mid] < A[left]
|    |  24|+                                                && !(A[mid] < target
|    |  25|+                                                     && target <= A[right])))
|    |  26|+                {
|    |  27|+                    right = mid - 1;
|    |  28|+                }
|    |  29|+              else
|    |  30|+                {
|    |  31|+                    left = mid + 1;
|    |  32|+                }
|    |  33|+          }
|  25|  34| 
|  26|  35|         return -1;
|  27|  36|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array.cpp
|  27|  27|     }
|  28|  28| };
|  29|  29| 
|  30|    |-class Solution2 {
|    |  30|+class Solution2
|    |  31|+{
|  31|  32|     /** 
|  32|  33|      * param A : an integer ratated sorted array
|  33|  34|      * param target :  an integer to be searched
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array.cpp
|  33|  33|      * param target :  an integer to be searched
|  34|  34|      * return : an integer
|  35|  35|      */
|  36|    |-public:
|  37|    |-    int search(vector<int> &A, int target) {
|  38|    |-        int left = 0, right = A.size();
|    |  36|+  public:
|    |  37|+    int search (vector < int >&A, int target)
|    |  38|+    {
|    |  39|+        int left = 0, right = A.size ();
|  39|  40| 
|  40|    |-        while (left < right) {
|  41|    |-            int mid = left + (right - left) / 2;
|  42|    |-            if (A[mid] == target) {
|  43|    |-                return mid;
|  44|    |-            } else if ((A[left] <= A[mid] && A[left] <= target && target < A[mid]) ||
|  45|    |-                       (A[left] > A[mid] && !(A[mid] < target && target <= A[right - 1]))) {
|  46|    |-                right = mid;
|  47|    |-            } else {
|  48|    |-                left = mid + 1;
|  49|    |-            }
|  50|    |-        }
|    |  41|+        while (left < right)
|    |  42|+          {
|    |  43|+              int mid = left + (right - left) / 2;
|    |  44|+              if (A[mid] == target)
|    |  45|+                {
|    |  46|+                    return mid;
|    |  47|+                }
|    |  48|+              else if ((A[left] <= A[mid] && A[left] <= target
|    |  49|+                        && target < A[mid]) || (A[left] > A[mid]
|    |  50|+                                                && !(A[mid] < target
|    |  51|+                                                     && target <=
|    |  52|+                                                     A[right - 1])))
|    |  53|+                {
|    |  54|+                    right = mid;
|    |  55|+                }
|    |  56|+              else
|    |  57|+                {
|    |  58|+                    left = mid + 1;
|    |  59|+                }
|    |  60|+          }
|  51|  61| 
|  52|  62|         return -1;
|  53|  63|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-array.cpp
|    |++++| /app/C++/partition-array.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|   6|    |-    int partitionArray(vector<int> &nums, int k) {
|   7|    |-        int left = 0, right = nums.size() - 1;
|   8|    |-        
|   9|    |-        while (left <= right) {
|  10|    |-            if (nums[left] < k) {
|  11|    |-                ++left;
|  12|    |-            } else if (nums[right] >= k) {
|  13|    |-                --right;
|  14|    |-            } else {
|  15|    |-               swap(nums[left++], nums[right--]);
|  16|    |-            }
|  17|    |-        }
|  18|    |-        
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|    |   7|+    int partitionArray (vector < int >&nums, int k)
|    |   8|+    {
|    |   9|+        int left = 0, right = nums.size () - 1;
|    |  10|+
|    |  11|+        while (left <= right)
|    |  12|+          {
|    |  13|+              if (nums[left] < k)
|    |  14|+                {
|    |  15|+                    ++left;
|    |  16|+                }
|    |  17|+              else if (nums[right] >= k)
|    |  18|+                {
|    |  19|+                    --right;
|    |  20|+                }
|    |  21|+              else
|    |  22|+                {
|    |  23|+                    swap (nums[left++], nums[right--]);
|    |  24|+                }
|    |  25|+          }
|    |  26|+
|  19|  27|         return left;
|  20|  28|     }
|  21|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-node-in-a-binary-search-tree.cpp
|    |++++| /app/C++/insert-node-in-a-binary-search-tree.cpp
|   1|   1| // Time:  O(h)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param root: The root of the binary search tree->
|   8|   9|      * @param node: insert this node into the binary search tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-node-in-a-binary-search-tree.cpp
|    |++++| /app/C++/insert-node-in-a-binary-search-tree.cpp
|   8|   8|      * @param node: insert this node into the binary search tree
|   9|   9|      * @return: The root of the new binary search tree->
|  10|  10|      */
|  11|    |-    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
|  12|    |-        if (root == nullptr) {
|  13|    |-            return node;
|  14|    |-        }
|  15|    |-        TreeNode* curr = root;
|  16|    |-        while (true) {
|  17|    |-            if (node->val < curr->val) {
|  18|    |-                if (curr->left != nullptr) {
|  19|    |-                    curr = curr->left;
|    |  11|+    TreeNode * insertNode (TreeNode * root, TreeNode * node)
|    |  12|+    {
|    |  13|+        if (root == nullptr)
|    |  14|+          {
|    |  15|+              return node;
|    |  16|+          }
|    |  17|+        TreeNode *curr = root;
|    |  18|+        while (true)
|    |  19|+          {
|    |  20|+              if (node->val < curr->val)
|    |  21|+                {
|    |  22|+                    if (curr->left != nullptr)
|    |  23|+                      {
|    |  24|+                          curr = curr->left;
|    |  25|+                      }
|    |  26|+                    else
|    |  27|+                      {
|    |  28|+                          curr->left = node;
|    |  29|+                          break;
|    |  30|+                      }
|  20|  31|                 }
|  21|    |-                else {
|  22|    |-                    curr->left = node;
|    |  32|+              else if (node->val > curr->val)
|    |  33|+                {
|    |  34|+                    if (curr->right != nullptr)
|    |  35|+                      {
|    |  36|+                          curr = curr->right;
|    |  37|+                      }
|    |  38|+                    else
|    |  39|+                      {
|    |  40|+                          curr->right = node;
|    |  41|+                          break;
|    |  42|+                      }
|    |  43|+                }
|    |  44|+              else
|    |  45|+                {
|    |  46|+                    curr->val = node->val;
|  23|  47|                     break;
|  24|  48|                 }
|  25|  49|             } else if (node->val > curr->val) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-node-in-a-binary-search-tree.cpp
|    |++++| /app/C++/insert-node-in-a-binary-search-tree.cpp
|  22|  22|                     curr->left = node;
|  23|  23|                     break;
|  24|  24|                 }
|  25|    |-            } else if (node->val > curr->val) {
|  26|    |-                if (curr->right != nullptr) {
|  27|    |-                    curr = curr->right;
|  28|    |-                }
|  29|    |-                else {
|  30|    |-                    curr->right = node;
|  31|    |-                    break;
|  32|    |-                }
|  33|    |-            } else {
|  34|    |-                curr->val = node->val;
|  35|    |-                break;
|  36|    |-            }
|  37|    |-        }
|    |  25|+          }
|  38|  26|         return root;
|  39|  27|     }
|  40|  28| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-node-in-a-binary-search-tree.cpp
|    |++++| /app/C++/insert-node-in-a-binary-search-tree.cpp
|  39|  39|     }
|  40|  40| };
|  41|  41| 
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  42|+class Solution2
|    |  43|+{
|    |  44|+  public:
|  44|  45|     /**
|  45|  46|      * @param root: The root of the binary search tree->
|  46|  47|      * @param node: insert this node into the binary search tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insert-node-in-a-binary-search-tree.cpp
|    |++++| /app/C++/insert-node-in-a-binary-search-tree.cpp
|  46|  46|      * @param node: insert this node into the binary search tree
|  47|  47|      * @return: The root of the new binary search tree->
|  48|  48|      */
|  49|    |-    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
|  50|    |-        if (root == nullptr) {
|  51|    |-            return node;
|  52|    |-        }
|  53|    |-        if (node->val < root->val) {
|  54|    |-            root->left = insertNode(root->left, node);
|  55|    |-        }
|  56|    |-        else if (node->val > root->val) {
|  57|    |-            root->right = insertNode(root->right, node);
|  58|    |-        }
|  59|    |-        else {
|  60|    |-            root->val = node->val;
|  61|    |-        }
|    |  49|+    TreeNode * insertNode (TreeNode * root, TreeNode * node)
|    |  50|+    {
|    |  51|+        if (root == nullptr)
|    |  52|+          {
|    |  53|+              return node;
|    |  54|+          }
|    |  55|+        if (node->val < root->val)
|    |  56|+          {
|    |  57|+              root->left = insertNode (root->left, node);
|    |  58|+          }
|    |  59|+        else if (node->val > root->val)
|    |  60|+          {
|    |  61|+              root->right = insertNode (root->right, node);
|    |  62|+          }
|    |  63|+        else
|    |  64|+          {
|    |  65|+              root->val = node->val;
|    |  66|+          }
|  62|  67|         return root;
|  63|  68|     }
|  64|  69| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-intervals.cpp
|    |++++| /app/C++/merge-intervals.cpp
|  10|  10|  *         this->end = end;
|  11|  11|  *     }
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param intervals: interval list.
|  17|  18|      * @return: A new interval list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-intervals.cpp
|    |++++| /app/C++/merge-intervals.cpp
|  16|  16|      * @param intervals: interval list.
|  17|  17|      * @return: A new interval list.
|  18|  18|      */
|  19|    |-    vector<Interval> merge(vector<Interval> &intervals) {
|  20|    |-        if (intervals.empty()) {
|  21|    |-            return intervals;
|  22|    |-        }
|    |  19|+    vector < Interval > merge (vector < Interval > &intervals)
|    |  20|+    {
|    |  21|+        if (intervals.empty ())
|    |  22|+          {
|    |  23|+              return intervals;
|    |  24|+          }
|  23|  25| 
|  24|    |-        sort(intervals.begin(), intervals.end(),
|  25|    |-        [](const Interval& a, const Interval& b) {
|  26|    |-             return a.start < b.start;               
|  27|    |-        });
|    |  26|+        sort (intervals.begin (), intervals.end (),
|    |  27|+              [](const Interval & a, const Interval & b)
|    |  28|+              {
|    |  29|+              return a.start < b.start;}
|    |  30|+        );
|  28|  31| 
|  29|    |-        vector<Interval> result = {intervals[0]};
|  30|    |-        for (int i = 1; i < intervals.size(); ++i) {
|  31|    |-            Interval& prev = result.back();
|  32|    |-            if (intervals[i].start <= prev.end) { 
|  33|    |-                prev.end = max(prev.end, intervals[i].end);
|  34|    |-            } else {
|  35|    |-                result.emplace_back(intervals[i]);
|  36|    |-            }
|  37|    |-        }
|    |  32|+        vector < Interval > result =
|    |  33|+        {
|    |  34|+        intervals[0]};
|    |  35|+        for (int i = 1; i < intervals.size (); ++i)
|    |  36|+          {
|    |  37|+              Interval & prev = result.back ();
|    |  38|+              if (intervals[i].start <= prev.end)
|    |  39|+                {
|    |  40|+                    prev.end = max (prev.end, intervals[i].end);
|    |  41|+                }
|    |  42|+              else
|    |  43|+                {
|    |  44|+                    result.emplace_back (intervals[i]);
|    |  45|+                }
|    |  46|+          }
|  38|  47| 
|  39|  48|         return result;
|  40|  49|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|   1|   1| // Time:  O(klog(min(m, n, k))
|   2|   2| // Space: O(min(m, n, k))
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: a matrix of integers
|   8|   9|      * @param k: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|   8|   8|      * @param k: an integer
|   9|   9|      * @return: the kth smallest number in the matrix
|  10|  10|      */
|  11|    |-    int kthSmallest(vector<vector<int>> &matrix, int k) {
|    |  11|+    int kthSmallest (vector < vector < int >>&matrix, int k)
|    |  12|+    {
|  12|  13|         int kth_smallest = 0;
|  13|  14| 
|  14|  15|         using P = pair<int, pair<int, int>>;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|  11|  11|     int kthSmallest(vector<vector<int>> &matrix, int k) {
|  12|  12|         int kth_smallest = 0;
|  13|  13| 
|  14|    |-        using P = pair<int, pair<int, int>>;
|  15|    |-        priority_queue<P, vector<P>, greater<P>> q;
|  16|    |-        auto push = [&matrix, &q](int i, int j) {
|  17|    |-            if (matrix.size() > matrix[0].size()) {
|  18|    |-                if (i < matrix[0].size() && j < matrix.size()) {
|  19|    |-                    q.emplace(matrix[j][i], make_pair(i, j));
|  20|    |-                }
|  21|    |-            } else {
|  22|    |-                if (i < matrix.size() && j < matrix[0].size()) {
|  23|    |-                    q.emplace(matrix[i][j], make_pair(i, j));
|  24|    |-                }
|  25|    |-            }
|  26|    |-        };
|  27|    |-
|  28|    |-        push(0, 0);
|  29|    |-        while (!q.empty() && k--) {
|  30|    |-            auto tmp = q.top(); q.pop();
|  31|    |-            kth_smallest = tmp.first;
|  32|    |-            int i, j;
|  33|    |-            tie(i, j) = tmp.second;
|  34|    |-            push(i, j + 1);
|  35|    |-            if (j == 0) {
|  36|    |-                push(i + 1, 0);
|  37|    |-            }
|  38|    |-        }
|  39|    |-        return kth_smallest;
|  40|    |-    }
|  41|    |-};
|  42|    |-
|    |  14|+        using P = pair < int, pair < int, int >>;
|    |  15|+          priority_queue < P, vector < P >, greater < P >> q;
|    |  16|+        auto push =[&matrix, &q] (int i, int j) {
|    |  17|+            if (matrix.size () > matrix[0].size ())
|    |  18|+              {
|    |  19|+               if (i < matrix[0].size () && j < matrix.size ()){
|    |  20|+                                                                q.
|    |  21|+                                                                emplace (matrix
|    |  22|+                                                                         [j]
|    |  23|+                                                                         [i],
|    |  24|+                                                                         make_pair
|    |  25|+                                                                         (i,
|    |  26|+                                                                          j));}
|    |  27|+                                                                }
|    |  28|+                                                                else
|    |  29|+                                                                {
|    |  30|+                                                                if (i <
|    |  31|+                                                                    matrix.
|    |  32|+                                                                    size ()
|    |  33|+                                                                    && j <
|    |  34|+                                                                    matrix[0].
|    |  35|+                                                                    size ())
|    |  36|+                                                                {
|    |  37|+                                                                q.
|    |  38|+                                                                emplace (matrix
|    |  39|+                                                                         [i]
|    |  40|+                                                                         [j],
|    |  41|+                                                                         make_pair
|    |  42|+                                                                         (i,
|    |  43|+                                                                          j));}
|    |  44|+                                                                }
|    |  45|+                                                                };
|    |  46|+                                                                push (0, 0);
|    |  47|+                                                                while (!q.
|    |  48|+                                                                       empty ()
|    |  49|+                                                                       && k--)
|    |  50|+                                                                {
|    |  51|+                                                                auto tmp =
|    |  52|+                                                                q.top ();
|    |  53|+                                                                q.pop ();
|    |  54|+                                                                kth_smallest =
|    |  55|+                                                                tmp.first;
|    |  56|+                                                                int i, j;
|    |  57|+                                                                tie (i, j) =
|    |  58|+                                                                tmp.second;
|    |  59|+                                                                push (i,
|    |  60|+                                                                      j + 1);
|    |  61|+                                                                if (j == 0)
|    |  62|+                                                                {
|    |  63|+                                                                push (i + 1,
|    |  64|+                                                                      0);}
|    |  65|+                                                                }
|    |  66|+                                                                return
|    |  67|+                                                                kth_smallest;}
|    |  68|+                                                                };
|  43|  69| // BST solution.
|  44|    |-class Solution2 {
|  45|    |-public:
|    |  70|+                                                                class Solution2
|    |  71|+                                                                {
|    |  72|+  public:
|  46|  73|     /**
|  47|  74|      * @param matrix: a matrix of integers
|  48|  75|      * @param k: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|  48|  48|      * @param k: an integer
|  49|  49|      * @return: the kth smallest number in the matrix
|  50|  50|      */
|  51|    |-    int kthSmallest(vector<vector<int>> &matrix, int k) {
|  52|    |-        if (matrix.size() < matrix[0].size()) {  // Height is smaller.
|  53|    |-            return horizontal_search(matrix, k);
|  54|    |-        } else {  // Width is smaller.
|  55|    |-            return vertical_search(matrix, k);
|  56|    |-        }
|  57|    |-    }
|  58|    |-
|  59|    |-    int horizontal_search(const vector<vector<int>> &matrix, int k) {
|  60|    |-        multimap<int, pair<int, int>> min_bst;
|  61|    |-
|  62|    |-        // Init BST by the first element of the first kth row.
|  63|    |-        for (int i = 0; i < min(static_cast<int>(matrix.size()), k); ++i) {
|  64|    |-            min_bst.emplace(pair<int, pair<int, int>>{matrix[i][0], {i, 0}});
|  65|    |-        }
|  66|    |-
|  67|    |-        int kth_smallest = INT_MAX;
|  68|    |-        while (!min_bst.empty() && k--) {
|  69|    |-            // Pop the min of BST.
|  70|    |-            if (k == 0) {
|  71|    |-                kth_smallest = min_bst.cbegin()->first;
|  72|    |-            }
|  73|    |-            // Pop the min of BST.
|  74|    |-            int i = min_bst.cbegin()->second.first;
|  75|    |-            int j = min_bst.cbegin()->second.second;
|  76|    |-            min_bst.erase(min_bst.cbegin());
|  77|    |-
|  78|    |-            // Insert the next possible element.
|  79|    |-            if (j + 1 < matrix[i].size()) {
|  80|    |-                min_bst.emplace(pair<int, pair<int, int>>{matrix[i][j + 1], {i, j + 1}});
|  81|    |-            }
|  82|    |-        }
|  83|    |-
|  84|    |-        return kth_smallest;
|  85|    |-    }
|  86|    |-
|  87|    |-    int vertical_search(const vector<vector<int>> &matrix, int k) {
|  88|    |-        multimap<int, pair<int, int>> min_bst;
|  89|    |-
|  90|    |-        // Init BST by the first element of the first kth column.
|  91|    |-        for (int j = 0; j < min(static_cast<int>(matrix[0].size()), k); ++j) {
|  92|    |-            min_bst.emplace(pair<int, pair<int, int>>{matrix[0][j], {0, j}});
|  93|    |-        }
|  94|    |-
|  95|    |-        int kth_smallest = INT_MAX;
|  96|    |-        while (!min_bst.empty() && k--) {
|  97|    |-            // Pop the min of Heap.
|  98|    |-            if (k == 0) {
|  99|    |-                kth_smallest = min_bst.cbegin()->first;
| 100|    |-            }
| 101|    |-            // Pop the min of BST.
| 102|    |-            int i = min_bst.cbegin()->second.first;
| 103|    |-            int j = min_bst.cbegin()->second.second;
| 104|    |-            min_bst.erase(min_bst.cbegin());
| 105|    |-
| 106|    |-            // Insert the next possible element.
| 107|    |-            if (i + 1 < matrix.size()) {
| 108|    |-                min_bst.emplace(pair<int, pair<int, int>>{matrix[i + 1][j], {i + 1, j}});
| 109|    |-            }
| 110|    |-        }
| 111|    |-
| 112|    |-        return kth_smallest;
| 113|    |-    }
| 114|    |-};
| 115|    |-
|    |  51|+                                                                int
|    |  52|+                                                                kthSmallest
|    |  53|+                                                                (vector <
|    |  54|+                                                                 vector <
|    |  55|+                                                                 int >>&matrix,
|    |  56|+                                                                 int k)
|    |  57|+                                                                {
|    |  58|+                                                                if (matrix.
|    |  59|+                                                                    size () <
|    |  60|+                                                                    matrix[0].
|    |  61|+                                                                    size ())
|    |  62|+                                                                {   // Height is smaller.
|    |  63|+                                                                return
|    |  64|+                                                                horizontal_search
|    |  65|+                                                                (matrix, k);}
|    |  66|+                                                                else
|    |  67|+                                                                {   // Width is smaller.
|    |  68|+                                                                return
|    |  69|+                                                                vertical_search
|    |  70|+                                                                (matrix, k);}
|    |  71|+                                                                }
|    |  72|+
|    |  73|+                                                                int
|    |  74|+                                                                horizontal_search
|    |  75|+                                                                (const vector <
|    |  76|+                                                                 vector <
|    |  77|+                                                                 int >>&matrix,
|    |  78|+                                                                 int k)
|    |  79|+                                                                {
|    |  80|+                                                                multimap < int,
|    |  81|+                                                                pair < int,
|    |  82|+                                                                int >>min_bst;
|    |  83|+                                                                // Init BST by the first element of the first kth row.
|    |  84|+                                                                for (int i = 0;
|    |  85|+                                                                     i <
|    |  86|+                                                                     min
|    |  87|+                                                                     (static_cast
|    |  88|+                                                                      <
|    |  89|+                                                                      int
|    |  90|+                                                                      >(matrix.
|    |  91|+                                                                        size
|    |  92|+                                                                        ()),
|    |  93|+                                                                      k); ++i)
|    |  94|+                                                                {
|    |  95|+                                                                min_bst.
|    |  96|+                                                                emplace (pair <
|    |  97|+                                                                         int,
|    |  98|+                                                                         pair <
|    |  99|+                                                                         int,
|    | 100|+                                                                         int >>
|    | 101|+                                                                         {
|    | 102|+                                                                         matrix
|    | 103|+                                                                         [i]
|    | 104|+                                                                         [0],
|    | 105|+                                                                         {
|    | 106|+                                                                         i,
|    | 107|+                                                                         0}});}
|    | 108|+
|    | 109|+                                                                int
|    | 110|+                                                                kth_smallest =
|    | 111|+                                                                INT_MAX;
|    | 112|+                                                                while
|    | 113|+                                                                (!min_bst.
|    | 114|+                                                                 empty ()
|    | 115|+                                                                 && k--)
|    | 116|+                                                                {
|    | 117|+                                                                // Pop the min of BST.
|    | 118|+                                                                if (k == 0)
|    | 119|+                                                                {
|    | 120|+                                                                kth_smallest =
|    | 121|+                                                                min_bst.
|    | 122|+                                                                cbegin ()->
|    | 123|+                                                                first;}
|    | 124|+                                                                // Pop the min of BST.
|    | 125|+                                                                int i =
|    | 126|+                                                                min_bst.
|    | 127|+                                                                cbegin ()->
|    | 128|+                                                                second.first;
|    | 129|+                                                                int j =
|    | 130|+                                                                min_bst.
|    | 131|+                                                                cbegin ()->
|    | 132|+                                                                second.second;
|    | 133|+                                                                min_bst.
|    | 134|+                                                                erase (min_bst.
|    | 135|+                                                                       cbegin
|    | 136|+                                                                       ());
|    | 137|+                                                                // Insert the next possible element.
|    | 138|+                                                                if (j + 1 <
|    | 139|+                                                                    matrix[i].
|    | 140|+                                                                    size ())
|    | 141|+                                                                {
|    | 142|+                                                                min_bst.
|    | 143|+                                                                emplace (pair <
|    | 144|+                                                                         int,
|    | 145|+                                                                         pair <
|    | 146|+                                                                         int,
|    | 147|+                                                                         int >>
|    | 148|+                                                                         {
|    | 149|+                                                                         matrix
|    | 150|+                                                                         [i][j
|    | 151|+                                                                             +
|    | 152|+                                                                             1],
|    | 153|+                                                                         {
|    | 154|+                                                                         i,
|    | 155|+                                                                         j +
|    | 156|+                                                                         1}});}
|    | 157|+                                                                }
|    | 158|+
|    | 159|+                                                                return
|    | 160|+                                                                kth_smallest;}
|    | 161|+
|    | 162|+                                                                int
|    | 163|+                                                                vertical_search
|    | 164|+                                                                (const vector <
|    | 165|+                                                                 vector <
|    | 166|+                                                                 int >>&matrix,
|    | 167|+                                                                 int k)
|    | 168|+                                                                {
|    | 169|+                                                                multimap < int,
|    | 170|+                                                                pair < int,
|    | 171|+                                                                int >>min_bst;
|    | 172|+                                                                // Init BST by the first element of the first kth column.
|    | 173|+                                                                for (int j = 0;
|    | 174|+                                                                     j <
|    | 175|+                                                                     min
|    | 176|+                                                                     (static_cast
|    | 177|+                                                                      <
|    | 178|+                                                                      int
|    | 179|+                                                                      >(matrix
|    | 180|+                                                                        [0].
|    | 181|+                                                                        size
|    | 182|+                                                                        ()),
|    | 183|+                                                                      k); ++j)
|    | 184|+                                                                {
|    | 185|+                                                                min_bst.
|    | 186|+                                                                emplace (pair <
|    | 187|+                                                                         int,
|    | 188|+                                                                         pair <
|    | 189|+                                                                         int,
|    | 190|+                                                                         int >>
|    | 191|+                                                                         {
|    | 192|+                                                                         matrix
|    | 193|+                                                                         [0]
|    | 194|+                                                                         [j],
|    | 195|+                                                                         {
|    | 196|+                                                                         0,
|    | 197|+                                                                         j}});}
|    | 198|+
|    | 199|+                                                                int
|    | 200|+                                                                kth_smallest =
|    | 201|+                                                                INT_MAX;
|    | 202|+                                                                while
|    | 203|+                                                                (!min_bst.
|    | 204|+                                                                 empty ()
|    | 205|+                                                                 && k--)
|    | 206|+                                                                {
|    | 207|+                                                                // Pop the min of Heap.
|    | 208|+                                                                if (k == 0)
|    | 209|+                                                                {
|    | 210|+                                                                kth_smallest =
|    | 211|+                                                                min_bst.
|    | 212|+                                                                cbegin ()->
|    | 213|+                                                                first;}
|    | 214|+                                                                // Pop the min of BST.
|    | 215|+                                                                int i =
|    | 216|+                                                                min_bst.
|    | 217|+                                                                cbegin ()->
|    | 218|+                                                                second.first;
|    | 219|+                                                                int j =
|    | 220|+                                                                min_bst.
|    | 221|+                                                                cbegin ()->
|    | 222|+                                                                second.second;
|    | 223|+                                                                min_bst.
|    | 224|+                                                                erase (min_bst.
|    | 225|+                                                                       cbegin
|    | 226|+                                                                       ());
|    | 227|+                                                                // Insert the next possible element.
|    | 228|+                                                                if (i + 1 <
|    | 229|+                                                                    matrix.
|    | 230|+                                                                    size ())
|    | 231|+                                                                {
|    | 232|+                                                                min_bst.
|    | 233|+                                                                emplace (pair <
|    | 234|+                                                                         int,
|    | 235|+                                                                         pair <
|    | 236|+                                                                         int,
|    | 237|+                                                                         int >>
|    | 238|+                                                                         {
|    | 239|+                                                                         matrix
|    | 240|+                                                                         [i +
|    | 241|+                                                                          1]
|    | 242|+                                                                         [j],
|    | 243|+                                                                         {
|    | 244|+                                                                         i + 1,
|    | 245|+                                                                         j}});}
|    | 246|+                                                                }
|    | 247|+
|    | 248|+                                                                return
|    | 249|+                                                                kth_smallest;}
|    | 250|+                                                                };
| 116| 251| // Time:  O(klog(min(m, n, k))
| 117| 252| // Space: O(min(m, n, k))
| 118| 253| // Heap solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
| 116| 116| // Time:  O(klog(min(m, n, k))
| 117| 117| // Space: O(min(m, n, k))
| 118| 118| // Heap solution.
| 119|    |-class Solution3 {
| 120|    |-public:
| 121|    |-    struct Compare {
| 122|    |-        bool operator()(const pair<int, pair<int, int>>& a, const pair<int, pair<int, int>>& b) {
| 123|    |-            return a.first > b.first;
| 124|    |-        }
| 125|    |-    };
|    | 119|+                                                                class Solution3
|    | 120|+                                                                {
|    | 121|+  public:
|    | 122|+                                                                struct Compare
|    | 123|+                                                                {
|    | 124|+                                                                bool
|    | 125|+                                                                operator ()
|    | 126|+                                                                (const pair <
|    | 127|+                                                                 int,
|    | 128|+                                                                 pair < int,
|    | 129|+                                                                 int >>&a,
|    | 130|+                                                                 const pair <
|    | 131|+                                                                 int,
|    | 132|+                                                                 pair < int,
|    | 133|+                                                                 int >>&b)
|    | 134|+                                                                {
|    | 135|+                                                                return a.
|    | 136|+                                                                first >
|    | 137|+                                                                b.first;}
|    | 138|+                                                                };
| 126| 139|     /**
| 127| 140|      * @param matrix: a matrix of integers
| 128| 141|      * @param k: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-smallest-number-in-sorted-matrix.cpp
|    |++++| /app/C++/kth-smallest-number-in-sorted-matrix.cpp
| 128| 128|      * @param k: an integer
| 129| 129|      * @return: the kth smallest number in the matrix
| 130| 130|      */
| 131|    |-    int kthSmallest(vector<vector<int>> &matrix, int k) {
| 132|    |-        if (matrix.size() < matrix[0].size()) {  // Height is smaller.
| 133|    |-            return horizontal_search(matrix, k);
| 134|    |-        } else {  // Width is smaller.
| 135|    |-            return vertical_search(matrix, k);
| 136|    |-        }
| 137|    |-    }
| 138|    |-
| 139|    |-    int horizontal_search(const vector<vector<int>> &matrix, int k) {
| 140|    |-        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, Compare> min_heap;
| 141|    |-
| 142|    |-        // Init Heap by the first element of the first kth row.
| 143|    |-        for (int i = 0; i < min(static_cast<int>(matrix.size()), k); ++i) {
| 144|    |-            min_heap.emplace(pair<int, pair<int, int>>{matrix[i][0], {i, 0}});
| 145|    |-        }
| 146|    |-
| 147|    |-        int kth_smallest = INT_MAX;
| 148|    |-        while (!min_heap.empty() && k--) {
| 149|    |-            // Pop the min of Heap.
| 150|    |-            if (k == 0) {
| 151|    |-                kth_smallest = min_heap.top().first;
| 152|    |-            }
| 153|    |-            kth_smallest = min_heap.top().first;
| 154|    |-            int i = min_heap.top().second.first;
| 155|    |-            int j = min_heap.top().second.second;
| 156|    |-            min_heap.pop();
| 157|    |-
| 158|    |-            // Insert the next possible element.
| 159|    |-            if (j + 1 < matrix[i].size()) {
| 160|    |-                min_heap.emplace(pair<int, pair<int, int>>{matrix[i][j + 1], {i, j + 1}});
| 161|    |-            }
| 162|    |-        }
| 163|    |-
| 164|    |-        return kth_smallest;
| 165|    |-    }
| 166|    |-
| 167|    |-    int vertical_search(const vector<vector<int>> &matrix, int k) {
| 168|    |-        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, Compare> min_heap;
| 169|    |-
| 170|    |-        // Init Heap by the first element of the first kth column.
| 171|    |-        for (int j = 0; j < min(static_cast<int>(matrix[0].size()), k); ++j) {
| 172|    |-            min_heap.emplace(pair<int, pair<int, int>>{matrix[0][j], {0, j}});
| 173|    |-        }
| 174|    |-
| 175|    |-        int kth_smallest = INT_MAX;
| 176|    |-        while (!min_heap.empty() && k--) {
| 177|    |-            // Pop the min of Heap.
| 178|    |-            if (k == 0) {
| 179|    |-                kth_smallest = min_heap.top().first;
| 180|    |-            }
| 181|    |-            int i = min_heap.top().second.first;
| 182|    |-            int j = min_heap.top().second.second;
| 183|    |-            min_heap.pop();
| 184|    |-
| 185|    |-            // Insert the next possible element.
| 186|    |-            if (i + 1 < matrix.size()) {
| 187|    |-                min_heap.emplace(pair<int, pair<int, int>>{matrix[i + 1][j], {i + 1, j}});
| 188|    |-            }
| 189|    |-        }
| 190|    |-
| 191|    |-        return kth_smallest;
| 192|    |-    }
| 193|    |-};
|    | 131|+                                                                int
|    | 132|+                                                                kthSmallest
|    | 133|+                                                                (vector <
|    | 134|+                                                                 vector <
|    | 135|+                                                                 int >>&matrix,
|    | 136|+                                                                 int k)
|    | 137|+                                                                {
|    | 138|+                                                                if (matrix.
|    | 139|+                                                                    size () <
|    | 140|+                                                                    matrix[0].
|    | 141|+                                                                    size ())
|    | 142|+                                                                {   // Height is smaller.
|    | 143|+                                                                return
|    | 144|+                                                                horizontal_search
|    | 145|+                                                                (matrix, k);}
|    | 146|+                                                                else
|    | 147|+                                                                {   // Width is smaller.
|    | 148|+                                                                return
|    | 149|+                                                                vertical_search
|    | 150|+                                                                (matrix, k);}
|    | 151|+                                                                }
|    | 152|+
|    | 153|+                                                                int
|    | 154|+                                                                horizontal_search
|    | 155|+                                                                (const vector <
|    | 156|+                                                                 vector <
|    | 157|+                                                                 int >>&matrix,
|    | 158|+                                                                 int k)
|    | 159|+                                                                {
|    | 160|+                                                                priority_queue
|    | 161|+                                                                < pair < int,
|    | 162|+                                                                pair < int,
|    | 163|+                                                                int >>,
|    | 164|+                                                                vector < pair <
|    | 165|+                                                                int,
|    | 166|+                                                                pair < int,
|    | 167|+                                                                int >>>,
|    | 168|+                                                                Compare >
|    | 169|+                                                                min_heap;
|    | 170|+                                                                // Init Heap by the first element of the first kth row.
|    | 171|+                                                                for (int i = 0;
|    | 172|+                                                                     i <
|    | 173|+                                                                     min
|    | 174|+                                                                     (static_cast
|    | 175|+                                                                      <
|    | 176|+                                                                      int
|    | 177|+                                                                      >(matrix.
|    | 178|+                                                                        size
|    | 179|+                                                                        ()),
|    | 180|+                                                                      k); ++i)
|    | 181|+                                                                {
|    | 182|+                                                                min_heap.
|    | 183|+                                                                emplace (pair <
|    | 184|+                                                                         int,
|    | 185|+                                                                         pair <
|    | 186|+                                                                         int,
|    | 187|+                                                                         int >>
|    | 188|+                                                                         {
|    | 189|+                                                                         matrix
|    | 190|+                                                                         [i]
|    | 191|+                                                                         [0],
|    | 192|+                                                                         {
|    | 193|+                                                                         i,
|    | 194|+                                                                         0}});}
|    | 195|+
|    | 196|+                                                                int
|    | 197|+                                                                kth_smallest =
|    | 198|+                                                                INT_MAX;
|    | 199|+                                                                while
|    | 200|+                                                                (!min_heap.
|    | 201|+                                                                 empty ()
|    | 202|+                                                                 && k--)
|    | 203|+                                                                {
|    | 204|+                                                                // Pop the min of Heap.
|    | 205|+                                                                if (k == 0)
|    | 206|+                                                                {
|    | 207|+                                                                kth_smallest =
|    | 208|+                                                                min_heap.
|    | 209|+                                                                top ().first;}
|    | 210|+                                                                kth_smallest =
|    | 211|+                                                                min_heap.
|    | 212|+                                                                top ().first;
|    | 213|+                                                                int i =
|    | 214|+                                                                min_heap.
|    | 215|+                                                                top ().second.
|    | 216|+                                                                first;
|    | 217|+                                                                int j =
|    | 218|+                                                                min_heap.
|    | 219|+                                                                top ().second.
|    | 220|+                                                                second;
|    | 221|+                                                                min_heap.
|    | 222|+                                                                pop ();
|    | 223|+                                                                // Insert the next possible element.
|    | 224|+                                                                if (j + 1 <
|    | 225|+                                                                    matrix[i].
|    | 226|+                                                                    size ())
|    | 227|+                                                                {
|    | 228|+                                                                min_heap.
|    | 229|+                                                                emplace (pair <
|    | 230|+                                                                         int,
|    | 231|+                                                                         pair <
|    | 232|+                                                                         int,
|    | 233|+                                                                         int >>
|    | 234|+                                                                         {
|    | 235|+                                                                         matrix
|    | 236|+                                                                         [i][j
|    | 237|+                                                                             +
|    | 238|+                                                                             1],
|    | 239|+                                                                         {
|    | 240|+                                                                         i,
|    | 241|+                                                                         j +
|    | 242|+                                                                         1}});}
|    | 243|+                                                                }
|    | 244|+
|    | 245|+                                                                return
|    | 246|+                                                                kth_smallest;}
|    | 247|+
|    | 248|+                                                                int
|    | 249|+                                                                vertical_search
|    | 250|+                                                                (const vector <
|    | 251|+                                                                 vector <
|    | 252|+                                                                 int >>&matrix,
|    | 253|+                                                                 int k)
|    | 254|+                                                                {
|    | 255|+                                                                priority_queue
|    | 256|+                                                                < pair < int,
|    | 257|+                                                                pair < int,
|    | 258|+                                                                int >>,
|    | 259|+                                                                vector < pair <
|    | 260|+                                                                int,
|    | 261|+                                                                pair < int,
|    | 262|+                                                                int >>>,
|    | 263|+                                                                Compare >
|    | 264|+                                                                min_heap;
|    | 265|+                                                                // Init Heap by the first element of the first kth column.
|    | 266|+                                                                for (int j = 0;
|    | 267|+                                                                     j <
|    | 268|+                                                                     min
|    | 269|+                                                                     (static_cast
|    | 270|+                                                                      <
|    | 271|+                                                                      int
|    | 272|+                                                                      >(matrix
|    | 273|+                                                                        [0].
|    | 274|+                                                                        size
|    | 275|+                                                                        ()),
|    | 276|+                                                                      k); ++j)
|    | 277|+                                                                {
|    | 278|+                                                                min_heap.
|    | 279|+                                                                emplace (pair <
|    | 280|+                                                                         int,
|    | 281|+                                                                         pair <
|    | 282|+                                                                         int,
|    | 283|+                                                                         int >>
|    | 284|+                                                                         {
|    | 285|+                                                                         matrix
|    | 286|+                                                                         [0]
|    | 287|+                                                                         [j],
|    | 288|+                                                                         {
|    | 289|+                                                                         0,
|    | 290|+                                                                         j}});}
|    | 291|+
|    | 292|+                                                                int
|    | 293|+                                                                kth_smallest =
|    | 294|+                                                                INT_MAX;
|    | 295|+                                                                while
|    | 296|+                                                                (!min_heap.
|    | 297|+                                                                 empty ()
|    | 298|+                                                                 && k--)
|    | 299|+                                                                {
|    | 300|+                                                                // Pop the min of Heap.
|    | 301|+                                                                if (k == 0)
|    | 302|+                                                                {
|    | 303|+                                                                kth_smallest =
|    | 304|+                                                                min_heap.
|    | 305|+                                                                top ().first;}
|    | 306|+                                                                int i =
|    | 307|+                                                                min_heap.
|    | 308|+                                                                top ().second.
|    | 309|+                                                                first;
|    | 310|+                                                                int j =
|    | 311|+                                                                min_heap.
|    | 312|+                                                                top ().second.
|    | 313|+                                                                second;
|    | 314|+                                                                min_heap.
|    | 315|+                                                                pop ();
|    | 316|+                                                                // Insert the next possible element.
|    | 317|+                                                                if (i + 1 <
|    | 318|+                                                                    matrix.
|    | 319|+                                                                    size ())
|    | 320|+                                                                {
|    | 321|+                                                                min_heap.
|    | 322|+                                                                emplace (pair <
|    | 323|+                                                                         int,
|    | 324|+                                                                         pair <
|    | 325|+                                                                         int,
|    | 326|+                                                                         int >>
|    | 327|+                                                                         {
|    | 328|+                                                                         matrix
|    | 329|+                                                                         [i +
|    | 330|+                                                                          1]
|    | 331|+                                                                         [j],
|    | 332|+                                                                         {
|    | 333|+                                                                         i + 1,
|    | 334|+                                                                         j}});}
|    | 335|+                                                                }
|    | 336|+
|    | 337|+                                                                return
|    | 338|+                                                                kth_smallest;}
|    | 339|+                                                                };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|   1|   1| // Time:  O(min(n, h)), per operation
|   2|   2| // Space: O(min(n, h))
|   3|   3| 
|   4|    |-class WordDictionary {
|   5|    |-public:
|   6|    |-    struct TrieNode {
|    |   4|+class WordDictionary
|    |   5|+{
|    |   6|+  public:
|    |   7|+    struct TrieNode
|    |   8|+    {
|   7|   9|         bool isString = false;
|   8|    |-        unordered_map<char, TrieNode *> leaves;
|    |  10|+          unordered_map < char, TrieNode * >leaves;
|   9|  11|     };
|  10|  12| 
|  11|  13|     WordDictionary() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|   8|   8|         unordered_map<char, TrieNode *> leaves;
|   9|   9|     };
|  10|  10| 
|  11|    |-    WordDictionary() {
|  12|    |-        root_ = new TrieNode();
|    |  11|+      WordDictionary ()
|    |  12|+    {
|    |  13|+        root_ = new TrieNode ();
|  13|  14|         root_->isString = true;
|  14|  15|     }
|  15|  16| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|  14|  14|     }
|  15|  15| 
|  16|  16|     // Adds a word into the data structure.
|  17|    |-    void addWord(string word) {
|  18|    |-            auto* p = root_;
|  19|    |-            for (const auto& c : word) {
|  20|    |-                if (p->leaves.find(c) == p->leaves.cend()) {
|    |  17|+    void addWord (string word)
|    |  18|+    {
|    |  19|+        auto *p = root_;
|    |  20|+      for (const auto & c:word)
|    |  21|+          {
|    |  22|+              if (p->leaves.find (c) == p->leaves.cend ())
|    |  23|+                {
|  21|  24|                     p->leaves[c] = new TrieNode;
|  22|  25|                 }
|  23|  26|                 p = p->leaves[c];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|  20|  20|                 if (p->leaves.find(c) == p->leaves.cend()) {
|  21|  21|                     p->leaves[c] = new TrieNode;
|  22|  22|                 }
|  23|    |-                p = p->leaves[c];
|  24|    |-            }
|  25|    |-            p->isString = true;
|    |  23|+              p = p->leaves[c];
|    |  24|+          }
|    |  25|+        p->isString = true;
|  26|  26|     }
|  27|  27| 
|  28|  28|     // Returns if the word is in the data structure. A word could
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|  27|  27| 
|  28|  28|     // Returns if the word is in the data structure. A word could
|  29|  29|     // contain the dot character '.' to represent any one letter.
|  30|    |-    bool search(string word) {
|  31|    |-        return searchWord(word, root_, 0);
|    |  30|+    bool search (string word)
|    |  31|+    {
|    |  32|+        return searchWord (word, root_, 0);
|  32|  33|     }
|  33|  34| 
|  34|  35|     bool searchWord(string word, TrieNode *node, int s) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|  31|  31|         return searchWord(word, root_, 0);
|  32|  32|     }
|  33|  33| 
|  34|    |-    bool searchWord(string word, TrieNode *node, int s) {
|  35|    |-        if (s == word.length()) {
|  36|    |-            return node->isString;
|  37|    |-        }
|    |  34|+    bool searchWord (string word, TrieNode * node, int s)
|    |  35|+    {
|    |  36|+        if (s == word.length ())
|    |  37|+          {
|    |  38|+              return node->isString;
|    |  39|+          }
|  38|  40|         // Match the char.
|  39|    |-        if (node->leaves.find(word[s]) != node->leaves.end()) {
|  40|    |-            return searchWord(word, node->leaves[word[s]], s + 1);
|  41|    |-        } else if (word[s] == '.') {  // Skip the char.
|  42|    |-            for (const auto& i : node->leaves) {
|  43|    |-                if (searchWord(word, i.second, s + 1)) {
|  44|    |-                    return true;
|    |  41|+        if (node->leaves.find (word[s]) != node->leaves.end ())
|    |  42|+          {
|    |  43|+              return searchWord (word, node->leaves[word[s]], s + 1);
|    |  44|+          }
|    |  45|+        else if (word[s] == '.')
|    |  46|+          {                     // Skip the char.
|    |  47|+            for (const auto & i:node->leaves)
|    |  48|+                {
|    |  49|+                    if (searchWord (word, i.second, s + 1))
|    |  50|+                      {
|    |  51|+                          return true;
|    |  52|+                      }
|  45|  53|                 }
|  46|    |-            }
|  47|    |-        }
|    |  54|+          }
|  48|  55|         return false;
|  49|  56|     }
|  50|  57| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-and-search-word.cpp
|    |++++| /app/C++/add-and-search-word.cpp
|  48|  48|         return false;
|  49|  49|     }
|  50|  50| 
|  51|    |-private:
|  52|    |-    TrieNode *root_;
|    |  51|+  private:
|    |  52|+    TrieNode * root_;
|  53|  53| };
|  54|  54| 
|  55|  55| // Your WordDictionary object will be instantiated and called as such:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array.cpp
|    |++++| /app/C++/merge-sorted-array.cpp
|   1|   1| // Time:  O(m + n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: sorted integer array A which has m elements,
|   8|   9|      *           but size of A is m+n
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array.cpp
|    |++++| /app/C++/merge-sorted-array.cpp
|   9|   9|      * @param B: sorted integer array B which has n elements
|  10|  10|      * @return: void
|  11|  11|      */
|  12|    |-    void mergeSortedArray(int A[], int m, int B[], int n) {
|    |  12|+    void mergeSortedArray (int A[], int m, int B[], int n)
|    |  13|+    {
|  13|  14|         int i = m + n;
|  14|    |-        while (m > 0 && n > 0) {
|  15|    |-            if (A[m - 1] > B[n - 1]) {
|  16|    |-                A[i - 1] = A[m - 1];
|  17|    |-                --m;
|  18|    |-            } else {
|  19|    |-                A[i - 1] = B[n - 1];
|  20|    |-                --n;
|  21|    |-            }
|  22|    |-            --i;
|  23|    |-        }
|    |  15|+        while (m > 0 && n > 0)
|    |  16|+          {
|    |  17|+              if (A[m - 1] > B[n - 1])
|    |  18|+                {
|    |  19|+                    A[i - 1] = A[m - 1];
|    |  20|+                    --m;
|    |  21|+                }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    A[i - 1] = B[n - 1];
|    |  25|+                    --n;
|    |  26|+                }
|    |  27|+              --i;
|    |  28|+          }
|  24|  29| 
|  25|    |-        while (n > 0) {
|  26|    |-            A[i - 1] = B[n - 1];
|  27|    |-            --n;
|  28|    |-            --i;
|  29|    |-        }
|    |  30|+        while (n > 0)
|    |  31|+          {
|    |  32|+              A[i - 1] = B[n - 1];
|    |  33|+              --n;
|    |  34|+              --i;
|    |  35|+          }
|  30|  36|     }
|  31|  37| };
|  32|  38| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array.cpp
|    |++++| /app/C++/merge-sorted-array.cpp
|  29|  29|         }
|  30|  30|     }
|  31|  31| };
|  32|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/validate-binary-search-tree.cpp
|    |++++| /app/C++/validate-binary-search-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: True if the binary tree is BST, or false
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/validate-binary-search-tree.cpp
|    |++++| /app/C++/validate-binary-search-tree.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: True if the binary tree is BST, or false
|  21|  21|      */
|  22|    |-    bool isValidBST(TreeNode *root) {
|  23|    |-        if (!root) {
|  24|    |-            return true;
|  25|    |-        }
|    |  22|+    bool isValidBST (TreeNode * root)
|    |  23|+    {
|    |  24|+        if (!root)
|    |  25|+          {
|    |  26|+              return true;
|    |  27|+          }
|  26|  28| 
|  27|    |-        if (!isValidBST(root->left)) {
|  28|    |-            return false;
|  29|    |-        }
|    |  29|+        if (!isValidBST (root->left))
|    |  30|+          {
|    |  31|+              return false;
|    |  32|+          }
|  30|  33| 
|  31|    |-        if (last && last != root && last->val >= root->val) {
|  32|    |-            return false;
|  33|    |-        }
|    |  34|+        if (last && last != root && last->val >= root->val)
|    |  35|+          {
|    |  36|+              return false;
|    |  37|+          }
|  34|  38| 
|  35|  39|         last = root;
|  36|  40| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/validate-binary-search-tree.cpp
|    |++++| /app/C++/validate-binary-search-tree.cpp
|  34|  34| 
|  35|  35|         last = root;
|  36|  36| 
|  37|    |-        if (!isValidBST(root->right)) {
|  38|    |-            return false;
|  39|    |-        }
|    |  37|+        if (!isValidBST (root->right))
|    |  38|+          {
|    |  39|+              return false;
|    |  40|+          }
|  40|  41| 
|  41|  42|         return true;
|  42|  43|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/validate-binary-search-tree.cpp
|    |++++| /app/C++/validate-binary-search-tree.cpp
|  41|  41|         return true;
|  42|  42|     }
|  43|  43| 
|  44|    |-private:
|  45|    |-    TreeNode *last = nullptr;
|    |  44|+  private:
|    |  45|+    TreeNode * last = nullptr;
|  46|  46| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/edit-distance.cpp
|    |++++| /app/C++/edit-distance.cpp
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|   4| // DP with rolling window
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param word1 & word2: Two string.
|   9|  10|      * @return: The minimum number of steps.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/edit-distance.cpp
|    |++++| /app/C++/edit-distance.cpp
|   8|   8|      * @param word1 & word2: Two string.
|   9|   9|      * @return: The minimum number of steps.
|  10|  10|      */
|  11|    |-    int minDistance(string word1, string word2) {
|  12|    |-        const size_t m = word1.size();
|  13|    |-        const size_t n = word2.size();
|    |  11|+    int minDistance (string word1, string word2)
|    |  12|+    {
|    |  13|+        const size_t m = word1.size ();
|    |  14|+        const size_t n = word2.size ();
|  14|  15| 
|  15|    |-        if (m < n) {
|  16|    |-            return minDistance(word2, word1);
|  17|    |-        }
|    |  16|+        if (m < n)
|    |  17|+          {
|    |  18|+              return minDistance (word2, word1);
|    |  19|+          }
|  18|  20| 
|  19|    |-        vector<vector<int>> steps(2, vector<int>(n + 1, 0));
|    |  21|+        vector < vector < int >>steps (2, vector < int >(n + 1, 0));
|  20|  22| 
|  21|    |-        for (int j = 0; j < n + 1; ++j) {
|  22|    |-            steps[0][j] = j;
|  23|    |-        }
|    |  23|+        for (int j = 0; j < n + 1; ++j)
|    |  24|+          {
|    |  25|+              steps[0][j] = j;
|    |  26|+          }
|  24|  27| 
|  25|    |-        for (int i = 1; i < m + 1; ++i) {
|  26|    |-            steps[i % 2][0] = i;
|  27|    |-            for (int j = 1; j < n + 1; ++j) {
|  28|    |-                steps[i % 2][j] = word1[i - 1] == word2[j - 1] ?
|  29|    |-                steps[(i - 1) % 2][j - 1] :
|  30|    |-                1 + min(steps[(i - 1) % 2][j - 1],
|  31|    |-                        min(steps[(i - 1) % 2][j], steps[i % 2][j - 1]));
|  32|    |-            }
|  33|    |-        }
|    |  28|+        for (int i = 1; i < m + 1; ++i)
|    |  29|+          {
|    |  30|+              steps[i % 2][0] = i;
|    |  31|+              for (int j = 1; j < n + 1; ++j)
|    |  32|+                {
|    |  33|+                    steps[i % 2][j] = word1[i - 1] == word2[j - 1] ?
|    |  34|+                        steps[(i - 1) % 2][j - 1] :
|    |  35|+                        1 + min (steps[(i - 1) % 2][j - 1],
|    |  36|+                                 min (steps[(i - 1) % 2][j],
|    |  37|+                                      steps[i % 2][j - 1]));
|    |  38|+                }
|    |  39|+          }
|  34|  40| 
|  35|  41|         return steps[m % 2][n];
|  36|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/edit-distance.cpp
|    |++++| /app/C++/edit-distance.cpp
|  39|  39| // Time:  O(m * n)
|  40|  40| // Space: O(m * n)
|  41|  41| // DP
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  42|+class Solution2
|    |  43|+{
|    |  44|+  public:
|  44|  45|     /**
|  45|  46|      * @param word1 & word2: Two string.
|  46|  47|      * @return: The minimum number of steps.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/edit-distance.cpp
|    |++++| /app/C++/edit-distance.cpp
|  45|  45|      * @param word1 & word2: Two string.
|  46|  46|      * @return: The minimum number of steps.
|  47|  47|      */
|  48|    |-    int minDistance(string word1, string word2) {
|  49|    |-        const size_t m = word1.size();
|  50|    |-        const size_t n = word2.size();
|    |  48|+    int minDistance (string word1, string word2)
|    |  49|+    {
|    |  50|+        const size_t m = word1.size ();
|    |  51|+        const size_t n = word2.size ();
|  51|  52| 
|  52|    |-        if (m < n) {
|  53|    |-            return minDistance(word2, word1);
|  54|    |-        }
|    |  53|+        if (m < n)
|    |  54|+          {
|    |  55|+              return minDistance (word2, word1);
|    |  56|+          }
|  55|  57| 
|  56|    |-        vector<vector<int>> steps(m + 1, vector<int>(n + 1, 0));
|    |  58|+        vector < vector < int >>steps (m + 1, vector < int >(n + 1, 0));
|  57|  59| 
|  58|    |-        for (int j = 0; j < n + 1; ++j) {
|  59|    |-            steps[0][j] = j;
|  60|    |-        }
|    |  60|+        for (int j = 0; j < n + 1; ++j)
|    |  61|+          {
|    |  62|+              steps[0][j] = j;
|    |  63|+          }
|  61|  64| 
|  62|    |-        for (int i = 1; i < m + 1; ++i) {
|  63|    |-            steps[i][0] = i;
|  64|    |-            for (int j = 1; j < n + 1; ++j) {
|  65|    |-                steps[i][j] = word1[i - 1] == word2[j - 1] ?
|  66|    |-                steps[i - 1][j - 1] :
|  67|    |-                1 + min(steps[i - 1][j - 1],
|  68|    |-                        min(steps[i - 1][j], steps[i][j - 1]));
|  69|    |-            }
|  70|    |-        }
|    |  65|+        for (int i = 1; i < m + 1; ++i)
|    |  66|+          {
|    |  67|+              steps[i][0] = i;
|    |  68|+              for (int j = 1; j < n + 1; ++j)
|    |  69|+                {
|    |  70|+                    steps[i][j] = word1[i - 1] == word2[j - 1] ?
|    |  71|+                        steps[i - 1][j - 1] :
|    |  72|+                        1 + min (steps[i - 1][j - 1],
|    |  73|+                                 min (steps[i - 1][j], steps[i][j - 1]));
|    |  74|+                }
|    |  75|+          }
|  71|  76| 
|  72|  77|         return steps[m][n];
|  73|  78|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-colors-ii.cpp
|    |++++| /app/C++/sort-colors-ii.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Inplace counting sort.
|   5|    |-class Solution{
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param colors: A list of integer
|   9|  10|      * @param k: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-colors-ii.cpp
|    |++++| /app/C++/sort-colors-ii.cpp
|   9|   9|      * @param k: An integer
|  10|  10|      * @return: nothing
|  11|  11|      */
|  12|    |-    void sortColors2(vector<int> &colors, int k) {
|  13|    |-        for (int i = 0; i < colors.size(); ++i) {
|  14|    |-            if (colors[i] > 0) {
|  15|    |-                int pos = colors[i] - 1;
|  16|    |-                if (colors[pos] <= 0) {  // Bucket exists.
|  17|    |-                    --colors[pos];
|  18|    |-                    colors[i] = 0;
|    |  12|+    void sortColors2 (vector < int >&colors, int k)
|    |  13|+    {
|    |  14|+        for (int i = 0; i < colors.size (); ++i)
|    |  15|+          {
|    |  16|+              if (colors[i] > 0)
|    |  17|+                {
|    |  18|+                    int pos = colors[i] - 1;
|    |  19|+                    if (colors[pos] <= 0)
|    |  20|+                      {         // Bucket exists.
|    |  21|+                          --colors[pos];
|    |  22|+                          colors[i] = 0;
|    |  23|+                      }
|    |  24|+                    else
|    |  25|+                      {         // Init a new bucket.
|    |  26|+                          colors[i] = colors[pos];
|    |  27|+                          colors[pos] = -1;
|    |  28|+                          --i;
|    |  29|+                      }
|  19|  30|                 }
|  20|    |-                else {  // Init a new bucket.
|  21|    |-                    colors[i] = colors[pos];
|  22|    |-                    colors[pos] = -1;
|  23|    |-                    --i;
|    |  31|+          }
|    |  32|+
|    |  33|+        for (int i = colors.size () - 1, pos = k - 1; pos >= 0; --pos)
|    |  34|+          {
|    |  35|+              while (colors[pos] < 0)
|    |  36|+                {               // Reorder the color by count of each bucket.
|    |  37|+                    ++colors[pos];
|    |  38|+                    colors[i--] = pos + 1;
|  24|  39|                 }
|  25|    |-            }
|  26|    |-        }
|  27|    |-
|  28|    |-        for (int i = colors.size() - 1, pos = k - 1; pos >= 0; --pos) {
|  29|    |-            while (colors[pos] < 0) {  // Reorder the color by count of each bucket.
|  30|    |-                ++colors[pos];
|  31|    |-                colors[i--] = pos + 1;
|  32|    |-            }
|  33|    |-        }
|    |  40|+          }
|  34|  41|     }
|  35|  42| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-element.cpp
|    |++++| /app/C++/remove-element.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param A: A list of integers
|   8|   9|      *@param elem: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-element.cpp
|    |++++| /app/C++/remove-element.cpp
|   8|   8|      *@param elem: An integer
|   9|   9|      *@return: The new length after remove
|  10|  10|      */
|  11|    |-    int removeElement(vector<int> &A, int elem) {
|    |  11|+    int removeElement (vector < int >&A, int elem)
|    |  12|+    {
|  12|  13|         int left = 0;
|  13|    |-        int right = A.size();
|  14|    |-        while (left < right) {
|  15|    |-            if (A[left] != elem) {
|  16|    |-                ++left;
|  17|    |-            } else {
|  18|    |-                swap(A[left], A[--right]);
|  19|    |-            }
|  20|    |-        }
|    |  14|+        int right = A.size ();
|    |  15|+        while (left < right)
|    |  16|+          {
|    |  17|+              if (A[left] != elem)
|    |  18|+                {
|    |  19|+                    ++left;
|    |  20|+                }
|    |  21|+              else
|    |  22|+                {
|    |  23|+                    swap (A[left], A[--right]);
|    |  24|+                }
|    |  25|+          }
|  21|  26|         return left;
|  22|  27|     }
|  23|  28| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/singleton.cpp
|    |++++| /app/C++/singleton.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Thread-Safe, Lazy Initilization
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @return: The same instance of this class every time
|   9|  10|      */
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/singleton.cpp
|    |++++| /app/C++/singleton.cpp
|   7|   7|     /**
|   8|   8|      * @return: The same instance of this class every time
|   9|   9|      */
|  10|    |-    static Solution* getInstance() {
|    |  10|+    static Solution *getInstance ()
|    |  11|+    {
|  11|  12|         // C++ 11 thread-safe local-static-initialization. (lazy initialization)
|  12|    |-        static Solution *instance = new Solution();
|    |  13|+        static Solution *instance = new Solution ();
|  13|  14| 
|  14|    |-        return instance;
|    |  15|+          return instance;
|  15|  16|     }
|  16|  17| 
|  17|  18|     // Noncopyable.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/singleton.cpp
|    |++++| /app/C++/singleton.cpp
|  15|  15|     }
|  16|  16| 
|  17|  17|     // Noncopyable.
|  18|    |-    Solution(const Solution&) = delete;
|  19|    |-    Solution& operator=(const Solution&) = delete;
|    |  18|+    Solution (const Solution &) = delete;
|    |  19|+    Solution & operator= (const Solution &) = delete;
|  20|  20| 
|  21|    |-private:
|  22|    |-    Solution() {}
|  23|    |-    ~Solution() {}
|    |  21|+  private:
|    |  22|+    Solution ()
|    |  23|+    {
|    |  24|+    }
|    |  25|+    ~Solution ()
|    |  26|+    {
|    |  27|+    }
|  24|  28| };

C++/singleton.cpp
|  12| ••••••••static•Solution•*instance•=•new•Solution();
|    | [NORMAL] CPPCleanBear:
|    | static data 'instance'
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-path-sum.cpp
|    |++++| /app/C++/minimum-path-sum.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param grid: a list of lists of integers.
|   8|   9|      * @return: An integer, minimizes the sum of all numbers along its path
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-path-sum.cpp
|    |++++| /app/C++/minimum-path-sum.cpp
|   7|   7|      * @param grid: a list of lists of integers.
|   8|   8|      * @return: An integer, minimizes the sum of all numbers along its path
|   9|   9|      */
|  10|    |-    int minPathSum(vector<vector<int>> &grid) {
|  11|    |-        const int m = grid.size();
|  12|    |-        const int n = grid[0].size();
|    |  10|+    int minPathSum (vector < vector < int >>&grid)
|    |  11|+    {
|    |  12|+        const int m = grid.size ();
|    |  13|+        const int n = grid[0].size ();
|  13|  14| 
|  14|    |-        vector<vector<int>> sum(2, vector<int>(n, 0));
|  15|    |-        sum[0][0] = grid[0][0];
|  16|    |-        for (int j = 1; j < n; ++j) {
|  17|    |-            sum[0][j] = sum[0][j - 1] + grid[0][j];
|  18|    |-        }
|    |  15|+          vector < vector < int >>sum (2, vector < int >(n, 0));
|    |  16|+          sum[0][0] = grid[0][0];
|    |  17|+        for (int j = 1; j < n; ++j)
|    |  18|+          {
|    |  19|+              sum[0][j] = sum[0][j - 1] + grid[0][j];
|    |  20|+          }
|  19|  21| 
|  20|    |-        for (int i = 1; i < m; ++i) {
|  21|    |-            sum[i % 2][0] = sum[(i - 1) % 2][0] + grid[i][0];
|  22|    |-            for (int j = 1; j < n; ++j) {
|  23|    |-                sum[i % 2][j] = min(sum[(i - 1) % 2][j], sum[i % 2][j - 1])
|  24|    |-                                + grid[i][j];
|  25|    |-            }
|  26|    |-        }
|    |  22|+        for (int i = 1; i < m; ++i)
|    |  23|+          {
|    |  24|+              sum[i % 2][0] = sum[(i - 1) % 2][0] + grid[i][0];
|    |  25|+              for (int j = 1; j < n; ++j)
|    |  26|+                {
|    |  27|+                    sum[i % 2][j] =
|    |  28|+                        min (sum[(i - 1) % 2][j],
|    |  29|+                             sum[i % 2][j - 1]) + grid[i][j];
|    |  30|+                }
|    |  31|+          }
|  27|  32| 
|  28|  33|         return sum[(m - 1) % 2][n - 1];
|  29|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-path-sum.cpp
|    |++++| /app/C++/minimum-path-sum.cpp
|  28|  28|         return sum[(m - 1) % 2][n - 1];
|  29|  29|     }
|  30|  30| };
|  31|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack.cpp
|    |++++| /app/C++/backpack.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(m)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param m: An integer m denotes the size of a backpack
|   8|   9|      * @param A: Given n items with size A[i]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack.cpp
|    |++++| /app/C++/backpack.cpp
|   8|   8|      * @param A: Given n items with size A[i]
|   9|   9|      * @return: The maximum size
|  10|  10|      */
|  11|    |-    int backPack(int m, vector<int> A) {
|    |  11|+    int backPack (int m, vector < int >A)
|    |  12|+    {
|  12|  13|         // table[i][j] denotes whether using the first i elements
|  13|  14|         // could fulfill size j.
|  14|  15|         vector<vector<bool>> table(2, vector<bool>(m + 1, false));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack.cpp
|    |++++| /app/C++/backpack.cpp
|  11|  11|     int backPack(int m, vector<int> A) {
|  12|  12|         // table[i][j] denotes whether using the first i elements
|  13|  13|         // could fulfill size j.
|  14|    |-        vector<vector<bool>> table(2, vector<bool>(m + 1, false));
|    |  14|+        vector < vector < bool >> table (2, vector < bool > (m + 1, false));
|  15|  15|         int max_size = 0;
|  16|    |-        table[0][0] = true;
|    |  16|+          table[0][0] = true;
|  17|  17| 
|  18|    |-        for (int i = 1; i <= A.size(); ++i) {
|  19|    |-            table[i % 2][0] = true;
|  20|    |-            for (int j = 1; j <= m; ++j) {
|  21|    |-                // If first i - 1 elements could fulfill the backpack, then
|  22|    |-                // first i elements would also do.
|  23|    |-                table[i % 2][j] = table[(i - 1) % 2][j];
|    |  18|+        for (int i = 1; i <= A.size (); ++i)
|    |  19|+          {
|    |  20|+              table[i % 2][0] = true;
|    |  21|+              for (int j = 1; j <= m; ++j)
|    |  22|+                {
|    |  23|+                    // If first i - 1 elements could fulfill the backpack, then
|    |  24|+                    // first i elements would also do.
|    |  25|+                    table[i % 2][j] = table[(i - 1) % 2][j];
|  24|  26| 
|  25|    |-                // Using the ith element to fulfill the backpack.
|  26|    |-                if (j >= A[i - 1]) {
|  27|    |-                    table[i % 2][j] = table[i % 2][j]
|  28|    |-                    || table[(i - 1) % 2][j - A[i - 1]];
|    |  27|+                    // Using the ith element to fulfill the backpack.
|    |  28|+                    if (j >= A[i - 1])
|    |  29|+                      {
|    |  30|+                          table[i % 2][j] = table[i % 2][j]
|    |  31|+                              || table[(i - 1) % 2][j - A[i - 1]];
|    |  32|+                      }
|    |  33|+
|    |  34|+                    // If it fulfills size j, update max size.
|    |  35|+                    if (table[i % 2][j])
|    |  36|+                      {
|    |  37|+                          max_size = max (max_size, j);
|    |  38|+                      }
|  29|  39|                 }
|  30|    |-
|  31|    |-                // If it fulfills size j, update max size.
|  32|    |-                if (table[i % 2][j]) {
|  33|    |-                    max_size = max(max_size, j);
|  34|    |-                }
|  35|    |-            }
|  36|    |-        }
|    |  40|+          }
|  37|  41| 
|  38|  42|         return max_size;
|  39|  43|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * This method will be invoked first, you should design your own algorithm
|  20|  21|      * to serialize a binary tree which denote by a root node to a string which
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  20|  20|      * to serialize a binary tree which denote by a root node to a string which
|  21|  21|      * can be easily deserialized by your own "deserialize" method later.
|  22|  22|      */
|  23|    |-    string serialize(TreeNode *root) {
|    |  23|+    string serialize (TreeNode * root)
|    |  24|+    {
|  24|  25|         string output;
|  25|    |-        serializeHelper(root, &output);
|  26|    |-        return output;
|    |  26|+          serializeHelper (root, &output);
|    |  27|+          return output;
|  27|  28|     }
|  28|  29| 
|  29|  30|     /**
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  33|  33|      * designed by yourself, and deserialize it here as you serialize it in
|  34|  34|      * "serialize" method.
|  35|  35|      */
|  36|    |-    TreeNode *deserialize(string data) {
|    |  36|+    TreeNode *deserialize (string data)
|    |  37|+    {
|  37|  38|         TreeNode *root = nullptr;
|  38|  39|         int start = 0;
|  39|  40|         return deserializeHelper(data, &start);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  36|  36|     TreeNode *deserialize(string data) {
|  37|  37|         TreeNode *root = nullptr;
|  38|  38|         int start = 0;
|  39|    |-        return deserializeHelper(data, &start);
|    |  39|+        return deserializeHelper (data, &start);
|  40|  40|     }
|  41|  41| 
|  42|  42| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  39|  39|         return deserializeHelper(data, &start);
|  40|  40|     }
|  41|  41| 
|  42|    |-private:
|  43|    |-    bool getNumber(const string &data, int *start, int *num) {
|    |  42|+  private:
|    |  43|+    bool getNumber (const string & data, int *start, int *num)
|    |  44|+    {
|  44|  45|         int sign = 1;
|  45|    |-        if (data[*start] == '#') {
|  46|    |-            *start += 2;  // Skip "# ".
|  47|    |-            return false;
|  48|    |-        } else if (data[*start] == '-') {
|  49|    |-            sign = -1;
|  50|    |-            ++(*start);
|  51|    |-        }
|    |  46|+        if (data[*start] == '#')
|    |  47|+          {
|    |  48|+              *start += 2;      // Skip "# ".
|    |  49|+              return false;
|    |  50|+          }
|    |  51|+        else if (data[*start] == '-')
|    |  52|+          {
|    |  53|+              sign = -1;
|    |  54|+              ++(*start);
|    |  55|+          }
|  52|  56| 
|  53|    |-        for (*num = 0; isdigit(data[*start]); ++(*start)) {
|  54|    |-            *num = *num * 10 + data[*start] - '0';
|  55|    |-        }
|    |  57|+        for (*num = 0; isdigit (data[*start]); ++(*start))
|    |  58|+          {
|    |  59|+              *num = *num * 10 + data[*start] - '0';
|    |  60|+          }
|  56|  61|         *num *= sign;
|  57|    |-        ++(*start);  // Skip " ".
|    |  62|+        ++(*start);             // Skip " ".
|  58|  63| 
|  59|  64|         return true;
|  60|  65|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  59|  59|         return true;
|  60|  60|     }
|  61|  61| 
|  62|    |-    void serializeHelper(const TreeNode *root, string *prev) {
|  63|    |-        if (!root)  {
|  64|    |-            prev->append("# ");
|  65|    |-        } else {
|  66|    |-            prev->append(to_string(root->val).append(" "));
|  67|    |-            serializeHelper(root->left, prev);
|  68|    |-            serializeHelper(root->right, prev);
|  69|    |-        }
|    |  62|+    void serializeHelper (const TreeNode * root, string * prev)
|    |  63|+    {
|    |  64|+        if (!root)
|    |  65|+          {
|    |  66|+              prev->append ("# ");
|    |  67|+          }
|    |  68|+        else
|    |  69|+          {
|    |  70|+              prev->append (to_string (root->val).append (" "));
|    |  71|+              serializeHelper (root->left, prev);
|    |  72|+              serializeHelper (root->right, prev);
|    |  73|+          }
|  70|  74|     }
|  71|  75| 
|  72|  76|     TreeNode *deserializeHelper(const string& data, int *start) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  69|  69|         }
|  70|  70|     }
|  71|  71| 
|  72|    |-    TreeNode *deserializeHelper(const string& data, int *start) {
|    |  72|+    TreeNode *deserializeHelper (const string & data, int *start)
|    |  73|+    {
|  73|  74|         int num;
|  74|    |-        if (!getNumber(data, start, &num)) {
|  75|    |-            return nullptr;
|  76|    |-        } else {
|  77|    |-            TreeNode *root = new TreeNode(num);
|  78|    |-            root->left = deserializeHelper(data, start);
|  79|    |-            root->right = deserializeHelper(data, start);
|  80|    |-            return root;
|  81|    |-        }
|    |  75|+        if (!getNumber (data, start, &num))
|    |  76|+          {
|    |  77|+              return nullptr;
|    |  78|+          }
|    |  79|+        else
|    |  80|+          {
|    |  81|+              TreeNode *root = new TreeNode (num);
|    |  82|+              root->left = deserializeHelper (data, start);
|    |  83|+              root->right = deserializeHelper (data, start);
|    |  84|+              return root;
|    |  85|+          }
|  82|  86|     }
|  83|  87| };
|  84|  88| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  82|  82|     }
|  83|  83| };
|  84|  84| 
|  85|    |-
|  86|  85| // Time:  O(n)
|  87|  86| // Space: O(n)
|  88|  87| class Solution2 {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  85|  85| 
|  86|  86| // Time:  O(n)
|  87|  87| // Space: O(n)
|  88|    |-class Solution2 {
|  89|    |-public:
|    |  88|+class Solution2
|    |  89|+{
|    |  90|+  public:
|  90|  91|     /**
|  91|  92|      * This method will be invoked first, you should design your own algorithm
|  92|  93|      * to serialize a binary tree which denote by a root node to a string which
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
|  92|  92|      * to serialize a binary tree which denote by a root node to a string which
|  93|  93|      * can be easily deserialized by your own "deserialize" method later.
|  94|  94|      */
|  95|    |-    string serialize(TreeNode *root) {
|    |  95|+    string serialize (TreeNode * root)
|    |  96|+    {
|  96|  97|         ostringstream out;
|  97|    |-        serializeHelper(root, out);
|  98|    |-        return out.str();
|    |  98|+          serializeHelper (root, out);
|    |  99|+          return out.str ();
|  99| 100|     }
| 100| 101| 
| 101| 102|     /**
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
| 105| 105|      * designed by yourself, and deserialize it here as you serialize it in
| 106| 106|      * "serialize" method.
| 107| 107|      */
| 108|    |-    TreeNode *deserialize(string data) {
| 109|    |-        istringstream in(data);  // Space: O(n)
| 110|    |-        return deserializeHelper(in);
|    | 108|+    TreeNode *deserialize (string data)
|    | 109|+    {
|    | 110|+        istringstream in (data);    // Space: O(n)
|    | 111|+        return deserializeHelper (in);
| 111| 112|     }
| 112| 113| 
| 113| 114| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
| 110| 110|         return deserializeHelper(in);
| 111| 111|     }
| 112| 112| 
| 113|    |-private:
| 114|    |-    void serializeHelper(const TreeNode *root, ostringstream& out) {
| 115|    |-        if (!root)  {
| 116|    |-            out << "# ";
| 117|    |-        } else {
| 118|    |-            out << root->val << " ";
| 119|    |-            serializeHelper(root->left, out);
| 120|    |-            serializeHelper(root->right, out);
| 121|    |-        }
|    | 113|+  private:
|    | 114|+    void serializeHelper (const TreeNode * root, ostringstream & out)
|    | 115|+    {
|    | 116|+        if (!root)
|    | 117|+          {
|    | 118|+              out << "# ";
|    | 119|+          }
|    | 120|+        else
|    | 121|+          {
|    | 122|+              out << root->val << " ";
|    | 123|+              serializeHelper (root->left, out);
|    | 124|+              serializeHelper (root->right, out);
|    | 125|+          }
| 122| 126|     }
| 123| 127| 
| 124| 128|     TreeNode *deserializeHelper(istringstream& in) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
| 121| 121|         }
| 122| 122|     }
| 123| 123| 
| 124|    |-    TreeNode *deserializeHelper(istringstream& in) {
|    | 124|+    TreeNode *deserializeHelper (istringstream & in)
|    | 125|+    {
| 125| 126|         string val;
| 126| 127|         in >> val;
| 127| 128|         if (val == "#") {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-serialization.cpp
|    |++++| /app/C++/binary-tree-serialization.cpp
| 124| 124|     TreeNode *deserializeHelper(istringstream& in) {
| 125| 125|         string val;
| 126| 126|         in >> val;
| 127|    |-        if (val == "#") {
| 128|    |-            return nullptr;
| 129|    |-        } else {
| 130|    |-            TreeNode* root = new TreeNode(stoi(val));
| 131|    |-            root->left = deserializeHelper(in);
| 132|    |-            root->right = deserializeHelper(in);
| 133|    |-            return root;
| 134|    |-        }
|    | 127|+        if (val == "#")
|    | 128|+          {
|    | 129|+              return nullptr;
|    | 130|+          }
|    | 131|+        else
|    | 132|+          {
|    | 133|+              TreeNode *root = new TreeNode (stoi (val));
|    | 134|+              root->left = deserializeHelper (in);
|    | 135|+              root->right = deserializeHelper (in);
|    | 136|+              return root;
|    | 137|+          }
| 135| 138|     }
| 136| 139| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index.cpp
|    |++++| /app/C++/permutation-index.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer array
|   8|   9|      * @return a long integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index.cpp
|    |++++| /app/C++/permutation-index.cpp
|   7|   7|      * @param A an integer array
|   8|   8|      * @return a long integer
|   9|   9|      */
|  10|    |-    long long permutationIndex(vector<int>& A) {
|    |  10|+    long long permutationIndex (vector < int >&A)
|    |  11|+    {
|  11|  12|         long long index = 1;
|  12|  13|         // Position 1 is paired with factor 0 and so is skipped.
|  13|  14|         int position = 2;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index.cpp
|    |++++| /app/C++/permutation-index.cpp
|  12|  12|         // Position 1 is paired with factor 0 and so is skipped.
|  13|  13|         int position = 2;
|  14|  14|         long long factor = 1;
|  15|    |-        for (int i = static_cast<int>(A.size()) - 2; i >= 0; --i) {
|  16|    |-            int successors = 0;
|  17|    |-            for (int j = i + 1; j < A.size(); ++j) {
|  18|    |-                if (A[i] > A[j]) {
|  19|    |-                    ++successors;
|    |  15|+        for (int i = static_cast < int >(A.size ()) - 2; i >= 0; --i)
|    |  16|+          {
|    |  17|+              int successors = 0;
|    |  18|+              for (int j = i + 1; j < A.size (); ++j)
|    |  19|+                {
|    |  20|+                    if (A[i] > A[j])
|    |  21|+                      {
|    |  22|+                          ++successors;
|    |  23|+                      }
|  20|  24|                 }
|  21|    |-            }
|  22|    |-            index += successors * factor;
|  23|    |-            factor *= position;
|  24|    |-            ++position;
|  25|    |-        }
|    |  25|+              index += successors * factor;
|    |  26|+              factor *= position;
|    |  27|+              ++position;
|    |  28|+          }
|  26|  29|         return index;
|  27|  30|     }
|  28|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/cosine-similarity.cpp
|    |++++| /app/C++/cosine-similarity.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|   public:
|   6|   7|     /**
|   7|   8|      * @param A: An integer array.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/cosine-similarity.cpp
|    |++++| /app/C++/cosine-similarity.cpp
|   8|   8|      * @param B: An integer array.
|   9|   9|      * @return: Cosine similarity.
|  10|  10|      */
|  11|    |-    double cosineSimilarity(vector<int> A, vector<int> B) {
|    |  11|+    double cosineSimilarity (vector < int >A, vector < int >B)
|    |  12|+    {
|  12|  13|         const double invalid = 2.0;
|  13|    |-        if (A.size() != B.size()) {
|  14|    |-            return invalid;
|  15|    |-        }
|    |  14|+        if (A.size () != B.size ())
|    |  15|+          {
|    |  16|+              return invalid;
|    |  17|+          }
|  16|  18| 
|  17|  19|         double A_dot_B = 0.0, A_dot_A = 0.0, B_dot_B = 0.0;
|  18|  20|         for (int i = 0; i < A.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/cosine-similarity.cpp
|    |++++| /app/C++/cosine-similarity.cpp
|  15|  15|         }
|  16|  16| 
|  17|  17|         double A_dot_B = 0.0, A_dot_A = 0.0, B_dot_B = 0.0;
|  18|    |-        for (int i = 0; i < A.size(); ++i) {
|  19|    |-            A_dot_B += A[i] * B[i];
|  20|    |-            A_dot_A += A[i] * A[i];
|  21|    |-            B_dot_B += B[i] * B[i];
|  22|    |-        }
|    |  18|+        for (int i = 0; i < A.size (); ++i)
|    |  19|+          {
|    |  20|+              A_dot_B += A[i] * B[i];
|    |  21|+              A_dot_A += A[i] * A[i];
|    |  22|+              B_dot_B += B[i] * B[i];
|    |  23|+          }
|  23|  24|         return A_dot_A && B_dot_B ?
|  24|    |-                   A_dot_B / sqrt(A_dot_A) / sqrt(B_dot_B) :
|  25|    |-                   invalid;
|    |  25|+            A_dot_B / sqrt (A_dot_A) / sqrt (B_dot_B) : invalid;
|  26|  26|     }
|  27|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|   1|   1| // Time:  O(m * n * log(m + n)) ~ O(m * n * log(m * n))
|   2|   2| // Space: O(m * n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param heights: a matrix of integers
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|   7|   7|      * @param heights: a matrix of integers
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int trapRainWater(vector<vector<int>> &heights) {
|  11|    |-        m_ = heights.size();
|  12|    |-        if (!m_) {
|  13|    |-            return 0;
|  14|    |-        }
|  15|    |-        n_ = heights[0].size();
|  16|    |-        if (!n_) {
|  17|    |-            return 0;
|  18|    |-        }
|    |  10|+    int trapRainWater (vector < vector < int >>&heights)
|    |  11|+    {
|    |  12|+        m_ = heights.size ();
|    |  13|+        if (!m_)
|    |  14|+          {
|    |  15|+              return 0;
|    |  16|+          }
|    |  17|+        n_ = heights[0].size ();
|    |  18|+        if (!n_)
|    |  19|+          {
|    |  20|+              return 0;
|    |  21|+          }
|  19|  22| 
|  20|    |-        is_visited_ = vector<vector<bool>>(m_, vector<bool>(n_, false));
|    |  23|+        is_visited_ =
|    |  24|+            vector < vector < bool >> (m_, vector < bool > (n_, false));
|  21|  25| 
|  22|  26|         int trap = 0;
|  23|  27| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  22|  22|         int trap = 0;
|  23|  23| 
|  24|  24|         // Put the cells on the border into min heap.
|  25|    |-        for (int i = 0; i < m_; ++i) {
|  26|    |-            heap_.emplace(Cell{i, 0, heights[i][0]});
|  27|    |-            is_visited_[i][0] = true;
|  28|    |-            heap_.emplace(Cell{i, n_ - 1, heights[i][n_ - 1]});
|  29|    |-            is_visited_[i][n_ - 1] = true;
|  30|    |-        }
|  31|    |-        for (int j = 0; j < n_; ++j) {
|  32|    |-            heap_.emplace(Cell{0, j, heights[0][j]});
|  33|    |-            is_visited_[0][j] = true;
|  34|    |-            heap_.emplace(Cell{m_ - 1, j, heights[m_ - 1][j]});
|  35|    |-            is_visited_[m_ - 1][j] = true;
|  36|    |-        }
|  37|    |-        const vector<pair<int, int>> directions{{0, -1}, {0, 1},
|  38|    |-                                                {-1, 0}, {1, 0}};
|    |  25|+        for (int i = 0; i < m_; ++i)
|    |  26|+          {
|    |  27|+              heap_.emplace (Cell
|    |  28|+                             {
|    |  29|+                             i, 0, heights[i][0]});
|    |  30|+              is_visited_[i][0] = true;
|    |  31|+              heap_.emplace (Cell
|    |  32|+                             {
|    |  33|+                             i, n_ - 1, heights[i][n_ - 1]});
|    |  34|+              is_visited_[i][n_ - 1] = true;
|    |  35|+          }
|    |  36|+        for (int j = 0; j < n_; ++j)
|    |  37|+          {
|    |  38|+              heap_.emplace (Cell
|    |  39|+                             {
|    |  40|+                             0, j, heights[0][j]});
|    |  41|+              is_visited_[0][j] = true;
|    |  42|+              heap_.emplace (Cell
|    |  43|+                             {
|    |  44|+                             m_ - 1, j, heights[m_ - 1][j]});
|    |  45|+              is_visited_[m_ - 1][j] = true;
|    |  46|+          }
|    |  47|+        const vector < pair < int, int >>directions
|    |  48|+        {
|    |  49|+            {
|    |  50|+            0, -1},
|    |  51|+            {
|    |  52|+            0, 1},
|    |  53|+            {
|    |  54|+            -1, 0},
|    |  55|+            {
|    |  56|+        1, 0}};
|  39|  57|         // BFS with priority queue (min heap)
|  40|    |-        while (!heap_.empty()) {
|  41|    |-            Cell c = heap_.top();
|  42|    |-            heap_.pop();
|  43|    |-            for (const auto& d : directions) {
|  44|    |-            	trap += fill(heights, c.i + d.first, c.j + d.second, c.height);
|  45|    |-            }
|  46|    |-        }
|    |  58|+        while (!heap_.empty ())
|    |  59|+          {
|    |  60|+              Cell c = heap_.top ();
|    |  61|+              heap_.pop ();
|    |  62|+            for (const auto & d:directions)
|    |  63|+                {
|    |  64|+                    trap +=
|    |  65|+                        fill (heights, c.i + d.first, c.j + d.second,
|    |  66|+                              c.height);
|    |  67|+                }
|    |  68|+          }
|  47|  69| 
|  48|  70|         return trap;
|  49|  71|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  48|  48|         return trap;
|  49|  49|     }
|  50|  50| 
|  51|    |-private:
|  52|    |-    int fill(const vector<vector<int>>& heights, int i, int j, int height) {
|    |  51|+  private:
|    |  52|+    int fill (const vector < vector < int >>&heights, int i, int j, int height)
|    |  53|+    {
|  53|  54|         // Out of border.
|  54|    |-        if ( i < 0 || i >= m_ || j < 0 || j >= n_) {
|  55|    |-            return 0;
|  56|    |-        }
|    |  55|+        if (i < 0 || i >= m_ || j < 0 || j >= n_)
|    |  56|+          {
|    |  57|+              return 0;
|    |  58|+          }
|  57|  59| 
|  58|  60|         // Fill unvisited cell.
|  59|  61|         if (!is_visited_[i][j]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  56|  56|         }
|  57|  57| 
|  58|  58|         // Fill unvisited cell.
|  59|    |-        if (!is_visited_[i][j]) {
|  60|    |-            heap_.emplace(Cell{i, j, max(height, heights[i][j])});
|  61|    |-            is_visited_[i][j] = true; // Marked as visited.
|  62|    |-            return max(0, height - heights[i][j]); // Fill in the gap.
|  63|    |-        }
|    |  59|+        if (!is_visited_[i][j])
|    |  60|+          {
|    |  61|+              heap_.emplace (Cell
|    |  62|+                             {
|    |  63|+                             i, j, max (height, heights[i][j])}
|    |  64|+              );
|    |  65|+              is_visited_[i][j] = true; // Marked as visited.
|    |  66|+              return max (0, height - heights[i][j]);   // Fill in the gap.
|    |  67|+          }
|  64|  68| 
|  65|  69|         return 0;
|  66|  70|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  65|  65|         return 0;
|  66|  66|     }
|  67|  67| 
|  68|    |-    struct Cell {
|    |  68|+    struct Cell
|    |  69|+    {
|  69|  70|         int i;
|  70|  71|         int j;
|  71|  72|         int height;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  71|  71|         int height;
|  72|  72|     };
|  73|  73| 
|  74|    |-    struct Compare {
|  75|    |-        bool operator()(const Cell& a, const Cell& b) {
|    |  74|+    struct Compare
|    |  75|+    {
|    |  76|+        bool operator () (const Cell & a, const Cell & b)
|    |  77|+        {
|  76|  78|             return a.height > b.height;
|  77|  79|         }
|  78|  80|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water-ii.cpp
|    |++++| /app/C++/trapping-rain-water-ii.cpp
|  79|  79| 
|  80|  80|     int m_;
|  81|  81|     int n_;
|  82|    |-    vector<vector<bool>> is_visited_;
|  83|    |-    priority_queue<Cell ,vector<Cell>, Compare> heap_; // Use min heap to get the lowerest cell.
|    |  82|+    vector < vector < bool >> is_visited_;
|    |  83|+    priority_queue < Cell, vector < Cell >, Compare > heap_;    // Use min heap to get the lowerest cell.
|  84|  84| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-two-sorted-lists.cpp
|    |++++| /app/C++/merge-two-sorted-lists.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param ListNode l1 is the head of the linked list
|  20|  21|      * @param ListNode l2 is the head of the linked list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-two-sorted-lists.cpp
|    |++++| /app/C++/merge-two-sorted-lists.cpp
|  20|  20|      * @param ListNode l2 is the head of the linked list
|  21|  21|      * @return: ListNode head of linked list
|  22|  22|      */
|  23|    |-    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
|  24|    |-        ListNode dummy{0};
|    |  23|+    ListNode * mergeTwoLists (ListNode * l1, ListNode * l2)
|    |  24|+    {
|    |  25|+        ListNode dummy
|    |  26|+        {
|    |  27|+        0};
|  25|  28|         auto curr = &dummy;
|  26|  29| 
|  27|  30|         while (l1 && l2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-two-sorted-lists.cpp
|    |++++| /app/C++/merge-two-sorted-lists.cpp
|  24|  24|         ListNode dummy{0};
|  25|  25|         auto curr = &dummy;
|  26|  26| 
|  27|    |-        while (l1 && l2) {
|  28|    |-            if (l1->val <= l2->val) {
|  29|    |-                curr->next = l1;
|  30|    |-                l1 = l1->next;
|  31|    |-            } else {
|  32|    |-                curr->next = l2;
|  33|    |-                l2 = l2->next;
|  34|    |-            }
|  35|    |-            curr = curr->next;
|  36|    |-        }
|    |  27|+        while (l1 && l2)
|    |  28|+          {
|    |  29|+              if (l1->val <= l2->val)
|    |  30|+                {
|    |  31|+                    curr->next = l1;
|    |  32|+                    l1 = l1->next;
|    |  33|+                }
|    |  34|+              else
|    |  35|+                {
|    |  36|+                    curr->next = l2;
|    |  37|+                    l2 = l2->next;
|    |  38|+                }
|    |  39|+              curr = curr->next;
|    |  40|+          }
|  37|  41|         curr->next = l1 ? l1 : l2;
|  38|  42| 
|  39|  43|         return dummy.next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  18|  18|  *    TreeNode * node = iterator.next();
|  19|  19|  *    do something for node
|  20|  20|  */
|  21|    |-class Solution {
|  22|    |-public:
|    |  21|+class Solution
|    |  22|+{
|    |  23|+  public:
|  23|  24|     //@param root: The root of binary tree.
|  24|    |-    Solution(TreeNode *root) {
|    |  25|+    Solution (TreeNode * root)
|    |  26|+    {
|  25|  27|         curr = root;
|  26|  28|     }
|  27|  29| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  26|  26|     }
|  27|  27| 
|  28|  28|     //@return: True if there has next node, or false
|  29|    |-    bool hasNext() {
|  30|    |-        return !s.empty() || curr != nullptr;
|    |  29|+    bool hasNext ()
|    |  30|+    {
|    |  31|+        return !s.empty () || curr != nullptr;
|  31|  32|     }
|  32|  33| 
|  33|  34|     //@return: return next node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  31|  31|     }
|  32|  32| 
|  33|  33|     //@return: return next node
|  34|    |-    TreeNode* next() {
|    |  34|+    TreeNode *next ()
|    |  35|+    {
|  35|  36|         // Go to left most descendant.
|  36|    |-        while (curr != nullptr) {
|  37|    |-            s.emplace(curr);
|  38|    |-            curr = curr->left;
|  39|    |-        }
|  40|    |-        curr = s.top(); // Left most node.
|  41|    |-        s.pop();
|    |  37|+        while (curr != nullptr)
|    |  38|+          {
|    |  39|+              s.emplace (curr);
|    |  40|+              curr = curr->left;
|    |  41|+          }
|    |  42|+        curr = s.top ();        // Left most node.
|    |  43|+        s.pop ();
|  42|  44| 
|  43|  45|         TreeNode *node = curr;
|  44|  46|         curr = curr->right; // Visit right child.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  41|  41|         s.pop();
|  42|  42| 
|  43|  43|         TreeNode *node = curr;
|  44|    |-        curr = curr->right; // Visit right child.
|    |  44|+        curr = curr->right;     // Visit right child.
|  45|  45| 
|  46|  46|         return node;
|  47|  47|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  45|  45| 
|  46|  46|         return node;
|  47|  47|     }
|  48|    |-private:
|  49|    |-    stack<TreeNode *> s;
|    |  48|+  private:
|    |  49|+    stack < TreeNode * >s;
|  50|  50|     TreeNode *curr;
|  51|  51| };
|  52|  52| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-search-tree-iterator.cpp
|    |++++| /app/C++/binary-search-tree-iterator.cpp
|  49|  49|     stack<TreeNode *> s;
|  50|  50|     TreeNode *curr;
|  51|  51| };
|  52|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/anagrams.cpp
|    |++++| /app/C++/anagrams.cpp
|   1|   1| // Time:  O(n * klogk), k is max length of strings
|   2|   2| // Space: O(m), m is number of anagram groups
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param strs: A list of strings
|   8|   9|      * @return: A list of strings
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/anagrams.cpp
|    |++++| /app/C++/anagrams.cpp
|   7|   7|      * @param strs: A list of strings
|   8|   8|      * @return: A list of strings
|   9|   9|      */
|  10|    |-    vector<string> anagrams(vector<string> &strs) {
|  11|    |-        unordered_map<string, int> table;
|    |  10|+    vector < string > anagrams (vector < string > &strs)
|    |  11|+    {
|    |  12|+        unordered_map < string, int >table;
|  12|  13| 
|  13|    |-        for (auto str : strs) {
|  14|    |-            sort(str.begin(), str.end());
|  15|    |-            ++table[str];
|  16|    |-        }
|    |  14|+        for (auto str:strs)
|    |  15|+          {
|    |  16|+              sort (str.begin (), str.end ());
|    |  17|+              ++table[str];
|    |  18|+          }
|  17|  19| 
|  18|    |-        vector<string> anagrams;
|  19|    |-        for (const auto& str : strs) {
|  20|    |-            string sorted_str(str);
|  21|    |-            sort(sorted_str.begin(), sorted_str.end());
|  22|    |-            if (table[sorted_str] >= 2) {
|  23|    |-                anagrams.emplace_back(str);
|  24|    |-            }
|  25|    |-        }
|    |  20|+        vector < string > anagrams;
|    |  21|+      for (const auto & str:strs)
|    |  22|+          {
|    |  23|+              string sorted_str (str);
|    |  24|+              sort (sorted_str.begin (), sorted_str.end ());
|    |  25|+              if (table[sorted_str] >= 2)
|    |  26|+                {
|    |  27|+                    anagrams.emplace_back (str);
|    |  28|+                }
|    |  29|+          }
|  26|  30| 
|  27|  31|         return anagrams;
|  28|  32|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/anagrams.cpp
|    |++++| /app/C++/anagrams.cpp
|  27|  27|         return anagrams;
|  28|  28|     }
|  29|  29| };
|  30|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/candy.cpp
|    |++++| /app/C++/candy.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param ratings Children's ratings
|   8|   9|      * @return the minimum candies you must give
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/candy.cpp
|    |++++| /app/C++/candy.cpp
|   7|   7|      * @param ratings Children's ratings
|   8|   8|      * @return the minimum candies you must give
|   9|   9|      */
|  10|    |-    int candy(vector<int>& ratings) {
|  11|    |-        vector<int> candies(ratings.size(), 1);
|  12|    |-        for (int i = 1; i < ratings.size(); ++i) {
|  13|    |-            if (ratings[i] > ratings[i - 1]) {
|  14|    |-                candies[i] = candies[i - 1] + 1;
|  15|    |-            }
|  16|    |-        }
|  17|    |-        for (int i = ratings.size() - 2; i >= 0; --i) {
|  18|    |-            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
|  19|    |-                candies[i] = candies[i + 1] + 1;
|  20|    |-            }
|  21|    |-        }
|  22|    |-        return accumulate(candies.cbegin(), candies.cend(), 0);
|    |  10|+    int candy (vector < int >&ratings)
|    |  11|+    {
|    |  12|+        vector < int >candies (ratings.size (), 1);
|    |  13|+        for (int i = 1; i < ratings.size (); ++i)
|    |  14|+          {
|    |  15|+              if (ratings[i] > ratings[i - 1])
|    |  16|+                {
|    |  17|+                    candies[i] = candies[i - 1] + 1;
|    |  18|+                }
|    |  19|+          }
|    |  20|+        for (int i = ratings.size () - 2; i >= 0; --i)
|    |  21|+          {
|    |  22|+              if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1])
|    |  23|+                {
|    |  24|+                    candies[i] = candies[i + 1] + 1;
|    |  25|+                }
|    |  26|+          }
|    |  27|+        return accumulate (candies.cbegin (), candies.cend (), 0);
|  23|  28|     }
|  24|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // Binary search solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A an integer array
|   9|  10|      * @param start an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|  10|  10|      * @param end an integer
|  11|  11|      * @return the number of possible answer
|  12|  12|      */
|  13|    |-    int subarraySumII(vector<int>& A, int start, int end) {
|    |  13|+    int subarraySumII (vector < int >&A, int start, int end)
|    |  14|+    {
|  14|  15|         // sum_from_start[i] denotes sum for 0 ~ i - 1.
|  15|    |-        vector<int> sum_from_start(A.size() + 1);
|  16|    |-        partial_sum(A.cbegin(), A.cend(), sum_from_start.begin() + 1);
|    |  16|+        vector < int >sum_from_start (A.size () + 1);
|    |  17|+          partial_sum (A.cbegin (), A.cend (), sum_from_start.begin () + 1);
|  17|  18| 
|  18|  19|         int result = 0;
|  19|  20|         for (int j = 0; j < A.size(); ++j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|  16|  16|         partial_sum(A.cbegin(), A.cend(), sum_from_start.begin() + 1);
|  17|  17| 
|  18|  18|         int result = 0;
|  19|    |-        for (int j = 0; j < A.size(); ++j) {
|  20|    |-            const auto left = lower_bound(sum_from_start.cbegin(),
|  21|    |-                                          sum_from_start.cbegin() + j + 1,
|  22|    |-                                          sum_from_start[j + 1] - end);
|  23|    |-            const auto right = upper_bound(sum_from_start.cbegin(),
|  24|    |-                                           sum_from_start.cbegin() + j + 1,
|  25|    |-                                           sum_from_start[j + 1] - start);
|  26|    |-            result += (right - sum_from_start.cbegin()) - 
|  27|    |-                      (left - sum_from_start.cbegin());
|  28|    |-        }
|    |  19|+        for (int j = 0; j < A.size (); ++j)
|    |  20|+          {
|    |  21|+              const auto left = lower_bound (sum_from_start.cbegin (),
|    |  22|+                                             sum_from_start.cbegin () + j + 1,
|    |  23|+                                             sum_from_start[j + 1] - end);
|    |  24|+              const auto right = upper_bound (sum_from_start.cbegin (),
|    |  25|+                                              sum_from_start.cbegin () + j + 1,
|    |  26|+                                              sum_from_start[j + 1] - start);
|    |  27|+                result += (right - sum_from_start.cbegin ()) -
|    |  28|+                  (left - sum_from_start.cbegin ());
|    |  29|+          }
|  29|  30| 
|  30|  31|         return result;
|  31|  32|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|  33|  33| 
|  34|  34| // Time:  O(n^2)
|  35|  35| // Space: O(n)
|  36|    |-class Solution2 {
|  37|    |-public:
|    |  36|+class Solution2
|    |  37|+{
|    |  38|+  public:
|  38|  39|     /**
|  39|  40|      * @param A an integer array
|  40|  41|      * @param start an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|  41|  41|      * @param end an integer
|  42|  42|      * @return the number of possible answer
|  43|  43|      */
|  44|    |-    int subarraySumII(vector<int>& A, int start, int end) {
|    |  44|+    int subarraySumII (vector < int >&A, int start, int end)
|    |  45|+    {
|  45|  46|         // sum_from_start[i] denotes sum for 0 ~ i - 1.
|  46|    |-        vector<int> sum_from_start(A.size() + 1);
|  47|    |-        partial_sum(A.cbegin(), A.cend(), sum_from_start.begin() + 1);
|    |  47|+        vector < int >sum_from_start (A.size () + 1);
|    |  48|+          partial_sum (A.cbegin (), A.cend (), sum_from_start.begin () + 1);
|  48|  49| 
|  49|  50|         int result = 0;
|  50|  51|         for (int i = 0, j = 0; j < A.size(); ++j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-ii.cpp
|    |++++| /app/C++/subarray-sum-ii.cpp
|  47|  47|         partial_sum(A.cbegin(), A.cend(), sum_from_start.begin() + 1);
|  48|  48| 
|  49|  49|         int result = 0;
|  50|    |-        for (int i = 0, j = 0; j < A.size(); ++j) {
|  51|    |-            int k = i;
|  52|    |-            while (k <= j) {
|  53|    |-                if (sum_from_start[j + 1] - sum_from_start[k] >= start &&
|  54|    |-                    sum_from_start[j + 1] - sum_from_start[k] <= end) {
|  55|    |-                    ++result;
|    |  50|+        for (int i = 0, j = 0; j < A.size (); ++j)
|    |  51|+          {
|    |  52|+              int k = i;
|    |  53|+              while (k <= j)
|    |  54|+                {
|    |  55|+                    if (sum_from_start[j + 1] - sum_from_start[k] >= start &&
|    |  56|+                        sum_from_start[j + 1] - sum_from_start[k] <= end)
|    |  57|+                      {
|    |  58|+                          ++result;
|    |  59|+                      }
|    |  60|+                    ++k;
|  56|  61|                 }
|  57|    |-                ++k;
|  58|    |-            }
|  59|    |-        }
|    |  62|+          }
|  60|  63| 
|  61|  64|         return result;
|  62|  65|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game.cpp
|    |++++| /app/C++/jump-game.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: A list of integers
|   8|   9|      * @return: The boolean answer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game.cpp
|    |++++| /app/C++/jump-game.cpp
|   7|   7|      * @param A: A list of integers
|   8|   8|      * @return: The boolean answer
|   9|   9|      */
|  10|    |-    bool canJump(vector<int> A) {
|    |  10|+    bool canJump (vector < int >A)
|    |  11|+    {
|  11|  12|         int reachable = 0;
|  12|    |-        for (int i = 0; i < A.size(); ++i) {
|  13|    |-            if (i > reachable) {
|  14|    |-                return false;
|  15|    |-            }
|  16|    |-            reachable = max(reachable, i + A[i]);
|  17|    |-        }
|    |  13|+        for (int i = 0; i < A.size (); ++i)
|    |  14|+          {
|    |  15|+              if (i > reachable)
|    |  16|+                {
|    |  17|+                    return false;
|    |  18|+                }
|    |  19|+              reachable = max (reachable, i + A[i]);
|    |  20|+          }
|  18|  21| 
|  19|  22|         return true;
|  20|  23|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/jump-game.cpp
|    |++++| /app/C++/jump-game.cpp
|  19|  19|         return true;
|  20|  20|     }
|  21|  21| };
|  22|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-depth-of-binary-tree.cpp
|    |++++| /app/C++/minimum-depth-of-binary-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-depth-of-binary-tree.cpp
|    |++++| /app/C++/minimum-depth-of-binary-tree.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: An integer
|  21|  21|      */
|  22|    |-    int minDepth(TreeNode *root) {
|  23|    |-        if (root == nullptr) {
|  24|    |-            return 0;
|  25|    |-        }
|    |  22|+    int minDepth (TreeNode * root)
|    |  23|+    {
|    |  24|+        if (root == nullptr)
|    |  25|+          {
|    |  26|+              return 0;
|    |  27|+          }
|  26|  28| 
|  27|  29|         // Both children exist.
|  28|  30|         if (root->left != nullptr && root->right != nullptr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-depth-of-binary-tree.cpp
|    |++++| /app/C++/minimum-depth-of-binary-tree.cpp
|  25|  25|         }
|  26|  26| 
|  27|  27|         // Both children exist.
|  28|    |-        if (root->left != nullptr && root->right != nullptr) {
|  29|    |-            return 1 + min(minDepth(root->left), minDepth(root->right));
|  30|    |-        }
|  31|    |-        else {
|  32|    |-            return 1 + max(minDepth(root->left), minDepth(root->right));
|  33|    |-        }
|    |  28|+        if (root->left != nullptr && root->right != nullptr)
|    |  29|+          {
|    |  30|+              return 1 + min (minDepth (root->left), minDepth (root->right));
|    |  31|+          }
|    |  32|+        else
|    |  33|+          {
|    |  34|+              return 1 + max (minDepth (root->left), minDepth (root->right));
|    |  35|+          }
|  34|  36|     }
|  35|  37| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A : An integer array
|   8|   9|      * @return : Two integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|   7|   7|      * @param A : An integer array
|   8|   8|      * @return : Two integers
|   9|   9|      */
|  10|    |-    vector<int> singleNumberIII(vector<int> &A) {
|    |  10|+    vector < int >singleNumberIII (vector < int >&A)
|    |  11|+    {
|  11|  12|         // Xor all the elements to get x ^ y.
|  12|    |-        const auto x_xor_y = accumulate(A.cbegin(), A.cend(), 0, bit_xor<int>());
|    |  13|+        const auto x_xor_y =
|    |  14|+            accumulate (A.cbegin (), A.cend (), 0, bit_xor < int >());
|  13|  15| 
|  14|  16|         // Get the last bit where 1 occurs.
|  15|  17|         const auto bit = x_xor_y & -x_xor_y;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|  17|  17|         // Get the subset of A where the number has the bit.
|  18|  18|         // The subset only contains one of the two integers, call it x.
|  19|  19|         // Xor all the elements in the subset to get x.
|  20|    |-        vector<int> result(2, 0);
|  21|    |-        for (const auto& i : A) {
|  22|    |-            result[static_cast<bool>(i & bit)] ^= i;
|  23|    |-        }
|    |  20|+          vector < int >result (2, 0);
|    |  21|+        for (const auto & i:A)
|    |  22|+          {
|    |  23|+              result[static_cast < bool > (i & bit)] ^= i;
|    |  24|+          }
|  24|  25|         return result;
|  25|  26|     }
|  26|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|  25|  25|     }
|  26|  26| };
|  27|  27| 
|  28|    |-class Solution2 {
|  29|    |-public:
|    |  28|+class Solution2
|    |  29|+{
|    |  30|+  public:
|  30|  31|     /**
|  31|  32|      * @param A : An integer array
|  32|  33|      * @return : Two integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|  31|  31|      * @param A : An integer array
|  32|  32|      * @return : Two integers
|  33|  33|      */
|  34|    |-    vector<int> singleNumberIII(vector<int> &A) {
|    |  34|+    vector < int >singleNumberIII (vector < int >&A)
|    |  35|+    {
|  35|  36|         // Xor all the elements to get x ^ y.
|  36|  37|         int x_xor_y = 0;
|  37|  38|         for (const auto& i : A) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|  34|  34|     vector<int> singleNumberIII(vector<int> &A) {
|  35|  35|         // Xor all the elements to get x ^ y.
|  36|  36|         int x_xor_y = 0;
|  37|    |-        for (const auto& i : A) {
|  38|    |-            x_xor_y ^= i;
|  39|    |-        }
|    |  37|+        for (const auto & i:A)
|    |  38|+          {
|    |  39|+              x_xor_y ^= i;
|    |  40|+          }
|  40|  41| 
|  41|  42|         // Get the last bit where 1 occurs.
|  42|  43|         const auto bit = x_xor_y & ~(x_xor_y - 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-iii.cpp
|    |++++| /app/C++/single-number-iii.cpp
|  45|  45|         // The subset only contains one of the two integers, call it x.
|  46|  46|         // Xor all the elements in the subset to get x.
|  47|  47|         int x = 0;
|  48|    |-        for (const auto& i : A) {
|  49|    |-            if (i & bit) {
|  50|    |-                x ^= i;
|  51|    |-            }
|  52|    |-        }
|    |  48|+      for (const auto & i:A)
|    |  49|+          {
|    |  50|+              if (i & bit)
|    |  51|+                {
|    |  52|+                    x ^= i;
|    |  53|+                }
|    |  54|+          }
|  53|  55| 
|  54|    |-        return {x, x_xor_y ^ x};
|    |  56|+        return
|    |  57|+        {
|    |  58|+        x, x_xor_y ^ x};
|  55|  59|     }
|  56|  60| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|   7|   7|  * Shape* shape = sf->getShape(shapeType);
|   8|   8|  * shape->draw();
|   9|   9|  */
|  10|    |-class Shape {
|  11|    |-public:
|  12|    |-    virtual void draw() const=0;
|    |  10|+class Shape
|    |  11|+{
|    |  12|+  public:
|    |  13|+    virtual void draw () const = 0;
|  13|  14| };
|  14|  15| 
|  15|  16| class Rectangle: public Shape {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|  12|  12|     virtual void draw() const=0;
|  13|  13| };
|  14|  14| 
|  15|    |-class Rectangle: public Shape {
|  16|    |-public:
|  17|    |-    virtual void draw() const {
|  18|    |-        cout << " ----" << endl
|  19|    |-             << "|    |" << endl
|  20|    |-             << " ----" << endl;
|    |  15|+class Rectangle:public Shape
|    |  16|+{
|    |  17|+  public:
|    |  18|+    virtual void draw () const
|    |  19|+    {
|    |  20|+        cout << " ----" << endl << "|    |" << endl << " ----" << endl;
|  21|  21|     }
|  22|  22| };
|  23|  23| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|  21|  21|     }
|  22|  22| };
|  23|  23| 
|  24|    |-class Square: public Shape {
|  25|    |-public:
|  26|    |-    virtual void draw() const {
|    |  24|+class Square:public Shape
|    |  25|+{
|    |  26|+  public:
|    |  27|+    virtual void draw () const
|    |  28|+    {
|  27|  29|         cout << " ----" << endl
|  28|    |-             << "|    |" << endl
|  29|    |-             << "|    |" << endl
|  30|    |-             << " ----" << endl;
|    |  30|+            << "|    |" << endl << "|    |" << endl << " ----" << endl;
|  31|  31|     }
|  32|  32| };
|  33|  33| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|  31|  31|     }
|  32|  32| };
|  33|  33| 
|  34|    |-class Triangle: public Shape {
|  35|    |-public:
|  36|    |-    virtual void draw() const {
|  37|    |-        cout << "  /\\" << endl
|  38|    |-             << " /  \\" << endl
|  39|    |-             << "/____\\" << endl;
|    |  34|+class Triangle:public Shape
|    |  35|+{
|    |  36|+  public:
|    |  37|+    virtual void draw () const
|    |  38|+    {
|    |  39|+        cout << "  /\\" << endl << " /  \\" << endl << "/____\\" << endl;
|  40|  40|     }
|  41|  41| };
|  42|  42| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|  40|  40|     }
|  41|  41| };
|  42|  42| 
|  43|    |-class ShapeFactory {
|  44|    |-public:
|    |  43|+class ShapeFactory
|    |  44|+{
|    |  45|+  public:
|  45|  46|     /**
|  46|  47|      * @param shapeType a string
|  47|  48|      * @return Get object of type Shape
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/shape-factory.cpp
|    |++++| /app/C++/shape-factory.cpp
|  46|  46|      * @param shapeType a string
|  47|  47|      * @return Get object of type Shape
|  48|  48|      */
|  49|    |-    Shape* getShape(string& shapeType) {
|  50|    |-        if (shapeType == "Square") {
|  51|    |-            return new Square();
|  52|    |-        } else if (shapeType == "Triangle") {
|  53|    |-            return new Triangle();
|  54|    |-        } else if (shapeType == "Rectangle") {
|  55|    |-            return new Rectangle();
|  56|    |-        }
|    |  49|+    Shape * getShape (string & shapeType)
|    |  50|+    {
|    |  51|+        if (shapeType == "Square")
|    |  52|+          {
|    |  53|+              return new Square ();
|    |  54|+          }
|    |  55|+        else if (shapeType == "Triangle")
|    |  56|+          {
|    |  57|+              return new Triangle ();
|    |  58|+          }
|    |  59|+        else if (shapeType == "Rectangle")
|    |  60|+          {
|    |  61|+              return new Rectangle ();
|    |  62|+          }
|  57|  63|     }
|  58|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Use combination in math.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param n, m: positive integer (1 <= n ,m <= 100)
|   9|  10|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|   8|   8|      * @param n, m: positive integer (1 <= n ,m <= 100)
|   9|   9|      * @return an integer
|  10|  10|      */
|  11|    |-    int uniquePaths(int m, int n) {
|  12|    |-        return combination(m + n - 2, min(m - 1, n - 1));
|    |  11|+    int uniquePaths (int m, int n)
|    |  12|+    {
|    |  13|+        return combination (m + n - 2, min (m - 1, n - 1));
|  13|  14|     }
|  14|  15| 
|  15|  16|     int combination(int  n, int k) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  12|  12|         return combination(m + n - 2, min(m - 1, n - 1));
|  13|  13|     }
|  14|  14| 
|  15|    |-    int combination(int  n, int k) {
|    |  15|+    int combination (int n, int k)
|    |  16|+    {
|  16|  17|         long long count = 1;
|  17|  18|         // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
|  18|  19|         for (int i = 1; i <= k; ++i, --n) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  15|  15|     int combination(int  n, int k) {
|  16|  16|         long long count = 1;
|  17|  17|         // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
|  18|    |-        for (int i = 1; i <= k; ++i, --n) {
|  19|    |-            count = count * n / i;
|  20|    |-        }
|    |  18|+        for (int i = 1; i <= k; ++i, --n)
|    |  19|+          {
|    |  20|+              count = count * n / i;
|    |  21|+          }
|  21|  22| 
|  22|  23|         return count;
|  23|  24|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  26|  26| // Time:  O(m * n)
|  27|  27| // Space: O(min(m, n))
|  28|  28| // DP solution with rolling window.
|  29|    |-class Solution2 {
|  30|    |-public:
|    |  29|+class Solution2
|    |  30|+{
|    |  31|+  public:
|  31|  32|     /**
|  32|  33|      * @param n, m: positive integer (1 <= n ,m <= 100)
|  33|  34|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  32|  32|      * @param n, m: positive integer (1 <= n ,m <= 100)
|  33|  33|      * @return an integer
|  34|  34|      */
|  35|    |-    int uniquePaths(int m, int n) {
|  36|    |-        if (m < n) {
|  37|    |-            return uniquePaths(n, m);
|  38|    |-        }
|    |  35|+    int uniquePaths (int m, int n)
|    |  36|+    {
|    |  37|+        if (m < n)
|    |  38|+          {
|    |  39|+              return uniquePaths (n, m);
|    |  40|+          }
|  39|  41| 
|  40|    |-        vector<vector<int>> path(2, vector<int>(n, 0));
|    |  42|+        vector < vector < int >>path (2, vector < int >(n, 0));
|  41|  43| 
|  42|    |-        for (int j = 0; j < n; ++j) {
|  43|    |-            path[0 % 2][j] = 1;
|  44|    |-        }
|    |  44|+        for (int j = 0; j < n; ++j)
|    |  45|+          {
|    |  46|+              path[0 % 2][j] = 1;
|    |  47|+          }
|  45|  48| 
|  46|    |-        for (int i = 1; i < m; ++i) {
|  47|    |-            path[i % 2][0] = path[(i - 1) % 2][0];
|  48|    |-            for (int j = 1; j < n; ++j) {
|  49|    |-                path[i % 2][j] = path[(i - 1) % 2][j] + path[i % 2][j - 1];
|  50|    |-            }
|  51|    |-        }
|    |  49|+        for (int i = 1; i < m; ++i)
|    |  50|+          {
|    |  51|+              path[i % 2][0] = path[(i - 1) % 2][0];
|    |  52|+              for (int j = 1; j < n; ++j)
|    |  53|+                {
|    |  54|+                    path[i % 2][j] = path[(i - 1) % 2][j] + path[i % 2][j - 1];
|    |  55|+                }
|    |  56|+          }
|  52|  57| 
|  53|  58|         return path[(m - 1) % 2][n - 1];
|  54|  59|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  57|  57| // Time:  O(m * n)
|  58|  58| // Space: O(m * n)
|  59|  59| // DP solution.
|  60|    |-class Solution3 {
|  61|    |-public:
|    |  60|+class Solution3
|    |  61|+{
|    |  62|+  public:
|  62|  63|     /**
|  63|  64|      * @param n, m: positive integer (1 <= n ,m <= 100)
|  64|  65|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  63|  63|      * @param n, m: positive integer (1 <= n ,m <= 100)
|  64|  64|      * @return an integer
|  65|  65|      */
|  66|    |-    int uniquePaths(int m, int n) {
|  67|    |-        if (m < n) {
|  68|    |-            return uniquePaths(n, m);
|  69|    |-        }
|    |  66|+    int uniquePaths (int m, int n)
|    |  67|+    {
|    |  68|+        if (m < n)
|    |  69|+          {
|    |  70|+              return uniquePaths (n, m);
|    |  71|+          }
|  70|  72| 
|  71|    |-        vector<vector<int>> path(m, vector<int>(n, 0));
|    |  73|+        vector < vector < int >>path (m, vector < int >(n, 0));
|  72|  74| 
|  73|    |-        for (int j = 0; j < n; ++j) {
|  74|    |-            path[0][j] = 1;
|  75|    |-        }
|    |  75|+        for (int j = 0; j < n; ++j)
|    |  76|+          {
|    |  77|+              path[0][j] = 1;
|    |  78|+          }
|  76|  79| 
|  77|    |-        for (int i = 1; i < m; ++i) {
|  78|    |-            path[i][0] = path[i - 1][0];
|  79|    |-            for (int j = 1; j < n; ++j) {
|  80|    |-                path[i][j] = path[i - 1][j] + path[i][j - 1];
|  81|    |-            }
|  82|    |-        }
|    |  80|+        for (int i = 1; i < m; ++i)
|    |  81|+          {
|    |  82|+              path[i][0] = path[i - 1][0];
|    |  83|+              for (int j = 1; j < n; ++j)
|    |  84|+                {
|    |  85|+                    path[i][j] = path[i - 1][j] + path[i][j - 1];
|    |  86|+                }
|    |  87|+          }
|  83|  88| 
|  84|  89|         return path[m - 1][n - 1];
|  85|  90|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths.cpp
|    |++++| /app/C++/unique-paths.cpp
|  84|  84|         return path[m - 1][n - 1];
|  85|  85|     }
|  86|  86| };
|  87|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16| 
|  17|    |-
|  18|    |-class Solution {
|    |  17|+class Solution
|    |  18|+{
|  19|  19|     /**
|  20|  20|      *@param preorder : A list of integers that preorder traversal of a tree
|  21|  21|      *@param inorder : A list of integers that inorder traversal of a tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|  21|  21|      *@param inorder : A list of integers that inorder traversal of a tree
|  22|  22|      *@return : Root of a tree
|  23|  23|      */
|  24|    |-public:
|  25|    |-    TreeNode *buildTree(vector<int> &pre, vector<int> &in) {
|  26|    |-        unordered_map<int, size_t> in_entry_idx_map;
|  27|    |-        for (size_t i = 0; i < in.size(); ++i) {
|  28|    |-            in_entry_idx_map.emplace(in[i], i);
|  29|    |-        }
|  30|    |-        return ReconstructPreInOrdersHelper(pre, 0, pre.size(), in, 0, in.size(),
|  31|    |-                                            in_entry_idx_map);
|    |  24|+  public:
|    |  25|+    TreeNode * buildTree (vector < int >&pre, vector < int >&in)
|    |  26|+    {
|    |  27|+        unordered_map < int, size_t > in_entry_idx_map;
|    |  28|+        for (size_t i = 0; i < in.size (); ++i)
|    |  29|+          {
|    |  30|+              in_entry_idx_map.emplace (in[i], i);
|    |  31|+          }
|    |  32|+        return ReconstructPreInOrdersHelper (pre, 0, pre.size (), in, 0,
|    |  33|+                                             in.size (), in_entry_idx_map);
|  32|  34|     }
|  33|  35| 
|  34|  36|     // Reconstructs the binary tree from pre[pre_s : pre_e - 1] and
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp
|  33|  33| 
|  34|  34|     // Reconstructs the binary tree from pre[pre_s : pre_e - 1] and
|  35|  35|     // in[in_s : in_e - 1].
|  36|    |-    TreeNode *ReconstructPreInOrdersHelper(const vector<int>& pre, size_t pre_s, size_t pre_e,
|  37|    |-                                           const vector<int>& in, size_t in_s, size_t in_e,
|  38|    |-                                           const unordered_map<int, size_t>& in_entry_idx_map) {
|  39|    |-        if (pre_e > pre_s && in_e > in_s) {
|  40|    |-            auto idx = in_entry_idx_map.at(pre[pre_s]);
|  41|    |-            auto left_tree_size = idx - in_s;
|    |  36|+    TreeNode *ReconstructPreInOrdersHelper (const vector < int >&pre,
|    |  37|+                                            size_t pre_s, size_t pre_e,
|    |  38|+                                            const vector < int >&in,
|    |  39|+                                            size_t in_s, size_t in_e,
|    |  40|+                                            const unordered_map < int,
|    |  41|+                                            size_t > &in_entry_idx_map)
|    |  42|+    {
|    |  43|+        if (pre_e > pre_s && in_e > in_s)
|    |  44|+          {
|    |  45|+              auto idx = in_entry_idx_map.at (pre[pre_s]);
|    |  46|+              auto left_tree_size = idx - in_s;
|  42|  47| 
|  43|    |-            TreeNode *node = new TreeNode(pre[pre_s]);
|  44|    |-            // Recursively builds the left subtree.
|  45|    |-            node->left = ReconstructPreInOrdersHelper(pre, pre_s + 1, pre_s + 1 + left_tree_size,
|  46|    |-                                                      in, in_s, idx, in_entry_idx_map);
|  47|    |-            // Recursively builds the right subtree.
|  48|    |-            node->right = ReconstructPreInOrdersHelper(pre, pre_s + 1 + left_tree_size, pre_e,
|  49|    |-                                                       in, idx + 1, in_e, in_entry_idx_map);
|  50|    |-            return node;
|  51|    |-        }
|    |  48|+              TreeNode *node = new TreeNode (pre[pre_s]);
|    |  49|+              // Recursively builds the left subtree.
|    |  50|+              node->left =
|    |  51|+                  ReconstructPreInOrdersHelper (pre, pre_s + 1,
|    |  52|+                                                pre_s + 1 + left_tree_size, in,
|    |  53|+                                                in_s, idx, in_entry_idx_map);
|    |  54|+              // Recursively builds the right subtree.
|    |  55|+              node->right =
|    |  56|+                  ReconstructPreInOrdersHelper (pre,
|    |  57|+                                                pre_s + 1 + left_tree_size,
|    |  58|+                                                pre_e, in, idx + 1, in_e,
|    |  59|+                                                in_entry_idx_map);
|    |  60|+              return node;
|    |  61|+          }
|  52|  62|         return nullptr;
|  53|  63|     }
|  54|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/matrix-zigzag-traversal.cpp
|    |++++| /app/C++/matrix-zigzag-traversal.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: a matrix of integers
|   8|   9|      * @return: a vector of integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/matrix-zigzag-traversal.cpp
|    |++++| /app/C++/matrix-zigzag-traversal.cpp
|   7|   7|      * @param matrix: a matrix of integers
|   8|   8|      * @return: a vector of integers
|   9|   9|      */
|  10|    |-    vector<int> printZMatrix(vector<vector<int>> &matrix) {
|  11|    |-        vector<int> zigzag;
|  12|    |-        const int m = matrix.size(), n = matrix[0].size();
|    |  10|+    vector < int >printZMatrix (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        vector < int >zigzag;
|    |  13|+        const int m = matrix.size (), n = matrix[0].size ();
|  13|  14| 
|  14|    |-        for (int i = 0; i < m + n - 1; ++i) {
|  15|    |-            if (i % 2) {
|  16|    |-                for (int y = min(i, n - 1);  y >= max(0, i - m + 1); --y) {
|  17|    |-                    zigzag.emplace_back(matrix[i - y][y]);
|    |  15|+        for (int i = 0; i < m + n - 1; ++i)
|    |  16|+          {
|    |  17|+              if (i % 2)
|    |  18|+                {
|    |  19|+                    for (int y = min (i, n - 1); y >= max (0, i - m + 1); --y)
|    |  20|+                      {
|    |  21|+                          zigzag.emplace_back (matrix[i - y][y]);
|    |  22|+                      }
|  18|  23|                 }
|  19|    |-            } else {
|  20|    |-                for (int x = min(i, m - 1);  x >= max(0, i - n + 1); --x) {
|  21|    |-                    zigzag.emplace_back(matrix[x][i - x]);
|    |  24|+              else
|    |  25|+                {
|    |  26|+                    for (int x = min (i, m - 1); x >= max (0, i - n + 1); --x)
|    |  27|+                      {
|    |  28|+                          zigzag.emplace_back (matrix[x][i - x]);
|    |  29|+                      }
|  22|  30|                 }
|  23|    |-            }
|  24|    |-        }
|    |  31|+          }
|  25|  32| 
|  26|  33|         return zigzag;
|  27|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/matrix-zigzag-traversal.cpp
|    |++++| /app/C++/matrix-zigzag-traversal.cpp
|  30|  30| // Time:  O((m + n)^2)
|  31|  31| // Space: O(1)
|  32|  32| 
|  33|    |-class Solution2 {
|  34|    |-public:
|    |  33|+class Solution2
|    |  34|+{
|    |  35|+  public:
|  35|  36|     /**
|  36|  37|      * @param matrix: a matrix of integers
|  37|  38|      * @return: a vector of integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/matrix-zigzag-traversal.cpp
|    |++++| /app/C++/matrix-zigzag-traversal.cpp
|  36|  36|      * @param matrix: a matrix of integers
|  37|  37|      * @return: a vector of integers
|  38|  38|      */
|  39|    |-    vector<int> printZMatrix(vector<vector<int>> &matrix) {
|  40|    |-        vector<int> zigzag;
|  41|    |-        const size_t m = matrix.size(), n = matrix[0].size();
|    |  39|+    vector < int >printZMatrix (vector < vector < int >>&matrix)
|    |  40|+    {
|    |  41|+        vector < int >zigzag;
|    |  42|+        const size_t m = matrix.size (), n = matrix[0].size ();
|  42|  43| 
|  43|    |-        for (int i = 0; i < m + n - 1; ++i) {
|  44|    |-            if (i % 2 == 0) {
|  45|    |-                for (int y = 0;  y < n; ++y) {
|  46|    |-                    if (m > i - y && i - y >= 0) {
|  47|    |-                        zigzag.emplace_back(matrix[i - y][y]);
|  48|    |-                    }
|    |  44|+        for (int i = 0; i < m + n - 1; ++i)
|    |  45|+          {
|    |  46|+              if (i % 2 == 0)
|    |  47|+                {
|    |  48|+                    for (int y = 0; y < n; ++y)
|    |  49|+                      {
|    |  50|+                          if (m > i - y && i - y >= 0)
|    |  51|+                            {
|    |  52|+                                zigzag.emplace_back (matrix[i - y][y]);
|    |  53|+                            }
|    |  54|+                      }
|  49|  55|                 }
|  50|    |-            } else {
|  51|    |-                for (int x = 0; x < m; ++x) {
|  52|    |-                    if (n > i - x && i - x >= 0) {
|  53|    |-                        zigzag.emplace_back(matrix[x][i - x]);
|  54|    |-                    }
|    |  56|+              else
|    |  57|+                {
|    |  58|+                    for (int x = 0; x < m; ++x)
|    |  59|+                      {
|    |  60|+                          if (n > i - x && i - x >= 0)
|    |  61|+                            {
|    |  62|+                                zigzag.emplace_back (matrix[x][i - x]);
|    |  63|+                            }
|    |  64|+                      }
|  55|  65|                 }
|  56|    |-            }
|  57|    |-        }
|    |  66|+          }
|  58|  67| 
|  59|  68|         return zigzag;
|  60|  69|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // DP with rolling window.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param values: a vector of integers
|   9|  10|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|   8|   8|      * @param values: a vector of integers
|   9|   9|      * @return: a boolean which equals to true if the first player will win
|  10|  10|      */
|  11|    |-    bool firstWillWin(vector<int> &values) {
|    |  11|+    bool firstWillWin (vector < int >&values)
|    |  12|+    {
|  12|  13|         // Even number case.
|  13|    |-        if (values.size() % 2 == 0) {
|  14|    |-            if (firstWinEvenCoins(values)) {
|  15|    |-                return true;
|  16|    |-            }
|  17|    |-        }
|    |  14|+        if (values.size () % 2 == 0)
|    |  15|+          {
|    |  16|+              if (firstWinEvenCoins (values))
|    |  17|+                {
|    |  18|+                    return true;
|    |  19|+                }
|    |  20|+          }
|  18|  21| 
|  19|  22|         // Count total.
|  20|  23|         int sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  18|  18| 
|  19|  19|         // Count total.
|  20|  20|         int sum = 0;
|  21|    |-        for (int i = 0; i < values.size(); ++i) {
|  22|    |-            sum += values[i];
|  23|    |-        }
|    |  21|+        for (int i = 0; i < values.size (); ++i)
|    |  22|+          {
|    |  23|+              sum += values[i];
|    |  24|+          }
|  24|  25| 
|  25|  26|         // P[i][n] = max(values[i] + min(P[i + 2][n - 2], P[i + 1][n - 2]),
|  26|  27|         //               values[i + n - 1] + min(P[i + 1][n - 2], P[i][n - 2]))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  24|  24| 
|  25|  25|         // P[i][n] = max(values[i] + min(P[i + 2][n - 2], P[i + 1][n - 2]),
|  26|  26|         //               values[i + n - 1] + min(P[i + 1][n - 2], P[i][n - 2]))
|  27|    |-        vector<vector<int>> P(values.size(), vector<int>(3, 0));
|    |  27|+        vector < vector < int >>P (values.size (), vector < int >(3, 0));
|  28|  28| 
|  29|    |-        for (int n = 0; n <= values.size(); ++n) {
|  30|    |-            for (int i = 0; i + n - 1 < values.size(); ++i) {
|  31|    |-                int a = i + 2 <= values.size() - 1 && n - 2 >= 0 ? P[i + 2][(n - 2) % 3] : 0;
|  32|    |-                int b = i + 1 <= values.size() - 1 && n - 2 >= 0 ? P[i + 1][(n - 2) % 3] : 0;
|  33|    |-                int c = n - 2 >= 0 ? P[i][(n - 2) % 3] : 0;
|  34|    |-                P[i][n % 3] = max(values[i] + min(a, b),
|  35|    |-                                  values[i + n - 1] + min(b, c));
|  36|    |-            }
|  37|    |-        }
|  38|    |-        return P[0][values.size() % 3] > sum - P[0][values.size() % 3];
|    |  29|+        for (int n = 0; n <= values.size (); ++n)
|    |  30|+          {
|    |  31|+              for (int i = 0; i + n - 1 < values.size (); ++i)
|    |  32|+                {
|    |  33|+                    int a = i + 2 <= values.size () - 1
|    |  34|+                        && n - 2 >= 0 ? P[i + 2][(n - 2) % 3] : 0;
|    |  35|+                    int b = i + 1 <= values.size () - 1
|    |  36|+                        && n - 2 >= 0 ? P[i + 1][(n - 2) % 3] : 0;
|    |  37|+                    int c = n - 2 >= 0 ? P[i][(n - 2) % 3] : 0;
|    |  38|+                    P[i][n % 3] = max (values[i] + min (a, b),
|    |  39|+                                       values[i + n - 1] + min (b, c));
|    |  40|+                }
|    |  41|+          }
|    |  42|+        return P[0][values.size () % 3] > sum - P[0][values.size () % 3];
|  39|  43|     }
|  40|  44| 
|  41|  45|     // Time: O(n), Space: O(1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  40|  40| 
|  41|  41|     // Time: O(n), Space: O(1)
|  42|  42|     // Odd / even numbered strategy for even numbered coins
|  43|    |-    bool firstWinEvenCoins(const vector<int>& values) {
|    |  43|+    bool firstWinEvenCoins (const vector < int >&values)
|    |  44|+    {
|  44|  45|         int sum = 0;
|  45|  46|         int odd_sum = 0;
|  46|  47|         int even_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  44|  44|         int sum = 0;
|  45|  45|         int odd_sum = 0;
|  46|  46|         int even_sum = 0;
|  47|    |-        for (int i = 0; i < values.size(); ++i) {
|  48|    |-            sum += values[i];
|  49|    |-            if (i % 2 == 0) {
|  50|    |-                odd_sum += values[i];
|  51|    |-            } else {
|  52|    |-                even_sum += values[i];
|  53|    |-            }
|  54|    |-        }
|    |  47|+        for (int i = 0; i < values.size (); ++i)
|    |  48|+          {
|    |  49|+              sum += values[i];
|    |  50|+              if (i % 2 == 0)
|    |  51|+                {
|    |  52|+                    odd_sum += values[i];
|    |  53|+                }
|    |  54|+              else
|    |  55|+                {
|    |  56|+                    even_sum += values[i];
|    |  57|+                }
|    |  58|+          }
|  55|  59| 
|  56|  60|         return odd_sum != even_sum;
|  57|  61|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  59|  59| 
|  60|  60| // Time:  O(n^2)
|  61|  61| // Space: O(n^2)
|  62|    |-class Solution2 {
|  63|    |-public:
|    |  62|+class Solution2
|    |  63|+{
|    |  64|+  public:
|  64|  65|     /**
|  65|  66|      * @param values: a vector of integers
|  66|  67|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  65|  65|      * @param values: a vector of integers
|  66|  66|      * @return: a boolean which equals to true if the first player will win
|  67|  67|      */
|  68|    |-    bool firstWillWin(vector<int> &values) {
|    |  68|+    bool firstWillWin (vector < int >&values)
|    |  69|+    {
|  69|  70|         // Even number case.
|  70|    |-        if (values.size() % 2 == 0) {
|  71|    |-            if (firstWinEvenCoins(values)) {
|  72|    |-                return true;
|  73|    |-            }
|  74|    |-        }
|    |  71|+        if (values.size () % 2 == 0)
|    |  72|+          {
|    |  73|+              if (firstWinEvenCoins (values))
|    |  74|+                {
|    |  75|+                    return true;
|    |  76|+                }
|    |  77|+          }
|  75|  78| 
|  76|  79|         // Count total.
|  77|  80|         int sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  75|  75| 
|  76|  76|         // Count total.
|  77|  77|         int sum = 0;
|  78|    |-        for (int i = 0; i < values.size(); ++i) {
|  79|    |-            sum += values[i];
|  80|    |-        }
|    |  78|+        for (int i = 0; i < values.size (); ++i)
|    |  79|+          {
|    |  80|+              sum += values[i];
|    |  81|+          }
|  81|  82| 
|  82|  83|         // P[i][n] = max(values[i] + min(P[i + 2][n - 2], P[i + 1][n - 2]),
|  83|  84|         //               values[i + n - 1] + min(P[i + 1][n - 2], P[i][n - 2]))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  81|  81| 
|  82|  82|         // P[i][n] = max(values[i] + min(P[i + 2][n - 2], P[i + 1][n - 2]),
|  83|  83|         //               values[i + n - 1] + min(P[i + 1][n - 2], P[i][n - 2]))
|  84|    |-        vector<vector<int>> P(values.size(), vector<int>(values.size() + 1, 0));
|    |  84|+        vector < vector < int >>P (values.size (),
|    |  85|+                                   vector < int >(values.size () + 1, 0));
|  85|  86| 
|  86|    |-        for (int n = 0; n <= values.size(); ++n) {
|  87|    |-            for (int i = 0; i + n - 1 < values.size(); ++i) {
|  88|    |-                int a = i + 2 <= values.size() - 1 && n - 2 >= 0 ? P[i + 2][n - 2] : 0;
|  89|    |-                int b = i + 1 <= values.size() - 1 && n - 2 >= 0 ? P[i + 1][n - 2] : 0;
|  90|    |-                int c = n - 2 >= 0 ? P[i][n - 2] : 0;
|  91|    |-                P[i][n] = max(values[i] + min(a, b),
|  92|    |-                              values[i + n - 1] + min(b, c));
|  93|    |-            }
|  94|    |-        }
|  95|    |-        return P[0][values.size()] > sum - P[0][values.size()];
|    |  87|+        for (int n = 0; n <= values.size (); ++n)
|    |  88|+          {
|    |  89|+              for (int i = 0; i + n - 1 < values.size (); ++i)
|    |  90|+                {
|    |  91|+                    int a = i + 2 <= values.size () - 1
|    |  92|+                        && n - 2 >= 0 ? P[i + 2][n - 2] : 0;
|    |  93|+                    int b = i + 1 <= values.size () - 1
|    |  94|+                        && n - 2 >= 0 ? P[i + 1][n - 2] : 0;
|    |  95|+                    int c = n - 2 >= 0 ? P[i][n - 2] : 0;
|    |  96|+                    P[i][n] = max (values[i] + min (a, b),
|    |  97|+                                   values[i + n - 1] + min (b, c));
|    |  98|+                }
|    |  99|+          }
|    | 100|+        return P[0][values.size ()] > sum - P[0][values.size ()];
|  96| 101|     }
|  97| 102| 
|  98| 103|     // Time: O(n), Space: O(1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
|  97|  97| 
|  98|  98|     // Time: O(n), Space: O(1)
|  99|  99|     // Odd / even numbered strategy for even numbered coins
| 100|    |-    bool firstWinEvenCoins(const vector<int>& values) {
|    | 100|+    bool firstWinEvenCoins (const vector < int >&values)
|    | 101|+    {
| 101| 102|         int sum = 0;
| 102| 103|         int odd_sum = 0;
| 103| 104|         int even_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 101| 101|         int sum = 0;
| 102| 102|         int odd_sum = 0;
| 103| 103|         int even_sum = 0;
| 104|    |-        for (int i = 0; i < values.size(); ++i) {
| 105|    |-            sum += values[i];
| 106|    |-            if (i % 2 == 0) {
| 107|    |-                odd_sum += values[i];
| 108|    |-            } else {
| 109|    |-                even_sum += values[i];
| 110|    |-            }
| 111|    |-        }
|    | 104|+        for (int i = 0; i < values.size (); ++i)
|    | 105|+          {
|    | 106|+              sum += values[i];
|    | 107|+              if (i % 2 == 0)
|    | 108|+                {
|    | 109|+                    odd_sum += values[i];
|    | 110|+                }
|    | 111|+              else
|    | 112|+                {
|    | 113|+                    even_sum += values[i];
|    | 114|+                }
|    | 115|+          }
| 112| 116| 
| 113| 117|         return odd_sum != even_sum;
| 114| 118|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 116| 116| 
| 117| 117| // Time:  O(n^2)
| 118| 118| // Space: O(n^2)
| 119|    |-class Solution3 {
| 120|    |-public:
|    | 119|+class Solution3
|    | 120|+{
|    | 121|+  public:
| 121| 122|     /**
| 122| 123|      * @param values: a vector of integers
| 123| 124|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 122| 122|      * @param values: a vector of integers
| 123| 123|      * @return: a boolean which equals to true if the first player will win
| 124| 124|      */
| 125|    |-    bool firstWillWin(vector<int> &values) {
|    | 125|+    bool firstWillWin (vector < int >&values)
|    | 126|+    {
| 126| 127|         // Even number case;
| 127|    |-        if (values.size() % 2 == 0) {
| 128|    |-            if (firstWinEvenCoins(values)) {
| 129|    |-                return true;
| 130|    |-            }
| 131|    |-        }
|    | 128|+        if (values.size () % 2 == 0)
|    | 129|+          {
|    | 130|+              if (firstWinEvenCoins (values))
|    | 131|+                {
|    | 132|+                    return true;
|    | 133|+                }
|    | 134|+          }
| 132| 135| 
| 133| 136|         // P[i][j] = max(values[i] + min(P[i + 2][j], P[i + 1][j - 1]),
| 134| 137|         //               values[j] + min(P[i + 1][j - 1], P[i][j - 2]))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 132| 132| 
| 133| 133|         // P[i][j] = max(values[i] + min(P[i + 2][j], P[i + 1][j - 1]),
| 134| 134|         //               values[j] + min(P[i + 1][j - 1], P[i][j - 2]))
| 135|    |-        vector<vector<int>> P(values.size(), vector<int>(values.size(), 0));
|    | 135|+        vector < vector < int >>P (values.size (),
|    | 136|+                                   vector < int >(values.size (), 0));
| 136| 137|         int sum = 0;
| 137|    |-        for (int i = 0; i < values.size(); ++i) {
| 138|    |-            sum += values[i];
| 139|    |-            for (int m = 0, n = i; n < values.size(); ++m, ++n) {
| 140|    |-                int a = m + 2 <= values.size() - 1 ? P[m + 2][n] : 0;
| 141|    |-                int b = m + 1 <= values.size() - 1  && n - 1 >= 0 ? P[m + 1][n - 1] : 0;
| 142|    |-                int c = n - 2 >= 0 ? P[m][n - 2] : 0;
| 143|    |-                P[m][n] = max(values[m] + min(a, b),
| 144|    |-                              values[n] + min(b, c));
| 145|    |-            }
| 146|    |-        }
| 147|    |-        return P[0][values.size() - 1] > sum - P[0][values.size() - 1];
|    | 138|+        for (int i = 0; i < values.size (); ++i)
|    | 139|+          {
|    | 140|+              sum += values[i];
|    | 141|+              for (int m = 0, n = i; n < values.size (); ++m, ++n)
|    | 142|+                {
|    | 143|+                    int a = m + 2 <= values.size () - 1 ? P[m + 2][n] : 0;
|    | 144|+                    int b = m + 1 <= values.size () - 1
|    | 145|+                        && n - 1 >= 0 ? P[m + 1][n - 1] : 0;
|    | 146|+                    int c = n - 2 >= 0 ? P[m][n - 2] : 0;
|    | 147|+                    P[m][n] = max (values[m] + min (a, b),
|    | 148|+                                   values[n] + min (b, c));
|    | 149|+                }
|    | 150|+          }
|    | 151|+        return P[0][values.size () - 1] > sum - P[0][values.size () - 1];
| 148| 152|     }
| 149| 153| 
| 150| 154|     // Time: O(n), Space: O(1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 149| 149| 
| 150| 150|     // Time: O(n), Space: O(1)
| 151| 151|     // Odd / even numbered strategy for even numbered coins
| 152|    |-    bool firstWinEvenCoins(const vector<int>& values) {
|    | 152|+    bool firstWinEvenCoins (const vector < int >&values)
|    | 153|+    {
| 153| 154|         int sum = 0;
| 154| 155|         int odd_sum = 0;
| 155| 156|         int even_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-iii.cpp
|    |++++| /app/C++/coins-in-a-line-iii.cpp
| 153| 153|         int sum = 0;
| 154| 154|         int odd_sum = 0;
| 155| 155|         int even_sum = 0;
| 156|    |-        for (int i = 0; i < values.size(); ++i) {
| 157|    |-            sum += values[i];
| 158|    |-            if (i % 2 == 0) {
| 159|    |-                odd_sum += values[i];
| 160|    |-            } else {
| 161|    |-                even_sum += values[i];
| 162|    |-            }
| 163|    |-        }
|    | 156|+        for (int i = 0; i < values.size (); ++i)
|    | 157|+          {
|    | 158|+              sum += values[i];
|    | 159|+              if (i % 2 == 0)
|    | 160|+                {
|    | 161|+                    odd_sum += values[i];
|    | 162|+                }
|    | 163|+              else
|    | 164|+                {
|    | 165|+                    even_sum += values[i];
|    | 166|+                }
|    | 167|+          }
| 164| 168| 
| 165| 169|         return odd_sum != even_sum;
| 166| 170|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|   1|   1| // Time:  O(k * n)
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param k: An integer
|   8|   9|      * @param prices: Given an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|   8|   8|      * @param prices: Given an integer array
|   9|   9|      * @return: Maximum profit
|  10|  10|      */
|  11|    |-    int maxProfit(int k, vector<int> &prices) {
|    |  11|+    int maxProfit (int k, vector < int >&prices)
|    |  12|+    {
|  12|  13|         // Optimized solution for unlimited transactions.
|  13|    |-        if (k >= prices.size() / 2) {
|  14|    |-            return maxUnlimitedTransactionsProfit(prices);
|  15|    |-        }
|    |  14|+        if (k >= prices.size () / 2)
|    |  15|+          {
|    |  16|+              return maxUnlimitedTransactionsProfit (prices);
|    |  17|+          }
|  16|  18| 
|  17|  19|         // Get max profit at most k transactions.
|  18|  20|         return maxAtMostKTransactionsProfit(prices, k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  15|  15|         }
|  16|  16| 
|  17|  17|         // Get max profit at most k transactions.
|  18|    |-        return maxAtMostKTransactionsProfit(prices, k);
|    |  18|+        return maxAtMostKTransactionsProfit (prices, k);
|  19|  19|     }
|  20|  20| 
|  21|  21|     int maxUnlimitedTransactionsProfit(const vector<int>& prices) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  18|  18|         return maxAtMostKTransactionsProfit(prices, k);
|  19|  19|     }
|  20|  20| 
|  21|    |-    int maxUnlimitedTransactionsProfit(const vector<int>& prices) {
|    |  21|+    int maxUnlimitedTransactionsProfit (const vector < int >&prices)
|    |  22|+    {
|  22|  23|         int profit = 0;
|  23|    |-        for (int i = 0; i < static_cast<int>(prices.size()) - 1; ++i) {
|  24|    |-            profit += max(0, prices[i + 1] - prices[i]);
|  25|    |-        }
|    |  24|+        for (int i = 0; i < static_cast < int >(prices.size ()) - 1; ++i)
|    |  25|+          {
|    |  26|+              profit += max (0, prices[i + 1] - prices[i]);
|    |  27|+          }
|  26|  28|         return profit;
|  27|  29|     }
|  28|  30| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  26|  26|         return profit;
|  27|  27|     }
|  28|  28| 
|  29|    |-    int maxAtMostKTransactionsProfit(const vector<int>& prices, const int k) {
|    |  29|+    int maxAtMostKTransactionsProfit (const vector < int >&prices, const int k)
|    |  30|+    {
|  30|  31|         // max_sell[j] short for max_sell[i][j]
|  31|  32|         // denotes as max profit at most j - 1 buy and sell transactions
|  32|  33|         // and buy the ith prices in the first i prices.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  30|  30|         // max_sell[j] short for max_sell[i][j]
|  31|  31|         // denotes as max profit at most j - 1 buy and sell transactions
|  32|  32|         // and buy the ith prices in the first i prices.
|  33|    |-        vector<int> max_sell(k + 1, INT_MIN);
|    |  33|+        vector < int >max_sell (k + 1, INT_MIN);
|  34|  34| 
|  35|  35|         // max_buy[j] short for max_buy[i][j]
|  36|  36|         // denotes as max profit at most j buy and sell transactions
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  35|  35|         // max_buy[j] short for max_buy[i][j]
|  36|  36|         // denotes as max profit at most j buy and sell transactions
|  37|  37|         // and sell the ith prices in the first i prices.
|  38|    |-        vector<int> max_buy(k + 1, INT_MIN);
|    |  38|+        vector < int >max_buy (k + 1, INT_MIN);
|  39|  39| 
|  40|  40|         max_sell[0] = max_buy[0] = 0;
|  41|  41| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iv.cpp
|  39|  39| 
|  40|  40|         max_sell[0] = max_buy[0] = 0;
|  41|  41| 
|  42|    |-        for (int i = 0; i < prices.size(); ++i) {
|  43|    |-            // Update max profix in [i / 2]  + 1 transactions.
|  44|    |-            for (int j = 1; j <= min(k, i / 2 + 1); ++j) {
|  45|    |-                // Update max profit of j-th buy
|  46|    |-                // by (j-1)-th sell - prices[i].
|  47|    |-                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i]);
|    |  42|+        for (int i = 0; i < prices.size (); ++i)
|    |  43|+          {
|    |  44|+              // Update max profix in [i / 2]  + 1 transactions.
|    |  45|+              for (int j = 1; j <= min (k, i / 2 + 1); ++j)
|    |  46|+                {
|    |  47|+                    // Update max profit of j-th buy
|    |  48|+                    // by (j-1)-th sell - prices[i].
|    |  49|+                    max_buy[j] = max (max_buy[j], max_sell[j - 1] - prices[i]);
|  48|  50| 
|  49|    |-                // Update max profit of jth sell
|  50|    |-                // by max(j-th buy + prices[i], (j-1)-th sell]).
|  51|    |-                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]);
|  52|    |-            }
|  53|    |-        }
|    |  51|+                    // Update max profit of jth sell
|    |  52|+                    // by max(j-th buy + prices[i], (j-1)-th sell]).
|    |  53|+                    max_sell[j] = max (max_sell[j], max_buy[j] + prices[i]);
|    |  54|+                }
|    |  55|+          }
|  54|  56| 
|  55|  57|         return max_sell[k];
|  56|  58|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gray-code.cpp
|    |++++| /app/C++/gray-code.cpp
|   1|   1| // Time:  (2^n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n a number
|   8|   9|      * @return Gray code
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gray-code.cpp
|    |++++| /app/C++/gray-code.cpp
|   7|   7|      * @param n a number
|   8|   8|      * @return Gray code
|   9|   9|      */
|  10|    |-    vector<int> grayCode(int n) {
|  11|    |-        vector<int> result = {0};
|  12|    |-        for (int i = 0; i < n; ++i) {
|  13|    |-            for (int j = result.size() - 1; j >= 0; --j) {
|  14|    |-                result.emplace_back(1 << i | result[j]);
|  15|    |-            }
|  16|    |-        }
|    |  10|+    vector < int >grayCode (int n)
|    |  11|+    {
|    |  12|+        vector < int >result = { 0 };
|    |  13|+        for (int i = 0; i < n; ++i)
|    |  14|+          {
|    |  15|+              for (int j = result.size () - 1; j >= 0; --j)
|    |  16|+                {
|    |  17|+                    result.emplace_back (1 << i | result[j]);
|    |  18|+                }
|    |  19|+          }
|  17|  20|         return result;
|  18|  21|     }
|  19|  22| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gray-code.cpp
|    |++++| /app/C++/gray-code.cpp
|  22|  22| // Space: O(1)
|  23|  23| // Proof of closed form formula could be found here:
|  24|  24| // http://math.stackexchange.com/questions/425894/proof-of-closed-form-formula-to-convert-a-binary-number-to-its-gray-code
|  25|    |-class Solution2 {
|  26|    |-public:
|    |  25|+class Solution2
|    |  26|+{
|    |  27|+  public:
|  27|  28|     /**
|  28|  29|      * @param n a number
|  29|  30|      * @return Gray code
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/gray-code.cpp
|    |++++| /app/C++/gray-code.cpp
|  28|  28|      * @param n a number
|  29|  29|      * @return Gray code
|  30|  30|      */
|  31|    |-    vector<int> grayCode(int n) {
|  32|    |-        vector<int> result;
|  33|    |-        for (int i = 0; i < 1 << n; ++i) {
|  34|    |-            result.emplace_back(i >> 1 ^ i);
|  35|    |-        }
|    |  31|+    vector < int >grayCode (int n)
|    |  32|+    {
|    |  33|+        vector < int >result;
|    |  34|+        for (int i = 0; i < 1 << n; ++i)
|    |  35|+          {
|    |  36|+              result.emplace_back (i >> 1 ^ i);
|    |  37|+          }
|  36|  38|         return result;
|  37|  39|     }
|  38|  40| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class MinStack {
|   5|    |-public:
|   6|    |-    MinStack() {
|    |   4|+class MinStack
|    |   5|+{
|    |   6|+  public:
|    |   7|+    MinStack ()
|    |   8|+    {
|   7|   9|         // do initialization if necessary
|   8|  10|     }
|   9|  11| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|   7|   7|         // do initialization if necessary
|   8|   8|     }
|   9|   9| 
|  10|    |-    void push(int number) {
|  11|    |-        if (elements_.empty()) {
|  12|    |-            elements_.emplace(0);
|  13|    |-            stack_min_ = number;
|  14|    |-        } else {
|  15|    |-            elements_.emplace(static_cast<int64_t>(number) - stack_min_);
|  16|    |-            if (number < stack_min_) {
|  17|    |-                stack_min_ = number; // Update min.
|  18|    |-            }
|  19|    |-        }
|    |  10|+    void push (int number)
|    |  11|+    {
|    |  12|+        if (elements_.empty ())
|    |  13|+          {
|    |  14|+              elements_.emplace (0);
|    |  15|+              stack_min_ = number;
|    |  16|+          }
|    |  17|+        else
|    |  18|+          {
|    |  19|+              elements_.emplace (static_cast < int64_t >
|    |  20|+                                 (number) - stack_min_);
|    |  21|+              if (number < stack_min_)
|    |  22|+                {
|    |  23|+                    stack_min_ = number;    // Update min.
|    |  24|+                }
|    |  25|+          }
|  20|  26|     }
|  21|  27| 
|  22|  28|     int pop() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  19|  19|         }
|  20|  20|     }
|  21|  21| 
|  22|    |-    int pop() {
|  23|    |-        auto diff = elements_.top();
|  24|    |-        elements_.pop();
|  25|    |-        if (diff < 0) {
|  26|    |-            stack_min_ -= diff; // Restore previous min.
|  27|    |-        }
|    |  22|+    int pop ()
|    |  23|+    {
|    |  24|+        auto diff = elements_.top ();
|    |  25|+        elements_.pop ();
|    |  26|+        if (diff < 0)
|    |  27|+          {
|    |  28|+              stack_min_ -= diff;   // Restore previous min.
|    |  29|+          }
|  28|  30|         return stack_min_ + diff;
|  29|  31|     }
|  30|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  28|  28|         return stack_min_ + diff;
|  29|  29|     }
|  30|  30| 
|  31|    |-    int min() {
|    |  31|+    int min ()
|    |  32|+    {
|  32|  33|         return stack_min_;
|  33|  34|     }
|  34|  35| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  32|  32|         return stack_min_;
|  33|  33|     }
|  34|  34| 
|  35|    |-private:
|  36|    |-    stack<int64_t> elements_;
|    |  35|+  private:
|    |  36|+    stack < int64_t > elements_;
|  37|  37|     int stack_min_;
|  38|  38| };
|  39|  39| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  39|  39| 
|  40|  40| // Time:  O(n)
|  41|  41| // Space: O(n)
|  42|    |-class MinStack2 {
|  43|    |-public:
|  44|    |-    MinStack() {
|    |  42|+class MinStack2
|    |  43|+{
|    |  44|+  public:
|    |  45|+    MinStack ()
|    |  46|+    {
|  45|  47|         // do initialization if necessary
|  46|  48|     }
|  47|  49| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  45|  45|         // do initialization if necessary
|  46|  46|     }
|  47|  47| 
|  48|    |-    void push(int number) {
|  49|    |-        if (cached_min_with_count_.empty() || cached_min_with_count_.top().first > number) {
|  50|    |-            cached_min_with_count_.emplace(number, 1);
|  51|    |-        } else if (cached_min_with_count_.top().first == number) {
|  52|    |-            ++cached_min_with_count_.top().second;
|  53|    |-        }
|  54|    |-        elements_.emplace(number);
|    |  48|+    void push (int number)
|    |  49|+    {
|    |  50|+        if (cached_min_with_count_.empty ()
|    |  51|+            || cached_min_with_count_.top ().first > number)
|    |  52|+          {
|    |  53|+              cached_min_with_count_.emplace (number, 1);
|    |  54|+          }
|    |  55|+        else if (cached_min_with_count_.top ().first == number)
|    |  56|+          {
|    |  57|+              ++cached_min_with_count_.top ().second;
|    |  58|+          }
|    |  59|+        elements_.emplace (number);
|  55|  60|     }
|  56|  61| 
|  57|  62|     int pop() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  54|  54|         elements_.emplace(number);
|  55|  55|     }
|  56|  56| 
|  57|    |-    int pop() {
|  58|    |-        if (cached_min_with_count_.top().first == elements_.top()) {
|  59|    |-            if (--cached_min_with_count_.top().second == 0) {
|  60|    |-                cached_min_with_count_.pop();
|  61|    |-            }
|  62|    |-        }
|  63|    |-        auto number = elements_.top();
|  64|    |-        elements_.pop();
|    |  57|+    int pop ()
|    |  58|+    {
|    |  59|+        if (cached_min_with_count_.top ().first == elements_.top ())
|    |  60|+          {
|    |  61|+              if (--cached_min_with_count_.top ().second == 0)
|    |  62|+                {
|    |  63|+                    cached_min_with_count_.pop ();
|    |  64|+                }
|    |  65|+          }
|    |  66|+        auto number = elements_.top ();
|    |  67|+        elements_.pop ();
|  65|  68|         return number;
|  66|  69|     }
|  67|  70| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  65|  65|         return number;
|  66|  66|     }
|  67|  67| 
|  68|    |-    int min() {
|  69|    |-        return cached_min_with_count_.top().first;
|    |  68|+    int min ()
|    |  69|+    {
|    |  70|+        return cached_min_with_count_.top ().first;
|  70|  71|     }
|  71|    |-private:
|  72|    |-    stack<int> elements_;
|  73|    |-    stack<pair<int, int>> cached_min_with_count_;
|    |  72|+  private:
|    |  73|+    stack < int >elements_;
|    |  74|+    stack < pair < int, int >>cached_min_with_count_;
|  74|  75| };
|  75|    |-
|  76|  76| 
|  77|  77| // Time:  O(n)
|  78|  78| // Space: O(n)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  76|  76| 
|  77|  77| // Time:  O(n)
|  78|  78| // Space: O(n)
|  79|    |-class MinStack3 {
|  80|    |-public:
|  81|    |-    MinStack() {
|    |  79|+class MinStack3
|    |  80|+{
|    |  81|+  public:
|    |  82|+    MinStack ()
|    |  83|+    {
|  82|  84|         // do initialization if necessary
|  83|  85|     }
|  84|  86| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  82|  82|         // do initialization if necessary
|  83|  83|     }
|  84|  84| 
|  85|    |-    void push(int number) {
|  86|    |-        if (cached_min_.empty() || cached_min_.top() >= number) {
|  87|    |-            cached_min_.emplace(number);
|  88|    |-        }
|  89|    |-        elements_.emplace(number);
|    |  85|+    void push (int number)
|    |  86|+    {
|    |  87|+        if (cached_min_.empty () || cached_min_.top () >= number)
|    |  88|+          {
|    |  89|+              cached_min_.emplace (number);
|    |  90|+          }
|    |  91|+        elements_.emplace (number);
|  90|  92|     }
|  91|  93| 
|  92|  94|     int pop() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  89|  89|         elements_.emplace(number);
|  90|  90|     }
|  91|  91| 
|  92|    |-    int pop() {
|  93|    |-        if (cached_min_.top() == elements_.top()) {
|  94|    |-            cached_min_.pop();
|  95|    |-        }
|  96|    |-        auto number = elements_.top();
|  97|    |-        elements_.pop();
|    |  92|+    int pop ()
|    |  93|+    {
|    |  94|+        if (cached_min_.top () == elements_.top ())
|    |  95|+          {
|    |  96|+              cached_min_.pop ();
|    |  97|+          }
|    |  98|+        auto number = elements_.top ();
|    |  99|+        elements_.pop ();
|  98| 100|         return number;
|  99| 101|     }
| 100| 102| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/min-stack.cpp
|    |++++| /app/C++/min-stack.cpp
|  98|  98|         return number;
|  99|  99|     }
| 100| 100| 
| 101|    |-    int min() {
| 102|    |-        return cached_min_.top();
|    | 101|+    int min ()
|    | 102|+    {
|    | 103|+        return cached_min_.top ();
| 103| 104|     }
| 104|    |-private:
| 105|    |-    stack<int> elements_;
| 106|    |-    stack<int> cached_min_;
|    | 105|+  private:
|    | 106|+    stack < int >elements_;
|    | 107|+    stack < int >cached_min_;
| 107| 108| };
| 108|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|   1|   1| // Time:  O(n * n!)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers.
|   8|   9|      * @return: A list of permutations.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|   7|   7|      * @param nums: A list of integers.
|   8|   8|      * @return: A list of permutations.
|   9|   9|      */
|  10|    |-    vector<vector<int>> permute(vector<int> nums) {
|  11|    |-        if (nums.empty()) {
|  12|    |-            return {};
|  13|    |-        }
|  14|    |-        vector<vector<int>> result;
|  15|    |-        vector<bool> used(nums.size(), false);
|  16|    |-        vector<int> ans;
|    |  10|+    vector < vector < int >>permute (vector < int >nums)
|    |  11|+    {
|    |  12|+        if (nums.empty ())
|    |  13|+          {
|    |  14|+              return
|    |  15|+              {
|    |  16|+              };
|    |  17|+          }
|    |  18|+        vector < vector < int >>result;
|    |  19|+        vector < bool > used (nums.size (), false);
|    |  20|+        vector < int >ans;
|  17|  21| 
|  18|    |-        sort(nums.begin(), nums.end());
|  19|    |-        permuteHelper(nums, &used, &ans, &result);
|    |  22|+        sort (nums.begin (), nums.end ());
|    |  23|+        permuteHelper (nums, &used, &ans, &result);
|  20|  24|         return result;
|  21|  25|     }
|  22|  26| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|  20|  20|         return result;
|  21|  21|     }
|  22|  22| 
|  23|    |-    void permuteHelper(const vector<int> &A, vector<bool> *used,
|  24|    |-                       vector<int> *ans, vector<vector<int>> *result) {
|  25|    |-        if (ans->size() == A.size()) {
|  26|    |-            result->emplace_back(*ans);
|  27|    |-            return;
|  28|    |-        }
|    |  23|+    void permuteHelper (const vector < int >&A, vector < bool > *used,
|    |  24|+                        vector < int >*ans, vector < vector < int >>*result)
|    |  25|+    {
|    |  26|+        if (ans->size () == A.size ())
|    |  27|+          {
|    |  28|+              result->emplace_back (*ans);
|    |  29|+              return;
|    |  30|+          }
|  29|  31| 
|  30|    |-        for (size_t i = 0; i < A.size(); ++i) {
|  31|    |-            if ((*used)[i]) {
|  32|    |-                continue;
|  33|    |-            }
|  34|    |-            (*used)[i] = true;
|  35|    |-            ans->emplace_back(A[i]);
|  36|    |-            permuteHelper(A, used, ans, result);
|  37|    |-            ans->pop_back();
|  38|    |-            (*used)[i] = false;
|  39|    |-        }
|    |  32|+        for (size_t i = 0; i < A.size (); ++i)
|    |  33|+          {
|    |  34|+              if ((*used)[i])
|    |  35|+                {
|    |  36|+                    continue;
|    |  37|+                }
|    |  38|+              (*used)[i] = true;
|    |  39|+              ans->emplace_back (A[i]);
|    |  40|+              permuteHelper (A, used, ans, result);
|    |  41|+              ans->pop_back ();
|    |  42|+              (*used)[i] = false;
|    |  43|+          }
|  40|  44|     }
|  41|  45| };
|  42|  46| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|  43|  43| // Time:  O(n * n!)
|  44|  44| // Space: O(n)
|  45|  45| // STL solution.
|  46|    |-class Solution2 {
|  47|    |-public:
|    |  46|+class Solution2
|    |  47|+{
|    |  48|+  public:
|  48|  49|     /**
|  49|  50|      * @param nums: A list of integers.
|  50|  51|      * @return: A list of permutations.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|  49|  49|      * @param nums: A list of integers.
|  50|  50|      * @return: A list of permutations.
|  51|  51|      */
|  52|    |-    vector<vector<int>> permute(vector<int> nums) {
|  53|    |-        if (nums.empty()) {
|  54|    |-            return {};
|  55|    |-        }
|  56|    |-        vector<vector<int>> result;
|  57|    |-        sort(nums.begin(), nums.end());
|  58|    |-        do {
|  59|    |-            result.emplace_back(nums);
|  60|    |-        } while (next_permutation(nums.begin(), nums.end()));
|    |  52|+    vector < vector < int >>permute (vector < int >nums)
|    |  53|+    {
|    |  54|+        if (nums.empty ())
|    |  55|+          {
|    |  56|+              return
|    |  57|+              {
|    |  58|+              };
|    |  59|+          }
|    |  60|+        vector < vector < int >>result;
|    |  61|+        sort (nums.begin (), nums.end ());
|    |  62|+        do
|    |  63|+          {
|    |  64|+              result.emplace_back (nums);
|    |  65|+          }
|    |  66|+        while (next_permutation (nums.begin (), nums.end ()));
|  61|  67|         return result;
|  62|  68|     }
|  63|  69| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations.cpp
|    |++++| /app/C++/permutations.cpp
|  61|  61|         return result;
|  62|  62|     }
|  63|  63| };
|  64|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning-ii.cpp
|    |++++| /app/C++/palindrome-partitioning-ii.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s a string
|   8|   9|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning-ii.cpp
|    |++++| /app/C++/palindrome-partitioning-ii.cpp
|   7|   7|      * @param s a string
|   8|   8|      * @return an integer
|   9|   9|      */
|  10|    |-    int minCut(string s) {
|  11|    |-        vector<deque<bool>> is_palindrome(s.size(), deque<bool>(s.size(), false));
|  12|    |-        vector<int> T(s.size() + 1);
|  13|    |-        iota(T.rbegin(), T.rend(), -1);
|  14|    |-        for (int i = s.size() - 1; i >= 0; --i) {
|  15|    |-            for (int j = i; j < s.size(); ++j) {
|  16|    |-                if (s[i] == s[j] && (j - i < 2 || is_palindrome[i + 1][j - 1])) {
|  17|    |-                    is_palindrome[i][j] = true;
|  18|    |-                    T[i] = min(T[i], 1 + T[j + 1]);
|    |  10|+    int minCut (string s)
|    |  11|+    {
|    |  12|+        vector < deque < bool >> is_palindrome (s.size (),
|    |  13|+                                                deque < bool > (s.size (),
|    |  14|+                                                                false));
|    |  15|+        vector < int >T (s.size () + 1);
|    |  16|+          iota (T.rbegin (), T.rend (), -1);
|    |  17|+        for (int i = s.size () - 1; i >= 0; --i)
|    |  18|+          {
|    |  19|+              for (int j = i; j < s.size (); ++j)
|    |  20|+                {
|    |  21|+                    if (s[i] == s[j]
|    |  22|+                        && (j - i < 2 || is_palindrome[i + 1][j - 1]))
|    |  23|+                      {
|    |  24|+                          is_palindrome[i][j] = true;
|    |  25|+                          T[i] = min (T[i], 1 + T[j + 1]);
|    |  26|+                      }
|  19|  27|                 }
|  20|    |-            }
|  21|    |-        }
|    |  28|+          }
|  22|  29|         return T[0];
|  23|  30|     }
|  24|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle-ii.cpp
|    |++++| /app/C++/linked-list-cycle-ii.cpp
|  10|  10|  *     }
|  11|  11|  * }
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param head: The first node of linked list.
|  17|  18|      * @return: The node where the cycle begins.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle-ii.cpp
|    |++++| /app/C++/linked-list-cycle-ii.cpp
|  17|  17|      * @return: The node where the cycle begins.
|  18|  18|      *           if there is no cycle, return null
|  19|  19|      */
|  20|    |-    ListNode *detectCycle(ListNode *head) {
|    |  20|+    ListNode * detectCycle (ListNode * head)
|    |  21|+    {
|  21|  22|         auto slow = head, fast = head;
|  22|  23| 
|  23|  24|         while (fast && fast->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle-ii.cpp
|    |++++| /app/C++/linked-list-cycle-ii.cpp
|  20|  20|     ListNode *detectCycle(ListNode *head) {
|  21|  21|         auto slow = head, fast = head;
|  22|  22| 
|  23|    |-        while (fast && fast->next) {
|  24|    |-            slow = slow->next, fast = fast->next->next;
|  25|    |-            if (slow == fast) {  // There is a cycle.
|  26|    |-                slow = head;
|  27|    |-                // Both pointers advance at the same time.
|  28|    |-                while (slow != fast) {
|  29|    |-                    slow = slow->next, fast = fast->next;
|    |  23|+        while (fast && fast->next)
|    |  24|+          {
|    |  25|+              slow = slow->next, fast = fast->next->next;
|    |  26|+              if (slow == fast)
|    |  27|+                {               // There is a cycle.
|    |  28|+                    slow = head;
|    |  29|+                    // Both pointers advance at the same time.
|    |  30|+                    while (slow != fast)
|    |  31|+                      {
|    |  32|+                          slow = slow->next, fast = fast->next;
|    |  33|+                      }
|    |  34|+                    return slow;    // slow is the begin of cycle.
|  30|  35|                 }
|  31|    |-                return slow;  // slow is the begin of cycle.
|  32|    |-            }
|  33|    |-        }
|  34|    |-        return nullptr;  // No cycle.
|    |  36|+          }
|    |  37|+        return nullptr;         // No cycle.
|  35|  38|     }
|  36|  39| };
|  37|  40| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle-ii.cpp
|    |++++| /app/C++/linked-list-cycle-ii.cpp
|  35|  35|     }
|  36|  36| };
|  37|  37| 
|  38|    |-class Solution2 {
|  39|    |-public:
|  40|    |-    ListNode *detectCycle(ListNode *head) {
|    |  38|+class Solution2
|    |  39|+{
|    |  40|+  public:
|    |  41|+    ListNode * detectCycle (ListNode * head)
|    |  42|+    {
|  41|  43|         auto slow = head, fast = head;
|  42|  44| 
|  43|  45|         // Slow and fast pointer only meet when there is a cycle.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle-ii.cpp
|    |++++| /app/C++/linked-list-cycle-ii.cpp
|  41|  41|         auto slow = head, fast = head;
|  42|  42| 
|  43|  43|         // Slow and fast pointer only meet when there is a cycle.
|  44|    |-        while (fast && fast->next) {
|  45|    |-            slow = slow->next;
|  46|    |-            fast = fast->next->next;
|  47|    |-            if (slow == fast) {
|  48|    |-                // Count length of the cycle.
|  49|    |-                int L = 0;
|  50|    |-                do {
|  51|    |-                    slow = slow->next;
|  52|    |-                    ++L;
|  53|    |-                } while (slow != fast);
|    |  44|+        while (fast && fast->next)
|    |  45|+          {
|    |  46|+              slow = slow->next;
|    |  47|+              fast = fast->next->next;
|    |  48|+              if (slow == fast)
|    |  49|+                {
|    |  50|+                    // Count length of the cycle.
|    |  51|+                    int L = 0;
|    |  52|+                    do
|    |  53|+                      {
|    |  54|+                          slow = slow->next;
|    |  55|+                          ++L;
|    |  56|+                      }
|    |  57|+                    while (slow != fast);
|  54|  58| 
|  55|    |-                // Fast pointer walks L steps ahead.
|  56|    |-                fast = head;
|  57|    |-                while (L--) {
|  58|    |-                    fast = fast->next;
|    |  59|+                    // Fast pointer walks L steps ahead.
|    |  60|+                    fast = head;
|    |  61|+                    while (L--)
|    |  62|+                      {
|    |  63|+                          fast = fast->next;
|    |  64|+                      }
|    |  65|+
|    |  66|+                    // The start of the cycle is the node they meet.
|    |  67|+                    slow = head;
|    |  68|+                    while (slow != fast)
|    |  69|+                      {
|    |  70|+                          slow = slow->next;
|    |  71|+                          fast = fast->next;
|    |  72|+                      }
|    |  73|+
|    |  74|+                    return slow;
|  59|  75|                 }
|  60|    |-
|  61|    |-                // The start of the cycle is the node they meet.
|  62|    |-                slow = head;
|  63|    |-                while (slow != fast) {
|  64|    |-                    slow = slow->next;
|  65|    |-                    fast = fast->next;
|  66|    |-                }
|  67|    |-
|  68|    |-                return slow;
|  69|    |-            }
|  70|    |-        }
|    |  76|+          }
|  71|  77|         return nullptr;
|  72|  78|     }
|  73|  79| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // DP Solution
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param prices: Given an integer array
|   9|  10|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|   8|   8|      * @param prices: Given an integer array
|   9|   9|      * @return: Maximum profit
|  10|  10|      */
|  11|    |-    int maxProfit(vector<int> &prices) {
|  12|    |-        if (prices.empty()) {
|  13|    |-            return 0;
|  14|    |-        }
|    |  11|+    int maxProfit (vector < int >&prices)
|    |  12|+    {
|    |  13|+        if (prices.empty ())
|    |  14|+          {
|    |  15|+              return 0;
|    |  16|+          }
|  15|  17| 
|  16|  18|         int hold1 = INT_MIN, hold2 = INT_MIN;
|  17|  19|         int release1 = INT_MIN, release2 = INT_MIN;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  16|  16|         int hold1 = INT_MIN, hold2 = INT_MIN;
|  17|  17|         int release1 = INT_MIN, release2 = INT_MIN;
|  18|  18| 
|  19|    |-        for (const auto& p : prices) {
|  20|    |-            hold1 = max(hold1, -p);
|  21|    |-            release1 = max(release1, hold1 + p);
|  22|    |-            hold2 = max(hold2, release1 - p);
|  23|    |-            release2 = max(release2, hold2 + p);
|  24|    |-        }
|    |  19|+      for (const auto & p:prices)
|    |  20|+          {
|    |  21|+              hold1 = max (hold1, -p);
|    |  22|+              release1 = max (release1, hold1 + p);
|    |  23|+              hold2 = max (hold2, release1 - p);
|    |  24|+              release2 = max (release2, hold2 + p);
|    |  25|+          }
|  25|  26| 
|  26|  27|         return release2;
|  27|  28|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  28|  28| };
|  29|  29| 
|  30|  30| // Generic Solution
|  31|    |-class Solution2 {
|  32|    |-public:
|    |  31|+class Solution2
|    |  32|+{
|    |  33|+  public:
|  33|  34|     /**
|  34|  35|      * @param prices: Given an integer array
|  35|  36|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  34|  34|      * @param prices: Given an integer array
|  35|  35|      * @return: Maximum profit
|  36|  36|      */
|  37|    |-    int maxProfit(vector<int> &prices) {
|  38|    |-        if (prices.empty()) {
|  39|    |-            return 0;
|  40|    |-        }
|    |  37|+    int maxProfit (vector < int >&prices)
|    |  38|+    {
|    |  39|+        if (prices.empty ())
|    |  40|+          {
|    |  41|+              return 0;
|    |  42|+          }
|  41|  43| 
|  42|  44|         const int k = 2;
|  43|  45| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  42|  42|         const int k = 2;
|  43|  43| 
|  44|  44|         // Optimized solution for unlimited transactions.
|  45|    |-        if (k >= prices.size() / 2) {
|  46|    |-            return maxUnlimitedTransactionsProfit(prices);
|  47|    |-        }
|    |  45|+        if (k >= prices.size () / 2)
|    |  46|+          {
|    |  47|+              return maxUnlimitedTransactionsProfit (prices);
|    |  48|+          }
|  48|  49| 
|  49|  50|         // Get max profit at most k transactions.
|  50|  51|         return maxAtMostKTransactionsProfit(prices, k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  47|  47|         }
|  48|  48| 
|  49|  49|         // Get max profit at most k transactions.
|  50|    |-        return maxAtMostKTransactionsProfit(prices, k);
|    |  50|+        return maxAtMostKTransactionsProfit (prices, k);
|  51|  51|     }
|  52|  52| 
|  53|  53|     int maxUnlimitedTransactionsProfit(vector<int> &prices) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  50|  50|         return maxAtMostKTransactionsProfit(prices, k);
|  51|  51|     }
|  52|  52| 
|  53|    |-    int maxUnlimitedTransactionsProfit(vector<int> &prices) {
|    |  53|+    int maxUnlimitedTransactionsProfit (vector < int >&prices)
|    |  54|+    {
|  54|  55|         int profit = 0;
|  55|    |-        for (int i = 0; i < prices.size() - 1; ++i) {
|  56|    |-            profit += max(0, prices[i + 1] - prices[i]);
|  57|    |-        }
|    |  56|+        for (int i = 0; i < prices.size () - 1; ++i)
|    |  57|+          {
|    |  58|+              profit += max (0, prices[i + 1] - prices[i]);
|    |  59|+          }
|  58|  60|         return profit;
|  59|  61|     }
|  60|  62| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  58|  58|         return profit;
|  59|  59|     }
|  60|  60| 
|  61|    |-    int maxAtMostKTransactionsProfit(vector<int> &prices, int k) {
|    |  61|+    int maxAtMostKTransactionsProfit (vector < int >&prices, int k)
|    |  62|+    {
|  62|  63|         // max_sell[j] short for max_sell[i][j]
|  63|  64|         // denotes as max profit at most j - 1 buy and sell transactions
|  64|  65|         // and buy the ith prices in the first i prices.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  62|  62|         // max_sell[j] short for max_sell[i][j]
|  63|  63|         // denotes as max profit at most j - 1 buy and sell transactions
|  64|  64|         // and buy the ith prices in the first i prices.
|  65|    |-        vector<int> max_sell(k + 1, INT_MIN);
|    |  65|+        vector < int >max_sell (k + 1, INT_MIN);
|  66|  66| 
|  67|  67|         // max_buy[j] short for max_buy[i][j]
|  68|  68|         // denotes as max profit at most j buy and sell transactions
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  67|  67|         // max_buy[j] short for max_buy[i][j]
|  68|  68|         // denotes as max profit at most j buy and sell transactions
|  69|  69|         // and sell the ith prices in the first i prices.
|  70|    |-        vector<int> max_buy(k + 1, INT_MIN);
|    |  70|+        vector < int >max_buy (k + 1, INT_MIN);
|  71|  71| 
|  72|  72|         max_sell[0] = max_buy[0] = 0;
|  73|  73| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-iii.cpp
|  71|  71| 
|  72|  72|         max_sell[0] = max_buy[0] = 0;
|  73|  73| 
|  74|    |-        for (int i = 0; i < prices.size(); ++i) {
|  75|    |-            // Update max profix in [i / 2]  + 1 transactions.
|  76|    |-            for (int j = 1; j <= min(k, i / 2 + 1); ++j) {
|  77|    |-                // Update max profit of j-th buy
|  78|    |-                // by (j-1)-th sell - prices[i].
|  79|    |-                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i]);
|    |  74|+        for (int i = 0; i < prices.size (); ++i)
|    |  75|+          {
|    |  76|+              // Update max profix in [i / 2]  + 1 transactions.
|    |  77|+              for (int j = 1; j <= min (k, i / 2 + 1); ++j)
|    |  78|+                {
|    |  79|+                    // Update max profit of j-th buy
|    |  80|+                    // by (j-1)-th sell - prices[i].
|    |  81|+                    max_buy[j] = max (max_buy[j], max_sell[j - 1] - prices[i]);
|  80|  82| 
|  81|    |-                // Update max profit of jth sell
|  82|    |-                // by max(j-th buy + prices[i], (j-1)-th sell]).
|  83|    |-                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]);
|  84|    |-            }
|  85|    |-        }
|    |  83|+                    // Update max profit of jth sell
|    |  84|+                    // by max(j-th buy + prices[i], (j-1)-th sell]).
|    |  85|+                    max_sell[j] = max (max_sell[j], max_buy[j] + prices[i]);
|    |  86|+                }
|    |  87|+          }
|  86|  88| 
|  87|  89|         return max_sell[k];
|  88|  90|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/roman-to-integer.cpp
|    |++++| /app/C++/roman-to-integer.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s Roman representation
|   8|   9|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/roman-to-integer.cpp
|    |++++| /app/C++/roman-to-integer.cpp
|   7|   7|      * @param s Roman representation
|   8|   8|      * @return an integer
|   9|   9|      */
|  10|    |-    int romanToInt(string& s) {
|  11|    |-        unordered_map<char, int> numeral_map = {{'I',    1}, {'V',   5}, {'X',  10},
|  12|    |-                                                {'L',   50}, {'C', 100}, {'D', 500},
|  13|    |-                                                {'M', 1000}};
|    |  10|+    int romanToInt (string & s)
|    |  11|+    {
|    |  12|+        unordered_map < char, int >numeral_map =
|    |  13|+            { {'I', 1}, {'V', 5}, {'X', 10},
|    |  14|+        {'L', 50}, {'C', 100}, {'D', 500},
|    |  15|+        {'M', 1000}
|    |  16|+        };
|  14|  17|         int decimal = 0;
|  15|    |-        for (int i = 0; i < s.length(); ++i) {
|  16|    |-            if (i > 0 && numeral_map[s[i]] > numeral_map[s[i - 1]]) {
|  17|    |-                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]];
|  18|    |-            } else {
|  19|    |-                decimal += numeral_map[s[i]];
|  20|    |-            }
|  21|    |-        }
|    |  18|+        for (int i = 0; i < s.length (); ++i)
|    |  19|+          {
|    |  20|+              if (i > 0 && numeral_map[s[i]] > numeral_map[s[i - 1]])
|    |  21|+                {
|    |  22|+                    decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]];
|    |  23|+                }
|    |  24|+              else
|    |  25|+                {
|    |  26|+                    decimal += numeral_map[s[i]];
|    |  27|+                }
|    |  28|+          }
|  22|  29|         return decimal;
|  23|  30|     }
|  24|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|   3|   3| // Space: O(1)
|   4|   4| 
|   5|   5| // Heap solution.
|   6|    |-class Solution {
|   7|    |-public:
|    |   6|+class Solution
|    |   7|+{
|    |   8|+  public:
|   8|   9|     /*
|   9|  10|      * @param n: The number n.
|  10|  11|      * @return: The nth prime number as description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|   9|   9|      * @param n: The number n.
|  10|  10|      * @return: The nth prime number as description.
|  11|  11|      */
|  12|    |-    long long nthUglyNumber(int n) {
|    |  12|+    long long nthUglyNumber (int n)
|    |  13|+    {
|  13|  14|         long long ugly_number = 0;
|  14|    |-        priority_queue<long long, vector<long long>, greater<long long>> heap;
|    |  15|+          priority_queue < long long, vector < long long >,
|    |  16|+            greater < long long >>heap;
|  15|  17| 
|  16|    |-        heap.emplace(1);
|  17|    |-        for (int i = 0; i <= n; ++i) {
|  18|    |-            ugly_number = heap.top();
|  19|    |-            heap.pop();
|  20|    |-            if (ugly_number % 3 == 0) {
|  21|    |-                heap.emplace(ugly_number * 3);
|  22|    |-            } else if (ugly_number % 5 == 0) {
|  23|    |-                heap.emplace(ugly_number * 3);
|  24|    |-                heap.emplace(ugly_number * 5);
|  25|    |-            } else {
|  26|    |-                heap.emplace(ugly_number * 3);
|  27|    |-                heap.emplace(ugly_number * 5);
|  28|    |-                heap.emplace(ugly_number * 7);
|  29|    |-            }
|  30|    |-        }
|    |  18|+          heap.emplace (1);
|    |  19|+        for (int i = 0; i <= n; ++i)
|    |  20|+          {
|    |  21|+              ugly_number = heap.top ();
|    |  22|+              heap.pop ();
|    |  23|+              if (ugly_number % 3 == 0)
|    |  24|+                {
|    |  25|+                    heap.emplace (ugly_number * 3);
|    |  26|+                }
|    |  27|+              else if (ugly_number % 5 == 0)
|    |  28|+                {
|    |  29|+                    heap.emplace (ugly_number * 3);
|    |  30|+                    heap.emplace (ugly_number * 5);
|    |  31|+                }
|    |  32|+              else
|    |  33|+                {
|    |  34|+                    heap.emplace (ugly_number * 3);
|    |  35|+                    heap.emplace (ugly_number * 5);
|    |  36|+                    heap.emplace (ugly_number * 7);
|    |  37|+                }
|    |  38|+          }
|  31|  39|         return ugly_number;
|  32|  40|     }
|  33|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|  33|  33| };
|  34|  34| 
|  35|  35| // BST solution.
|  36|    |-class Solution2 {
|  37|    |-public:
|    |  36|+class Solution2
|    |  37|+{
|    |  38|+  public:
|  38|  39|     /*
|  39|  40|      * @param n: The number n.
|  40|  41|      * @return: The nth prime number as description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|  39|  39|      * @param n: The number n.
|  40|  40|      * @return: The nth prime number as description.
|  41|  41|      */
|  42|    |-    long long nthUglyNumber(int n) {
|    |  42|+    long long nthUglyNumber (int n)
|    |  43|+    {
|  43|  44|         long long ugly_number = 0;
|  44|    |-        set<long long> bst;
|    |  45|+          set < long long >bst;
|  45|  46| 
|  46|    |-        bst.emplace(1);
|  47|    |-        for (int i = 0; i <= n; ++i) {
|  48|    |-            ugly_number = *bst.cbegin();
|  49|    |-            bst.erase(bst.cbegin());
|  50|    |-            if (ugly_number % 3 == 0) {
|  51|    |-                bst.emplace(ugly_number * 3);
|  52|    |-            } else if (ugly_number % 5 == 0) {
|  53|    |-                bst.emplace(ugly_number * 3);
|  54|    |-                bst.emplace(ugly_number * 5);
|  55|    |-            } else {
|  56|    |-                bst.emplace(ugly_number * 3);
|  57|    |-                bst.emplace(ugly_number * 5);
|  58|    |-                bst.emplace(ugly_number * 7);
|  59|    |-            }
|  60|    |-        }
|    |  47|+          bst.emplace (1);
|    |  48|+        for (int i = 0; i <= n; ++i)
|    |  49|+          {
|    |  50|+              ugly_number = *bst.cbegin ();
|    |  51|+              bst.erase (bst.cbegin ());
|    |  52|+              if (ugly_number % 3 == 0)
|    |  53|+                {
|    |  54|+                    bst.emplace (ugly_number * 3);
|    |  55|+                }
|    |  56|+              else if (ugly_number % 5 == 0)
|    |  57|+                {
|    |  58|+                    bst.emplace (ugly_number * 3);
|    |  59|+                    bst.emplace (ugly_number * 5);
|    |  60|+                }
|    |  61|+              else
|    |  62|+                {
|    |  63|+                    bst.emplace (ugly_number * 3);
|    |  64|+                    bst.emplace (ugly_number * 5);
|    |  65|+                    bst.emplace (ugly_number * 7);
|    |  66|+                }
|    |  67|+          }
|  61|  68|         return ugly_number;
|  62|  69|     }
|  63|  70| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|  65|  65| // Time:  O(n)
|  66|  66| // Space: O(n)
|  67|  67| // DP solution.
|  68|    |-class Solution3 {
|  69|    |-public:
|    |  68|+class Solution3
|    |  69|+{
|    |  70|+  public:
|  70|  71|     /*
|  71|  72|      * @param n: The number n.
|  72|  73|      * @return: The nth prime number as description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|  71|  71|      * @param n: The number n.
|  72|  72|      * @return: The nth prime number as description.
|  73|  73|      */
|  74|    |-    long long nthUglyNumber(int n) {
|  75|    |-        vector<long long> uglies(n + 1);
|  76|    |-        uglies[0] = 1;
|  77|    |-    
|    |  74|+    long long nthUglyNumber (int n)
|    |  75|+    {
|    |  76|+        vector < long long >uglies (n + 1);
|    |  77|+          uglies[0] = 1;
|    |  78|+
|  78|  79|         long long f3 = 3, f5 = 5, f7 = 7;
|  79|  80|         int idx3 = 0, idx5 = 0, idx7 = 0;
|  80|  81|     
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number-ii.cpp
|    |++++| /app/C++/ugly-number-ii.cpp
|  77|  77|     
|  78|  78|         long long f3 = 3, f5 = 5, f7 = 7;
|  79|  79|         int idx3 = 0, idx5 = 0, idx7 = 0;
|  80|    |-    
|  81|    |-        for (int i = 1; i <= n; ++i) {
|  82|    |-            long long min_val = min(min(f3, f5), f7);
|  83|    |-            uglies[i] = min_val;
|  84|    |-    
|  85|    |-            if (min_val == f3) {
|  86|    |-                f3 = 3 * uglies[++idx3];
|  87|    |-            }
|  88|    |-            if (min_val == f5) {
|  89|    |-                f5 = 5 * uglies[++idx5];
|  90|    |-            }
|  91|    |-            if (min_val == f7) {
|  92|    |-                f7 = 7 * uglies[++idx7];
|  93|    |-            }
|  94|    |-        }
|    |  80|+
|    |  81|+        for (int i = 1; i <= n; ++i)
|    |  82|+          {
|    |  83|+              long long min_val = min (min (f3, f5), f7);
|    |  84|+                uglies[i] = min_val;
|    |  85|+
|    |  86|+              if (min_val == f3)
|    |  87|+                {
|    |  88|+                    f3 = 3 * uglies[++idx3];
|    |  89|+                }
|    |  90|+              if (min_val == f5)
|    |  91|+                {
|    |  92|+                    f5 = 5 * uglies[++idx5];
|    |  93|+                }
|    |  94|+              if (min_val == f7)
|    |  95|+                {
|    |  96|+                    f7 = 7 * uglies[++idx7];
|    |  97|+                }
|    |  98|+          }
|  95|  99| 
|  96| 100|         return uglies[n];
|  97| 101|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-paths.cpp
|    |++++| /app/C++/binary-tree-paths.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root the root of the binary tree
|  20|  21|      * @return all root-to-leaf paths
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-paths.cpp
|    |++++| /app/C++/binary-tree-paths.cpp
|  19|  19|      * @param root the root of the binary tree
|  20|  20|      * @return all root-to-leaf paths
|  21|  21|      */
|  22|    |-    vector<string> binaryTreePaths(TreeNode* root) {
|  23|    |-        vector<string> result;
|  24|    |-        vector<TreeNode *> path;
|  25|    |-        binaryTreePathsRecu(root, &path, &result);
|    |  22|+    vector < string > binaryTreePaths (TreeNode * root)
|    |  23|+    {
|    |  24|+        vector < string > result;
|    |  25|+        vector < TreeNode * >path;
|    |  26|+        binaryTreePathsRecu (root, &path, &result);
|  26|  27|         return result;
|  27|  28|     }
|  28|  29| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-paths.cpp
|    |++++| /app/C++/binary-tree-paths.cpp
|  26|  26|         return result;
|  27|  27|     }
|  28|  28| 
|  29|    |-    void binaryTreePathsRecu(TreeNode *node, vector<TreeNode *> *path,
|  30|    |-                             vector<string> *result) {
|  31|    |-        if (!node) {
|  32|    |-            return;
|  33|    |-        }
|    |  29|+    void binaryTreePathsRecu (TreeNode * node, vector < TreeNode * >*path,
|    |  30|+                              vector < string > *result)
|    |  31|+    {
|    |  32|+        if (!node)
|    |  33|+          {
|    |  34|+              return;
|    |  35|+          }
|  34|  36| 
|  35|    |-        if (!node->left && !node->right) {
|  36|    |-            string ans = "";
|  37|    |-            for (const auto& n : *path) {
|  38|    |-                ans.append(to_string(n->val).append("->"));
|  39|    |-            }
|  40|    |-            result->emplace_back(move(ans.append(to_string(node->val))));
|  41|    |-        }
|    |  37|+        if (!node->left && !node->right)
|    |  38|+          {
|    |  39|+              string ans = "";
|    |  40|+            for (const auto & n:*path)
|    |  41|+                {
|    |  42|+                    ans.append (to_string (n->val).append ("->"));
|    |  43|+                }
|    |  44|+              result->emplace_back (move (ans.append (to_string (node->val))));
|    |  45|+          }
|  42|  46| 
|  43|    |-        if (node->left) {
|  44|    |-            path->emplace_back(node);
|  45|    |-            binaryTreePathsRecu(node->left, path, result);
|  46|    |-            path->pop_back();
|  47|    |-        }
|    |  47|+        if (node->left)
|    |  48|+          {
|    |  49|+              path->emplace_back (node);
|    |  50|+              binaryTreePathsRecu (node->left, path, result);
|    |  51|+              path->pop_back ();
|    |  52|+          }
|  48|  53| 
|  49|    |-        if (node->right) {
|  50|    |-            path->emplace_back(node);
|  51|    |-            binaryTreePathsRecu(node->right, path, result);
|  52|    |-            path->pop_back();
|  53|    |-        }
|    |  54|+        if (node->right)
|    |  55|+          {
|    |  56|+              path->emplace_back (node);
|    |  57|+              binaryTreePathsRecu (node->right, path, result);
|    |  58|+              path->pop_back ();
|    |  59|+          }
|  54|  60|     }
|  55|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Iteration with greedy
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param s: A string
|   9|  10|      * @param p: A string includes "?" and "*"
|  10|  11|      * @return: A boolean
|  11|  12|      */
|  12|    |-    bool isMatch(const char *s, const char *p) {
|    |  13|+    bool isMatch (const char *s, const char *p)
|    |  14|+    {
|  13|  15|         int p_pos = 0, s_pos = 0;
|  14|  16|         int last_s_pos = -1, last_p_pos = -1;
|  15|  17|         const int s_len = strlen(s), p_len = strlen(p);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|  12|  12|     bool isMatch(const char *s, const char *p) {
|  13|  13|         int p_pos = 0, s_pos = 0;
|  14|  14|         int last_s_pos = -1, last_p_pos = -1;
|  15|    |-        const int s_len = strlen(s), p_len = strlen(p);
|  16|    |-        while (s_pos < s_len) {
|  17|    |-            if (p_pos < p_len && (p[p_pos] == s[s_pos] || p[p_pos] == '?')) {
|  18|    |-                // Matched a char.
|  19|    |-                ++s_pos;
|  20|    |-                ++p_pos;
|  21|    |-            } else if (p_pos < p_len && p[p_pos] == '*') {
|  22|    |-                // Matched '*'.
|  23|    |-                ++p_pos;
|  24|    |-                last_s_pos = s_pos;
|  25|    |-                last_p_pos = p_pos;
|  26|    |-            } else if (last_p_pos != -1) {
|  27|    |-                // Rollback to the last position of '*' plus 1.
|  28|    |-                // And try next position of last matched one.
|  29|    |-                ++last_s_pos;
|  30|    |-                s_pos = last_s_pos;
|  31|    |-                p_pos = last_p_pos;
|  32|    |-            } else {
|  33|    |-                // s_pos < s_len && no matched p, no position to retry.
|  34|    |-                return false;
|  35|    |-            }
|  36|    |-        }
|    |  15|+        const int s_len = strlen (s), p_len = strlen (p);
|    |  16|+        while (s_pos < s_len)
|    |  17|+          {
|    |  18|+              if (p_pos < p_len && (p[p_pos] == s[s_pos] || p[p_pos] == '?'))
|    |  19|+                {
|    |  20|+                    // Matched a char.
|    |  21|+                    ++s_pos;
|    |  22|+                    ++p_pos;
|    |  23|+                }
|    |  24|+              else if (p_pos < p_len && p[p_pos] == '*')
|    |  25|+                {
|    |  26|+                    // Matched '*'.
|    |  27|+                    ++p_pos;
|    |  28|+                    last_s_pos = s_pos;
|    |  29|+                    last_p_pos = p_pos;
|    |  30|+                }
|    |  31|+              else if (last_p_pos != -1)
|    |  32|+                {
|    |  33|+                    // Rollback to the last position of '*' plus 1.
|    |  34|+                    // And try next position of last matched one.
|    |  35|+                    ++last_s_pos;
|    |  36|+                    s_pos = last_s_pos;
|    |  37|+                    p_pos = last_p_pos;
|    |  38|+                }
|    |  39|+              else
|    |  40|+                {
|    |  41|+                    // s_pos < s_len && no matched p, no position to retry.
|    |  42|+                    return false;
|    |  43|+                }
|    |  44|+          }
|  37|  45| 
|  38|  46|         // Skip '*' in p.
|  39|  47|         while (p_pos < p_len && p[p_pos] == '*') {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|  36|  36|         }
|  37|  37| 
|  38|  38|         // Skip '*' in p.
|  39|    |-        while (p_pos < p_len && p[p_pos] == '*') {
|  40|    |-            ++p_pos;
|  41|    |-        }
|    |  39|+        while (p_pos < p_len && p[p_pos] == '*')
|    |  40|+          {
|    |  41|+              ++p_pos;
|    |  42|+          }
|  42|  43| 
|  43|  44|         // Check if pattern is all matched.
|  44|  45|         return p_pos == p_len;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|  49|  49| // Space: O(m)
|  50|  50| 
|  51|  51| // DP solution with rolling window
|  52|    |-class Solution2 {
|  53|    |-public:
|    |  52|+class Solution2
|    |  53|+{
|    |  54|+  public:
|  54|  55|     /**
|  55|  56|      * @param s: A string
|  56|  57|      * @param p: A string includes "?" and "*"
|  57|  58|      * @return: A boolean
|  58|  59|      */
|  59|    |-    bool isMatch(const char *s, const char *p) {
|  60|    |-        const size_t s_len = strlen(s);
|  61|    |-        const size_t p_len = strlen(p);
|    |  60|+    bool isMatch (const char *s, const char *p)
|    |  61|+    {
|    |  62|+        const size_t s_len = strlen (s);
|    |  63|+        const size_t p_len = strlen (p);
|  62|  64| 
|  63|  65|         // match[i][j] denotes as:
|  64|  66|         // s[0, i - 1] matches p[0, j - 1] or not.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|  62|  62| 
|  63|  63|         // match[i][j] denotes as:
|  64|  64|         // s[0, i - 1] matches p[0, j - 1] or not.
|  65|    |-        vector<vector<bool>> match(2, vector<bool>(p_len + 1));
|    |  65|+          vector < vector < bool >> match (2, vector < bool > (p_len + 1));
|  66|  66| 
|  67|    |-        match[0][0] = true;
|  68|    |-        for (int i = 1; i <= p_len; ++i) {
|  69|    |-            if (p[i - 1] == '*') {
|  70|    |-                match[0 % 2][i] = match[0 % 2][i - 1];
|  71|    |-            }
|  72|    |-        }
|    |  67|+          match[0][0] = true;
|    |  68|+        for (int i = 1; i <= p_len; ++i)
|    |  69|+          {
|    |  70|+              if (p[i - 1] == '*')
|    |  71|+                {
|    |  72|+                    match[0 % 2][i] = match[0 % 2][i - 1];
|    |  73|+                }
|    |  74|+          }
|  73|  75| 
|  74|    |-        for (int i = 1; i <= s_len; ++i) {
|  75|    |-            match[i % 2][0] = false;
|  76|    |-            for (int j = 1; j <= p_len; ++j) {
|  77|    |-                if (p[j - 1] != '*') {
|  78|    |-                    match[i % 2][j] = match[(i - 1) % 2][j - 1]
|  79|    |-                    && (s[i - 1] == p[j - 1] || p[j - 1] == '?');
|    |  76|+        for (int i = 1; i <= s_len; ++i)
|    |  77|+          {
|    |  78|+              match[i % 2][0] = false;
|    |  79|+              for (int j = 1; j <= p_len; ++j)
|    |  80|+                {
|    |  81|+                    if (p[j - 1] != '*')
|    |  82|+                      {
|    |  83|+                          match[i % 2][j] = match[(i - 1) % 2][j - 1]
|    |  84|+                              && (s[i - 1] == p[j - 1] || p[j - 1] == '?');
|    |  85|+                      }
|    |  86|+                    else
|    |  87|+                      {
|    |  88|+                          match[i % 2][j] = match[i % 2][j - 1]
|    |  89|+                              || match[(i - 1) % 2][j];
|    |  90|+                      }
|  80|  91|                 }
|  81|    |-                else {
|  82|    |-                    match[i % 2][j] = match[i % 2][j - 1] || match[(i - 1) % 2][j];
|  83|    |-                }
|  84|    |-            }
|  85|    |-        }
|    |  92|+          }
|  86|  93|         return match[s_len % 2][p_len];
|  87|  94|     }
|  88|  95| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
|  91|  91| // Space: O(m * n)
|  92|  92| 
|  93|  93| // DP solution
|  94|    |-class Solution3 {
|  95|    |-public:
|    |  94|+class Solution3
|    |  95|+{
|    |  96|+  public:
|  96|  97|     /**
|  97|  98|      * @param s: A string
|  98|  99|      * @param p: A string includes "?" and "*"
|  99| 100|      * @return: A boolean
| 100| 101|      */
| 101|    |-    bool isMatch(const char *s, const char *p) {
| 102|    |-        const size_t s_len = strlen(s);
| 103|    |-        const size_t p_len = strlen(p);
|    | 102|+    bool isMatch (const char *s, const char *p)
|    | 103|+    {
|    | 104|+        const size_t s_len = strlen (s);
|    | 105|+        const size_t p_len = strlen (p);
| 104| 106| 
| 105| 107|         // match[i][j] denotes as:
| 106| 108|         // s[0, i - 1] matches p[0, j - 1] or not.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
| 104| 104| 
| 105| 105|         // match[i][j] denotes as:
| 106| 106|         // s[0, i - 1] matches p[0, j - 1] or not.
| 107|    |-        vector<vector<bool>> match(s_len + 1, vector<bool>(p_len + 1));
|    | 107|+          vector < vector < bool >> match (s_len + 1,
|    | 108|+                                           vector < bool > (p_len + 1));
| 108| 109| 
| 109|    |-        match[0][0] = true;
| 110|    |-        for (int i = 1; i <= p_len; ++i) {
| 111|    |-            if (p[i - 1] == '*') {
| 112|    |-                match[0][i] = match[0][i - 1];
| 113|    |-            }
| 114|    |-        }
|    | 110|+          match[0][0] = true;
|    | 111|+        for (int i = 1; i <= p_len; ++i)
|    | 112|+          {
|    | 113|+              if (p[i - 1] == '*')
|    | 114|+                {
|    | 115|+                    match[0][i] = match[0][i - 1];
|    | 116|+                }
|    | 117|+          }
| 115| 118| 
| 116|    |-        for (int i = 1; i <= s_len; ++i) {
| 117|    |-            match[i][0] = false;
| 118|    |-            for (int j = 1; j <= p_len; ++j) {
| 119|    |-                if (p[j - 1] != '*') {
| 120|    |-                    match[i][j] = match[i - 1][j - 1]
| 121|    |-                    && (s[i - 1] == p[j - 1] || p[j - 1] == '?');
|    | 119|+        for (int i = 1; i <= s_len; ++i)
|    | 120|+          {
|    | 121|+              match[i][0] = false;
|    | 122|+              for (int j = 1; j <= p_len; ++j)
|    | 123|+                {
|    | 124|+                    if (p[j - 1] != '*')
|    | 125|+                      {
|    | 126|+                          match[i][j] = match[i - 1][j - 1]
|    | 127|+                              && (s[i - 1] == p[j - 1] || p[j - 1] == '?');
|    | 128|+                      }
|    | 129|+                    else
|    | 130|+                      {
|    | 131|+                          match[i][j] = match[i][j - 1] || match[i - 1][j];
|    | 132|+                      }
| 122| 133|                 }
| 123|    |-                else {
| 124|    |-                    match[i][j] = match[i][j - 1] || match[i - 1][j];
| 125|    |-                }
| 126|    |-            }
| 127|    |-        }
|    | 134|+          }
| 128| 135|         return match[s_len][p_len];
| 129| 136|     }
| 130| 137| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wildcard-matching.cpp
|    |++++| /app/C++/wildcard-matching.cpp
| 132| 132| // Time:  O(m * n^2)
| 133| 133| // Space: O(m + n)
| 134| 134| // Recursion
| 135|    |-class Solution_TLE {
| 136|    |-public:
|    | 135|+class Solution_TLE
|    | 136|+{
|    | 137|+  public:
| 137| 138|     /**
| 138| 139|      * @param s: A string
| 139| 140|      * @param p: A string includes "?" and "*"
| 140| 141|      * @return: A boolean
| 141| 142|      */
| 142|    |-    bool isMatch(const char *s, const char *p) {
| 143|    |-        if (*s == 0 || *p == 0) {
| 144|    |-            return *s == 0 && *p == 0;
| 145|    |-        }
|    | 143|+    bool isMatch (const char *s, const char *p)
|    | 144|+    {
|    | 145|+        if (*s == 0 || *p == 0)
|    | 146|+          {
|    | 147|+              return *s == 0 && *p == 0;
|    | 148|+          }
| 146| 149| 
| 147|    |-        if (p[0] != '*') {
| 148|    |-            if (p[0] == s[0] || p[0] == '?') {
| 149|    |-                // Matched a char.
| 150|    |-                return isMatch(s + 1, p + 1);
| 151|    |-            } else {
| 152|    |-                return false;
| 153|    |-            }
| 154|    |-        } else {
| 155|    |-            // Try all possible matches with '*' in p.
| 156|    |-            while (*s != 0) {
| 157|    |-                if (isMatch(s, p + 1)) {
| 158|    |-                    return true;
|    | 150|+        if (p[0] != '*')
|    | 151|+          {
|    | 152|+              if (p[0] == s[0] || p[0] == '?')
|    | 153|+                {
|    | 154|+                    // Matched a char.
|    | 155|+                    return isMatch (s + 1, p + 1);
| 159| 156|                 }
| 160|    |-                ++s;
| 161|    |-            }
| 162|    |-            return isMatch(s, p + 1);
| 163|    |-        }
|    | 157|+              else
|    | 158|+                {
|    | 159|+                    return false;
|    | 160|+                }
|    | 161|+          }
|    | 162|+        else
|    | 163|+          {
|    | 164|+              // Try all possible matches with '*' in p.
|    | 165|+              while (*s != 0)
|    | 166|+                {
|    | 167|+                    if (isMatch (s, p + 1))
|    | 168|+                      {
|    | 169|+                          return true;
|    | 170|+                      }
|    | 171|+                    ++s;
|    | 172|+                }
|    | 173|+              return isMatch (s, p + 1);
|    | 174|+          }
| 164| 175|     }
| 165| 176| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack-vi.cpp
|    |++++| /app/C++/backpack-vi.cpp
|   1|   1| // Time:  O(n * t)
|   2|   2| // Space: O(t)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums an integer array and all positive numbers, no duplicates
|   8|   9|      * @param target an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack-vi.cpp
|    |++++| /app/C++/backpack-vi.cpp
|   8|   8|      * @param target an integer
|   9|   9|      * @return an integer
|  10|  10|      */
|  11|    |-    int backPackVI(vector<int>& nums, int target) {
|  12|    |-        vector<int> dp(target + 1);
|  13|    |-        dp[0] = 1;
|  14|    |-        for (int i = 1; i <= target; ++i) {
|  15|    |-            for (const auto& num : nums) {
|  16|    |-                if (i >= num) {
|  17|    |-                    dp[i] += dp[i - num];
|    |  11|+    int backPackVI (vector < int >&nums, int target)
|    |  12|+    {
|    |  13|+        vector < int >dp (target + 1);
|    |  14|+          dp[0] = 1;
|    |  15|+        for (int i = 1; i <= target; ++i)
|    |  16|+          {
|    |  17|+            for (const auto & num:nums)
|    |  18|+                {
|    |  19|+                    if (i >= num)
|    |  20|+                      {
|    |  21|+                          dp[i] += dp[i - num];
|    |  22|+                      }
|  18|  23|                 }
|  19|    |-            }
|  20|    |-        }
|  21|    |-        return dp.back();
|    |  24|+          }
|    |  25|+        return dp.back ();
|  22|  26|     }
|  23|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16| // Morris Traversal.
|  17|    |-class Solution {
|    |  17|+class Solution
|    |  18|+{
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: Postorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: Postorder in vector which contains node values.
|  21|  21|      */
|  22|    |-public:
|  23|    |-    vector<int> postorderTraversal(TreeNode *root) {
|  24|    |-        vector<int> res;
|  25|    |-        TreeNode dummy(INT_MIN);
|  26|    |-        dummy.left = root;
|    |  22|+  public:
|    |  23|+    vector < int >postorderTraversal (TreeNode * root)
|    |  24|+    {
|    |  25|+        vector < int >res;
|    |  26|+        TreeNode dummy (INT_MIN);
|    |  27|+          dummy.left = root;
|  27|  28|         TreeNode *curr = &dummy;
|  28|    |-        while (curr) {
|  29|    |-            if (!curr->left) {
|  30|    |-                curr = curr->right;
|  31|    |-            } else {
|  32|    |-                TreeNode *node = curr->left;
|  33|    |-                while (node->right && node->right != curr) {
|  34|    |-                    node = node->right;
|  35|    |-                }
|  36|    |-                if (!node->right) {
|  37|    |-                    node->right = curr;
|  38|    |-                    curr = curr->left;
|  39|    |-                } else {
|  40|    |-                    vector<int> v = trace_back(curr->left, node);
|  41|    |-                    res.insert(res.end(), v.begin(), v.end());
|  42|    |-                    node->right = nullptr;
|    |  29|+        while (curr)
|    |  30|+          {
|    |  31|+              if (!curr->left)
|    |  32|+                {
|  43|  33|                     curr = curr->right;
|  44|  34|                 }
|  45|  35|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  42|  42|                     node->right = nullptr;
|  43|  43|                     curr = curr->right;
|  44|  44|                 }
|  45|    |-            }
|  46|    |-        }
|    |  45|+              else
|    |  46|+                {
|    |  47|+                    TreeNode *node = curr->left;
|    |  48|+                    while (node->right && node->right != curr)
|    |  49|+                      {
|    |  50|+                          node = node->right;
|    |  51|+                      }
|    |  52|+                    if (!node->right)
|    |  53|+                      {
|    |  54|+                          node->right = curr;
|    |  55|+                          curr = curr->left;
|    |  56|+                      }
|    |  57|+                    else
|    |  58|+                      {
|    |  59|+                          vector < int >v = trace_back (curr->left, node);
|    |  60|+                          res.insert (res.end (), v.begin (), v.end ());
|    |  61|+                          node->right = nullptr;
|    |  62|+                          curr = curr->right;
|    |  63|+                      }
|    |  64|+                }
|    |  65|+          }
|  47|  66|         return res;
|  48|  67|     }
|  49|  68| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  47|  47|         return res;
|  48|  48|     }
|  49|  49| 
|  50|    |-private:
|  51|    |-    vector<int> trace_back(TreeNode *frm, TreeNode *to) {
|  52|    |-        vector<int> res;
|    |  50|+  private:
|    |  51|+    vector < int >trace_back (TreeNode * frm, TreeNode * to)
|    |  52|+    {
|    |  53|+        vector < int >res;
|  53|  54|         TreeNode *curr = frm;
|  54|    |-        while (curr != to) {
|  55|    |-            res.emplace_back(curr->val);
|  56|    |-            curr = curr->right;
|  57|    |-        }
|  58|    |-        res.emplace_back(to->val);
|  59|    |-        reverse(res.begin(), res.end());
|    |  55|+        while (curr != to)
|    |  56|+          {
|    |  57|+              res.emplace_back (curr->val);
|    |  58|+              curr = curr->right;
|    |  59|+          }
|    |  60|+        res.emplace_back (to->val);
|    |  61|+        reverse (res.begin (), res.end ());
|  60|  62|         return res;
|  61|  63|     }
|  62|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  64|  64| // Time:  O(n)
|  65|  65| // Space: O(h)
|  66|  66| // Stack solution.
|  67|    |-class Solution2 {
|    |  67|+class Solution2
|    |  68|+{
|  68|  69|     /**
|  69|  70|      * @param root: The root of binary tree.
|  70|  71|      * @return: Postorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-postorder-traversal.cpp
|    |++++| /app/C++/binary-tree-postorder-traversal.cpp
|  69|  69|      * @param root: The root of binary tree.
|  70|  70|      * @return: Postorder in vector which contains node values.
|  71|  71|      */
|  72|    |-public:
|  73|    |-    vector<int> postorderTraversal(TreeNode *root) {
|  74|    |-        vector<int> res;
|  75|    |-        stack<pair<TreeNode *, bool>> s;
|  76|    |-        s.emplace(root, false);
|  77|    |-        while (!s.empty()) {
|  78|    |-            bool visited;
|  79|    |-            tie(root, visited) = s.top();
|  80|    |-            s.pop();
|  81|    |-            if (root == nullptr) {
|  82|    |-                continue;
|  83|    |-            }
|  84|    |-            if (visited) {
|  85|    |-                res.emplace_back(root->val);
|  86|    |-            } else {
|  87|    |-                s.emplace(root, true);
|  88|    |-                s.emplace(root->right, false);
|  89|    |-                s.emplace(root->left, false);
|  90|    |-            }
|  91|    |-        }
|    |  72|+  public:
|    |  73|+    vector < int >postorderTraversal (TreeNode * root)
|    |  74|+    {
|    |  75|+        vector < int >res;
|    |  76|+          stack < pair < TreeNode *, bool >> s;
|    |  77|+          s.emplace (root, false);
|    |  78|+        while (!s.empty ())
|    |  79|+          {
|    |  80|+              bool visited;
|    |  81|+                tie (root, visited) = s.top ();
|    |  82|+                s.pop ();
|    |  83|+              if (root == nullptr)
|    |  84|+                {
|    |  85|+                    continue;
|    |  86|+                }
|    |  87|+              if (visited)
|    |  88|+                {
|    |  89|+                    res.emplace_back (root->val);
|    |  90|+                }
|    |  91|+              else
|    |  92|+                {
|    |  93|+                    s.emplace (root, true);
|    |  94|+                    s.emplace (root->right, false);
|    |  95|+                    s.emplace (root->left, false);
|    |  96|+                }
|    |  97|+          }
|  92|  98|         return res;
|  93|  99|     }
|  94| 100| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // Iterative solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param digits A digital string
|   9|  10|      * @return all posible letter combinations
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|   8|   8|      * @param digits A digital string
|   9|   9|      * @return all posible letter combinations
|  10|  10|      */
|  11|    |-    vector<string> letterCombinations(string& digits) {
|  12|    |-        if (digits.empty()) {
|  13|    |-            return {};
|  14|    |-        }
|    |  11|+    vector < string > letterCombinations (string & digits)
|    |  12|+    {
|    |  13|+        if (digits.empty ())
|    |  14|+          {
|    |  15|+              return
|    |  16|+              {
|    |  17|+              };
|    |  18|+          }
|  15|  19| 
|  16|    |-        vector<string> result = {""};
|  17|    |-        vector<string> lookup = {"", "", "abc", "def",
|  18|    |-                                 "ghi", "jkl", "mno",
|  19|    |-                                 "pqrs", "tuv", "wxyz"};
|    |  20|+        vector < string > result =
|    |  21|+        {
|    |  22|+        ""};
|    |  23|+        vector < string > lookup =
|    |  24|+        {
|    |  25|+        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
|  20|  26| 
|  21|    |-        for (int i = digits.size() - 1; i >= 0; --i) {
|  22|    |-            const string& choices = lookup[digits[i] - '0'];
|  23|    |-            const int n = result.size(), m = choices.length();
|  24|    |-            for (int j = n; j < m * n; ++j) {
|  25|    |-                result.emplace_back(result[j % n]);
|  26|    |-            }
|  27|    |-            for (int j = 0; j < m * n; ++j) {
|  28|    |-                result[j].insert(result[j].end(), choices[j / n]);
|  29|    |-            }
|  30|    |-        }
|  31|    |-        for (auto& s : result) {
|  32|    |-            reverse(s.begin(), s.end());
|  33|    |-        }
|    |  27|+        for (int i = digits.size () - 1; i >= 0; --i)
|    |  28|+          {
|    |  29|+              const string & choices = lookup[digits[i] - '0'];
|    |  30|+              const int n = result.size (), m = choices.length ();
|    |  31|+              for (int j = n; j < m * n; ++j)
|    |  32|+                {
|    |  33|+                    result.emplace_back (result[j % n]);
|    |  34|+                }
|    |  35|+              for (int j = 0; j < m * n; ++j)
|    |  36|+                {
|    |  37|+                    result[j].insert (result[j].end (), choices[j / n]);
|    |  38|+                }
|    |  39|+          }
|    |  40|+      for (auto & s:result)
|    |  41|+          {
|    |  42|+              reverse (s.begin (), s.end ());
|    |  43|+          }
|  34|  44| 
|  35|  45|         return result;
|  36|  46|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|  39|  39| // Time:  O(n * 4^n)
|  40|  40| // Space: O(n)
|  41|  41| // Recursion solution.
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  42|+class Solution2
|    |  43|+{
|    |  44|+  public:
|  44|  45|     /**
|  45|  46|      * @param digits A digital string
|  46|  47|      * @return all posible letter combinations
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|  45|  45|      * @param digits A digital string
|  46|  46|      * @return all posible letter combinations
|  47|  47|      */
|  48|    |-    vector<string> letterCombinations(string& digits) {
|  49|    |-        if (digits.empty()) {
|  50|    |-            return {};
|  51|    |-        }
|    |  48|+    vector < string > letterCombinations (string & digits)
|    |  49|+    {
|    |  50|+        if (digits.empty ())
|    |  51|+          {
|    |  52|+              return
|    |  53|+              {
|    |  54|+              };
|    |  55|+          }
|  52|  56| 
|  53|    |-        vector<string> result = {};
|  54|    |-        vector<string> lookup = {"", "", "abc", "def",
|  55|    |-                                 "ghi", "jkl", "mno",
|  56|    |-                                 "pqrs", "tuv", "wxyz"};
|    |  57|+        vector < string > result =
|    |  58|+        {
|    |  59|+        };
|    |  60|+        vector < string > lookup =
|    |  61|+        {
|    |  62|+        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
|  57|  63|         string combination;
|  58|  64|         int len = 0;
|  59|  65|         letterCombinationsRecu(digits, lookup, &combination, &len, &result);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|  56|  56|                                  "pqrs", "tuv", "wxyz"};
|  57|  57|         string combination;
|  58|  58|         int len = 0;
|  59|    |-        letterCombinationsRecu(digits, lookup, &combination, &len, &result);
|    |  59|+        letterCombinationsRecu (digits, lookup, &combination, &len, &result);
|  60|  60|         return result;
|  61|  61|     }
|  62|  62| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/letter-combinations-of-a-phone-number.cpp
|    |++++| /app/C++/letter-combinations-of-a-phone-number.cpp
|  60|  60|         return result;
|  61|  61|     }
|  62|  62| 
|  63|    |-    void letterCombinationsRecu(const string& digits, vector<string>& lookup,
|  64|    |-                                string *combination,
|  65|    |-                                int *len, vector<string> *result) {
|  66|    |-       if (*len == digits.size()) {
|  67|    |-            result->emplace_back(*combination);
|  68|    |-        } else {
|  69|    |-            for (const auto& c : lookup[digits[*len] - '0']) {
|  70|    |-                combination->insert(combination->end(), c), ++(*len);
|  71|    |-                letterCombinationsRecu(digits, lookup, combination, len, result);
|  72|    |-                combination->pop_back(), --(*len);
|  73|    |-            }
|  74|    |-        }
|    |  63|+    void letterCombinationsRecu (const string & digits,
|    |  64|+                                 vector < string > &lookup,
|    |  65|+                                 string * combination, int *len,
|    |  66|+                                 vector < string > *result)
|    |  67|+    {
|    |  68|+        if (*len == digits.size ())
|    |  69|+          {
|    |  70|+              result->emplace_back (*combination);
|    |  71|+          }
|    |  72|+        else
|    |  73|+          {
|    |  74|+            for (const auto & c:lookup[digits[*len] - '0'])
|    |  75|+                {
|    |  76|+                    combination->insert (combination->end (), c), ++(*len);
|    |  77|+                    letterCombinationsRecu (digits, lookup, combination, len,
|    |  78|+                                            result);
|    |  79|+                    combination->pop_back (), --(*len);
|    |  80|+                }
|    |  81|+          }
|  75|  82|     }
|  76|  83| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/recover-rotated-sorted-array.cpp
|    |++++| /app/C++/recover-rotated-sorted-array.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|   6|    |-    void recoverRotatedSortedArray(vector<int> &nums) {
|   7|    |-        int i = findMinPoint(nums);
|   8|    |-        reverse(nums.begin(), nums.begin() + i);
|   9|    |-        reverse(nums.begin() + i, nums.end());
|  10|    |-        reverse(nums.begin(), nums.end());
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|    |   7|+    void recoverRotatedSortedArray (vector < int >&nums)
|    |   8|+    {
|    |   9|+        int i = findMinPoint (nums);
|    |  10|+          reverse (nums.begin (), nums.begin () + i);
|    |  11|+          reverse (nums.begin () + i, nums.end ());
|    |  12|+          reverse (nums.begin (), nums.end ());
|  11|  13|     }
|  12|  14| 
|  13|  15| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/recover-rotated-sorted-array.cpp
|    |++++| /app/C++/recover-rotated-sorted-array.cpp
|  10|  10|         reverse(nums.begin(), nums.end());
|  11|  11|     }
|  12|  12| 
|  13|    |-
|  14|    |-    int findMinPoint(vector<int> &num) {
|    |  13|+    int findMinPoint (vector < int >&num)
|    |  14|+    {
|  15|  15|         int left = 0;
|  16|    |-        int right = num.size() - 1;
|    |  16|+        int right = num.size () - 1;
|  17|  17| 
|  18|  18|         // Find min left s.t. num[left] > num[left + 1].
|  19|  19|         while (left < right && num[left] >= num[right]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/recover-rotated-sorted-array.cpp
|    |++++| /app/C++/recover-rotated-sorted-array.cpp
|  16|  16|         int right = num.size() - 1;
|  17|  17| 
|  18|  18|         // Find min left s.t. num[left] > num[left + 1].
|  19|    |-        while (left < right && num[left] >= num[right]) {
|  20|    |-            int mid = left + (right - left) / 2;
|  21|    |-            if (num[mid] < num[left]) {
|  22|    |-                right = mid;
|  23|    |-            } else if (num[mid] > num[left]) {
|  24|    |-                left = mid + 1;
|  25|    |-            } else {
|  26|    |-                ++left;
|  27|    |-            }
|  28|    |-        }
|    |  19|+        while (left < right && num[left] >= num[right])
|    |  20|+          {
|    |  21|+              int mid = left + (right - left) / 2;
|    |  22|+              if (num[mid] < num[left])
|    |  23|+                {
|    |  24|+                    right = mid;
|    |  25|+                }
|    |  26|+              else if (num[mid] > num[left])
|    |  27|+                {
|    |  28|+                    left = mid + 1;
|    |  29|+                }
|    |  30|+              else
|    |  31|+                {
|    |  32|+                    ++left;
|    |  33|+                }
|    |  34|+          }
|  29|  35| 
|  30|  36|         return left;
|  31|  37|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-square.cpp
|    |++++| /app/C++/maximal-square.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: a matrix of 0 and 1
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-square.cpp
|    |++++| /app/C++/maximal-square.cpp
|   7|   7|      * @param matrix: a matrix of 0 and 1
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int maxSquare(vector<vector<int> > &matrix) {
|  11|    |-        if (matrix.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|  14|    |-        const int m = matrix.size(), n = matrix[0].size();
|  15|    |-        vector<vector<int>> size(2, vector<int>(n, 0));
|    |  10|+    int maxSquare (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        if (matrix.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|    |  16|+        const int m = matrix.size (), n = matrix[0].size ();
|    |  17|+        vector < vector < int >>size (2, vector < int >(n, 0));
|  16|  18|         int max_size = 0;
|  17|  19| 
|  18|  20|         for (int j = 0; j < n; ++j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-square.cpp
|    |++++| /app/C++/maximal-square.cpp
|  15|  15|         vector<vector<int>> size(2, vector<int>(n, 0));
|  16|  16|         int max_size = 0;
|  17|  17| 
|  18|    |-        for (int j = 0; j < n; ++j) {
|  19|    |-            size[0][j] = matrix[0][j];
|  20|    |-            max_size = max(max_size, size[0][j]);
|  21|    |-        }
|  22|    |-        for (int i = 1; i < m; ++i) {
|  23|    |-            size[i % 2][0] = matrix[i][0];
|  24|    |-            for (int j = 1; j < n; ++j) {
|  25|    |-                if (matrix[i][j] == 1) {
|  26|    |-                    size[i % 2][j] = min(size[i % 2][j - 1], 
|  27|    |-                                         min(size[(i - 1) % 2][j], 
|  28|    |-                                             size[(i - 1) % 2][j - 1])) + 1;
|  29|    |-                    max_size = max(max_size, size[i % 2][j]);
|  30|    |-                } else {
|  31|    |-                    size[i % 2][j] = 0;
|    |  18|+        for (int j = 0; j < n; ++j)
|    |  19|+          {
|    |  20|+              size[0][j] = matrix[0][j];
|    |  21|+              max_size = max (max_size, size[0][j]);
|    |  22|+          }
|    |  23|+        for (int i = 1; i < m; ++i)
|    |  24|+          {
|    |  25|+              size[i % 2][0] = matrix[i][0];
|    |  26|+              for (int j = 1; j < n; ++j)
|    |  27|+                {
|    |  28|+                    if (matrix[i][j] == 1)
|    |  29|+                      {
|    |  30|+                          size[i % 2][j] = min (size[i % 2][j - 1],
|    |  31|+                                                min (size[(i - 1) % 2][j],
|    |  32|+                                                     size[(i - 1) % 2][j -
|    |  33|+                                                                       1])) +
|    |  34|+                              1;
|    |  35|+                          max_size = max (max_size, size[i % 2][j]);
|    |  36|+                      }
|    |  37|+                    else
|    |  38|+                      {
|    |  39|+                          size[i % 2][j] = 0;
|    |  40|+                      }
|  32|  41|                 }
|  33|    |-            }
|  34|    |-        }
|    |  42|+          }
|  35|  43|         return max_size * max_size;
|  36|  44|     }
|  37|  45| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: An array of integers
|   8|   9|      * @return: An array of integers that's next permuation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|   7|   7|      * @param nums: An array of integers
|   8|   8|      * @return: An array of integers that's next permuation
|   9|   9|      */
|  10|    |-    vector<int> nextPermuation(vector<int> &nums) {
|    |  10|+    vector < int >nextPermuation (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int k = -1, l = 0;
|  12|  13| 
|  13|  14|         // Find the last index k before the decreasing sequence.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|  11|  11|         int k = -1, l = 0;
|  12|  12| 
|  13|  13|         // Find the last index k before the decreasing sequence.
|  14|    |-        for (int i = 0; i < nums.size() - 1; ++i) {
|  15|    |-            if (nums[i] < nums[i + 1]) {
|  16|    |-                k = i;
|  17|    |-            }
|  18|    |-        }
|    |  14|+        for (int i = 0; i < nums.size () - 1; ++i)
|    |  15|+          {
|    |  16|+              if (nums[i] < nums[i + 1])
|    |  17|+                {
|    |  18|+                    k = i;
|    |  19|+                }
|    |  20|+          }
|  19|  21| 
|  20|    |-        if (k >= 0) {
|  21|    |-            // Find the smallest number which is larger than the value of the index k,
|  22|    |-            // and swap the values.
|  23|    |-            for (int i = k + 1; i < nums.size(); ++i) {
|  24|    |-                if (nums[i] > nums[k]) {
|  25|    |-                    l = i;
|    |  22|+        if (k >= 0)
|    |  23|+          {
|    |  24|+              // Find the smallest number which is larger than the value of the index k,
|    |  25|+              // and swap the values.
|    |  26|+              for (int i = k + 1; i < nums.size (); ++i)
|    |  27|+                {
|    |  28|+                    if (nums[i] > nums[k])
|    |  29|+                      {
|    |  30|+                          l = i;
|    |  31|+                      }
|  26|  32|                 }
|  27|    |-            }
|  28|    |-            swap(nums[k], nums[l]);
|  29|    |-        }
|    |  33|+              swap (nums[k], nums[l]);
|    |  34|+          }
|  30|  35| 
|  31|  36|         // Reverse the sequence after the index k.
|  32|  37|         reverse(nums.begin() + k + 1, nums.end());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Reverse the sequence after the index k.
|  32|    |-        reverse(nums.begin() + k + 1, nums.end());
|    |  32|+        reverse (nums.begin () + k + 1, nums.end ());
|  33|  33| 
|  34|  34|         return nums;
|  35|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|  35|  35|     }
|  36|  36| };
|  37|  37| 
|  38|    |-class Solution2 {
|  39|    |-public:
|    |  38|+class Solution2
|    |  39|+{
|    |  40|+  public:
|  40|  41|     /**
|  41|  42|      * @param nums: An array of integers
|  42|  43|      * @return: An array of integers that's next permuation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation.cpp
|    |++++| /app/C++/next-permutation.cpp
|  41|  41|      * @param nums: An array of integers
|  42|  42|      * @return: An array of integers that's next permuation
|  43|  43|      */
|  44|    |-    vector<int> nextPermuation(vector<int> &nums) {
|  45|    |-        next_permutation(nums.begin(), nums.end());
|    |  44|+    vector < int >nextPermuation (vector < int >&nums)
|    |  45|+    {
|    |  46|+        next_permutation (nums.begin (), nums.end ());
|  46|  47|         return nums;
|  47|  48|     }
|  48|  49| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/identical-binary-tree.cpp
|    |++++| /app/C++/identical-binary-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @aaram a, b, the root of binary trees.
|  20|  21|      * @return true if they are identical, or false.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/identical-binary-tree.cpp
|    |++++| /app/C++/identical-binary-tree.cpp
|  19|  19|      * @aaram a, b, the root of binary trees.
|  20|  20|      * @return true if they are identical, or false.
|  21|  21|      */
|  22|    |-    bool isIdentical(TreeNode* a, TreeNode* b) {
|  23|    |-        if (!a && !b) {
|  24|    |-            return true;
|  25|    |-        } 
|  26|    |-        if (a && b) {
|  27|    |-            return a->val == b->val &&
|  28|    |-                   isIdentical(a->left, b->left) &&
|  29|    |-                   isIdentical(a->right, b->right);
|  30|    |-        }
|    |  22|+    bool isIdentical (TreeNode * a, TreeNode * b)
|    |  23|+    {
|    |  24|+        if (!a && !b)
|    |  25|+          {
|    |  26|+              return true;
|    |  27|+          }
|    |  28|+        if (a && b)
|    |  29|+          {
|    |  30|+              return a->val == b->val &&
|    |  31|+                  isIdentical (a->left, b->left) &&
|    |  32|+                  isIdentical (a->right, b->right);
|    |  33|+          }
|  31|  34|         return false;
|  32|  35|     }
|  33|  36| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: a vector of integers
|   8|   9|      * @return: the maximum difference
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|   7|   7|      * @param nums: a vector of integers
|   8|   8|      * @return: the maximum difference
|   9|   9|      */
|  10|    |-    struct Bucket {
|  11|    |-        int max = numeric_limits<int>::min();
|  12|    |-        int min = numeric_limits<int>::max();
|    |  10|+    struct Bucket
|    |  11|+    {
|    |  12|+        int max = numeric_limits < int >::min ();
|    |  13|+        int min = numeric_limits < int >::max ();
|  13|  14|     };
|  14|  15| 
|  15|  16|     int maximumGap(vector<int> nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  12|  12|         int min = numeric_limits<int>::max();
|  13|  13|     };
|  14|  14| 
|  15|    |-    int maximumGap(vector<int> nums) {
|  16|    |-        if (nums.size() < 2) {
|  17|    |-            return 0;
|  18|    |-        }
|    |  15|+    int maximumGap (vector < int >nums)
|    |  16|+    {
|    |  17|+        if (nums.size () < 2)
|    |  18|+          {
|    |  19|+              return 0;
|    |  20|+          }
|  19|  21| 
|  20|  22|         // Init bucket.
|  21|  23|         int max_val = *max_element(nums.cbegin(), nums.cend());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  18|  18|         }
|  19|  19| 
|  20|  20|         // Init bucket.
|  21|    |-        int max_val = *max_element(nums.cbegin(), nums.cend());
|  22|    |-        int min_val = *min_element(nums.cbegin(), nums.cend());
|  23|    |-        int gap = max(1, static_cast<int>((max_val - min_val) /
|  24|    |-                                          (nums.size() - 1)));
|  25|    |-        vector<Bucket> buckets((max_val - min_val) / gap + 1);
|    |  21|+        int max_val = *max_element (nums.cbegin (), nums.cend ());
|    |  22|+        int min_val = *min_element (nums.cbegin (), nums.cend ());
|    |  23|+        int gap = max (1, static_cast < int >((max_val - min_val) /
|    |  24|+                                              (nums.size () - 1)));
|    |  25|+        vector < Bucket > buckets ((max_val - min_val) / gap + 1);
|  26|  26| 
|  27|  27|         // Find the bucket where the n should be put.
|  28|  28|         for (const auto& n : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  25|  25|         vector<Bucket> buckets((max_val - min_val) / gap + 1);
|  26|  26| 
|  27|  27|         // Find the bucket where the n should be put.
|  28|    |-        for (const auto& n : nums) {
|  29|    |-            // min_val / max_val is in the first / last bucket.
|  30|    |-            if (n == max_val || n == min_val) {
|  31|    |-                continue;
|  32|    |-            }
|  33|    |-            int i = (n - min_val) / gap;
|  34|    |-            buckets[i].min = min(buckets[i].min, n);
|  35|    |-            buckets[i].max = max(buckets[i].max, n);
|  36|    |-        }
|    |  28|+      for (const auto & n:nums)
|    |  29|+          {
|    |  30|+              // min_val / max_val is in the first / last bucket.
|    |  31|+              if (n == max_val || n == min_val)
|    |  32|+                {
|    |  33|+                    continue;
|    |  34|+                }
|    |  35|+              int i = (n - min_val) / gap;
|    |  36|+              buckets[i].min = min (buckets[i].min, n);
|    |  37|+              buckets[i].max = max (buckets[i].max, n);
|    |  38|+          }
|  37|  39| 
|  38|  40|         // Maximum gap should not be smaller than any gap inside the bucket.
|  39|  41|         // i.e. max_gap >= (max_val - min_val) / (count - 1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  39|  39|         // i.e. max_gap >= (max_val - min_val) / (count - 1)
|  40|  40|         // Thus, only count each bucket gap between the first and the last bucket.
|  41|  41|         int max_gap = 0, pre_bucket_max = min_val;
|  42|    |-        for (const auto& bucket : buckets) {
|  43|    |-            if (bucket.min != numeric_limits<int>::max()) {
|  44|    |-                max_gap = max(max_gap, bucket.min - pre_bucket_max);
|  45|    |-                pre_bucket_max = bucket.max;
|  46|    |-            }
|  47|    |-        }
|    |  42|+      for (const auto & bucket:buckets)
|    |  43|+          {
|    |  44|+              if (bucket.min != numeric_limits < int >::max ())
|    |  45|+                {
|    |  46|+                    max_gap = max (max_gap, bucket.min - pre_bucket_max);
|    |  47|+                    pre_bucket_max = bucket.max;
|    |  48|+                }
|    |  49|+          }
|  48|  50|         // Count the last bucket.
|  49|    |-        max_gap = max(max_gap, max_val - pre_bucket_max);
|    |  51|+        max_gap = max (max_gap, max_val - pre_bucket_max);
|  50|  52| 
|  51|  53|         return max_gap;
|  52|  54|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  54|  54| 
|  55|  55| // Time:  O(nlogn)
|  56|  56| // Space: O(n)
|  57|    |-class Solution2 {
|  58|    |-public:
|    |  57|+class Solution2
|    |  58|+{
|    |  59|+  public:
|  59|  60|     /**
|  60|  61|      * @param nums: a vector of integers
|  61|  62|      * @return: the maximum difference
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  60|  60|      * @param nums: a vector of integers
|  61|  61|      * @return: the maximum difference
|  62|  62|      */
|  63|    |-    int maximumGap(vector<int> nums) {
|  64|    |-        if (nums.size() < 2) {
|  65|    |-            return 0;
|  66|    |-        }
|    |  63|+    int maximumGap (vector < int >nums)
|    |  64|+    {
|    |  65|+        if (nums.size () < 2)
|    |  66|+          {
|    |  67|+              return 0;
|    |  68|+          }
|  67|  69| 
|  68|  70|         // Init bucket.
|  69|  71|         int max_val = *max_element(nums.cbegin(), nums.cend());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  66|  66|         }
|  67|  67| 
|  68|  68|         // Init bucket.
|  69|    |-        int max_val = *max_element(nums.cbegin(), nums.cend());
|  70|    |-        int min_val = *min_element(nums.cbegin(), nums.cend());
|  71|    |-        int gap = max(1, static_cast<int>((max_val - min_val) /
|  72|    |-                                          (nums.size() - 1)));
|  73|    |-        map<int, array<int, 2>> bucket;
|  74|    |-        using ValueType = enum {MIN, MAX};
|    |  69|+        int max_val = *max_element (nums.cbegin (), nums.cend ());
|    |  70|+        int min_val = *min_element (nums.cbegin (), nums.cend ());
|    |  71|+        int gap = max (1, static_cast < int >((max_val - min_val) /
|    |  72|+                                              (nums.size () - 1)));
|    |  73|+        map < int, array < int, 2 >> bucket;
|    |  74|+        using ValueType = enum
|    |  75|+        { MIN, MAX };
|  75|  76| 
|  76|  77|         // Find the bucket where the n should be put.
|  77|  78|         for (const auto& n : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  74|  74|         using ValueType = enum {MIN, MAX};
|  75|  75| 
|  76|  76|         // Find the bucket where the n should be put.
|  77|    |-        for (const auto& n : nums) {
|  78|    |-            // min_val / max_val is in the first / last bucket.
|  79|    |-            if (n == max_val || n == min_val) {
|  80|    |-                continue ;    
|  81|    |-            }
|  82|    |-            int i = (n - min_val) / gap;
|  83|    |-            bucket[i][MIN] = min(!bucket[i][MIN] ? INT_MAX : 
|  84|    |-                                                   bucket[i][MIN], n);
|  85|    |-            bucket[i][MAX] = max(!bucket[i][MAX] ? INT_MIN :
|  86|    |-                                                   bucket[i][MAX], n);
|  87|    |-        }
|    |  77|+      for (const auto & n:nums)
|    |  78|+          {
|    |  79|+              // min_val / max_val is in the first / last bucket.
|    |  80|+              if (n == max_val || n == min_val)
|    |  81|+                {
|    |  82|+                    continue;
|    |  83|+                }
|    |  84|+              int i = (n - min_val) / gap;
|    |  85|+              bucket[i][MIN] = min (!bucket[i][MIN] ? INT_MAX :
|    |  86|+                                    bucket[i][MIN], n);
|    |  87|+              bucket[i][MAX] = max (!bucket[i][MAX] ? INT_MIN :
|    |  88|+                                    bucket[i][MAX], n);
|    |  89|+          }
|  88|  90| 
|  89|  91|         // Count each bucket gap between the first and the last bucket.
|  90|  92|         int max_gap = 0, pre_bucket_max = min_val;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-gap.cpp
|    |++++| /app/C++/maximum-gap.cpp
|  88|  88| 
|  89|  89|         // Count each bucket gap between the first and the last bucket.
|  90|  90|         int max_gap = 0, pre_bucket_max = min_val;
|  91|    |-        for (auto& kvp : bucket) {
|  92|    |-            max_gap = max(max_gap, kvp.second[MIN] - pre_bucket_max);
|  93|    |-            pre_bucket_max = (kvp.second)[MAX];
|  94|    |-        }
|    |  91|+      for (auto & kvp:bucket)
|    |  92|+          {
|    |  93|+              max_gap = max (max_gap, kvp.second[MIN] - pre_bucket_max);
|    |  94|+              pre_bucket_max = (kvp.second)[MAX];
|    |  95|+          }
|  95|  96|         // Count the last bucket.
|  96|    |-        max_gap = max(max_gap, max_val - pre_bucket_max);
|    |  97|+        max_gap = max (max_gap, max_val - pre_bucket_max);
|  97|  98| 
|  98|  99|         return max_gap;
|  99| 100|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-consecutive-sequence.cpp
|    |++++| /app/C++/longest-consecutive-sequence.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-consecutive-sequence.cpp
|    |++++| /app/C++/longest-consecutive-sequence.cpp
|   7|   7|      * @param nums: A list of integers
|   8|   8|      * @return an integer
|   9|   9|      */
|  10|    |-    int longestConsecutive(vector<int> &num) {
|    |  10|+    int longestConsecutive (vector < int >&num)
|    |  11|+    {
|  11|  12|         // unprocessed_entries records the existence of each entry in num.
|  12|    |-        unordered_set<int> unprocessed_entries;
|  13|    |-        for (const auto& a : num) {
|  14|    |-            unprocessed_entries.emplace(a);
|  15|    |-        }
|    |  13|+        unordered_set < int >unprocessed_entries;
|    |  14|+        for (const auto & a:num)
|    |  15|+          {
|    |  16|+              unprocessed_entries.emplace (a);
|    |  17|+          }
|  16|  18| 
|  17|  19|         int max_interval_size = 0;
|  18|  20|         while (!unprocessed_entries.empty()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-consecutive-sequence.cpp
|    |++++| /app/C++/longest-consecutive-sequence.cpp
|  15|  15|         }
|  16|  16| 
|  17|  17|         int max_interval_size = 0;
|  18|    |-        while (!unprocessed_entries.empty()) {
|  19|    |-            int a = *unprocessed_entries.begin();
|  20|    |-            unprocessed_entries.erase(a);
|    |  18|+        while (!unprocessed_entries.empty ())
|    |  19|+          {
|    |  20|+              int a = *unprocessed_entries.begin ();
|    |  21|+              unprocessed_entries.erase (a);
|  21|  22| 
|  22|    |-            // Finds the lower bound of the largest range containing a.
|  23|    |-            int lower_bound = a - 1;
|  24|    |-            while (unprocessed_entries.count(lower_bound)) {
|  25|    |-                unprocessed_entries.erase(lower_bound);
|  26|    |-                --lower_bound;
|  27|    |-            }
|    |  23|+              // Finds the lower bound of the largest range containing a.
|    |  24|+              int lower_bound = a - 1;
|    |  25|+              while (unprocessed_entries.count (lower_bound))
|    |  26|+                {
|    |  27|+                    unprocessed_entries.erase (lower_bound);
|    |  28|+                    --lower_bound;
|    |  29|+                }
|  28|  30| 
|  29|    |-            // Finds the upper bound of the largest range containing a.
|  30|    |-            int upper_bound = a + 1;
|  31|    |-            while (unprocessed_entries.count(upper_bound)) {
|  32|    |-                unprocessed_entries.erase(upper_bound);
|  33|    |-                ++upper_bound;
|  34|    |-            }
|  35|    |-            max_interval_size =
|  36|    |-            max(max_interval_size, upper_bound - lower_bound - 1);
|  37|    |-        }
|    |  31|+              // Finds the upper bound of the largest range containing a.
|    |  32|+              int upper_bound = a + 1;
|    |  33|+              while (unprocessed_entries.count (upper_bound))
|    |  34|+                {
|    |  35|+                    unprocessed_entries.erase (upper_bound);
|    |  36|+                    ++upper_bound;
|    |  37|+                }
|    |  38|+              max_interval_size =
|    |  39|+                  max (max_interval_size, upper_bound - lower_bound - 1);
|    |  40|+          }
|  38|  41|         return max_interval_size;
|  39|  42|     }
|  40|  43| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack-ii.cpp
|    |++++| /app/C++/backpack-ii.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(m)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param m: An integer m denotes the size of a backpack
|   8|   9|      * @param A & V: Given n items with size A[i] and value V[i]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack-ii.cpp
|    |++++| /app/C++/backpack-ii.cpp
|   8|   8|      * @param A & V: Given n items with size A[i] and value V[i]
|   9|   9|      * @return: The maximum value
|  10|  10|      */
|  11|    |-    int backPackII(int m, vector<int> A, vector<int> V) {
|    |  11|+    int backPackII (int m, vector < int >A, vector < int >V)
|    |  12|+    {
|  12|  13|         // table[i][j] denotes max_value of using the first i elements
|  13|  14|         // to fulfill size j.
|  14|  15|         vector<vector<int>> table(2, vector<int>(m + 1, INT_MIN));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/backpack-ii.cpp
|    |++++| /app/C++/backpack-ii.cpp
|  11|  11|     int backPackII(int m, vector<int> A, vector<int> V) {
|  12|  12|         // table[i][j] denotes max_value of using the first i elements
|  13|  13|         // to fulfill size j.
|  14|    |-        vector<vector<int>> table(2, vector<int>(m + 1, INT_MIN));
|    |  14|+        vector < vector < int >>table (2, vector < int >(m + 1, INT_MIN));
|  15|  15|         int max_value = 0;
|  16|    |-        table[0][0] = 0;
|    |  16|+          table[0][0] = 0;
|  17|  17| 
|  18|    |-        for (int i = 1; i <= A.size(); ++i) {
|  19|    |-            table[i % 2][0] = 0;
|  20|    |-            for (int j = 1; j <= m; ++j) {
|  21|    |-                // If first i - 1 elements could fulfill the backpack, then
|  22|    |-                // first i elements would also do.
|  23|    |-                table[i % 2][j] = table[(i - 1) % 2][j];
|    |  18|+        for (int i = 1; i <= A.size (); ++i)
|    |  19|+          {
|    |  20|+              table[i % 2][0] = 0;
|    |  21|+              for (int j = 1; j <= m; ++j)
|    |  22|+                {
|    |  23|+                    // If first i - 1 elements could fulfill the backpack, then
|    |  24|+                    // first i elements would also do.
|    |  25|+                    table[i % 2][j] = table[(i - 1) % 2][j];
|  24|  26| 
|  25|    |-                // Using the ith element to fulfill the backpack.
|  26|    |-                if (j >= A[i - 1] && table[(i - 1) % 2][j - A[i - 1]] >= 0) {
|  27|    |-                    table[i % 2][j] = max(table[i % 2][j],
|  28|    |-                                          table[(i - 1) % 2][j - A[i - 1]] + V[i - 1]);
|    |  27|+                    // Using the ith element to fulfill the backpack.
|    |  28|+                    if (j >= A[i - 1] && table[(i - 1) % 2][j - A[i - 1]] >= 0)
|    |  29|+                      {
|    |  30|+                          table[i % 2][j] = max (table[i % 2][j],
|    |  31|+                                                 table[(i - 1) % 2][j -
|    |  32|+                                                                    A[i - 1]] +
|    |  33|+                                                 V[i - 1]);
|    |  34|+                      }
|    |  35|+
|    |  36|+                    // If it fulfulls size j, update max size.
|    |  37|+                    if (table[i % 2][j] >= 0)
|    |  38|+                      {
|    |  39|+                          max_value = max (max_value, table[i % 2][j]);
|    |  40|+                      }
|  29|  41|                 }
|  30|    |-
|  31|    |-                // If it fulfulls size j, update max size.
|  32|    |-                if (table[i % 2][j] >= 0) {
|  33|    |-                    max_value = max(max_value, table[i % 2][j]);
|  34|    |-                }
|  35|    |-            }
|  36|    |-        }
|    |  42|+          }
|  37|  43|         return max_value;
|  38|  44|     }
|  39|  45| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number.cpp
|    |++++| /app/C++/single-number.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|   6|    |-	/**
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|    |   7|+    /**
|   7|   8| 	 * @param A: Array of integers.
|   8|   9| 	 * return: The single number.
|   9|  10| 	 */
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number.cpp
|    |++++| /app/C++/single-number.cpp
|   7|   7| 	 * @param A: Array of integers.
|   8|   8| 	 * return: The single number.
|   9|   9| 	 */
|  10|    |-    int singleNumber(vector<int> &A) {
|  11|    |-        return accumulate(A.cbegin(), A.cend(), 0, std::bit_xor<int>());
|    |  10|+    int singleNumber (vector < int >&A)
|    |  11|+    {
|    |  12|+        return accumulate (A.cbegin (), A.cend (), 0, std::bit_xor < int >());
|  12|  13|     }
|  13|  14| };
|  14|  15| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number.cpp
|    |++++| /app/C++/single-number.cpp
|  12|  12|     }
|  13|  13| };
|  14|  14| 
|  15|    |-class Solution2 {
|  16|    |-public:
|    |  15|+class Solution2
|    |  16|+{
|    |  17|+  public:
|  17|  18|     /**
|  18|  19|      * @param A: Array of integers.
|  19|  20|      * return: The single number.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number.cpp
|    |++++| /app/C++/single-number.cpp
|  18|  18|      * @param A: Array of integers.
|  19|  19|      * return: The single number.
|  20|  20|      */
|  21|    |-    int singleNumber(vector<int> &A) {
|    |  21|+    int singleNumber (vector < int >&A)
|    |  22|+    {
|  22|  23|         int single = 0;
|  23|    |-        for (const auto& i : A) {
|  24|    |-            single ^= i;
|  25|    |-        }
|    |  24|+        for (const auto & i:A)
|    |  25|+          {
|    |  26|+              single ^= i;
|    |  27|+          }
|  26|  28| 
|  27|  29|         return single;
|  28|  30|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: a list of integers
|   8|   9|      * @return : return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array.cpp
|   7|   7|      * @param A: a list of integers
|   8|   8|      * @return : return an integer
|   9|   9|      */
|  10|    |-    int removeDuplicates(vector<int> &nums) {
|  11|    |-        if (nums.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int removeDuplicates (vector < int >&nums)
|    |  11|+    {
|    |  12|+        if (nums.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|  17|         int left = 0;
|  16|  18|         int right = 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array.cpp
|  15|  15|         int left = 0;
|  16|  16|         int right = 1;
|  17|  17| 
|  18|    |-        while (right < nums.size()) {
|  19|    |-            if (nums[left] != nums[right]) {
|  20|    |-                ++left;
|  21|    |-                nums[left] = nums[right];
|  22|    |-            }
|  23|    |-            ++right;
|  24|    |-        }
|    |  18|+        while (right < nums.size ())
|    |  19|+          {
|    |  20|+              if (nums[left] != nums[right])
|    |  21|+                {
|    |  22|+                    ++left;
|    |  23|+                    nums[left] = nums[right];
|    |  24|+                }
|    |  25|+              ++right;
|    |  26|+          }
|  25|  27| 
|  26|  28|         return left + 1;
|  27|  29|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Catalan Number: C(2n, n) - C(2n, n - 1)
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @paramn n: An integer
|   9|  10|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|   8|   8|      * @paramn n: An integer
|   9|   9|      * @return: An integer
|  10|  10|      */
|  11|    |-    int numTrees(int n) {
|  12|    |-        if (n == 0) {
|  13|    |-            return 1;
|  14|    |-        }
|  15|    |-        return combination(2 * n, n) - combination(2 * n, n - 1);
|    |  11|+    int numTrees (int n)
|    |  12|+    {
|    |  13|+        if (n == 0)
|    |  14|+          {
|    |  15|+              return 1;
|    |  16|+          }
|    |  17|+        return combination (2 * n, n) - combination (2 * n, n - 1);
|  16|  18|     }
|  17|  19| 
|  18|  20|     int combination(const int  n, const int k) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|  15|  15|         return combination(2 * n, n) - combination(2 * n, n - 1);
|  16|  16|     }
|  17|  17| 
|  18|    |-    int combination(const int  n, const int k) {
|    |  18|+    int combination (const int n, const int k)
|    |  19|+    {
|  19|  20|         long long count = 1;
|  20|  21|         // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
|  21|  22|         for (int i = 1; i <= k; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|  18|  18|     int combination(const int  n, const int k) {
|  19|  19|         long long count = 1;
|  20|  20|         // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
|  21|    |-        for (int i = 1; i <= k; ++i) {
|  22|    |-            count = count * (n - i + 1) / i;
|  23|    |-        }
|    |  21|+        for (int i = 1; i <= k; ++i)
|    |  22|+          {
|    |  23|+              count = count * (n - i + 1) / i;
|    |  24|+          }
|  24|  25| 
|  25|  26|         return count;
|  26|  27|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|  28|  28| 
|  29|  29| // Time:  O(n^2)
|  30|  30| // Space: O(n)
|  31|    |-class Solution2 {
|  32|    |-public:
|    |  31|+class Solution2
|    |  32|+{
|    |  33|+  public:
|  33|  34|     /**
|  34|  35|      * @paramn n: An integer
|  35|  36|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees.cpp
|    |++++| /app/C++/unique-binary-search-trees.cpp
|  34|  34|      * @paramn n: An integer
|  35|  35|      * @return: An integer
|  36|  36|      */
|  37|    |-    int numTrees(int n) {
|  38|    |-        vector<int> num(n + 1, 0);
|  39|    |-        num[0] = 1;
|  40|    |-        for (int i = 1; i <= n; ++i) {
|  41|    |-            for (int j = 0; j < i; ++j) {
|  42|    |-                num[i] += num[j] * num[i - 1 - j];
|  43|    |-            }
|  44|    |-        }
|    |  37|+    int numTrees (int n)
|    |  38|+    {
|    |  39|+        vector < int >num (n + 1, 0);
|    |  40|+          num[0] = 1;
|    |  41|+        for (int i = 1; i <= n; ++i)
|    |  42|+          {
|    |  43|+              for (int j = 0; j < i; ++j)
|    |  44|+                {
|    |  45|+                    num[i] += num[j] * num[i - 1 - j];
|    |  46|+                }
|    |  47|+          }
|  45|  48|         return num[n];
|  46|  49|     }
|  47|  50| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|   1|   1| // Time:  O(n) ~ O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /*
|   7|   8|      * param k : description of k
|   8|   9|      * param nums : description of array and index 0 ~ n-1
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|   8|   8|      * param nums : description of array and index 0 ~ n-1
|   9|   9|      * return: description of return
|  10|  10|      */
|  11|    |-    int kthLargestElement(int k, vector<int> nums) {
|  12|    |-        int left = 0, right = nums.size() - 1;
|  13|    |-        default_random_engine gen((random_device())());
|  14|    |-        while (left <= right) {
|  15|    |-            // Generates a random int in [left, right].
|  16|    |-            uniform_int_distribution<int> dis(left, right);
|  17|    |-            int pivot_idx = dis(gen);
|  18|    |-            int new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums);
|  19|    |-            if (new_pivot_idx == k - 1) {
|  20|    |-                return nums[new_pivot_idx];
|  21|    |-            } else if (new_pivot_idx > k - 1) {
|  22|    |-                right = new_pivot_idx - 1;
|  23|    |-            } else {  // new_pivot_idx < k - 1.
|  24|    |-                left = new_pivot_idx + 1;
|  25|    |-            }
|  26|    |-        }
|    |  11|+    int kthLargestElement (int k, vector < int >nums)
|    |  12|+    {
|    |  13|+        int left = 0, right = nums.size () - 1;
|    |  14|+        default_random_engine gen ((random_device ())());
|    |  15|+        while (left <= right)
|    |  16|+          {
|    |  17|+              // Generates a random int in [left, right].
|    |  18|+              uniform_int_distribution < int >dis (left, right);
|    |  19|+              int pivot_idx = dis (gen);
|    |  20|+              int new_pivot_idx =
|    |  21|+                  PartitionAroundPivot (left, right, pivot_idx, nums);
|    |  22|+              if (new_pivot_idx == k - 1)
|    |  23|+                {
|    |  24|+                    return nums[new_pivot_idx];
|    |  25|+                }
|    |  26|+              else if (new_pivot_idx > k - 1)
|    |  27|+                {
|    |  28|+                    right = new_pivot_idx - 1;
|    |  29|+                }
|    |  30|+              else
|    |  31|+                {               // new_pivot_idx < k - 1.
|    |  32|+                    left = new_pivot_idx + 1;
|    |  33|+                }
|    |  34|+          }
|  27|  35|     }
|  28|  36| 
|  29|  37|     // Partition nums[left : right] around pivot_idx, returns the new index of the
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|  31|  31|     // nums[left : new_pivot_idx - 1] contains elements that are greater than the
|  32|  32|     // pivot, and nums[new_pivot_idx + 1 : right] contains elements that are less
|  33|  33|     // than the pivot.
|  34|    |-    int PartitionAroundPivot(int left, int right, int pivot_idx, vector<int>& nums) {
|    |  34|+    int PartitionAroundPivot (int left, int right, int pivot_idx,
|    |  35|+                              vector < int >&nums)
|    |  36|+    {
|  35|  37|         int pivot_value = nums[pivot_idx];
|  36|  38|         int new_pivot_idx = left;
|  37|  39|         swap(nums[pivot_idx], nums[right]);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|  34|  34|     int PartitionAroundPivot(int left, int right, int pivot_idx, vector<int>& nums) {
|  35|  35|         int pivot_value = nums[pivot_idx];
|  36|  36|         int new_pivot_idx = left;
|  37|    |-        swap(nums[pivot_idx], nums[right]);
|  38|    |-        for (int i = left; i < right; ++i) {
|  39|    |-            if (nums[i] > pivot_value) {
|  40|    |-                swap(nums[i], nums[new_pivot_idx++]);
|  41|    |-            }
|  42|    |-        }
|  43|    |-        swap(nums[right], nums[new_pivot_idx]);
|    |  37|+        swap (nums[pivot_idx], nums[right]);
|    |  38|+        for (int i = left; i < right; ++i)
|    |  39|+          {
|    |  40|+              if (nums[i] > pivot_value)
|    |  41|+                {
|    |  42|+                    swap (nums[i], nums[new_pivot_idx++]);
|    |  43|+                }
|    |  44|+          }
|    |  45|+        swap (nums[right], nums[new_pivot_idx]);
|  44|  46|         return new_pivot_idx;
|  45|  47|     }
|  46|  48| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|  45|  45|     }
|  46|  46| };
|  47|  47| 
|  48|    |-class Solution2 {
|  49|    |-public:
|    |  48|+class Solution2
|    |  49|+{
|    |  50|+  public:
|  50|  51|     /*
|  51|  52|      * param k : description of k
|  52|  53|      * param nums : description of array and index 0 ~ n-1
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/kth-largest-element.cpp
|    |++++| /app/C++/kth-largest-element.cpp
|  52|  52|      * param nums : description of array and index 0 ~ n-1
|  53|  53|      * return: description of return
|  54|  54|      */
|  55|    |-    int kthLargestElement(int k, vector<int> nums) {
|  56|    |-        nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater<int>());
|  57|    |-        return nums[k - 1];
|    |  55|+    int kthLargestElement (int k, vector < int >nums)
|    |  56|+    {
|    |  57|+        nth_element (nums.begin (), nums.begin () + k - 1, nums.end (),
|    |  58|+                     greater < int >());
|    |  59|+          return nums[k - 1];
|  58|  60|     }
|  59|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/lowest-common-ancestor.cpp
|    |++++| /app/C++/lowest-common-ancestor.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of the binary search tree.
|  20|  21|      * @param A and B: two nodes in a Binary.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/lowest-common-ancestor.cpp
|    |++++| /app/C++/lowest-common-ancestor.cpp
|  20|  20|      * @param A and B: two nodes in a Binary.
|  21|  21|      * @return: Return the least common ancestor(LCA) of the two nodes.
|  22|  22|      */
|  23|    |-    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *A, TreeNode *B) {
|  24|    |-        if (root == nullptr || root == A || root == B) {
|  25|    |-            return root;
|  26|    |-        }
|  27|    |-        TreeNode *left = lowestCommonAncestor(root->left, A, B);
|  28|    |-        TreeNode *right = lowestCommonAncestor(root->right, A, B);
|  29|    |-         // 1. If the current subtree contains both A and B,
|  30|    |-         //    return their LCA.
|  31|    |-         // 2. If only one of them is in that subtree,
|  32|    |-         //    return that one of them.
|  33|    |-         // 3. If neither of them is in that subtree,
|  34|    |-         //    return the node of that subtree.
|    |  23|+    TreeNode * lowestCommonAncestor (TreeNode * root, TreeNode * A,
|    |  24|+                                     TreeNode * B)
|    |  25|+    {
|    |  26|+        if (root == nullptr || root == A || root == B)
|    |  27|+          {
|    |  28|+              return root;
|    |  29|+          }
|    |  30|+        TreeNode *left = lowestCommonAncestor (root->left, A, B);
|    |  31|+        TreeNode *right = lowestCommonAncestor (root->right, A, B);
|    |  32|+        // 1. If the current subtree contains both A and B,
|    |  33|+        //    return their LCA.
|    |  34|+        // 2. If only one of them is in that subtree,
|    |  35|+        //    return that one of them.
|    |  36|+        // 3. If neither of them is in that subtree,
|    |  37|+        //    return the node of that subtree.
|  35|  38|         return left ? (right ? root : left) : right;
|  36|  39|     }
|  37|  40| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-missing-positive.cpp
|    |++++| /app/C++/first-missing-positive.cpp
|   4|   4| #include <algorithm>
|   5|   5| #include <vector>
|   6|   6| 
|   7|    |-using std::swap;
|   8|    |-using std::vector;
|    |   7|+using
|    |   8|+    std::swap;
|    |   9|+using
|    |  10|+    std::vector;
|   9|  11| 
|  10|    |-class Solution {
|  11|    |-    public:
|    |  12|+class
|    |  13|+    Solution
|    |  14|+{
|    |  15|+  public:
|  12|  16|         /**    
|  13|  17|          * @param A: a vector of integers
|  14|  18|          * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-missing-positive.cpp
|    |++++| /app/C++/first-missing-positive.cpp
|  13|  13|          * @param A: a vector of integers
|  14|  14|          * @return: an integer
|  15|  15|          */
|  16|    |-        int firstMissingPositive(vector<int> A) {
|  17|    |-            // Record which values are present by writing A[i] to index A[i] - 1 if A[i]
|  18|    |-            // is between 1 and A.size(), inclusive. We save the value at index
|  19|    |-            // A[i] - 1 by swapping it with the entry at i. If A[i] is negative or
|  20|    |-            // greater than n, we just advance i.
|  21|    |-            size_t i = 0;
|  22|    |-            while (i < A.size()) {
|  23|    |-                if (A[i] > 0 && A[i] <= A.size() &&
|  24|    |-                        A[A[i] - 1] != A[i]) {
|  25|    |-                    swap(A[i], A[A[i] - 1]);
|  26|    |-                } else {
|    |  16|+    int
|    |  17|+    firstMissingPositive (vector < int >A)
|    |  18|+    {
|    |  19|+        // Record which values are present by writing A[i] to index A[i] - 1 if A[i]
|    |  20|+        // is between 1 and A.size(), inclusive. We save the value at index
|    |  21|+        // A[i] - 1 by swapping it with the entry at i. If A[i] is negative or
|    |  22|+        // greater than n, we just advance i.
|    |  23|+        size_t
|    |  24|+            i = 0;
|    |  25|+        while (i < A.size ())
|    |  26|+          {
|    |  27|+              if (A[i] > 0 && A[i] <= A.size () && A[A[i] - 1] != A[i])
|    |  28|+                {
|    |  29|+                    swap (A[i], A[A[i] - 1]);
|    |  30|+                }
|    |  31|+              else
|    |  32|+                {
|  27|  33|                     ++i;
|  28|  34|                 }
|  29|  35|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-missing-positive.cpp
|    |++++| /app/C++/first-missing-positive.cpp
|  26|  26|                 } else {
|  27|  27|                     ++i;
|  28|  28|                 }
|  29|    |-            }
|    |  29|+          }
|  30|  30| 
|  31|    |-            // Second pass through A to search for the first index i such that
|  32|    |-            // A[i] != i+1, indicating that i + 1 is absent. If all numbers between 1
|  33|    |-            // and A.size() are present, the smallest missing positive is A.size() + 1.
|  34|    |-            for (size_t i = 0; i < A.size(); ++i) {
|  35|    |-                if (A[i] != i + 1) {
|    |  31|+        // Second pass through A to search for the first index i such that
|    |  32|+        // A[i] != i+1, indicating that i + 1 is absent. If all numbers between 1
|    |  33|+        // and A.size() are present, the smallest missing positive is A.size() + 1.
|    |  34|+        for (size_t i = 0; i < A.size (); ++i)
|    |  35|+          {
|    |  36|+              if (A[i] != i + 1)
|    |  37|+                {
|  36|  38|                     return i + 1;
|  37|  39|                 }
|  38|  40|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-missing-positive.cpp
|    |++++| /app/C++/first-missing-positive.cpp
|  35|  35|                 if (A[i] != i + 1) {
|  36|  36|                     return i + 1;
|  37|  37|                 }
|  38|    |-            }
|  39|    |-            return A.size() + 1;
|  40|    |-        }
|    |  38|+          }
|    |  39|+        return A.size () + 1;
|    |  40|+    }
|  41|  41| };
|  42|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |- 
|    |  16|+
|  17|  17|  // Morris Traversal (Preorder) if the data of the tree nodes could be modified.
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      * @param T1, T2: The roots of binary tree.
|  22|  23|      * @return: True if T2 is a subtree of T1, or false.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  21|  21|      * @param T1, T2: The roots of binary tree.
|  22|  22|      * @return: True if T2 is a subtree of T1, or false.
|  23|  23|      */
|  24|    |-    bool isSubtree(TreeNode *T1, TreeNode *T2) {
|  25|    |-        if (!T2) {
|  26|    |-            return true;
|  27|    |-        }
|    |  24|+    bool isSubtree (TreeNode * T1, TreeNode * T2)
|    |  25|+    {
|    |  26|+        if (!T2)
|    |  27|+          {
|    |  28|+              return true;
|    |  29|+          }
|  28|  30|         bool found = false;
|  29|  31|         TreeNode *curr = T1;
|  30|  32|         while (curr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  27|  27|         }
|  28|  28|         bool found = false;
|  29|  29|         TreeNode *curr = T1;
|  30|    |-        while (curr) {
|  31|    |-            if (!curr->left) {
|  32|    |-                if (!found && isSameTree(curr, curr, T2)) {
|  33|    |-                    found = true;
|  34|    |-                }
|  35|    |-                curr = curr->right;
|  36|    |-            } else {
|  37|    |-                TreeNode *node = curr->left;
|  38|    |-                while (node->right && node->right != curr) {
|  39|    |-                    node = node->right;
|  40|    |-                }
|  41|    |-                // Traverse the left child if only if the subtree is not found.
|  42|    |-                if (!found && !node->right) {
|  43|    |-                    if (isSameTree(curr, curr, T2)) {
|  44|    |-                        found = true;
|  45|    |-                    }
|  46|    |-                    node->right = curr;
|  47|    |-                    curr = curr->left;
|  48|    |-                } else {
|  49|    |-                    // Rollback the modification.
|  50|    |-                    node->right = nullptr;
|    |  30|+        while (curr)
|    |  31|+          {
|    |  32|+              if (!curr->left)
|    |  33|+                {
|    |  34|+                    if (!found && isSameTree (curr, curr, T2))
|    |  35|+                      {
|    |  36|+                          found = true;
|    |  37|+                      }
|  51|  38|                     curr = curr->right;
|  52|  39|                 }
|  53|  40|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  50|  50|                     node->right = nullptr;
|  51|  51|                     curr = curr->right;
|  52|  52|                 }
|  53|    |-            }
|  54|    |-        }
|    |  53|+              else
|    |  54|+                {
|    |  55|+                    TreeNode *node = curr->left;
|    |  56|+                    while (node->right && node->right != curr)
|    |  57|+                      {
|    |  58|+                          node = node->right;
|    |  59|+                      }
|    |  60|+                    // Traverse the left child if only if the subtree is not found.
|    |  61|+                    if (!found && !node->right)
|    |  62|+                      {
|    |  63|+                          if (isSameTree (curr, curr, T2))
|    |  64|+                            {
|    |  65|+                                found = true;
|    |  66|+                            }
|    |  67|+                          node->right = curr;
|    |  68|+                          curr = curr->left;
|    |  69|+                      }
|    |  70|+                    else
|    |  71|+                      {
|    |  72|+                          // Rollback the modification.
|    |  73|+                          node->right = nullptr;
|    |  74|+                          curr = curr->right;
|    |  75|+                      }
|    |  76|+                }
|    |  77|+          }
|  55|  78|         // Complete the traversal to rollback the modification due to Morris Traversal.
|  56|  79|         return found;
|  57|  80|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  56|  56|         return found;
|  57|  57|     }
|  58|  58| 
|  59|    |-    bool isSameTree(const TreeNode *T1_root,
|  60|    |-                    const TreeNode *T1, const TreeNode *T2) {
|    |  59|+    bool isSameTree (const TreeNode * T1_root,
|    |  60|+                     const TreeNode * T1, const TreeNode * T2)
|    |  61|+    {
|  61|  62| 
|  62|    |-        if (!T1 && !T2) {
|  63|    |-            return true;
|  64|    |-        }
|    |  63|+        if (!T1 && !T2)
|    |  64|+          {
|    |  65|+              return true;
|    |  66|+          }
|  65|  67| 
|  66|    |-        if (T1 && T2) {
|  67|    |-            return T1->val == T2->val &&
|  68|    |-                   isSameTree(T1_root, T1->left, T2->left) &&
|  69|    |-                   isSameTree(T1_root, realRightChild(T1), T2->right);
|  70|    |-        }
|    |  68|+        if (T1 && T2)
|    |  69|+          {
|    |  70|+              return T1->val == T2->val &&
|    |  71|+                  isSameTree (T1_root, T1->left, T2->left) &&
|    |  72|+                  isSameTree (T1_root, realRightChild (T1), T2->right);
|    |  73|+          }
|  71|  74| 
|  72|  75|         return false;
|  73|  76|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  71|  71| 
|  72|  72|         return false;
|  73|  73|     }
|  74|    |-    
|    |  74|+
|  75|  75|     // Treat the right child as nullptr if it has been used for
|  76|  76|     // Morris Traversal.
|  77|  77|     TreeNode *realRightChild(const TreeNode *curr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  74|  74|     
|  75|  75|     // Treat the right child as nullptr if it has been used for
|  76|  76|     // Morris Traversal.
|  77|    |-    TreeNode *realRightChild(const TreeNode *curr) {
|  78|    |-        TreeNode* curr_right = curr ? curr->right : nullptr;
|  79|    |-        if (curr_right && curr_right->left) {
|  80|    |-            TreeNode *node = curr_right->left;
|  81|    |-            while (node->right && node->right != curr_right) {
|  82|    |-                node = node->right;
|  83|    |-            }
|  84|    |-            if (node->right) {
|  85|    |-                curr_right = nullptr;
|  86|    |-            }
|  87|    |-        }
|    |  77|+    TreeNode *realRightChild (const TreeNode * curr)
|    |  78|+    {
|    |  79|+        TreeNode *curr_right = curr ? curr->right : nullptr;
|    |  80|+        if (curr_right && curr_right->left)
|    |  81|+          {
|    |  82|+              TreeNode *node = curr_right->left;
|    |  83|+              while (node->right && node->right != curr_right)
|    |  84|+                {
|    |  85|+                    node = node->right;
|    |  86|+                }
|    |  87|+              if (node->right)
|    |  88|+                {
|    |  89|+                    curr_right = nullptr;
|    |  90|+                }
|    |  91|+          }
|  88|  92|         return curr_right;
|  89|  93|     }
|  90|  94| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  91|  91| 
|  92|  92| // Time:  O(m * n)
|  93|  93| // Space: O(h)
|  94|    |-class Solution2 {
|  95|    |-public:
|    |  94|+class Solution2
|    |  95|+{
|    |  96|+  public:
|  96|  97|     /**
|  97|  98|      * @param T1, T2: The roots of binary tree.
|  98|  99|      * @return: True if T2 is a subtree of T1, or false.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
|  97|  97|      * @param T1, T2: The roots of binary tree.
|  98|  98|      * @return: True if T2 is a subtree of T1, or false.
|  99|  99|      */
| 100|    |-    bool isSubtree(TreeNode *T1, TreeNode *T2) {
| 101|    |-        if (!T2) {
| 102|    |-            return true;
| 103|    |-        } else if (!T1) {  // !T1 && T2
| 104|    |-            return false;
| 105|    |-        } else {  // T1 && T2
| 106|    |-            return isSameTree(T1, T2) ||
| 107|    |-                   isSubtree(T1->left, T2) ||
| 108|    |-                   isSubtree(T1->right, T2);
| 109|    |-        }
|    | 100|+    bool isSubtree (TreeNode * T1, TreeNode * T2)
|    | 101|+    {
|    | 102|+        if (!T2)
|    | 103|+          {
|    | 104|+              return true;
|    | 105|+          }
|    | 106|+        else if (!T1)
|    | 107|+          {                     // !T1 && T2
|    | 108|+              return false;
|    | 109|+          }
|    | 110|+        else
|    | 111|+          {                     // T1 && T2
|    | 112|+              return isSameTree (T1, T2) ||
|    | 113|+                  isSubtree (T1->left, T2) || isSubtree (T1->right, T2);
|    | 114|+          }
| 110| 115| 
| 111| 116|     }
| 112| 117| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subtree.cpp
|    |++++| /app/C++/subtree.cpp
| 110| 110| 
| 111| 111|     }
| 112| 112| 
| 113|    |-    bool isSameTree(TreeNode *T1, TreeNode *T2) {
| 114|    |-        if (!T1 && !T2) {
| 115|    |-            return true;
| 116|    |-        }
|    | 113|+    bool isSameTree (TreeNode * T1, TreeNode * T2)
|    | 114|+    {
|    | 115|+        if (!T1 && !T2)
|    | 116|+          {
|    | 117|+              return true;
|    | 118|+          }
| 117| 119| 
| 118|    |-        if (T1 && T2) {
| 119|    |-            return T1->val == T2->val &&
| 120|    |-                   isSameTree(T1->left, T2->left) &&
| 121|    |-                   isSameTree(T1->right, T2->right);
| 122|    |-        }
|    | 120|+        if (T1 && T2)
|    | 121|+          {
|    | 122|+              return T1->val == T2->val &&
|    | 123|+                  isSameTree (T1->left, T2->left) &&
|    | 124|+                  isSameTree (T1->right, T2->right);
|    | 125|+          }
| 123| 126| 
| 124| 127|         return false;
| 125| 128|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|    |++++| /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|   1|   1| // Time:  O(nlogn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums n non-negative integer array
|   8|   9|      * @return a string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|    |++++| /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|   7|   7|      * @param nums n non-negative integer array
|   8|   8|      * @return a string
|   9|   9|      */
|  10|    |-    string minNumber(vector<int>& nums) {
|  11|    |-        sort(nums.begin(), nums.end(), [](const int &i, const int &j) {
|  12|    |-            return to_string(i) + to_string(j) < to_string(j) + to_string(i);
|  13|    |-        });
|    |  10|+    string minNumber (vector < int >&nums)
|    |  11|+    {
|    |  12|+        sort (nums.begin (), nums.end (),[](const int &i, const int &j)
|    |  13|+              {
|    |  14|+              return to_string (i) + to_string (j) <
|    |  15|+              to_string (j) + to_string (i);}
|    |  16|+        );
|  14|  17| 
|  15|  18|         string min_num;
|  16|  19|         for (const auto& i : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|    |++++| /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|  13|  13|         });
|  14|  14| 
|  15|  15|         string min_num;
|  16|    |-        for (const auto& i : nums) {
|  17|    |-            min_num.append(to_string(i));
|  18|    |-        }
|    |  16|+      for (const auto & i:nums)
|    |  17|+          {
|    |  18|+              min_num.append (to_string (i));
|    |  19|+          }
|  19|  20| 
|  20|  21|         int i = 0;
|  21|  22|         while (i + 1 < min_num.length() && min_num[i] == '0')  {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|    |++++| /app/C++/reorder-array-to-construct-the-minimum-number.cpp
|  18|  18|         }
|  19|  19| 
|  20|  20|         int i = 0;
|  21|    |-        while (i + 1 < min_num.length() && min_num[i] == '0')  {
|  22|    |-            ++i;
|  23|    |-        }
|  24|    |-        
|  25|    |-        return min_num.empty() ? "0" : min_num.substr(i);
|    |  21|+        while (i + 1 < min_num.length () && min_num[i] == '0')
|    |  22|+          {
|    |  23|+              ++i;
|    |  24|+          }
|    |  25|+
|    |  26|+        return min_num.empty ()? "0" : min_num.substr (i);
|  26|  27|     }
|  27|  28| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  19|  19|      * @param head: The first node of linked list.
|  20|  20|      * @return: void
|  21|  21|      */
|  22|    |-    void reorderList(ListNode *head) {
|  23|    |-        if (!head) {
|  24|    |-            return;
|  25|    |-        }
|    |  22|+    void reorderList (ListNode * head)
|    |  23|+    {
|    |  24|+        if (!head)
|    |  25|+          {
|    |  26|+              return;
|    |  27|+          }
|  26|  28| 
|  27|  29|         auto slow = head, fast = head;
|  28|  30| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  26|  26| 
|  27|  27|         auto slow = head, fast = head;
|  28|  28| 
|  29|    |-        while (fast->next && fast->next->next) {
|  30|    |-            slow = slow->next;
|  31|    |-            fast = fast->next->next;
|  32|    |-        }
|    |  29|+        while (fast->next && fast->next->next)
|    |  30|+          {
|    |  31|+              slow = slow->next;
|    |  32|+              fast = fast->next->next;
|    |  33|+          }
|  33|  34| 
|  34|  35|         // Split into two lists.
|  35|  36|         auto tmp = slow->next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  36|  36|         slow->next = nullptr;
|  37|  37|         slow = tmp;
|  38|  38| 
|  39|    |-        merge(head, reverse(slow));
|    |  39|+        merge (head, reverse (slow));
|  40|  40|     }
|  41|  41| 
|  42|  42| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  39|  39|         merge(head, reverse(slow));
|  40|  40|     }
|  41|  41| 
|  42|    |-private:
|  43|    |-    ListNode *reverse(ListNode *head) {
|  44|    |-        ListNode dummy{0};
|    |  42|+  private:
|    |  43|+    ListNode * reverse (ListNode * head)
|    |  44|+    {
|    |  45|+        ListNode dummy
|    |  46|+        {
|    |  47|+        0};
|  45|  48| 
|  46|    |-        while (head) {
|  47|    |-            auto tmp = head->next;
|  48|    |-            head->next = dummy.next;
|  49|    |-            dummy.next = head;
|  50|    |-            head = tmp;
|  51|    |-        }
|    |  49|+        while (head)
|    |  50|+          {
|    |  51|+              auto tmp = head->next;
|    |  52|+              head->next = dummy.next;
|    |  53|+              dummy.next = head;
|    |  54|+              head = tmp;
|    |  55|+          }
|  52|  56| 
|  53|  57|         return dummy.next;
|  54|  58|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  53|  53|         return dummy.next;
|  54|  54|     }
|  55|  55| 
|  56|    |-    ListNode *merge(ListNode *list1, ListNode *list2) {
|  57|    |-        ListNode dummy{0};
|    |  56|+    ListNode *merge (ListNode * list1, ListNode * list2)
|    |  57|+    {
|    |  58|+        ListNode dummy
|    |  59|+        {
|    |  60|+        0};
|  58|  61|         auto ptr = &dummy;
|  59|  62| 
|  60|  63|         while (list1 && list2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reorder-list.cpp
|    |++++| /app/C++/reorder-list.cpp
|  57|  57|         ListNode dummy{0};
|  58|  58|         auto ptr = &dummy;
|  59|  59| 
|  60|    |-        while (list1 && list2) {
|  61|    |-            auto tmp = list1->next;
|    |  60|+        while (list1 && list2)
|    |  61|+          {
|    |  62|+              auto tmp = list1->next;
|  62|  63| 
|  63|    |-            ptr->next = list1;
|  64|    |-            ptr = ptr->next;
|  65|    |-            ptr->next = list2;
|  66|    |-            ptr = ptr->next;
|    |  64|+              ptr->next = list1;
|    |  65|+              ptr = ptr->next;
|    |  66|+              ptr->next = list2;
|    |  67|+              ptr = ptr->next;
|  67|  68| 
|  68|    |-            list1 = tmp;
|  69|    |-            list2 = list2->next;
|  70|    |-        }
|    |  69|+              list1 = tmp;
|    |  70|+              list2 = list2->next;
|    |  71|+          }
|  71|  72| 
|  72|    |-        if (list1) {
|  73|    |-            ptr->next = list1;
|  74|    |-        }
|    |  73|+        if (list1)
|    |  74|+          {
|    |  75|+              ptr->next = list1;
|    |  76|+          }
|  75|  77| 
|  76|  78|         return dummy.next;
|  77|  79|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Two Pointers solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param S: A list of integers
|   9|  10|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|   8|   8|      * @param S: A list of integers
|   9|   9|      * @return: An integer
|  10|  10|      */
|  11|    |-    int triangleCount(vector<int> &S) {
|  12|    |-        sort(S.begin(), S.end());
|  13|    |-        const int n = S.size();
|    |  11|+    int triangleCount (vector < int >&S)
|    |  12|+    {
|    |  13|+        sort (S.begin (), S.end ());
|    |  14|+        const int n = S.size ();
|  14|  15| 
|  15|  16|         int count = 0;
|  16|  17|         for (int k = 2; k < n; ++k) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|  13|  13|         const int n = S.size();
|  14|  14| 
|  15|  15|         int count = 0;
|  16|    |-        for (int k = 2; k < n; ++k) {
|  17|    |-            int i = 0, j = k - 1;
|  18|    |-            while (i < j) {  // Two Pointers, linear time.
|  19|    |-                if (S[i] + S[j] <= S[k]) {
|  20|    |-                    ++i;
|  21|    |-                } else {
|  22|    |-                    count += j - i;
|  23|    |-                    --j;
|    |  16|+        for (int k = 2; k < n; ++k)
|    |  17|+          {
|    |  18|+              int i = 0, j = k - 1;
|    |  19|+              while (i < j)
|    |  20|+                {               // Two Pointers, linear time.
|    |  21|+                    if (S[i] + S[j] <= S[k])
|    |  22|+                      {
|    |  23|+                          ++i;
|    |  24|+                      }
|    |  25|+                    else
|    |  26|+                      {
|    |  27|+                          count += j - i;
|    |  28|+                          --j;
|    |  29|+                      }
|  24|  30|                 }
|  25|    |-            }
|  26|    |-        }
|    |  31|+          }
|  27|  32| 
|  28|  33|         return count;
|  29|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|  31|  31| 
|  32|  32| // Time:  O(n^2)
|  33|  33| // Space: O(1)
|  34|    |-class Solution2 {
|  35|    |-public:
|    |  34|+class Solution2
|    |  35|+{
|    |  36|+  public:
|  36|  37|     /**
|  37|  38|      * @param S: A list of integers
|  38|  39|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|  37|  37|      * @param S: A list of integers
|  38|  38|      * @return: An integer
|  39|  39|      */
|  40|    |-    int triangleCount(vector<int> &S) {
|  41|    |-        sort(S.begin(), S.end());
|  42|    |-        const int n = S.size();
|    |  40|+    int triangleCount (vector < int >&S)
|    |  41|+    {
|    |  42|+        sort (S.begin (), S.end ());
|    |  43|+        const int n = S.size ();
|  43|  44| 
|  44|  45|         int count = 0;
|  45|  46| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/triangle-count.cpp
|    |++++| /app/C++/triangle-count.cpp
|  43|  43| 
|  44|  44|         int count = 0;
|  45|  45| 
|  46|    |-        for (int i = 0; i < n - 2; ++i) {
|  47|    |-            int k = i + 2;
|  48|    |-            for (int j = i + 1; j < n; ++j) {
|  49|    |-                while (k < n && S[i] + S[j] > S[k]) {
|  50|    |-                    ++k;
|    |  46|+        for (int i = 0; i < n - 2; ++i)
|    |  47|+          {
|    |  48|+              int k = i + 2;
|    |  49|+              for (int j = i + 1; j < n; ++j)
|    |  50|+                {
|    |  51|+                    while (k < n && S[i] + S[j] > S[k])
|    |  52|+                      {
|    |  53|+                          ++k;
|    |  54|+                      }
|    |  55|+                    count += k - j - 1;
|  51|  56|                 }
|  52|    |-                count += k - j - 1;
|  53|    |-            }
|  54|    |-        }
|    |  57|+          }
|  55|  58|         return count;
|  56|  59|     }
|  57|  60| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  17|  17| // Time:  O(n)
|  18|  18| // Space: O(w), w is the max number of nodes of the levels.
|  19|  19| // BFS solution.
|  20|    |-class Solution {
|  21|    |-public:
|    |  20|+class Solution
|    |  21|+{
|    |  22|+  public:
|  22|  23|     /**
|  23|  24|      * @param root: a TreeNode, the root of the binary tree
|  24|  25|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  23|  23|      * @param root: a TreeNode, the root of the binary tree
|  24|  24|      * @return: nothing
|  25|  25|      */
|  26|    |-    void invertBinaryTree(TreeNode *root) {
|  27|    |-        if (root != nullptr) {
|  28|    |-            queue<TreeNode*> nodes;
|  29|    |-            nodes.emplace(root);
|  30|    |-            while (!nodes.empty()) {
|  31|    |-                auto node = nodes.front();
|  32|    |-                nodes.pop();
|  33|    |-                swap(node->left, node->right);
|  34|    |-                if (node->left != nullptr) {
|  35|    |-                    nodes.emplace(node->left);
|    |  26|+    void invertBinaryTree (TreeNode * root)
|    |  27|+    {
|    |  28|+        if (root != nullptr)
|    |  29|+          {
|    |  30|+              queue < TreeNode * >nodes;
|    |  31|+              nodes.emplace (root);
|    |  32|+              while (!nodes.empty ())
|    |  33|+                {
|    |  34|+                    auto node = nodes.front ();
|    |  35|+                      nodes.pop ();
|    |  36|+                      swap (node->left, node->right);
|    |  37|+                    if (node->left != nullptr)
|    |  38|+                      {
|    |  39|+                          nodes.emplace (node->left);
|    |  40|+                      }
|    |  41|+                    if (node->right != nullptr)
|    |  42|+                      {
|    |  43|+                          nodes.emplace (node->right);
|    |  44|+                      }
|  36|  45|                 }
|  37|    |-                if (node->right != nullptr) {
|  38|    |-                    nodes.emplace(node->right);
|  39|    |-                }
|  40|    |-            }
|  41|    |-        }
|    |  46|+          }
|  42|  47|     }
|  43|  48| };
|  44|  49| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  45|  45| // Time:  O(n)
|  46|  46| // Space: O(h)
|  47|  47| // Stack solution.
|  48|    |-class Solution2 {
|  49|    |-public:
|    |  48|+class Solution2
|    |  49|+{
|    |  50|+  public:
|  50|  51|     /**
|  51|  52|      * @param root: a TreeNode, the root of the binary tree
|  52|  53|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  51|  51|      * @param root: a TreeNode, the root of the binary tree
|  52|  52|      * @return: nothing
|  53|  53|      */
|  54|    |-    void invertBinaryTree(TreeNode *root) {
|  55|    |-        if (root != nullptr) {
|  56|    |-            stack<TreeNode*> nodes;
|  57|    |-            nodes.emplace(root);
|  58|    |-            while (!nodes.empty()) {
|  59|    |-                auto node = nodes.top();
|  60|    |-                nodes.pop();
|  61|    |-                swap(node->left, node->right);
|  62|    |-                if (node->left != nullptr) {
|  63|    |-                    nodes.emplace(node->left);
|    |  54|+    void invertBinaryTree (TreeNode * root)
|    |  55|+    {
|    |  56|+        if (root != nullptr)
|    |  57|+          {
|    |  58|+              stack < TreeNode * >nodes;
|    |  59|+              nodes.emplace (root);
|    |  60|+              while (!nodes.empty ())
|    |  61|+                {
|    |  62|+                    auto node = nodes.top ();
|    |  63|+                      nodes.pop ();
|    |  64|+                      swap (node->left, node->right);
|    |  65|+                    if (node->left != nullptr)
|    |  66|+                      {
|    |  67|+                          nodes.emplace (node->left);
|    |  68|+                      }
|    |  69|+                    if (node->right != nullptr)
|    |  70|+                      {
|    |  71|+                          nodes.emplace (node->right);
|    |  72|+                      }
|  64|  73|                 }
|  65|    |-                if (node->right != nullptr) {
|  66|    |-                    nodes.emplace(node->right);
|  67|    |-                }
|  68|    |-            }
|  69|    |-        }
|    |  74|+          }
|  70|  75|     }
|  71|  76| };
|  72|  77| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  73|  73| // Time:  O(n)
|  74|  74| // Space: O(h) 
|  75|  75| // DFS, Recursive solution.
|  76|    |-class Solution3 {
|  77|    |-public:
|    |  76|+class Solution3
|    |  77|+{
|    |  78|+  public:
|  78|  79|     /**
|  79|  80|      * @param root: a TreeNode, the root of the binary tree
|  80|  81|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/invert-binary-tree.cpp
|    |++++| /app/C++/invert-binary-tree.cpp
|  79|  79|      * @param root: a TreeNode, the root of the binary tree
|  80|  80|      * @return: nothing
|  81|  81|      */
|  82|    |-    void invertBinaryTree(TreeNode *root) {
|  83|    |-        if (root != nullptr) {
|  84|    |-            swap(root->left, root->right);
|  85|    |-            invertBinaryTree(root->left);
|  86|    |-            invertBinaryTree(root->right);
|  87|    |-        }
|    |  82|+    void invertBinaryTree (TreeNode * root)
|    |  83|+    {
|    |  84|+        if (root != nullptr)
|    |  85|+          {
|    |  86|+              swap (root->left, root->right);
|    |  87|+              invertBinaryTree (root->left);
|    |  88|+              invertBinaryTree (root->right);
|    |  89|+          }
|  88|  90|     }
|  89|  91| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-ii.cpp
|    |++++| /app/C++/coins-in-a-line-ii.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // DP with rolling window.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param values: a vector of integers
|   9|  10|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-ii.cpp
|    |++++| /app/C++/coins-in-a-line-ii.cpp
|   8|   8|      * @param values: a vector of integers
|   9|   9|      * @return: a boolean which equals to true if the first player will win
|  10|  10|      */
|  11|    |-    bool firstWillWin(vector<int> &values) {
|  12|    |-        vector<int> P(5);
|    |  11|+    bool firstWillWin (vector < int >&values)
|    |  12|+    {
|    |  13|+        vector < int >P (5);
|  13|  14|         int sum = 0;
|  14|    |-        for (int i = values.size() - 1; i >= 0; --i) {
|  15|    |-            sum += values[i];
|  16|    |-            const int a = i + 1 < values.size() ? values[i + 1]: 0;
|  17|    |-            const int b = i + 2 < values.size() ? P[(i + 2) % 5] : 0;
|  18|    |-            const int c = i + 3 < values.size() ? P[(i + 3) % 5] : 0;
|  19|    |-            const int d = i + 4 < values.size() ? P[(i + 4) % 5] : 0;
|  20|    |-            // P[i] = max(values[i] + min(P[i + 2], P[i + 3]),
|  21|    |-            //            values[i] + values[i + 1] + min(P[i + 3], P[i + 4]))
|  22|    |-            P[i % 5] = max(values[i] + min(b, c), values[i] + a + min(c, d));
|  23|    |-        }
|    |  15|+        for (int i = values.size () - 1; i >= 0; --i)
|    |  16|+          {
|    |  17|+              sum += values[i];
|    |  18|+              const int a = i + 1 < values.size ()? values[i + 1] : 0;
|    |  19|+              const int b = i + 2 < values.size ()? P[(i + 2) % 5] : 0;
|    |  20|+              const int c = i + 3 < values.size ()? P[(i + 3) % 5] : 0;
|    |  21|+              const int d = i + 4 < values.size ()? P[(i + 4) % 5] : 0;
|    |  22|+              // P[i] = max(values[i] + min(P[i + 2], P[i + 3]),
|    |  23|+              //            values[i] + values[i + 1] + min(P[i + 3], P[i + 4]))
|    |  24|+                P[i % 5] =
|    |  25|+                  max (values[i] + min (b, c), values[i] + a + min (c, d));
|    |  26|+          }
|  24|  27| 
|  25|  28|         return P[0] > sum - P[0];
|  26|  29|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-ii.cpp
|    |++++| /app/C++/coins-in-a-line-ii.cpp
|  26|  26|     }
|  27|  27| };
|  28|  28| 
|  29|    |-
|  30|  29| // Time:  O(n)
|  31|  30| // Space: O(n)
|  32|  31| class Solution2 {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-ii.cpp
|    |++++| /app/C++/coins-in-a-line-ii.cpp
|  29|  29| 
|  30|  30| // Time:  O(n)
|  31|  31| // Space: O(n)
|  32|    |-class Solution2 {
|  33|    |-public:
|    |  32|+class Solution2
|    |  33|+{
|    |  34|+  public:
|  34|  35|     /**
|  35|  36|      * @param values: a vector of integers
|  36|  37|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line-ii.cpp
|    |++++| /app/C++/coins-in-a-line-ii.cpp
|  35|  35|      * @param values: a vector of integers
|  36|  36|      * @return: a boolean which equals to true if the first player will win
|  37|  37|      */
|  38|    |-    bool firstWillWin(vector<int> &values) {
|  39|    |-        vector<int> P(values.size());
|    |  38|+    bool firstWillWin (vector < int >&values)
|    |  39|+    {
|    |  40|+        vector < int >P (values.size ());
|  40|  41|         int sum = 0;
|  41|    |-        for (int i = values.size() - 1; i >= 0; --i) {
|  42|    |-            sum += values[i];
|  43|    |-            const int a = i + 1 < values.size() ? values[i + 1]: 0;
|  44|    |-            const int b = i + 2 < values.size() ? P[i + 2] : 0;
|  45|    |-            const int c = i + 3 < values.size() ? P[i + 3] : 0;
|  46|    |-            const int d = i + 4 < values.size() ? P[i + 4] : 0;
|  47|    |-            // P[i] = max(values[i] + min(P[i + 2], P[i + 3]),
|  48|    |-            //            values[i] + values[i + 1] + min(P[i + 3], P[i + 4]))
|  49|    |-            P[i] = max(values[i] + min(b, c),  values[i] + a + min(c, d));
|  50|    |-        }
|    |  42|+        for (int i = values.size () - 1; i >= 0; --i)
|    |  43|+          {
|    |  44|+              sum += values[i];
|    |  45|+              const int a = i + 1 < values.size ()? values[i + 1] : 0;
|    |  46|+              const int b = i + 2 < values.size ()? P[i + 2] : 0;
|    |  47|+              const int c = i + 3 < values.size ()? P[i + 3] : 0;
|    |  48|+              const int d = i + 4 < values.size ()? P[i + 4] : 0;
|    |  49|+              // P[i] = max(values[i] + min(P[i + 2], P[i + 3]),
|    |  50|+              //            values[i] + values[i + 1] + min(P[i + 3], P[i + 4]))
|    |  51|+                P[i] =
|    |  52|+                  max (values[i] + min (b, c), values[i] + a + min (c, d));
|    |  53|+          }
|  51|  54| 
|  52|  55|         return P[0] > sum - P[0];
|  53|  56|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // Ascending stack solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param matrix a boolean 2D matrix
|   9|  10|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|   8|   8|      * @param matrix a boolean 2D matrix
|   9|   9|      * @return an integer
|  10|  10|      */
|  11|    |-    int maximalRectangle(vector<vector<bool> > &matrix) {
|  12|    |-        if (matrix.empty() || matrix[0].empty()) {
|  13|    |-            return 0;
|  14|    |-        }
|    |  11|+    int maximalRectangle (vector < vector < bool > >&matrix)
|    |  12|+    {
|    |  13|+        if (matrix.empty () || matrix[0].empty ())
|    |  14|+          {
|    |  15|+              return 0;
|    |  16|+          }
|  15|  17| 
|  16|  18|         int res = 0;
|  17|  19|         vector<int> height(matrix[0].size(), 0);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|  14|  14|         }
|  15|  15| 
|  16|  16|         int res = 0;
|  17|    |-        vector<int> height(matrix[0].size(), 0);
|  18|    |-        for (int i = 0; i < matrix.size(); ++i) {
|  19|    |-            for (int j = 0; j < matrix[0].size(); ++j) {
|  20|    |-                height[j] = matrix[i][j] == 1 ? height[j] + 1 : 0;
|  21|    |-            }
|  22|    |-            res = max(res, largestRectangleArea(height));
|  23|    |-        }
|    |  17|+        vector < int >height (matrix[0].size (), 0);
|    |  18|+        for (int i = 0; i < matrix.size (); ++i)
|    |  19|+          {
|    |  20|+              for (int j = 0; j < matrix[0].size (); ++j)
|    |  21|+                {
|    |  22|+                    height[j] = matrix[i][j] == 1 ? height[j] + 1 : 0;
|    |  23|+                }
|    |  24|+              res = max (res, largestRectangleArea (height));
|    |  25|+          }
|  24|  26| 
|  25|  27|         return res;
|  26|  28|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|  25|  25|         return res;
|  26|  26|     }
|  27|  27| 
|  28|    |-private:
|  29|    |-    int largestRectangleArea(const vector<int> &height) {
|  30|    |-        stack<int> increasing_height;
|    |  28|+  private:
|    |  29|+    int largestRectangleArea (const vector < int >&height)
|    |  30|+    {
|    |  31|+        stack < int >increasing_height;
|  31|  32|         int max_area = 0;
|  32|  33| 
|  33|  34|         for (int i = 0; i <= height.size();) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|  30|  30|         stack<int> increasing_height;
|  31|  31|         int max_area = 0;
|  32|  32| 
|  33|    |-        for (int i = 0; i <= height.size();) {
|  34|    |-            if (increasing_height.empty() ||
|  35|    |-                (i < height.size() && height[i] > height[increasing_height.top()])) {
|  36|    |-                increasing_height.emplace(i);
|  37|    |-                ++i;
|  38|    |-            } else {
|  39|    |-                auto h = height[increasing_height.top()];
|  40|    |-                increasing_height.pop();
|  41|    |-                auto left = increasing_height.empty() ? -1 : increasing_height.top();
|  42|    |-                max_area = max(max_area, h * (i - left - 1));
|  43|    |-            }
|  44|    |-        }
|    |  33|+        for (int i = 0; i <= height.size ();)
|    |  34|+          {
|    |  35|+              if (increasing_height.empty () ||
|    |  36|+                  (i < height.size ()
|    |  37|+                   && height[i] > height[increasing_height.top ()]))
|    |  38|+                {
|    |  39|+                    increasing_height.emplace (i);
|    |  40|+                    ++i;
|    |  41|+                }
|    |  42|+              else
|    |  43|+                {
|    |  44|+                    auto h = height[increasing_height.top ()];
|    |  45|+                    increasing_height.pop ();
|    |  46|+                    auto left =
|    |  47|+                        increasing_height.empty ()? -1 : increasing_height.
|    |  48|+                        top ();
|    |  49|+                    max_area = max (max_area, h * (i - left - 1));
|    |  50|+                }
|    |  51|+          }
|  45|  52|         return max_area;
|  46|  53|     }
|  47|  54| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|  49|  49| // Time:  O(m * n)
|  50|  50| // Space: O(n)
|  51|  51| // DP solution.
|  52|    |-class Solution2 {
|  53|    |-public:
|    |  52|+class Solution2
|    |  53|+{
|    |  54|+  public:
|  54|  55|     /**
|  55|  56|      * @param matrix a boolean 2D matrix
|  56|  57|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximal-rectangle.cpp
|    |++++| /app/C++/maximal-rectangle.cpp
|  55|  55|      * @param matrix a boolean 2D matrix
|  56|  56|      * @return an integer
|  57|  57|      */
|  58|    |-    int maximalRectangle(vector<vector<bool> > &matrix) {
|  59|    |-        if (matrix.empty()) {
|  60|    |-            return 0;
|  61|    |-        }
|    |  58|+    int maximalRectangle (vector < vector < bool > >&matrix)
|    |  59|+    {
|    |  60|+        if (matrix.empty ())
|    |  61|+          {
|    |  62|+              return 0;
|    |  63|+          }
|  62|  64| 
|  63|    |-        const int m = matrix.size();
|  64|    |-        const int n = matrix.front().size();
|    |  65|+        const int m = matrix.size ();
|    |  66|+        const int n = matrix.front ().size ();
|  65|  67|         int res = 0;
|  66|    |-        vector<int> H(n, 0);  // Height of all ones rectangle include matrix[i][j].
|  67|    |-        vector<int> L(n, 0);  // Left closed bound of all ones rectangle include matrix[i][j].
|  68|    |-        vector<int> R(n, n);  // Right open bound of all onces rectangle include matrix[i][j].
|    |  68|+        vector < int >H (n, 0); // Height of all ones rectangle include matrix[i][j].
|    |  69|+        vector < int >L (n, 0); // Left closed bound of all ones rectangle include matrix[i][j].
|    |  70|+        vector < int >R (n, n); // Right open bound of all onces rectangle include matrix[i][j].
|  69|  71| 
|  70|    |-        for (int i = 0; i < m; ++i) {
|  71|    |-            int left = 0, right = n;
|  72|    |-            for (int j = 0; j < n; ++j) {
|  73|    |-                if (matrix[i][j] == 1) {
|  74|    |-                    ++H[j];  // Update height.
|  75|    |-                    L[j] = max(L[j], left); // Update left bound.
|  76|    |-                } else {
|  77|    |-                    left = j + 1;
|  78|    |-                    H[j] = L[j] = 0;
|  79|    |-                    R[j] = n;
|    |  72|+        for (int i = 0; i < m; ++i)
|    |  73|+          {
|    |  74|+              int left = 0, right = n;
|    |  75|+              for (int j = 0; j < n; ++j)
|    |  76|+                {
|    |  77|+                    if (matrix[i][j] == 1)
|    |  78|+                      {
|    |  79|+                          ++H[j];   // Update height.
|    |  80|+                          L[j] = max (L[j], left);  // Update left bound.
|    |  81|+                      }
|    |  82|+                    else
|    |  83|+                      {
|    |  84|+                          left = j + 1;
|    |  85|+                          H[j] = L[j] = 0;
|    |  86|+                          R[j] = n;
|    |  87|+                      }
|  80|  88|                 }
|  81|    |-            }
|  82|  89| 
|  83|    |-            for (int j = n - 1; j >= 0; --j) {
|  84|    |-                if (matrix[i][j] == 1) {
|  85|    |-                    R[j] = min(R[j], right);  // Update right bound.
|  86|    |-                    res = max(res, H[j] * (R[j] - L[j]));
|  87|    |-                } else {
|  88|    |-                    right = j;
|    |  90|+              for (int j = n - 1; j >= 0; --j)
|    |  91|+                {
|    |  92|+                    if (matrix[i][j] == 1)
|    |  93|+                      {
|    |  94|+                          R[j] = min (R[j], right); // Update right bound.
|    |  95|+                          res = max (res, H[j] * (R[j] - L[j]));
|    |  96|+                      }
|    |  97|+                    else
|    |  98|+                      {
|    |  99|+                          right = j;
|    | 100|+                      }
|  89| 101|                 }
|  90|    |-            }
|  91|    |-        }
|    | 102|+          }
|  92| 103| 
|  93| 104|         return res;
|  94| 105|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/update-bits.cpp
|    |++++| /app/C++/update-bits.cpp
|   1|   1| // Time:  O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param n, m: Two integer
|   8|   9|      *@param i, j: Two bit positions
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/update-bits.cpp
|    |++++| /app/C++/update-bits.cpp
|   8|   8|      *@param i, j: Two bit positions
|   9|   9|      *return: An integer
|  10|  10|      */
|  11|    |-    int updateBits(int n, int m, int i, int j) {
|    |  11|+    int updateBits (int n, int m, int i, int j)
|    |  12|+    {
|  12|  13|         int right_part = n & ((1 << i) - 1);
|  13|  14|         // The behavior of right shift >= 32 is undefined in C++.
|  14|  15|         int left_part = j >= 31 ? 0 : (n >> (j + 1)) << (j + 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/update-bits.cpp
|    |++++| /app/C++/update-bits.cpp
|  12|  12|         int right_part = n & ((1 << i) - 1);
|  13|  13|         // The behavior of right shift >= 32 is undefined in C++.
|  14|  14|         int left_part = j >= 31 ? 0 : (n >> (j + 1)) << (j + 1);
|  15|    |-        return left_part | (m << i) | right_part;
|    |  15|+          return left_part | (m << i) | right_part;
|  16|  16|     }
|  17|  17| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/submatrix-sum.cpp
|    |++++| /app/C++/submatrix-sum.cpp
|   1|   1| // Time:  O(m * n^2), where m > n
|   2|   2| // Space: O(m)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix an integer matrix
|   8|   9|      * @return the coordinate of the left-up and right-down number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/submatrix-sum.cpp
|    |++++| /app/C++/submatrix-sum.cpp
|   7|   7|      * @param matrix an integer matrix
|   8|   8|      * @return the coordinate of the left-up and right-down number
|   9|   9|      */
|  10|    |-    vector<vector<int>> submatrixSum(vector<vector<int>>& matrix) {
|  11|    |-        if (matrix.size() < matrix[0].size()) {  // Height is smaller.
|  12|    |-            return horizontal_search(matrix);
|  13|    |-        } else {  // Width is smaller.
|  14|    |-            return vertical_search(matrix);
|  15|    |-        }
|    |  10|+    vector < vector < int >>submatrixSum (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        if (matrix.size () < matrix[0].size ())
|    |  13|+          {                     // Height is smaller.
|    |  14|+              return horizontal_search (matrix);
|    |  15|+          }
|    |  16|+        else
|    |  17|+          {                     // Width is smaller.
|    |  18|+              return vertical_search (matrix);
|    |  19|+          }
|  16|  20|     }
|  17|  21| 
|  18|  22|     vector<vector<int>> horizontal_search(const vector<vector<int>>& matrix) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/submatrix-sum.cpp
|    |++++| /app/C++/submatrix-sum.cpp
|  15|  15|         }
|  16|  16|     }
|  17|  17| 
|  18|    |-    vector<vector<int>> horizontal_search(const vector<vector<int>>& matrix) {
|  19|    |-        for (int up = 0; up < matrix.size(); ++up) {
|  20|    |-            vector<int> temp_row(matrix[0].size());
|  21|    |-            for (int down = up; down < matrix.size(); ++down) {
|  22|    |-                // Find sum of every mini-column between 
|  23|    |-                // up and down rows and save it into temp_row[]
|  24|    |-                for (int j = 0; j < matrix[0].size(); ++j) {
|  25|    |-                    temp_row[j] += matrix[down][j];
|    |  18|+    vector < vector < int >>horizontal_search (const vector < vector <
|    |  19|+                                               int >>&matrix)
|    |  20|+    {
|    |  21|+        for (int up = 0; up < matrix.size (); ++up)
|    |  22|+          {
|    |  23|+              vector < int >temp_row (matrix[0].size ());
|    |  24|+              for (int down = up; down < matrix.size (); ++down)
|    |  25|+                {
|    |  26|+                    // Find sum of every mini-column between 
|    |  27|+                    // up and down rows and save it into temp_row[]
|    |  28|+                    for (int j = 0; j < matrix[0].size (); ++j)
|    |  29|+                      {
|    |  30|+                          temp_row[j] += matrix[down][j];
|    |  31|+                      }
|    |  32|+
|    |  33|+                    // Find the subarray which equals to zero in temp_row[].
|    |  34|+                    const auto & left_right = subarraySum (temp_row);
|    |  35|+                    if (!left_right.empty ())
|    |  36|+                      {
|    |  37|+                          return
|    |  38|+                          {
|    |  39|+                              {
|    |  40|+                              up, left_right[0]}
|    |  41|+                              ,
|    |  42|+                              {
|    |  43|+                              down, left_right[1]}
|    |  44|+                          };
|    |  45|+                      }
|  26|  46|                 }
|  27|    |-
|  28|    |-                // Find the subarray which equals to zero in temp_row[].
|  29|    |-                const auto& left_right = subarraySum(temp_row);
|  30|    |-                if (!left_right.empty()) {
|  31|    |-                    return {{up, left_right[0]}, {down, left_right[1]}};
|  32|    |-                }
|  33|    |-            }
|  34|    |-        }
|  35|    |-        return {{-1, -1}, {-1, -1}};
|    |  47|+          }
|    |  48|+        return
|    |  49|+        {
|    |  50|+            {
|    |  51|+            -1, -1}
|    |  52|+            ,
|    |  53|+            {
|    |  54|+            -1, -1}
|    |  55|+        };
|  36|  56|     }
|  37|  57| 
|  38|  58|     vector<vector<int>> vertical_search(const vector<vector<int>>& matrix) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/submatrix-sum.cpp
|    |++++| /app/C++/submatrix-sum.cpp
|  35|  35|         return {{-1, -1}, {-1, -1}};
|  36|  36|     }
|  37|  37| 
|  38|    |-    vector<vector<int>> vertical_search(const vector<vector<int>>& matrix) {
|  39|    |-        for (int left = 0; left < matrix[0].size(); ++left) {
|  40|    |-            vector<int> temp_col(matrix.size());
|  41|    |-            for (int right = left; right < matrix[0].size(); ++right) {
|  42|    |-                // Find sum of every mini-row between 
|  43|    |-                // left and right cols and save it into temp_col[]
|  44|    |-                for (int i = 0; i < matrix.size(); ++i) {
|  45|    |-                    temp_col[i] += matrix[i][right];
|    |  38|+    vector < vector < int >>vertical_search (const vector < vector <
|    |  39|+                                             int >>&matrix)
|    |  40|+    {
|    |  41|+        for (int left = 0; left < matrix[0].size (); ++left)
|    |  42|+          {
|    |  43|+              vector < int >temp_col (matrix.size ());
|    |  44|+              for (int right = left; right < matrix[0].size (); ++right)
|    |  45|+                {
|    |  46|+                    // Find sum of every mini-row between 
|    |  47|+                    // left and right cols and save it into temp_col[]
|    |  48|+                    for (int i = 0; i < matrix.size (); ++i)
|    |  49|+                      {
|    |  50|+                          temp_col[i] += matrix[i][right];
|    |  51|+                      }
|    |  52|+
|    |  53|+                    // Find the subarray which equals to zero in temp_col[].
|    |  54|+                    const auto & up_down = subarraySum (temp_col);
|    |  55|+                    if (!up_down.empty ())
|    |  56|+                      {
|    |  57|+                          return
|    |  58|+                          {
|    |  59|+                              {
|    |  60|+                              up_down[0], left}
|    |  61|+                              ,
|    |  62|+                              {
|    |  63|+                              up_down[1], right}
|    |  64|+                          };
|    |  65|+                      }
|  46|  66|                 }
|  47|    |-
|  48|    |-                // Find the subarray which equals to zero in temp_col[].
|  49|    |-                const auto& up_down = subarraySum(temp_col);
|  50|    |-                if (!up_down.empty()) {
|  51|    |-                    return {{up_down[0], left}, {up_down[1], right}};
|  52|    |-                }
|  53|    |-            }
|  54|    |-        }
|  55|    |-        return {{-1, -1}, {-1, -1}};
|    |  67|+          }
|    |  68|+        return
|    |  69|+        {
|    |  70|+            {
|    |  71|+            -1, -1}
|    |  72|+            ,
|    |  73|+            {
|    |  74|+            -1, -1}
|    |  75|+        };
|  56|  76|     }
|  57|  77| 
|  58|  78|     vector<int> subarraySum(const vector<int>& A) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/submatrix-sum.cpp
|    |++++| /app/C++/submatrix-sum.cpp
|  55|  55|         return {{-1, -1}, {-1, -1}};
|  56|  56|     }
|  57|  57| 
|  58|    |-    vector<int> subarraySum(const vector<int>& A) {
|  59|    |-        unordered_map<int, int> lookup;
|    |  58|+    vector < int >subarraySum (const vector < int >&A)
|    |  59|+    {
|    |  60|+        unordered_map < int, int >lookup;
|  60|  61|         lookup[0] = -1;
|  61|    |-        for (int i = 0, sum = 0; i < A.size(); ++i) {
|  62|    |-            sum += A[i];
|  63|    |-            if (!lookup.emplace(sum, i).second) {  // Already exists.
|  64|    |-                return {lookup[sum] + 1, i};
|  65|    |-            }
|  66|    |-        }
|  67|    |-        return {};
|    |  62|+        for (int i = 0, sum = 0; i < A.size (); ++i)
|    |  63|+          {
|    |  64|+              sum += A[i];
|    |  65|+              if (!lookup.emplace (sum, i).second)
|    |  66|+                {               // Already exists.
|    |  67|+                    return
|    |  68|+                    {
|    |  69|+                    lookup[sum] + 1, i};
|    |  70|+                }
|    |  71|+          }
|    |  72|+        return
|    |  73|+        {
|    |  74|+        };
|  68|  75|     }
|  69|  76| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-modify.cpp
|    |++++| /app/C++/segment-tree-modify.cpp
|  15|  15|  *     }
|  16|  16|  * }
|  17|  17|  */
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      *@param root, index, value: The root of segment tree and
|  22|  23|      *@ change the node's value with [index, index] to the new given value
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-modify.cpp
|    |++++| /app/C++/segment-tree-modify.cpp
|  22|  22|      *@ change the node's value with [index, index] to the new given value
|  23|  23|      *@return: void
|  24|  24|      */
|  25|    |-    void modify(SegmentTreeNode *root, int index, int value) {
|    |  25|+    void modify (SegmentTreeNode * root, int index, int value)
|    |  26|+    {
|  26|  27|         // Out of range.
|  27|    |-        if (root == nullptr || root->start > index || root->end < index) {
|  28|    |-            return;
|  29|    |-        }
|    |  28|+        if (root == nullptr || root->start > index || root->end < index)
|    |  29|+          {
|    |  30|+              return;
|    |  31|+          }
|  30|  32| 
|  31|  33|         // Change the node's value with [index, index] to the new given value.
|  32|  34|         if (root->start == index && root->end == index) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-modify.cpp
|    |++++| /app/C++/segment-tree-modify.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Change the node's value with [index, index] to the new given value.
|  32|    |-        if (root->start == index && root->end == index) {
|  33|    |-            root->max = value;
|  34|    |-            return;
|  35|    |-        }
|    |  32|+        if (root->start == index && root->end == index)
|    |  33|+          {
|    |  34|+              root->max = value;
|    |  35|+              return;
|    |  36|+          }
|  36|  37| 
|  37|    |-        modify(root->left, index, value);
|  38|    |-        modify(root->right, index, value);
|    |  38|+        modify (root->left, index, value);
|    |  39|+        modify (root->right, index, value);
|  39|  40| 
|  40|    |-        int left_max = root->left != nullptr? root->left->max : INT_MIN;
|  41|    |-        int right_max = root->right != nullptr? root->right->max : INT_MIN;
|    |  41|+        int left_max = root->left != nullptr ? root->left->max : INT_MIN;
|    |  42|+        int right_max = root->right != nullptr ? root->right->max : INT_MIN;
|  42|  43| 
|  43|  44|         // Update max.
|  44|  45|         root->max = max(left_max, right_max);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-modify.cpp
|    |++++| /app/C++/segment-tree-modify.cpp
|  41|  41|         int right_max = root->right != nullptr? root->right->max : INT_MIN;
|  42|  42| 
|  43|  43|         // Update max.
|  44|    |-        root->max = max(left_max, right_max);
|    |  44|+        root->max = max (left_max, right_max);
|  45|  45|     }
|  46|  46| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|     /**
|   6|   7|      * @param A: Given an integers array A
|   7|   8|      * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|   6|   6|      * @param A: Given an integers array A
|   7|   7|      * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
|   8|   8|      */
|   9|    |-public:
|  10|    |-    vector<long long> productExcludeItself(vector<int> &nums) {
|  11|    |-        if (nums.empty()) {
|  12|    |-            return {};
|  13|    |-        }
|    |   9|+  public:
|    |  10|+    vector < long long >productExcludeItself (vector < int >&nums)
|    |  11|+    {
|    |  12|+        if (nums.empty ())
|    |  13|+          {
|    |  14|+              return
|    |  15|+              {
|    |  16|+              };
|    |  17|+          }
|  14|  18| 
|  15|    |-        vector<long long> left_product(nums.size());
|    |  19|+        vector < long long >left_product (nums.size ());
|  16|  20| 
|  17|  21|         left_product[0] = 1;
|  18|  22|         for (int i = 1; i < nums.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|  15|  15|         vector<long long> left_product(nums.size());
|  16|  16| 
|  17|  17|         left_product[0] = 1;
|  18|    |-        for (int i = 1; i < nums.size(); ++i) {
|  19|    |-            left_product[i] = left_product[i - 1] * nums[i - 1];
|  20|    |-        }
|    |  18|+        for (int i = 1; i < nums.size (); ++i)
|    |  19|+          {
|    |  20|+              left_product[i] = left_product[i - 1] * nums[i - 1];
|    |  21|+          }
|  21|  22| 
|  22|  23|         long long right_product = 1;
|  23|  24|         for (int i = static_cast<int>(nums.size()) - 2; i >= 0; --i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|  20|  20|         }
|  21|  21| 
|  22|  22|         long long right_product = 1;
|  23|    |-        for (int i = static_cast<int>(nums.size()) - 2; i >= 0; --i) {
|  24|    |-            right_product *= nums[i + 1];
|  25|    |-            left_product[i] = left_product[i] * right_product;
|  26|    |-        }
|    |  23|+        for (int i = static_cast < int >(nums.size ()) - 2; i >= 0; --i)
|    |  24|+          {
|    |  25|+              right_product *= nums[i + 1];
|    |  26|+              left_product[i] = left_product[i] * right_product;
|    |  27|+          }
|  27|  28| 
|  28|  29|         return left_product;
|  29|  30|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|  31|  31| 
|  32|  32| // Time:  O(n)
|  33|  33| // Space: O(n)
|  34|    |-class Solution2 {
|  35|    |-public:
|    |  34|+class Solution2
|    |  35|+{
|    |  36|+  public:
|  36|  37|     /**
|  37|  38|      * @param A: Given an integers array A
|  38|  39|      * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|  37|  37|      * @param A: Given an integers array A
|  38|  38|      * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
|  39|  39|      */
|  40|    |-    vector<long long> productExcludeItself(vector<int> &nums) {
|  41|    |-        if (nums.empty()) {
|  42|    |-            return {};
|  43|    |-        }
|    |  40|+    vector < long long >productExcludeItself (vector < int >&nums)
|    |  41|+    {
|    |  42|+        if (nums.empty ())
|    |  43|+          {
|    |  44|+              return
|    |  45|+              {
|    |  46|+              };
|    |  47|+          }
|  44|  48| 
|  45|    |-        vector<long long> left_product(nums.size());
|  46|    |-        vector<long long> right_product(nums.size());
|  47|    |-        vector<long long> product(nums.size());
|    |  49|+        vector < long long >left_product (nums.size ());
|    |  50|+        vector < long long >right_product (nums.size ());
|    |  51|+        vector < long long >product (nums.size ());
|  48|  52| 
|  49|  53|         left_product[0] = 1;
|  50|  54|         for (int i = 1; i < nums.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/product-of-array-exclude-itself.cpp
|    |++++| /app/C++/product-of-array-exclude-itself.cpp
|  47|  47|         vector<long long> product(nums.size());
|  48|  48| 
|  49|  49|         left_product[0] = 1;
|  50|    |-        for (int i = 1; i < nums.size(); ++i) {
|  51|    |-            left_product[i] = left_product[i - 1] * nums[i - 1];
|  52|    |-        }
|    |  50|+        for (int i = 1; i < nums.size (); ++i)
|    |  51|+          {
|    |  52|+              left_product[i] = left_product[i - 1] * nums[i - 1];
|    |  53|+          }
|  53|  54| 
|  54|    |-        right_product[nums.size() - 1] = 1;
|  55|    |-        for (int j = static_cast<int>(nums.size()) - 2; j >= 0; --j) {
|  56|    |-            right_product[j] = right_product[j + 1] * nums[j + 1];
|  57|    |-        }
|    |  55|+        right_product[nums.size () - 1] = 1;
|    |  56|+        for (int j = static_cast < int >(nums.size ()) - 2; j >= 0; --j)
|    |  57|+          {
|    |  58|+              right_product[j] = right_product[j + 1] * nums[j + 1];
|    |  59|+          }
|  58|  60| 
|  59|    |-        for (int k = 0; k < nums.size(); ++k) {
|  60|    |-            product[k] = left_product[k] * right_product[k];
|  61|    |-        }
|    |  61|+        for (int k = 0; k < nums.size (); ++k)
|    |  62|+          {
|    |  63|+              product[k] = left_product[k] * right_product[k];
|    |  64|+          }
|  62|  65| 
|  63|  66|         return product;
|  64|  67|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // Merge sort. (stable)
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A an integer array
|   9|  10|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|   8|   8|      * @param A an integer array
|   9|   9|      * @return void
|  10|  10|      */
|  11|    |-    void sortIntegers2(vector<int>& A) {
|  12|    |-        mergeSort(&A, 0, A.size() - 1);
|    |  11|+    void sortIntegers2 (vector < int >&A)
|    |  12|+    {
|    |  13|+        mergeSort (&A, 0, A.size () - 1);
|  13|  14|     }
|  14|  15| 
|  15|  16| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  12|  12|         mergeSort(&A, 0, A.size() - 1);
|  13|  13|     }
|  14|  14| 
|  15|    |-private:
|  16|    |-    void mergeSort(vector<int> *A, int start, int end) {
|  17|    |-        if (end - start <= 0) {
|  18|    |-            return;
|  19|    |-        }
|    |  15|+  private:
|    |  16|+    void mergeSort (vector < int >*A, int start, int end)
|    |  17|+    {
|    |  18|+        if (end - start <= 0)
|    |  19|+          {
|    |  20|+              return;
|    |  21|+          }
|  20|  22|         int mid = start + (end - start) / 2;
|  21|    |-        mergeSort(A, start, mid);
|  22|    |-        mergeSort(A, mid + 1, end);
|    |  23|+        mergeSort (A, start, mid);
|    |  24|+        mergeSort (A, mid + 1, end);
|  23|  25| 
|  24|  26|         int l = start;
|  25|  27|         vector<int> tmp;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  22|  22|         mergeSort(A, mid + 1, end);
|  23|  23| 
|  24|  24|         int l = start;
|  25|    |-        vector<int> tmp;
|  26|    |-        for (int i = mid + 1; i <= end; ++i) {
|  27|    |-            // Merge the two sorted arrays into tmp.
|  28|    |-            while (l <= mid && (*A)[l] <= (*A)[i]) {
|  29|    |-                tmp.emplace_back((*A)[l++]);
|  30|    |-            }
|  31|    |-            tmp.emplace_back((*A)[i]);
|  32|    |-        }
|  33|    |-        while (l <= mid) {
|  34|    |-            tmp.emplace_back((*A)[l++]);
|  35|    |-        }
|    |  25|+        vector < int >tmp;
|    |  26|+        for (int i = mid + 1; i <= end; ++i)
|    |  27|+          {
|    |  28|+              // Merge the two sorted arrays into tmp.
|    |  29|+              while (l <= mid && (*A)[l] <= (*A)[i])
|    |  30|+                {
|    |  31|+                    tmp.emplace_back ((*A)[l++]);
|    |  32|+                }
|    |  33|+              tmp.emplace_back ((*A)[i]);
|    |  34|+          }
|    |  35|+        while (l <= mid)
|    |  36|+          {
|    |  37|+              tmp.emplace_back ((*A)[l++]);
|    |  38|+          }
|  36|  39|         // Copy tmp back to A.
|  37|    |-        copy(tmp.begin(), tmp.end(), A->begin() + start);
|    |  40|+        copy (tmp.begin (), tmp.end (), A->begin () + start);
|  38|  41|     }
|  39|  42| };
|  40|  43| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  41|  41| // Time:  O(nlogn)
|  42|  42| // Space: O(1)
|  43|  43| // Heap sort. (unstable)
|  44|    |-class Solution {
|  45|    |-public:
|    |  44|+class Solution
|    |  45|+{
|    |  46|+  public:
|  46|  47|     /**
|  47|  48|      * @param A an integer array
|  48|  49|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  47|  47|      * @param A an integer array
|  48|  48|      * @return void
|  49|  49|      */
|  50|    |-    void sortIntegers2(vector<int>& A) {
|  51|    |-        heapify(&A);
|  52|    |-        for (int i = static_cast<int>(A.size()) - 1; i >= 0; --i) {
|  53|    |-            swap(A[0], A[i]);
|  54|    |-            sift_down(&A, 0, i);
|  55|    |-        }
|    |  50|+    void sortIntegers2 (vector < int >&A)
|    |  51|+    {
|    |  52|+        heapify (&A);
|    |  53|+        for (int i = static_cast < int >(A.size ()) - 1; i >= 0; --i)
|    |  54|+          {
|    |  55|+              swap (A[0], A[i]);
|    |  56|+              sift_down (&A, 0, i);
|    |  57|+          }
|  56|  58|     }
|  57|  59| 
|  58|  60| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  55|  55|         }
|  56|  56|     }
|  57|  57| 
|  58|    |-private:
|  59|    |-    void heapify(vector<int> *A) {
|  60|    |-        for (int i = A->size() / 2; i >= 0; --i) {
|  61|    |-            sift_down(A, i, A->size());
|  62|    |-        }
|    |  58|+  private:
|    |  59|+    void heapify (vector < int >*A)
|    |  60|+    {
|    |  61|+        for (int i = A->size () / 2; i >= 0; --i)
|    |  62|+          {
|    |  63|+              sift_down (A, i, A->size ());
|    |  64|+          }
|  63|  65|     }
|  64|  66| 
|  65|  67|     void sift_down(vector<int> *A, int index, int size) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  62|  62|         }
|  63|  63|     }
|  64|  64| 
|  65|    |-    void sift_down(vector<int> *A, int index, int size) {
|  66|    |-        while (index < size) {
|  67|    |-            int largest = index;
|  68|    |-            if (index * 2 + 1 < size && (*A)[index * 2 + 1] > (*A)[largest]) {
|  69|    |-                largest = index * 2 + 1;
|  70|    |-            }
|  71|    |-            if (index * 2 + 2 < size && (*A)[index * 2 + 2] > (*A)[largest]) {
|  72|    |-                largest = index * 2 + 2;
|  73|    |-            }
|  74|    |-            if (largest == index) {
|  75|    |-                break;
|  76|    |-            }
|  77|    |-            swap((*A)[largest], (*A)[index]);
|  78|    |-            index = largest;
|  79|    |-        }
|    |  65|+    void sift_down (vector < int >*A, int index, int size)
|    |  66|+    {
|    |  67|+        while (index < size)
|    |  68|+          {
|    |  69|+              int largest = index;
|    |  70|+              if (index * 2 + 1 < size && (*A)[index * 2 + 1] > (*A)[largest])
|    |  71|+                {
|    |  72|+                    largest = index * 2 + 1;
|    |  73|+                }
|    |  74|+              if (index * 2 + 2 < size && (*A)[index * 2 + 2] > (*A)[largest])
|    |  75|+                {
|    |  76|+                    largest = index * 2 + 2;
|    |  77|+                }
|    |  78|+              if (largest == index)
|    |  79|+                {
|    |  80|+                    break;
|    |  81|+                }
|    |  82|+              swap ((*A)[largest], (*A)[index]);
|    |  83|+              index = largest;
|    |  84|+          }
|  80|  85|     }
|  81|  86| };
|  82|  87| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  83|  83| // Time:  O(nlogn) ~ O(n^2)
|  84|  84| // Space: O(logn) ~ O(n)
|  85|  85| // Quick sort. (unstable)
|  86|    |-class Solution {
|  87|    |-public:
|    |  86|+class Solution
|    |  87|+{
|    |  88|+  public:
|  88|  89|     /**
|  89|  90|      * @param A an integer array
|  90|  91|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  89|  89|      * @param A an integer array
|  90|  90|      * @return void
|  91|  91|      */
|  92|    |-    void sortIntegers2(vector<int>& A) {
|  93|    |-        quickSort(&A, 0, A.size() - 1);
|    |  92|+    void sortIntegers2 (vector < int >&A)
|    |  93|+    {
|    |  94|+        quickSort (&A, 0, A.size () - 1);
|  94|  95|     }
|  95|  96| 
|  96|  97| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
|  93|  93|         quickSort(&A, 0, A.size() - 1);
|  94|  94|     }
|  95|  95| 
|  96|    |-private:
|  97|    |-    void quickSort(vector<int> *A, int left, int right) {
|  98|    |-        if (left <= right) {
|  99|    |-            return;
| 100|    |-        }
| 101|    |-        default_random_engine gen((random_device())());
| 102|    |-        uniform_int_distribution<int> dis(left, right);
| 103|    |-        int pivot_idx = PartitionAroundPivot(left, right, dis(gen), A);
| 104|    |-        quickSort(A, left, pivot_idx - 1);
| 105|    |-        quickSort(A, pivot_idx + 1, right);
|    |  96|+  private:
|    |  97|+    void quickSort (vector < int >*A, int left, int right)
|    |  98|+    {
|    |  99|+        if (left <= right)
|    | 100|+          {
|    | 101|+              return;
|    | 102|+          }
|    | 103|+        default_random_engine gen ((random_device ())());
|    | 104|+        uniform_int_distribution < int >dis (left, right);
|    | 105|+        int pivot_idx = PartitionAroundPivot (left, right, dis (gen), A);
|    | 106|+        quickSort (A, left, pivot_idx - 1);
|    | 107|+        quickSort (A, pivot_idx + 1, right);
| 106| 108|     }
| 107| 109| 
| 108| 110|     int PartitionAroundPivot(int left, int right,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
| 105| 105|         quickSort(A, pivot_idx + 1, right);
| 106| 106|     }
| 107| 107| 
| 108|    |-    int PartitionAroundPivot(int left, int right,
| 109|    |-                             int pivot_idx, vector<int> *A) {
|    | 108|+    int PartitionAroundPivot (int left, int right,
|    | 109|+                              int pivot_idx, vector < int >*A)
|    | 110|+    {
| 110| 111|         int pivot_value = (*A)[pivot_idx];
| 111| 112|         int new_pivot_idx = left;
| 112| 113|         swap((*A)[pivot_idx], (*A)[right]);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers-ii.cpp
|    |++++| /app/C++/sort-integers-ii.cpp
| 109| 109|                              int pivot_idx, vector<int> *A) {
| 110| 110|         int pivot_value = (*A)[pivot_idx];
| 111| 111|         int new_pivot_idx = left;
| 112|    |-        swap((*A)[pivot_idx], (*A)[right]);
| 113|    |-        for (int i = left; i < right; ++i) {
| 114|    |-            if ((*A)[i] < pivot_value) {
| 115|    |-                swap((*A)[i], (*A)[new_pivot_idx++]);
| 116|    |-            }
| 117|    |-        }
| 118|    |-        swap((*A)[right], (*A)[new_pivot_idx]);
|    | 112|+        swap ((*A)[pivot_idx], (*A)[right]);
|    | 113|+        for (int i = left; i < right; ++i)
|    | 114|+          {
|    | 115|+              if ((*A)[i] < pivot_value)
|    | 116|+                {
|    | 117|+                    swap ((*A)[i], (*A)[new_pivot_idx++]);
|    | 118|+                }
|    | 119|+          }
|    | 120|+        swap ((*A)[right], (*A)[new_pivot_idx]);
| 119| 121|         return new_pivot_idx;
| 120| 122|     }
| 121| 123| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-binary.cpp
|    |++++| /app/C++/add-binary.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param a a number
|   8|   9|      * @param b a number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-binary.cpp
|    |++++| /app/C++/add-binary.cpp
|   8|   8|      * @param b a number
|   9|   9|      * @return the result
|  10|  10|      */
|  11|    |-    string addBinary(string& a, string& b) {
|    |  11|+    string addBinary (string & a, string & b)
|    |  12|+    {
|  12|  13|         string result;
|  13|    |-        int result_length = max(a.length(), b.length()) ;
|    |  14|+        int result_length = max (a.length (), b.length ());
|  14|  15| 
|  15|  16|         int carry = 0;
|  16|  17|         for (int i = 0; i < result_length; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/add-binary.cpp
|    |++++| /app/C++/add-binary.cpp
|  13|  13|         int result_length = max(a.length(), b.length()) ;
|  14|  14| 
|  15|  15|         int carry = 0;
|  16|    |-        for (int i = 0; i < result_length; ++i) {
|  17|    |-            int a_bit_i = i < a.length() ? a[a.length() - 1 - i] - '0' : 0;
|  18|    |-            int b_bit_i = i < b.length() ? b[b.length() - 1 - i] - '0' : 0;
|  19|    |-            int sum = carry + a_bit_i + b_bit_i;
|  20|    |-            carry = sum / 2;
|  21|    |-            sum %= 2;
|  22|    |-            result.push_back('0' + sum);
|  23|    |-        }
|  24|    |-        if (carry) {
|  25|    |-            result.push_back('0' + carry);
|  26|    |-        }
|  27|    |-        reverse(result.begin(), result.end());
|    |  16|+        for (int i = 0; i < result_length; ++i)
|    |  17|+          {
|    |  18|+              int a_bit_i = i < a.length ()? a[a.length () - 1 - i] - '0' : 0;
|    |  19|+              int b_bit_i = i < b.length ()? b[b.length () - 1 - i] - '0' : 0;
|    |  20|+              int sum = carry + a_bit_i + b_bit_i;
|    |  21|+                carry = sum / 2;
|    |  22|+                sum %= 2;
|    |  23|+                result.push_back ('0' + sum);
|    |  24|+          }
|    |  25|+        if (carry)
|    |  26|+          {
|    |  27|+              result.push_back ('0' + carry);
|    |  28|+          }
|    |  29|+        reverse (result.begin (), result.end ());
|  28|  30| 
|  29|  31|         return result;
|  30|  32|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-product-subarray.cpp
|    |++++| /app/C++/maximum-product-subarray.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: a vector of integers
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-product-subarray.cpp
|    |++++| /app/C++/maximum-product-subarray.cpp
|   7|   7|      * @param nums: a vector of integers
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int maxProduct(vector<int>& nums) {
|    |  10|+    int maxProduct (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int global_max = INT_MIN, local_max = 1, local_min = 1;
|  12|  13| 
|  13|  14|         for (const auto& n : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-product-subarray.cpp
|    |++++| /app/C++/maximum-product-subarray.cpp
|  10|  10|     int maxProduct(vector<int>& nums) {
|  11|  11|         int global_max = INT_MIN, local_max = 1, local_min = 1;
|  12|  12| 
|  13|    |-        for (const auto& n : nums) {
|  14|    |-            int cur_max = local_max * n;
|  15|    |-            int cur_min = local_min * n;
|  16|    |-            local_max = max(n, max(cur_max, cur_min));
|  17|    |-            local_min = min(n, min(cur_max, cur_min));
|  18|    |-            global_max = max(global_max, local_max);
|  19|    |-        }
|    |  13|+        for (const auto & n:nums)
|    |  14|+          {
|    |  15|+              int cur_max = local_max * n;
|    |  16|+              int cur_min = local_min * n;
|    |  17|+                local_max = max (n, max (cur_max, cur_min));
|    |  18|+                local_min = min (n, min (cur_max, cur_min));
|    |  19|+                global_max = max (global_max, local_max);
|    |  20|+          }
|  20|  21| 
|  21|  22|         return global_max;
|  22|  23|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|    |++++| /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|  23|  23|  *     }
|  24|  24|  * }
|  25|  25|  */
|  26|    |-class Solution {
|  27|    |-public:
|    |  26|+class Solution
|    |  27|+{
|    |  28|+  public:
|  28|  29|     /**
|  29|  30|      * @param root: The root of tree
|  30|  31|      * @return: the head of doubly list node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|    |++++| /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|  29|  29|      * @param root: The root of tree
|  30|  30|      * @return: the head of doubly list node
|  31|  31|      */
|  32|    |-    DoublyListNode* bstToDoublyList(TreeNode* root) {
|    |  32|+    DoublyListNode * bstToDoublyList (TreeNode * root)
|    |  33|+    {
|  33|  34|         DoublyListNode *prev = nullptr, *head = nullptr;
|  34|    |-        treeToDoublyList(root, &prev, &head);
|  35|    |-        return head;
|    |  35|+          treeToDoublyList (root, &prev, &head);
|    |  36|+          return head;
|  36|  37|     }
|  37|  38| 
|  38|  39|     void treeToDoublyList(TreeNode *p, DoublyListNode **prev, DoublyListNode **head) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|    |++++| /app/C++/convert-binary-search-tree-to-doubly-linked-list.cpp
|  35|  35|         return head;
|  36|  36|     }
|  37|  37| 
|  38|    |-    void treeToDoublyList(TreeNode *p, DoublyListNode **prev, DoublyListNode **head) {
|  39|    |-      if (!p) {
|  40|    |-          return;
|  41|    |-      }
|  42|    |-      treeToDoublyList(p->left, prev, head);
|  43|    |-      DoublyListNode *root = new DoublyListNode(p->val);
|  44|    |-      if (!*prev) {
|  45|    |-          *head = root;
|  46|    |-      } else {
|  47|    |-          root->prev = *prev;
|  48|    |-          (*prev)->next = root;
|  49|    |-      }
|  50|    |-      *prev = root;
|  51|    |-      treeToDoublyList(p->right, prev, head);
|    |  38|+    void treeToDoublyList (TreeNode * p, DoublyListNode ** prev,
|    |  39|+                           DoublyListNode ** head)
|    |  40|+    {
|    |  41|+        if (!p)
|    |  42|+          {
|    |  43|+              return;
|    |  44|+          }
|    |  45|+        treeToDoublyList (p->left, prev, head);
|    |  46|+        DoublyListNode *root = new DoublyListNode (p->val);
|    |  47|+        if (!*prev)
|    |  48|+          {
|    |  49|+              *head = root;
|    |  50|+          }
|    |  51|+        else
|    |  52|+          {
|    |  53|+              root->prev = *prev;
|    |  54|+              (*prev)->next = root;
|    |  55|+          }
|    |  56|+        *prev = root;
|    |  57|+        treeToDoublyList (p->right, prev, head);
|  52|  58|     }
|  53|  59| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16| // Morris Traversal.
|  17|    |-class Solution {
|    |  17|+class Solution
|    |  18|+{
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: Inorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: Inorder in vector which contains node values.
|  21|  21|      */
|  22|    |-public:
|  23|    |-    vector<int> inorderTraversal(TreeNode *root) {
|  24|    |-        vector<int> res;
|    |  22|+  public:
|    |  23|+    vector < int >inorderTraversal (TreeNode * root)
|    |  24|+    {
|    |  25|+        vector < int >res;
|  25|  26|         TreeNode *prev = nullptr;
|  26|  27|         TreeNode *curr = root;
|  27|  28|         while (curr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  24|  24|         vector<int> res;
|  25|  25|         TreeNode *prev = nullptr;
|  26|  26|         TreeNode *curr = root;
|  27|    |-        while (curr) {
|  28|    |-            if (!curr->left) {
|  29|    |-                res.emplace_back(curr->val);
|  30|    |-                prev = curr;
|  31|    |-                curr = curr->right;
|  32|    |-            } else {
|  33|    |-                TreeNode *node = curr->left;
|  34|    |-                while (node->right && node->right != curr) {
|  35|    |-                    node = node->right;
|  36|    |-                }
|  37|    |-                if (!node->right) {
|  38|    |-                    node->right = curr;
|  39|    |-                    curr = curr->left;
|  40|    |-                } else {
|  41|    |-                    res.emplace_back(curr->val);
|    |  27|+        while (curr)
|    |  28|+          {
|    |  29|+              if (!curr->left)
|    |  30|+                {
|    |  31|+                    res.emplace_back (curr->val);
|  42|  32|                     prev = curr;
|  43|    |-                    node->right = nullptr;
|  44|  33|                     curr = curr->right;
|  45|  34|                 }
|  46|  35|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  43|  43|                     node->right = nullptr;
|  44|  44|                     curr = curr->right;
|  45|  45|                 }
|  46|    |-            }
|  47|    |-        }
|    |  46|+              else
|    |  47|+                {
|    |  48|+                    TreeNode *node = curr->left;
|    |  49|+                    while (node->right && node->right != curr)
|    |  50|+                      {
|    |  51|+                          node = node->right;
|    |  52|+                      }
|    |  53|+                    if (!node->right)
|    |  54|+                      {
|    |  55|+                          node->right = curr;
|    |  56|+                          curr = curr->left;
|    |  57|+                      }
|    |  58|+                    else
|    |  59|+                      {
|    |  60|+                          res.emplace_back (curr->val);
|    |  61|+                          prev = curr;
|    |  62|+                          node->right = nullptr;
|    |  63|+                          curr = curr->right;
|    |  64|+                      }
|    |  65|+                }
|    |  66|+          }
|  48|  67|         return res;
|  49|  68|     }
|  50|  69| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  52|  52| // Time:  O(n)
|  53|  53| // Space: O(h)
|  54|  54| // Stack solution.
|  55|    |-class Solution2 {
|    |  55|+class Solution2
|    |  56|+{
|  56|  57|     /**
|  57|  58|      * @param root: The root of binary tree.
|  58|  59|      * @return: Inorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-inorder-traversal.cpp
|    |++++| /app/C++/binary-tree-inorder-traversal.cpp
|  57|  57|      * @param root: The root of binary tree.
|  58|  58|      * @return: Inorder in vector which contains node values.
|  59|  59|      */
|  60|    |-public:
|  61|    |-    vector<int> inorderTraversal(TreeNode *root) {
|  62|    |-        vector<int> res;
|  63|    |-        stack<pair<TreeNode *, bool>> s;
|  64|    |-        s.emplace(root, false);
|  65|    |-        while (!s.empty()) {
|  66|    |-            bool visited;
|  67|    |-            tie(root, visited) = s.top();
|  68|    |-            s.pop();
|  69|    |-            if (root == nullptr) {
|  70|    |-                continue;
|  71|    |-            }
|  72|    |-            if (visited) {
|  73|    |-                res.emplace_back(root->val);
|  74|    |-            } else {
|  75|    |-                s.emplace(root->right, false);
|  76|    |-                s.emplace(root, true);
|  77|    |-                s.emplace(root->left, false);
|  78|    |-            }
|  79|    |-        }
|    |  60|+  public:
|    |  61|+    vector < int >inorderTraversal (TreeNode * root)
|    |  62|+    {
|    |  63|+        vector < int >res;
|    |  64|+          stack < pair < TreeNode *, bool >> s;
|    |  65|+          s.emplace (root, false);
|    |  66|+        while (!s.empty ())
|    |  67|+          {
|    |  68|+              bool visited;
|    |  69|+                tie (root, visited) = s.top ();
|    |  70|+                s.pop ();
|    |  71|+              if (root == nullptr)
|    |  72|+                {
|    |  73|+                    continue;
|    |  74|+                }
|    |  75|+              if (visited)
|    |  76|+                {
|    |  77|+                    res.emplace_back (root->val);
|    |  78|+                }
|    |  79|+              else
|    |  80|+                {
|    |  81|+                    s.emplace (root->right, false);
|    |  82|+                    s.emplace (root, true);
|    |  83|+                    s.emplace (root->left, false);
|    |  84|+                }
|    |  85|+          }
|  80|  86|         return res;
|  81|  87|     }
|  82|  88| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/simplify-path.cpp
|    |++++| /app/C++/simplify-path.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param path the original path
|   8|   9|      * @return the simplified path
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/simplify-path.cpp
|    |++++| /app/C++/simplify-path.cpp
|   7|   7|      * @param path the original path
|   8|   8|      * @return the simplified path
|   9|   9|      */
|  10|    |-    string simplifyPath(string& path) {
|  11|    |-        vector<string> names;
|  12|    |-        vector<string> tokens(move(split(path, '/')));
|  13|    |-        for (const auto& token : tokens) {
|  14|    |-            if (token == ".." && !names.empty()) {
|  15|    |-                names.pop_back();
|  16|    |-            } else if (token != ".." && token != "." && !token.empty()) {
|  17|    |-                names.emplace_back(token);
|  18|    |-            }
|  19|    |-        }
|  20|    |-        return string("/").append(join(names, '/'));
|    |  10|+    string simplifyPath (string & path)
|    |  11|+    {
|    |  12|+        vector < string > names;
|    |  13|+        vector < string > tokens (move (split (path, '/')));
|    |  14|+        for (const auto & token:tokens)
|    |  15|+          {
|    |  16|+              if (token == ".." && !names.empty ())
|    |  17|+                {
|    |  18|+                    names.pop_back ();
|    |  19|+                }
|    |  20|+              else if (token != ".." && token != "." && !token.empty ())
|    |  21|+                {
|    |  22|+                    names.emplace_back (token);
|    |  23|+                }
|    |  24|+          }
|    |  25|+        return string ("/").append (join (names, '/'));
|  21|  26|     }
|  22|  27| 
|  23|  28|     // Split string by delimitor.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/simplify-path.cpp
|    |++++| /app/C++/simplify-path.cpp
|  21|  21|     }
|  22|  22| 
|  23|  23|     // Split string by delimitor.
|  24|    |-    vector<string> split(const string& s, const char delim) {
|  25|    |-        vector<string> tokens;
|  26|    |-        stringstream ss(s);
|    |  24|+    vector < string > split (const string & s, const char delim)
|    |  25|+    {
|    |  26|+        vector < string > tokens;
|    |  27|+        stringstream ss (s);
|  27|  28|         string token;
|  28|    |-        while (getline(ss, token, delim)) {
|  29|    |-            tokens.emplace_back(token);
|  30|    |-        }
|    |  29|+        while (getline (ss, token, delim))
|    |  30|+          {
|    |  31|+              tokens.emplace_back (token);
|    |  32|+          }
|  31|  33|         return tokens;
|  32|  34|     }
|  33|  35| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/simplify-path.cpp
|    |++++| /app/C++/simplify-path.cpp
|  32|  32|     }
|  33|  33| 
|  34|  34|     // Join strings with delimitor.
|  35|    |-    string join(const vector<string>& names, const char delim) {
|    |  35|+    string join (const vector < string > &names, const char delim)
|    |  36|+    {
|  36|  37|         ostringstream ss;
|  37|    |-        if (!names.empty()) {
|  38|    |-            const string delim_str(1, delim);
|  39|    |-            copy(names.cbegin(), prev(names.cend()),
|  40|    |-                 ostream_iterator<string>(ss, delim_str.c_str()));
|  41|    |-            ss << names.back();
|  42|    |-        }
|  43|    |-        return ss.str();
|    |  38|+        if (!names.empty ())
|    |  39|+          {
|    |  40|+              const string delim_str (1, delim);
|    |  41|+              copy (names.cbegin (), prev (names.cend ()),
|    |  42|+                    ostream_iterator < string > (ss, delim_str.c_str ()));
|    |  43|+              ss << names.back ();
|    |  44|+          }
|    |  45|+        return ss.str ();
|  44|  46|     }
|  45|  47| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // BIT solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A an array
|   9|  10|      * @return total of reverse pairs
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|   8|   8|      * @param A an array
|   9|   9|      * @return total of reverse pairs
|  10|  10|      */
|  11|    |-    long long reversePairs(vector<int>& A) {
|    |  11|+    long long reversePairs (vector < int >&A)
|    |  12|+    {
|  12|  13|         // Get the place (position in the ascending order) of each number.
|  13|    |-        vector<int> sorted_A(A), places(A.size());
|  14|    |-        sort(sorted_A.begin(), sorted_A.end());
|  15|    |-        for (int i = 0; i < A.size(); ++i) {
|  16|    |-            places[i] = 
|  17|    |-                lower_bound(sorted_A.begin(), sorted_A.end(), A[i]) -
|  18|    |-                sorted_A.begin();
|  19|    |-        }
|    |  14|+        vector < int >sorted_A (A), places (A.size ());
|    |  15|+          sort (sorted_A.begin (), sorted_A.end ());
|    |  16|+        for (int i = 0; i < A.size (); ++i)
|    |  17|+          {
|    |  18|+              places[i] =
|    |  19|+                  lower_bound (sorted_A.begin (), sorted_A.end (), A[i]) -
|    |  20|+                  sorted_A.begin ();
|    |  21|+          }
|  20|  22|         // Count the smaller elements after the number.
|  21|  23|         long long count = 0;
|  22|  24|         vector<int> bit(A.size() + 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  19|  19|         }
|  20|  20|         // Count the smaller elements after the number.
|  21|  21|         long long count = 0;
|  22|    |-        vector<int> bit(A.size() + 1);
|  23|    |-        for (int i = A.size() - 1; i >= 0; --i) {
|  24|    |-            count += query(bit, places[i]);
|  25|    |-            add(bit, places[i] + 1, 1);
|  26|    |-        }
|    |  22|+        vector < int >bit (A.size () + 1);
|    |  23|+        for (int i = A.size () - 1; i >= 0; --i)
|    |  24|+          {
|    |  25|+              count += query (bit, places[i]);
|    |  26|+              add (bit, places[i] + 1, 1);
|    |  27|+          }
|  27|  28|         return count;
|  28|  29|     }
|  29|  30| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  27|  27|         return count;
|  28|  28|     }
|  29|  29| 
|  30|    |-private:
|  31|    |-    void add(vector<int>& bit, int i, int val) {
|  32|    |-        for (; i < bit.size(); i += lower_bit(i)) {
|  33|    |-            bit[i] += val;
|  34|    |-        }
|    |  30|+  private:
|    |  31|+    void add (vector < int >&bit, int i, int val)
|    |  32|+    {
|    |  33|+        for (; i < bit.size (); i += lower_bit (i))
|    |  34|+          {
|    |  35|+              bit[i] += val;
|    |  36|+          }
|  35|  37|     }
|  36|  38| 
|  37|  39|     int query(const vector<int>& bit, int i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  34|  34|         }
|  35|  35|     }
|  36|  36| 
|  37|    |-    int query(const vector<int>& bit, int i) {
|    |  37|+    int query (const vector < int >&bit, int i)
|    |  38|+    {
|  38|  39|         int sum = 0;
|  39|    |-        for (; i > 0; i -= lower_bit(i)) {
|  40|    |-            sum += bit[i];
|  41|    |-        }
|    |  40|+        for (; i > 0; i -= lower_bit (i))
|    |  41|+          {
|    |  42|+              sum += bit[i];
|    |  43|+          }
|  42|  44|         return sum;
|  43|  45|     }
|  44|  46| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  42|  42|         return sum;
|  43|  43|     }
|  44|  44| 
|  45|    |-    int lower_bit(int i) {
|    |  45|+    int lower_bit (int i)
|    |  46|+    {
|  46|  47|         return i & -i;
|  47|  48|     }
|  48|  49| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  50|  50| // Time:  O(nlogn)
|  51|  51| // Space: O(n)
|  52|  52| // Merge sort solution.
|  53|    |-class Solution2 {
|  54|    |-public:
|    |  53|+class Solution2
|    |  54|+{
|    |  55|+  public:
|  55|  56|     /**
|  56|  57|      * @param A an array
|  57|  58|      * @return total of reverse pairs
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  56|  56|      * @param A an array
|  57|  57|      * @return total of reverse pairs
|  58|  58|      */
|  59|    |-    long long reversePairs(vector<int>& A) {
|    |  59|+    long long reversePairs (vector < int >&A)
|    |  60|+    {
|  60|  61|         long long count = 0;
|  61|    |-        vector<pair<int, int>> num_idxs;
|  62|    |-        for (int i = 0; i < A.size(); ++i) {
|  63|    |-            num_idxs.emplace_back(A[i], i);
|  64|    |-        }
|  65|    |-        countAndMergeSort(&num_idxs, 0, num_idxs.size() - 1, &count);
|    |  62|+          vector < pair < int, int >>num_idxs;
|    |  63|+        for (int i = 0; i < A.size (); ++i)
|    |  64|+          {
|    |  65|+              num_idxs.emplace_back (A[i], i);
|    |  66|+          }
|    |  67|+        countAndMergeSort (&num_idxs, 0, num_idxs.size () - 1, &count);
|  66|  68|         return count;
|  67|  69|     }
|  68|  70| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  66|  66|         return count;
|  67|  67|     }
|  68|  68| 
|  69|    |-private:
|  70|    |-    void countAndMergeSort(vector<pair<int, int>> *num_idxs, int start, int end, long long *count) {
|  71|    |-        if (end - start <= 0) {  // The number of range [start, end] of which size is less than 2 doesn't need sort.
|  72|    |-            return;
|  73|    |-        }
|    |  69|+  private:
|    |  70|+    void countAndMergeSort (vector < pair < int, int >>*num_idxs, int start,
|    |  71|+                            int end, long long *count)
|    |  72|+    {
|    |  73|+        if (end - start <= 0)
|    |  74|+          {                     // The number of range [start, end] of which size is less than 2 doesn't need sort.
|    |  75|+              return;
|    |  76|+          }
|  74|  77|         int mid = start + (end - start) / 2;
|  75|    |-        countAndMergeSort(num_idxs, start, mid, count);
|  76|    |-        countAndMergeSort(num_idxs, mid + 1, end, count);
|    |  78|+        countAndMergeSort (num_idxs, start, mid, count);
|    |  79|+        countAndMergeSort (num_idxs, mid + 1, end, count);
|  77|  80| 
|  78|  81|         int l = start;
|  79|  82|         vector<pair<int, int>> tmp;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-pairs.cpp
|    |++++| /app/C++/reverse-pairs.cpp
|  76|  76|         countAndMergeSort(num_idxs, mid + 1, end, count);
|  77|  77| 
|  78|  78|         int l = start;
|  79|    |-        vector<pair<int, int>> tmp;
|  80|    |-        for (int i = mid + 1; i <= end; ++i) {
|  81|    |-            // Merge the two sorted arrays into tmp.
|  82|    |-            while (l <= mid && (*num_idxs)[l].first <= (*num_idxs)[i].first) {
|  83|    |-                tmp.emplace_back((*num_idxs)[l++]);
|  84|    |-            }
|  85|    |-            tmp.emplace_back((*num_idxs)[i]);
|  86|    |-            *count += mid - l + 1;
|  87|    |-        }
|  88|    |-        while (l <= mid) {
|  89|    |-            tmp.emplace_back((*num_idxs)[l++]);
|  90|    |-        }
|    |  79|+        vector < pair < int, int >>tmp;
|    |  80|+        for (int i = mid + 1; i <= end; ++i)
|    |  81|+          {
|    |  82|+              // Merge the two sorted arrays into tmp.
|    |  83|+              while (l <= mid && (*num_idxs)[l].first <= (*num_idxs)[i].first)
|    |  84|+                {
|    |  85|+                    tmp.emplace_back ((*num_idxs)[l++]);
|    |  86|+                }
|    |  87|+              tmp.emplace_back ((*num_idxs)[i]);
|    |  88|+              *count += mid - l + 1;
|    |  89|+          }
|    |  90|+        while (l <= mid)
|    |  91|+          {
|    |  92|+              tmp.emplace_back ((*num_idxs)[l++]);
|    |  93|+          }
|  91|  94|         // Copy tmp back to num_idxs.
|  92|    |-        copy(tmp.begin(), tmp.end(), num_idxs->begin() + start);
|    |  95|+        copy (tmp.begin (), tmp.end (), num_idxs->begin () + start);
|  93|  96|     }
|  94|  97| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-size-subarray-sum.cpp
|    |++++| /app/C++/minimum-size-subarray-sum.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Sliding window solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums: a vector of integers
|   9|  10|      * @param s: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-size-subarray-sum.cpp
|    |++++| /app/C++/minimum-size-subarray-sum.cpp
|   9|   9|      * @param s: an integer
|  10|  10|      * @return: an integer representing the minimum size of subarray
|  11|  11|      */
|  12|    |-    int minimumSize(vector<int> &nums, int s) {
|  13|    |-        int start = -1, sum = 0, min_size = numeric_limits<int>::max();
|  14|    |-        for (int i = 0; i < nums.size(); ++i) {
|  15|    |-            sum += nums[i];
|  16|    |-            while (sum >= s) {
|  17|    |-                min_size = min(min_size, i - start);
|  18|    |-                sum -= nums[++start];
|  19|    |-            }
|  20|    |-        }
|  21|    |-        if (min_size == numeric_limits<int>::max()) {
|  22|    |-            return 0;
|  23|    |-        }
|    |  12|+    int minimumSize (vector < int >&nums, int s)
|    |  13|+    {
|    |  14|+        int start = -1, sum = 0, min_size = numeric_limits < int >::max ();
|    |  15|+        for (int i = 0; i < nums.size (); ++i)
|    |  16|+          {
|    |  17|+              sum += nums[i];
|    |  18|+              while (sum >= s)
|    |  19|+                {
|    |  20|+                    min_size = min (min_size, i - start);
|    |  21|+                    sum -= nums[++start];
|    |  22|+                }
|    |  23|+          }
|    |  24|+        if (min_size == numeric_limits < int >::max ())
|    |  25|+          {
|    |  26|+              return 0;
|    |  27|+          }
|  24|  28|         return min_size;
|  25|  29|     }
|  26|  30| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-size-subarray-sum.cpp
|    |++++| /app/C++/minimum-size-subarray-sum.cpp
|  28|  28| // Time:  O(nlogn)
|  29|  29| // Space: O(n)
|  30|  30| // Binary search solution.
|  31|    |-class Solution2 {
|  32|    |-public:
|    |  31|+class Solution2
|    |  32|+{
|    |  33|+  public:
|  33|  34|     /**
|  34|  35|      * @param nums: a vector of integers
|  35|  36|      * @param s: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-size-subarray-sum.cpp
|    |++++| /app/C++/minimum-size-subarray-sum.cpp
|  35|  35|      * @param s: an integer
|  36|  36|      * @return: an integer representing the minimum size of subarray
|  37|  37|      */
|  38|    |-    int minimumSize(vector<int> &nums, int s) {
|  39|    |-        int min_size = numeric_limits<int>::max();
|  40|    |-        vector<int> sum_from_start(nums.size() + 1);
|  41|    |-        partial_sum(nums.cbegin(), nums.cend(), sum_from_start.begin() + 1);
|  42|    |-        for (int i = 0; i < nums.size(); ++i) {
|  43|    |-            const auto& end_it = lower_bound(sum_from_start.cbegin() + i,
|  44|    |-                                             sum_from_start.cend(),
|  45|    |-                                             sum_from_start[i] + s);
|  46|    |-            if (end_it != sum_from_start.cend()) {
|  47|    |-                int end = static_cast<int>(end_it - sum_from_start.cbegin());
|  48|    |-                min_size = min(min_size, end - i);
|  49|    |-            }
|  50|    |-        }
|  51|    |-        if (min_size == numeric_limits<int>::max()) {
|  52|    |-            return 0;
|  53|    |-        }
|    |  38|+    int minimumSize (vector < int >&nums, int s)
|    |  39|+    {
|    |  40|+        int min_size = numeric_limits < int >::max ();
|    |  41|+          vector < int >sum_from_start (nums.size () + 1);
|    |  42|+          partial_sum (nums.cbegin (), nums.cend (),
|    |  43|+                       sum_from_start.begin () + 1);
|    |  44|+        for (int i = 0; i < nums.size (); ++i)
|    |  45|+          {
|    |  46|+              const auto & end_it = lower_bound (sum_from_start.cbegin () + i,
|    |  47|+                                                 sum_from_start.cend (),
|    |  48|+                                                 sum_from_start[i] + s);
|    |  49|+              if (end_it != sum_from_start.cend ())
|    |  50|+                {
|    |  51|+                    int end =
|    |  52|+                        static_cast < int >(end_it - sum_from_start.cbegin ());
|    |  53|+                      min_size = min (min_size, end - i);
|    |  54|+                }
|    |  55|+          }
|    |  56|+        if (min_size == numeric_limits < int >::max ())
|    |  57|+          {
|    |  58|+              return 0;
|    |  59|+          }
|  54|  60|         return min_size;
|  55|  61|     }
|  56|  62| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house.cpp
|    |++++| /app/C++/paint-house.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param costs n x 3 cost matrix
|   8|   9|      * @return an integer, the minimum cost to paint all houses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house.cpp
|    |++++| /app/C++/paint-house.cpp
|   7|   7|      * @param costs n x 3 cost matrix
|   8|   8|      * @return an integer, the minimum cost to paint all houses
|   9|   9|      */
|  10|    |-    int minCost(vector<vector<int>>& costs) {
|  11|    |-        if (costs.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int minCost (vector < vector < int >>&costs)
|    |  11|+    {
|    |  12|+        if (costs.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|    |-        vector<vector<int>> min_cost(2, costs[0]);
|    |  17|+        vector < vector < int >>min_cost (2, costs[0]);
|  16|  18| 
|  17|    |-        const int n = costs.size();
|  18|    |-        for (int i = 1; i < n; ++i) {
|  19|    |-            min_cost[i % 2][0] = costs[i][0] +
|  20|    |-                                 min(min_cost[(i - 1) % 2][1],
|  21|    |-                                     min_cost[(i - 1) % 2][2]);
|  22|    |-            min_cost[i % 2][1] = costs[i][1] +
|  23|    |-                                 min(min_cost[(i - 1) % 2][0],
|  24|    |-                                     min_cost[(i - 1) % 2][2]);
|  25|    |-            min_cost[i % 2][2] = costs[i][2] +
|  26|    |-                                 min(min_cost[(i - 1) % 2][0],
|  27|    |-                                     min_cost[(i - 1) % 2][1]);
|  28|    |-        }
|    |  19|+        const int n = costs.size ();
|    |  20|+        for (int i = 1; i < n; ++i)
|    |  21|+          {
|    |  22|+              min_cost[i % 2][0] = costs[i][0] +
|    |  23|+                  min (min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2]);
|    |  24|+              min_cost[i % 2][1] = costs[i][1] +
|    |  25|+                  min (min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2]);
|    |  26|+              min_cost[i % 2][2] = costs[i][2] +
|    |  27|+                  min (min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1]);
|    |  28|+          }
|  29|  29| 
|  30|    |-        return min(min_cost[(n - 1) % 2][0],
|  31|    |-                   min(min_cost[(n - 1) % 2][1], min_cost[(n - 1) % 2][2]));
|    |  30|+        return min (min_cost[(n - 1) % 2][0],
|    |  31|+                    min (min_cost[(n - 1) % 2][1], min_cost[(n - 1) % 2][2]));
|  32|  32|     }
|  33|  33| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // DP Solution
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param prices: Given an integer array
|   9|  10|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|   8|   8|      * @param prices: Given an integer array
|   9|   9|      * @return: Maximum profit
|  10|  10|      */
|  11|    |-    int maxProfit(vector<int> &prices) {
|    |  11|+    int maxProfit (vector < int >&prices)
|    |  12|+    {
|  12|  13|         int profit = 0;
|  13|    |-        for (int i = 0; i < static_cast<int>(prices.size()) - 1; ++i) {
|  14|    |-            profit += max(0, prices[i + 1] - prices[i]);
|  15|    |-        }
|    |  14|+        for (int i = 0; i < static_cast < int >(prices.size ()) - 1; ++i)
|    |  15|+          {
|    |  16|+              profit += max (0, prices[i + 1] - prices[i]);
|    |  17|+          }
|  16|  18|         return profit;
|  17|  19|     }
|  18|  20| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  18|  18| };
|  19|  19| 
|  20|  20| // Generic Solution
|  21|    |-class Solution2 {
|  22|    |-public:
|    |  21|+class Solution2
|    |  22|+{
|    |  23|+  public:
|  23|  24|     /**
|  24|  25|      * @param prices: Given an integer array
|  25|  26|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  24|  24|      * @param prices: Given an integer array
|  25|  25|      * @return: Maximum profit
|  26|  26|      */
|  27|    |-    int maxProfit(vector<int> &prices) {
|  28|    |-        const int k = prices.size();
|    |  27|+    int maxProfit (vector < int >&prices)
|    |  28|+    {
|    |  29|+        const int k = prices.size ();
|  29|  30| 
|  30|  31|         // Optimized solution for unlimited transactions.
|  31|  32|         if (k >= prices.size() / 2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  28|  28|         const int k = prices.size();
|  29|  29| 
|  30|  30|         // Optimized solution for unlimited transactions.
|  31|    |-        if (k >= prices.size() / 2) {
|  32|    |-            return maxUnlimitedTransactionsProfit(prices);
|  33|    |-        }
|    |  31|+        if (k >= prices.size () / 2)
|    |  32|+          {
|    |  33|+              return maxUnlimitedTransactionsProfit (prices);
|    |  34|+          }
|  34|  35| 
|  35|  36|         // Get max profit at most k transactions.
|  36|  37|         return maxAtMostKTransactionsProfit(prices, k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  33|  33|         }
|  34|  34| 
|  35|  35|         // Get max profit at most k transactions.
|  36|    |-        return maxAtMostKTransactionsProfit(prices, k);
|    |  36|+        return maxAtMostKTransactionsProfit (prices, k);
|  37|  37|     }
|  38|  38| 
|  39|  39|     int maxUnlimitedTransactionsProfit(const vector<int>& prices) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  36|  36|         return maxAtMostKTransactionsProfit(prices, k);
|  37|  37|     }
|  38|  38| 
|  39|    |-    int maxUnlimitedTransactionsProfit(const vector<int>& prices) {
|    |  39|+    int maxUnlimitedTransactionsProfit (const vector < int >&prices)
|    |  40|+    {
|  40|  41|         int profit = 0;
|  41|    |-        for (int i = 0; i < static_cast<int>(prices.size()) - 1; ++i) {
|  42|    |-            profit += max(0, prices[i + 1] - prices[i]);
|  43|    |-        }
|    |  42|+        for (int i = 0; i < static_cast < int >(prices.size ()) - 1; ++i)
|    |  43|+          {
|    |  44|+              profit += max (0, prices[i + 1] - prices[i]);
|    |  45|+          }
|  44|  46|         return profit;
|  45|  47|     }
|  46|  48| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  44|  44|         return profit;
|  45|  45|     }
|  46|  46| 
|  47|    |-    int maxAtMostKTransactionsProfit(const vector<int>& prices, const int k) {
|    |  47|+    int maxAtMostKTransactionsProfit (const vector < int >&prices, const int k)
|    |  48|+    {
|  48|  49|         // max_sell[j] short for max_sell[i][j]
|  49|  50|         // denotes as max profit at most j - 1 buy and sell transactions
|  50|  51|         // and buy the ith prices in the first i prices.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  48|  48|         // max_sell[j] short for max_sell[i][j]
|  49|  49|         // denotes as max profit at most j - 1 buy and sell transactions
|  50|  50|         // and buy the ith prices in the first i prices.
|  51|    |-        vector<int> max_sell(k + 1, INT_MIN);
|    |  51|+        vector < int >max_sell (k + 1, INT_MIN);
|  52|  52| 
|  53|  53|         // max_buy[j] short for max_buy[i][j]
|  54|  54|         // denotes as max profit at most j buy and sell transactions
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  53|  53|         // max_buy[j] short for max_buy[i][j]
|  54|  54|         // denotes as max profit at most j buy and sell transactions
|  55|  55|         // and sell the ith prices in the first i prices.
|  56|    |-        vector<int> max_buy(k + 1, INT_MIN);
|    |  56|+        vector < int >max_buy (k + 1, INT_MIN);
|  57|  57| 
|  58|  58|         max_sell[0] = max_buy[0] = 0;
|  59|  59| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock-ii.cpp
|  57|  57| 
|  58|  58|         max_sell[0] = max_buy[0] = 0;
|  59|  59| 
|  60|    |-        for (int i = 0; i < prices.size(); ++i) {
|  61|    |-            // Update max profix in [i / 2]  + 1 transactions.
|  62|    |-            for (int j = 1; j <= min(k, i / 2 + 1); ++j) {
|  63|    |-                // Update max profit of j-th buy
|  64|    |-                // by (j-1)-th sell - prices[i].
|  65|    |-                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i]);
|    |  60|+        for (int i = 0; i < prices.size (); ++i)
|    |  61|+          {
|    |  62|+              // Update max profix in [i / 2]  + 1 transactions.
|    |  63|+              for (int j = 1; j <= min (k, i / 2 + 1); ++j)
|    |  64|+                {
|    |  65|+                    // Update max profit of j-th buy
|    |  66|+                    // by (j-1)-th sell - prices[i].
|    |  67|+                    max_buy[j] = max (max_buy[j], max_sell[j - 1] - prices[i]);
|  66|  68| 
|  67|    |-                // Update max profit of jth sell
|  68|    |-                // by max(j-th buy + prices[i], (j-1)-th sell]).
|  69|    |-                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]);
|  70|    |-            }
|  71|    |-        }
|    |  69|+                    // Update max profit of jth sell
|    |  70|+                    // by max(j-th buy + prices[i], (j-1)-th sell]).
|    |  71|+                    max_sell[j] = max (max_sell[j], max_buy[j] + prices[i]);
|    |  72|+                }
|    |  73|+          }
|  72|  74| 
|  73|  75|         return max_sell[k];
|  74|  76|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-sequence.cpp
|    |++++| /app/C++/permutation-sequence.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: n
|   8|   9|      * @param k: the kth permutation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-sequence.cpp
|    |++++| /app/C++/permutation-sequence.cpp
|   8|   8|      * @param k: the kth permutation
|   9|   9|      * @return: return the k-th permutation
|  10|  10|      */
|  11|    |-    string getPermutation(int n, int k) {
|  12|    |-        vector<int> nums;
|    |  11|+    string getPermutation (int n, int k)
|    |  12|+    {
|    |  13|+        vector < int >nums;
|  13|  14|         int total = 1;
|  14|    |-        for (int i = 1; i <= n; ++i) {
|  15|    |-            nums.emplace_back(i);
|  16|    |-            total *= i;
|  17|    |-        }
|    |  15|+        for (int i = 1; i <= n; ++i)
|    |  16|+          {
|    |  17|+              nums.emplace_back (i);
|    |  18|+              total *= i;
|    |  19|+          }
|  18|  20| 
|  19|  21|         // Cantor Ordering:
|  20|  22|         // Construct the k-th permutation with a list of n numbers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-sequence.cpp
|    |++++| /app/C++/permutation-sequence.cpp
|  24|  24|         // construct the (((k - 1) % (n - 1)!) + 1)-th permutation with the remaining n-1 numbers
|  25|  25|         int group = total;
|  26|  26|         stringstream output;
|  27|    |-        while (n > 0) {
|  28|    |-            group /= n;
|  29|    |-            int idx = (k - 1) / group;
|  30|    |-            output << nums[idx];
|  31|    |-            nums.erase(nums.begin() + idx);
|  32|    |-            k = (k - 1) % group + 1;
|  33|    |-            --n;
|  34|    |-        }
|    |  27|+        while (n > 0)
|    |  28|+          {
|    |  29|+              group /= n;
|    |  30|+              int idx = (k - 1) / group;
|    |  31|+              output << nums[idx];
|    |  32|+              nums.erase (nums.begin () + idx);
|    |  33|+              k = (k - 1) % group + 1;
|    |  34|+              --n;
|    |  35|+          }
|  35|  36| 
|  36|    |-        return output.str();
|    |  37|+        return output.str ();
|  37|  38|     }
|  38|  39| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/plus-one.cpp
|    |++++| /app/C++/plus-one.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param digits a number represented as an array of digits
|   8|   9|      * @return the result
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/plus-one.cpp
|    |++++| /app/C++/plus-one.cpp
|   7|   7|      * @param digits a number represented as an array of digits
|   8|   8|      * @return the result
|   9|   9|      */
|  10|    |-    vector<int> plusOne(vector<int>& digits) {
|  11|    |-        vector<int> result(digits.cbegin(), digits.cend());
|    |  10|+    vector < int >plusOne (vector < int >&digits)
|    |  11|+    {
|    |  12|+        vector < int >result (digits.cbegin (), digits.cend ());
|  12|  13|         int carry = 1;
|  13|    |-        for (auto it = result.rbegin(); it != result.rend(); ++it) {
|  14|    |-            *it += carry;
|  15|    |-            carry = *it / 10;
|  16|    |-            *it %= 10;
|  17|    |-        }
|  18|    |-        if (carry == 1) {
|  19|    |-            result.emplace(result.begin(), carry);
|  20|    |-        }
|    |  14|+        for (auto it = result.rbegin (); it != result.rend (); ++it)
|    |  15|+          {
|    |  16|+              *it += carry;
|    |  17|+              carry = *it / 10;
|    |  18|+              *it %= 10;
|    |  19|+          }
|    |  20|+        if (carry == 1)
|    |  21|+          {
|    |  22|+              result.emplace (result.begin (), carry);
|    |  23|+          }
|  21|  24|         return result;
|  22|  25|     }
|  23|  26| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum.cpp
|    |++++| /app/C++/3-sum.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param numbers : Give an array numbers of n integer
|   8|   9|      * @return : Find all unique triplets in the array which gives the sum of zero.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum.cpp
|    |++++| /app/C++/3-sum.cpp
|   7|   7|      * @param numbers : Give an array numbers of n integer
|   8|   8|      * @return : Find all unique triplets in the array which gives the sum of zero.
|   9|   9|      */
|  10|    |-    vector<vector<int>> threeSum(vector<int> &nums) {
|  11|    |-        vector<vector<int>> ans;
|    |  10|+    vector < vector < int >>threeSum (vector < int >&nums)
|    |  11|+    {
|    |  12|+        vector < vector < int >>ans;
|  12|  13|         const int target = 0;
|  13|  14| 
|  14|  15|         // Make nums in increasing order. Time: O(nlogn)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum.cpp
|    |++++| /app/C++/3-sum.cpp
|  12|  12|         const int target = 0;
|  13|  13| 
|  14|  14|         // Make nums in increasing order. Time: O(nlogn)
|  15|    |-        sort(nums.begin(), nums.end());
|    |  15|+          sort (nums.begin (), nums.end ());
|  16|  16| 
|  17|    |-        for (int i = 0; i < static_cast<int>(nums.size()) - 2; ++i) {
|  18|    |-            if (i == 0 || nums[i] != nums[i - 1]) {  // Skip duplicated.
|  19|    |-                for (int j = i + 1, k = nums.size() - 1; j < k; ) {  // Time: O(n) for each i.
|  20|    |-                    if (j - 1 > i  && nums[j] == nums[j - 1]) {  // Skip duplicated.
|  21|    |-                        ++j;
|  22|    |-                    } else if (k + 1 < nums.size() && nums[k] == nums[k + 1]) {  // Skip duplicated.
|  23|    |-                        --k;
|  24|    |-                    } else {
|  25|    |-                        const auto sum = nums[i] + nums[j] + nums[k];
|  26|    |-                        if (sum > target) {  // Should decrease sum.
|  27|    |-                            --k;
|  28|    |-                        } else if (sum < target) {  // Should increase sum.
|  29|    |-                            ++j;
|  30|    |-                        } else {
|  31|    |-                            ans.push_back({nums[i], nums[j], nums[k]});
|  32|    |-                            ++j, --k;
|  33|    |-                        }
|  34|    |-                    }
|    |  17|+        for (int i = 0; i < static_cast < int >(nums.size ()) - 2; ++i)
|    |  18|+          {
|    |  19|+              if (i == 0 || nums[i] != nums[i - 1])
|    |  20|+                {               // Skip duplicated.
|    |  21|+                    for (int j = i + 1, k = nums.size () - 1; j < k;)
|    |  22|+                      {         // Time: O(n) for each i.
|    |  23|+                          if (j - 1 > i && nums[j] == nums[j - 1])
|    |  24|+                            {   // Skip duplicated.
|    |  25|+                                ++j;
|    |  26|+                            }
|    |  27|+                          else if (k + 1 < nums.size ()
|    |  28|+                                   && nums[k] == nums[k + 1])
|    |  29|+                            {   // Skip duplicated.
|    |  30|+                                --k;
|    |  31|+                            }
|    |  32|+                          else
|    |  33|+                            {
|    |  34|+                                const auto sum = nums[i] + nums[j] + nums[k];
|    |  35|+                                if (sum > target)
|    |  36|+                                  { // Should decrease sum.
|    |  37|+                                      --k;
|    |  38|+                                  }
|    |  39|+                                else if (sum < target)
|    |  40|+                                  { // Should increase sum.
|    |  41|+                                      ++j;
|    |  42|+                                  }
|    |  43|+                                else
|    |  44|+                                  {
|    |  45|+                                      ans.push_back (
|    |  46|+                                                        {
|    |  47|+                                                        nums[i], nums[j],
|    |  48|+                                                        nums[k]}
|    |  49|+                                      );
|    |  50|+                                      ++j, --k;
|    |  51|+                                  }
|    |  52|+                            }
|    |  53|+                      }
|  35|  54|                 }
|  36|    |-            }
|  37|    |-        }
|    |  55|+          }
|  38|  56| 
|  39|  57|         return ans;
|  40|  58|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum.cpp
|    |++++| /app/C++/3-sum.cpp
|  39|  39|         return ans;
|  40|  40|     }
|  41|  41| };
|  42|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Two pointer solution
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param heights: a vector of integers
|   9|  10|      * @return: a integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|   8|   8|      * @param heights: a vector of integers
|   9|   9|      * @return: a integer
|  10|  10|      */
|  11|    |-    int trapRainWater(vector<int> &heights) {
|  12|    |-        if (heights.empty()) {
|  13|    |-            return 0;
|  14|    |-        }
|    |  11|+    int trapRainWater (vector < int >&heights)
|    |  12|+    {
|    |  13|+        if (heights.empty ())
|    |  14|+          {
|    |  15|+              return 0;
|    |  16|+          }
|  15|  17| 
|  16|    |-        int i = 0, j = heights.size() - 1;
|    |  18|+        int i = 0, j = heights.size () - 1;
|  17|  19|         int left_height = heights[0];
|  18|    |-        int right_height = heights[heights.size() - 1];
|    |  20|+        int right_height = heights[heights.size () - 1];
|  19|  21|         int trap = 0;
|  20|  22| 
|  21|  23|         while (i < j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  18|  18|         int right_height = heights[heights.size() - 1];
|  19|  19|         int trap = 0;
|  20|  20| 
|  21|    |-        while (i < j) {
|  22|    |-            if (left_height < right_height) {
|  23|    |-                ++i;
|  24|    |-                // Fill in the gap.
|  25|    |-                trap += max(0, left_height - heights[i]);
|  26|    |-                // Update current max height from left.
|  27|    |-                left_height = max(left_height, heights[i]);
|  28|    |-            }
|  29|    |-            else {
|  30|    |-                --j;
|  31|    |-                // Fill in the gap.
|  32|    |-                trap += max(0, right_height - heights[j]);
|  33|    |-                // Update current max height from right.
|  34|    |-                right_height = max(right_height, heights[j]);
|  35|    |-            }
|  36|    |-        }
|    |  21|+        while (i < j)
|    |  22|+          {
|    |  23|+              if (left_height < right_height)
|    |  24|+                {
|    |  25|+                    ++i;
|    |  26|+                    // Fill in the gap.
|    |  27|+                    trap += max (0, left_height - heights[i]);
|    |  28|+                    // Update current max height from left.
|    |  29|+                    left_height = max (left_height, heights[i]);
|    |  30|+                }
|    |  31|+              else
|    |  32|+                {
|    |  33|+                    --j;
|    |  34|+                    // Fill in the gap.
|    |  35|+                    trap += max (0, right_height - heights[j]);
|    |  36|+                    // Update current max height from right.
|    |  37|+                    right_height = max (right_height, heights[j]);
|    |  38|+                }
|    |  39|+          }
|  37|  40| 
|  38|  41|         return trap;
|  39|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  40|  40| };
|  41|  41| 
|  42|  42| // Two pass scan solution
|  43|    |-class Solution2 {
|  44|    |-public:
|    |  43|+class Solution2
|    |  44|+{
|    |  45|+  public:
|  45|  46|     /**
|  46|  47|      * @param heights: a vector of integers
|  47|  48|      * @return: a integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  46|  46|      * @param heights: a vector of integers
|  47|  47|      * @return: a integer
|  48|  48|      */
|  49|    |-    int trapRainWater(vector<int> &heights) {
|    |  49|+    int trapRainWater (vector < int >&heights)
|    |  50|+    {
|  50|  51|         int trap = 0;
|  51|  52| 
|  52|  53|         // Find the top.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  51|  51| 
|  52|  52|         // Find the top.
|  53|  53|         int top = 0;
|  54|    |-        for (int i = 0; i < heights.size(); ++i) {
|  55|    |-            if (heights[top] < heights[i]) {
|  56|    |-                top = i;
|  57|    |-            }
|  58|    |-        }
|    |  54|+        for (int i = 0; i < heights.size (); ++i)
|    |  55|+          {
|    |  56|+              if (heights[top] < heights[i])
|    |  57|+                {
|    |  58|+                    top = i;
|    |  59|+                }
|    |  60|+          }
|  59|  61| 
|  60|  62|         // Count trapped water in the left of top.
|  61|  63|         int left_second_top = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  59|  59| 
|  60|  60|         // Count trapped water in the left of top.
|  61|  61|         int left_second_top = 0;
|  62|    |-        for (int i = 0; i < top; ++i) {
|  63|    |-            if (heights[left_second_top] < heights[i]) {
|  64|    |-                left_second_top = i;
|  65|    |-            }
|  66|    |-            trap += heights[left_second_top] - heights[i];
|  67|    |-        }
|    |  62|+        for (int i = 0; i < top; ++i)
|    |  63|+          {
|    |  64|+              if (heights[left_second_top] < heights[i])
|    |  65|+                {
|    |  66|+                    left_second_top = i;
|    |  67|+                }
|    |  68|+              trap += heights[left_second_top] - heights[i];
|    |  69|+          }
|  68|  70| 
|  69|  71|         // Count trapped water in the right of top.
|  70|  72|         int right_second_top = heights.size() - 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trapping-rain-water.cpp
|    |++++| /app/C++/trapping-rain-water.cpp
|  67|  67|         }
|  68|  68| 
|  69|  69|         // Count trapped water in the right of top.
|  70|    |-        int right_second_top = heights.size() - 1;
|  71|    |-        for (int i = heights.size() - 1; i > top; --i) {
|  72|    |-            if (heights[right_second_top] < heights[i]) {
|  73|    |-                right_second_top = i;
|  74|    |-            }
|  75|    |-            trap += heights[right_second_top] - heights[i];
|  76|    |-        }
|    |  70|+        int right_second_top = heights.size () - 1;
|    |  71|+        for (int i = heights.size () - 1; i > top; --i)
|    |  72|+          {
|    |  73|+              if (heights[right_second_top] < heights[i])
|    |  74|+                {
|    |  75|+                    right_second_top = i;
|    |  76|+                }
|    |  77|+              trap += heights[right_second_top] - heights[i];
|    |  78|+          }
|  77|  79| 
|  78|  80|         return trap;
|  79|  81|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle.cpp
|    |++++| /app/C++/linked-list-cycle.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: True if it has a cycle, or false
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle.cpp
|    |++++| /app/C++/linked-list-cycle.cpp
|  19|  19|      * @param head: The first node of linked list.
|  20|  20|      * @return: True if it has a cycle, or false
|  21|  21|      */
|  22|    |-    bool hasCycle(ListNode *head) {
|    |  22|+    bool hasCycle (ListNode * head)
|    |  23|+    {
|  23|  24|         auto slow = head, fast = head;
|  24|  25| 
|  25|  26|         while (fast && fast->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/linked-list-cycle.cpp
|    |++++| /app/C++/linked-list-cycle.cpp
|  22|  22|     bool hasCycle(ListNode *head) {
|  23|  23|         auto slow = head, fast = head;
|  24|  24| 
|  25|    |-        while (fast && fast->next) {
|  26|    |-            slow = slow->next, fast = fast->next->next;
|  27|    |-            if (slow == fast) {  // There is a cycle.
|  28|    |-                return true;
|  29|    |-            }
|  30|    |-        }
|  31|    |-        return false;  // No cycle.
|    |  25|+        while (fast && fast->next)
|    |  26|+          {
|    |  27|+              slow = slow->next, fast = fast->next->next;
|    |  28|+              if (slow == fast)
|    |  29|+                {               // There is a cycle.
|    |  30|+                    return true;
|    |  31|+                }
|    |  32|+          }
|    |  33|+        return false;           // No cycle.
|  32|  34|     }
|  33|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/restore-ip-addresses.cpp
|    |++++| /app/C++/restore-ip-addresses.cpp
|   1|   1| // Time:  O(n^m) = O(3^4)
|   2|   2| // Space: O(n * m) = O(3 * 4)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s the IP string
|   8|   9|      * @return All possible valid IP addresses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/restore-ip-addresses.cpp
|    |++++| /app/C++/restore-ip-addresses.cpp
|   7|   7|      * @param s the IP string
|   8|   8|      * @return All possible valid IP addresses
|   9|   9|      */
|  10|    |-    vector<string> restoreIpAddresses(string& s) {
|  11|    |-        vector<string> result;
|    |  10|+    vector < string > restoreIpAddresses (string & s)
|    |  11|+    {
|    |  12|+        vector < string > result;
|  12|  13|         string cur;
|  13|    |-        restoreIpAddressesHelper(s, 0, 0, &cur, &result);
|  14|    |-        return result;
|    |  14|+          restoreIpAddressesHelper (s, 0, 0, &cur, &result);
|    |  15|+          return result;
|  15|  16|     }
|  16|  17| 
|  17|  18|     void restoreIpAddressesHelper(const string& s,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/restore-ip-addresses.cpp
|    |++++| /app/C++/restore-ip-addresses.cpp
|  14|  14|         return result;
|  15|  15|     }
|  16|  16| 
|  17|    |-    void restoreIpAddressesHelper(const string& s,
|  18|    |-                                  int start, int dots,
|  19|    |-                                  string *cur,
|  20|    |-                                  vector<string> *result) {
|    |  17|+    void restoreIpAddressesHelper (const string & s,
|    |  18|+                                   int start, int dots,
|    |  19|+                                   string * cur, vector < string > *result)
|    |  20|+    {
|  21|  21|         // Pruning to improve performance.
|  22|    |-        if (((4 - dots) * 3 < s.length() - start) ||
|  23|    |-            ((4 - dots) > s.length() - start)) {
|  24|    |-            return;
|  25|    |-        }
|    |  22|+        if (((4 - dots) * 3 < s.length () - start) ||
|    |  23|+            ((4 - dots) > s.length () - start))
|    |  24|+          {
|    |  25|+              return;
|    |  26|+          }
|  26|  27| 
|  27|    |-        if (start == s.length() && dots == 4) {
|  28|    |-            result->emplace_back(cur->begin(), prev(cur->end()));
|  29|    |-        } else {
|  30|    |-            for (int i = start; i < start + 3; ++i) {
|  31|    |-                string tmp = s.substr(start, i - start + 1);
|  32|    |-                if (i < s.length() && isValid(tmp)) {
|  33|    |-                    tmp.push_back('.');
|  34|    |-                    cur->append(tmp);
|  35|    |-                    restoreIpAddressesHelper(s, i + 1, dots + 1, cur, result);
|  36|    |-                    cur->resize(cur->length() - (i - start + 2));
|    |  28|+        if (start == s.length () && dots == 4)
|    |  29|+          {
|    |  30|+              result->emplace_back (cur->begin (), prev (cur->end ()));
|    |  31|+          }
|    |  32|+        else
|    |  33|+          {
|    |  34|+              for (int i = start; i < start + 3; ++i)
|    |  35|+                {
|    |  36|+                    string tmp = s.substr (start, i - start + 1);
|    |  37|+                    if (i < s.length () && isValid (tmp))
|    |  38|+                      {
|    |  39|+                          tmp.push_back ('.');
|    |  40|+                          cur->append (tmp);
|    |  41|+                          restoreIpAddressesHelper (s, i + 1, dots + 1, cur,
|    |  42|+                                                    result);
|    |  43|+                          cur->resize (cur->length () - (i - start + 2));
|    |  44|+                      }
|  37|  45|                 }
|  38|    |-            }
|  39|    |-        }
|    |  46|+          }
|  40|  47|     }
|  41|  48| 
|  42|  49|     bool isValid(const string &s) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/restore-ip-addresses.cpp
|    |++++| /app/C++/restore-ip-addresses.cpp
|  39|  39|         }
|  40|  40|     }
|  41|  41| 
|  42|    |-    bool isValid(const string &s) {
|  43|    |-        if (s.empty() || (s[0] == '0' && s != "0")) {
|  44|    |-            return false;
|  45|    |-        }
|  46|    |-        return stoi(s) < 256;
|    |  42|+    bool isValid (const string & s)
|    |  43|+    {
|    |  44|+        if (s.empty () || (s[0] == '0' && s != "0"))
|    |  45|+          {
|    |  46|+              return false;
|    |  47|+          }
|    |  48|+        return stoi (s) < 256;
|  47|  49|     }
|  48|  50| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-linked-list-elements.cpp
|    |++++| /app/C++/remove-linked-list-elements.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head a ListNode
|  16|  17|      * @param val an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-linked-list-elements.cpp
|    |++++| /app/C++/remove-linked-list-elements.cpp
|  16|  16|      * @param val an integer
|  17|  17|      * @return a ListNode
|  18|  18|      */
|  19|    |-    ListNode *removeElements(ListNode *head, int val) {
|  20|    |-        ListNode dummy{0};
|  21|    |-        dummy.next = head;
|    |  19|+    ListNode * removeElements (ListNode * head, int val)
|    |  20|+    {
|    |  21|+        ListNode dummy
|    |  22|+        {
|    |  23|+        0};
|    |  24|+          dummy.next = head;
|  22|  25|         auto prev = &dummy, curr = dummy.next;
|  23|    |-        
|  24|    |-        while (curr) {
|  25|    |-            if (curr->val == val) {
|  26|    |-                prev->next = curr->next;
|  27|    |-                delete curr;
|  28|    |-            } else {
|  29|    |-                prev = curr;
|  30|    |-            }
|  31|    |-            curr = curr->next;
|  32|    |-        }
|    |  26|+
|    |  27|+        while (curr)
|    |  28|+          {
|    |  29|+              if (curr->val == val)
|    |  30|+                {
|    |  31|+                    prev->next = curr->next;
|    |  32|+                    delete curr;
|    |  33|+                }
|    |  34|+              else
|    |  35|+                {
|    |  36|+                    prev = curr;
|    |  37|+                }
|    |  38|+              curr = curr->next;
|    |  39|+          }
|  33|  40|         return dummy.next;
|  34|  41|     }
|  35|  42| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // DP Solution
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param prices: Given an integer array
|   9|  10|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|   8|   8|      * @param prices: Given an integer array
|   9|   9|      * @return: Maximum profit
|  10|  10|      */
|  11|    |-    int maxProfit(vector<int> &prices) {
|  12|    |-        if (prices.empty()) {
|  13|    |-            return 0;
|  14|    |-        }
|    |  11|+    int maxProfit (vector < int >&prices)
|    |  12|+    {
|    |  13|+        if (prices.empty ())
|    |  14|+          {
|    |  15|+              return 0;
|    |  16|+          }
|  15|  17| 
|  16|    |-        int hold1 = numeric_limits<int>::min();
|  17|    |-        int release1 = numeric_limits<int>::min();
|    |  18|+        int hold1 = numeric_limits < int >::min ();
|    |  19|+        int release1 = numeric_limits < int >::min ();
|  18|  20| 
|  19|    |-        for (const auto& p : prices) {
|  20|    |-            hold1 = max(hold1, -p);
|  21|    |-            release1 = max(release1, hold1 + p);
|  22|    |-        }
|    |  21|+      for (const auto & p:prices)
|    |  22|+          {
|    |  23|+              hold1 = max (hold1, -p);
|    |  24|+              release1 = max (release1, hold1 + p);
|    |  25|+          }
|  23|  26| 
|  24|  27|         return release1;
|  25|  28|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  25|  25|     }
|  26|  26| };
|  27|  27| 
|  28|    |-class Solution2 {
|  29|    |-public:
|    |  28|+class Solution2
|    |  29|+{
|    |  30|+  public:
|  30|  31|     /**
|  31|  32|      * @param prices: Given an integer array
|  32|  33|      * @return: Maximum profit
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  31|  31|      * @param prices: Given an integer array
|  32|  32|      * @return: Maximum profit
|  33|  33|      */
|  34|    |-    int maxProfit(vector<int> &prices) {
|  35|    |-        if (prices.empty()) {
|  36|    |-            return 0;
|  37|    |-        }
|    |  34|+    int maxProfit (vector < int >&prices)
|    |  35|+    {
|    |  36|+        if (prices.empty ())
|    |  37|+          {
|    |  38|+              return 0;
|    |  39|+          }
|  38|  40| 
|  39|  41|         const int k = 1;
|  40|  42| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  39|  39|         const int k = 1;
|  40|  40| 
|  41|  41|         // Optimized solution for unlimited transactions.
|  42|    |-        if (k >= prices.size() / 2) {
|  43|    |-            return maxUnlimitedTransactionsProfit(prices);
|  44|    |-        }
|    |  42|+        if (k >= prices.size () / 2)
|    |  43|+          {
|    |  44|+              return maxUnlimitedTransactionsProfit (prices);
|    |  45|+          }
|  45|  46| 
|  46|  47|         // Get max profit at most k transactions.
|  47|  48|         return maxAtMostKTransactionsProfit(prices, k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  44|  44|         }
|  45|  45| 
|  46|  46|         // Get max profit at most k transactions.
|  47|    |-        return maxAtMostKTransactionsProfit(prices, k);
|    |  47|+        return maxAtMostKTransactionsProfit (prices, k);
|  48|  48|     }
|  49|  49| 
|  50|  50|     int maxUnlimitedTransactionsProfit(vector<int> &prices) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  47|  47|         return maxAtMostKTransactionsProfit(prices, k);
|  48|  48|     }
|  49|  49| 
|  50|    |-    int maxUnlimitedTransactionsProfit(vector<int> &prices) {
|    |  50|+    int maxUnlimitedTransactionsProfit (vector < int >&prices)
|    |  51|+    {
|  51|  52|         int profit = 0;
|  52|    |-        for (int i = 0; i < prices.size() - 1; ++i) {
|  53|    |-            profit += max(0, prices[i + 1] - prices[i]);
|  54|    |-        }
|    |  53|+        for (int i = 0; i < prices.size () - 1; ++i)
|    |  54|+          {
|    |  55|+              profit += max (0, prices[i + 1] - prices[i]);
|    |  56|+          }
|  55|  57|         return profit;
|  56|  58|     }
|  57|  59| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  55|  55|         return profit;
|  56|  56|     }
|  57|  57| 
|  58|    |-    int maxAtMostKTransactionsProfit(vector<int> &prices, int k) {
|    |  58|+    int maxAtMostKTransactionsProfit (vector < int >&prices, int k)
|    |  59|+    {
|  59|  60|         // max_sell[j] short for max_sell[i][j]
|  60|  61|         // denotes as max profit at most j - 1 buy and sell transactions
|  61|  62|         // and buy the ith prices in the first i prices.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  59|  59|         // max_sell[j] short for max_sell[i][j]
|  60|  60|         // denotes as max profit at most j - 1 buy and sell transactions
|  61|  61|         // and buy the ith prices in the first i prices.
|  62|    |-        vector<int> max_sell(k + 1, INT_MIN);
|    |  62|+        vector < int >max_sell (k + 1, INT_MIN);
|  63|  63| 
|  64|  64|         // max_buy[j] short for max_buy[i][j]
|  65|  65|         // denotes as max profit at most j buy and sell transactions
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  64|  64|         // max_buy[j] short for max_buy[i][j]
|  65|  65|         // denotes as max profit at most j buy and sell transactions
|  66|  66|         // and sell the ith prices in the first i prices.
|  67|    |-        vector<int> max_buy(k + 1, INT_MIN);
|    |  67|+        vector < int >max_buy (k + 1, INT_MIN);
|  68|  68| 
|  69|  69|         max_sell[0] = max_buy[0] = 0;
|  70|  70| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  68|  68| 
|  69|  69|         max_sell[0] = max_buy[0] = 0;
|  70|  70| 
|  71|    |-        for (int i = 0; i < prices.size(); ++i) {
|  72|    |-            // Update max profix in [i / 2]  + 1 transactions.
|  73|    |-            for (int j = 1; j <= min(k, i / 2 + 1); ++j) {
|  74|    |-                // Update max profit of j-th buy
|  75|    |-                // by (j-1)-th sell - prices[i].
|  76|    |-                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i]);
|    |  71|+        for (int i = 0; i < prices.size (); ++i)
|    |  72|+          {
|    |  73|+              // Update max profix in [i / 2]  + 1 transactions.
|    |  74|+              for (int j = 1; j <= min (k, i / 2 + 1); ++j)
|    |  75|+                {
|    |  76|+                    // Update max profit of j-th buy
|    |  77|+                    // by (j-1)-th sell - prices[i].
|    |  78|+                    max_buy[j] = max (max_buy[j], max_sell[j - 1] - prices[i]);
|  77|  79| 
|  78|    |-                // Update max profit of jth sell
|  79|    |-                // by max(j-th buy + prices[i], (j-1)-th sell]).
|  80|    |-                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]);
|  81|    |-            }
|  82|    |-        }
|    |  80|+                    // Update max profit of jth sell
|    |  81|+                    // by max(j-th buy + prices[i], (j-1)-th sell]).
|    |  82|+                    max_sell[j] = max (max_sell[j], max_buy[j] + prices[i]);
|    |  83|+                }
|    |  84|+          }
|  83|  85| 
|  84|  86|         return max_sell[k];
|  85|  87|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/best-time-to-buy-and-sell-stock.cpp
|    |++++| /app/C++/best-time-to-buy-and-sell-stock.cpp
|  84|  84|         return max_sell[k];
|  85|  85|     }
|  86|  86| };
|  87|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-list-with-random-pointer.cpp
|    |++++| /app/C++/copy-list-with-random-pointer.cpp
|   9|   9|  *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head: The head of linked list with a random pointer.
|  16|  17|      * @return: A new head of a deep copy of the list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-list-with-random-pointer.cpp
|    |++++| /app/C++/copy-list-with-random-pointer.cpp
|  15|  15|      * @param head: The head of linked list with a random pointer.
|  16|  16|      * @return: A new head of a deep copy of the list.
|  17|  17|      */
|  18|    |-    RandomListNode *copyRandomList(RandomListNode *head) {
|    |  18|+    RandomListNode * copyRandomList (RandomListNode * head)
|    |  19|+    {
|  19|  20|         // Insert the copied node after the original one.
|  20|    |-        for (auto curr = head; curr; curr = curr->next->next) {
|  21|    |-            auto node = new RandomListNode(curr->label);
|  22|    |-            node->next = curr->next;
|  23|    |-            curr->next = node;
|  24|    |-        }
|    |  21|+        for (auto curr = head; curr; curr = curr->next->next)
|    |  22|+          {
|    |  23|+              auto node = new RandomListNode (curr->label);
|    |  24|+                node->next = curr->next;
|    |  25|+                curr->next = node;
|    |  26|+          }
|  25|  27| 
|  26|  28|         // Update random node.
|  27|  29|         for (auto curr = head; curr; curr = curr->next->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-list-with-random-pointer.cpp
|    |++++| /app/C++/copy-list-with-random-pointer.cpp
|  24|  24|         }
|  25|  25| 
|  26|  26|         // Update random node.
|  27|    |-        for (auto curr = head; curr; curr = curr->next->next) {
|  28|    |-            if (curr->random) {
|  29|    |-                curr->next->random = curr->random->next;
|  30|    |-            }
|  31|    |-        }
|    |  27|+        for (auto curr = head; curr; curr = curr->next->next)
|    |  28|+          {
|    |  29|+              if (curr->random)
|    |  30|+                {
|    |  31|+                    curr->next->random = curr->random->next;
|    |  32|+                }
|    |  33|+          }
|  32|  34| 
|  33|  35|         // Seperate the copied nodes from original ones.
|  34|  36|         RandomListNode dummy{0};
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/copy-list-with-random-pointer.cpp
|    |++++| /app/C++/copy-list-with-random-pointer.cpp
|  31|  31|         }
|  32|  32| 
|  33|  33|         // Seperate the copied nodes from original ones.
|  34|    |-        RandomListNode dummy{0};
|    |  34|+        RandomListNode dummy
|    |  35|+        {
|    |  36|+        0};
|  35|  37|         for (auto curr = head, copy_curr = &dummy;
|  36|    |-             curr;
|  37|    |-             copy_curr = copy_curr->next, curr = curr->next) {
|  38|    |-            copy_curr->next = curr->next;
|  39|    |-            curr->next = curr->next->next;
|  40|    |-        }
|    |  38|+             curr; copy_curr = copy_curr->next, curr = curr->next)
|    |  39|+          {
|    |  40|+              copy_curr->next = curr->next;
|    |  41|+              curr->next = curr->next->next;
|    |  42|+          }
|  41|  43| 
|  42|  44|         return dummy.next;
|  43|  45|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/compare-strings.cpp
|    |++++| /app/C++/compare-strings.cpp
|   2|   2| // Space: O(c)
|   3|   3| 
|   4|   4| // len(A) is much larger than len(B), this solution is better
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A: A string includes Upper Case letters
|   9|  10|      * @param B: A string includes Upper Case letter
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/compare-strings.cpp
|    |++++| /app/C++/compare-strings.cpp
|  10|  10|      * @return:  if string A contains all of the characters in B return true
|  11|  11|      *           else return false
|  12|  12|      */
|  13|    |-    bool compareStrings(string A, string B) {
|  14|    |-        unordered_map<char, int> h;
|  15|    |-        for (const auto& c: B) {
|  16|    |-            ++h[c];
|  17|    |-        }
|    |  13|+    bool compareStrings (string A, string B)
|    |  14|+    {
|    |  15|+        unordered_map < char, int >h;
|    |  16|+        for (const auto & c:B)
|    |  17|+          {
|    |  18|+              ++h[c];
|    |  19|+          }
|  18|  20| 
|  19|    |-        size_t cnt = B.length();
|  20|    |-        for (const auto& c: A) {
|  21|    |-            if (h[c] > 0) {
|  22|    |-                --h[c];
|  23|    |-                --cnt;
|  24|    |-            }
|  25|    |-            if (cnt == 0) {
|  26|    |-                return true;
|  27|    |-            }
|  28|    |-        }
|    |  21|+        size_t cnt = B.length ();
|    |  22|+      for (const auto & c:A)
|    |  23|+          {
|    |  24|+              if (h[c] > 0)
|    |  25|+                {
|    |  26|+                    --h[c];
|    |  27|+                    --cnt;
|    |  28|+                }
|    |  29|+              if (cnt == 0)
|    |  30|+                {
|    |  31|+                    return true;
|    |  32|+                }
|    |  33|+          }
|  29|  34| 
|  30|    |-        if (cnt > 0) {
|  31|    |-            return false;
|  32|    |-        }
|    |  35|+        if (cnt > 0)
|    |  36|+          {
|    |  37|+              return false;
|    |  38|+          }
|  33|  39| 
|  34|  40|         return true;
|  35|  41|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/compare-strings.cpp
|    |++++| /app/C++/compare-strings.cpp
|  35|  35|     }
|  36|  36| };
|  37|  37| 
|  38|    |-class Solution2 {
|  39|    |-public:
|    |  38|+class Solution2
|    |  39|+{
|    |  40|+  public:
|  40|  41|     /**
|  41|  42|      * @param A: A string includes Upper Case letters
|  42|  43|      * @param B: A string includes Upper Case letter
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/compare-strings.cpp
|    |++++| /app/C++/compare-strings.cpp
|  43|  43|      * @return:  if string A contains all of the characters in B return true 
|  44|  44|      *           else return false
|  45|  45|      */
|  46|    |-    bool compareStrings(string A, string B) {
|  47|    |-        unordered_map<char, int> h;
|  48|    |-        for (const auto& c: A) {
|  49|    |-            ++h[c];
|  50|    |-        }
|    |  46|+    bool compareStrings (string A, string B)
|    |  47|+    {
|    |  48|+        unordered_map < char, int >h;
|    |  49|+        for (const auto & c:A)
|    |  50|+          {
|    |  51|+              ++h[c];
|    |  52|+          }
|  51|  53| 
|  52|    |-        for (const auto& c: B) {
|  53|    |-            if (--h[c] < 0) {
|  54|    |-                return false;
|  55|    |-            }
|  56|    |-        }
|    |  54|+        for (const auto & c:B)
|    |  55|+          {
|    |  56|+              if (--h[c] < 0)
|    |  57|+                {
|    |  58|+                    return false;
|    |  59|+                }
|    |  60|+          }
|  57|  61| 
|  58|  62|         return true;
|  59|  63|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/compare-strings.cpp
|    |++++| /app/C++/compare-strings.cpp
|  58|  58|         return true;
|  59|  59|     }
|  60|  60| };
|  61|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/clone-graph.cpp
|    |++++| /app/C++/clone-graph.cpp
|   9|   9|  *     UndirectedGraphNode(int x) : label(x) {};
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param node: A undirected graph node
|  16|  17|      * @return: A undirected graph node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/clone-graph.cpp
|    |++++| /app/C++/clone-graph.cpp
|  15|  15|      * @param node: A undirected graph node
|  16|  16|      * @return: A undirected graph node
|  17|  17|      */
|  18|    |-    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
|  19|    |-        if (!node) {
|  20|    |-            return nullptr;
|  21|    |-        }
|  22|    |-        unordered_map<const UndirectedGraphNode *, UndirectedGraphNode *> copied;
|  23|    |-        copied[node] = new UndirectedGraphNode(node->label);
|  24|    |-        queue<const UndirectedGraphNode *> q;
|  25|    |-        q.emplace(node);
|  26|    |-        while (!q.empty()) {
|  27|    |-            auto node = q.front();
|  28|    |-            q.pop();
|    |  18|+    UndirectedGraphNode * cloneGraph (UndirectedGraphNode * node)
|    |  19|+    {
|    |  20|+        if (!node)
|    |  21|+          {
|    |  22|+              return nullptr;
|    |  23|+          }
|    |  24|+        unordered_map < const UndirectedGraphNode *,
|    |  25|+            UndirectedGraphNode * >copied;
|    |  26|+        copied[node] = new UndirectedGraphNode (node->label);
|    |  27|+        queue < const UndirectedGraphNode *>q;
|    |  28|+        q.emplace (node);
|    |  29|+        while (!q.empty ())
|    |  30|+          {
|    |  31|+              auto node = q.front ();
|    |  32|+              q.pop ();
|  29|  33| 
|  30|    |-            for (const auto& n : node->neighbors) {
|  31|    |-                if (copied.find(n) == copied.end()) {
|  32|    |-                    copied[n] = new UndirectedGraphNode(n->label);
|  33|    |-                    q.emplace(n);
|    |  34|+            for (const auto & n:node->neighbors)
|    |  35|+                {
|    |  36|+                    if (copied.find (n) == copied.end ())
|    |  37|+                      {
|    |  38|+                          copied[n] = new UndirectedGraphNode (n->label);
|    |  39|+                          q.emplace (n);
|    |  40|+                      }
|    |  41|+
|    |  42|+                    copied[node]->neighbors.emplace_back (copied[n]);
|  34|  43|                 }
|  35|    |-
|  36|    |-                copied[node]->neighbors.emplace_back(copied[n]);
|  37|    |-            }
|  38|    |-        }
|    |  44|+          }
|  39|  45| 
|  40|  46|         return copied[node];
|  41|  47|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  15|  15|  *     }
|  16|  16|  * }
|  17|  17|  */
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      *@param A: a list of integer
|  22|  23|      *@return: The root of Segment Tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  21|  21|      *@param A: a list of integer
|  22|  22|      *@return: The root of Segment Tree
|  23|  23|      */
|  24|    |-    SegmentTreeNode * build(vector<int>& A) {
|  25|    |-        return buildRecu(A, 0, A.size() - 1);
|    |  24|+    SegmentTreeNode * build (vector < int >&A)
|    |  25|+    {
|    |  26|+        return buildRecu (A, 0, A.size () - 1);
|  26|  27|     }
|  27|  28| 
|  28|  29|     SegmentTreeNode *buildRecu(const vector<int>& A, 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  25|  25|         return buildRecu(A, 0, A.size() - 1);
|  26|  26|     }
|  27|  27| 
|  28|    |-    SegmentTreeNode *buildRecu(const vector<int>& A, 
|  29|    |-                               const int start, const int end) {
|  30|    |-        if (start > end) {
|  31|    |-            return nullptr;
|  32|    |-        }
|    |  28|+    SegmentTreeNode *buildRecu (const vector < int >&A,
|    |  29|+                                const int start, const int end)
|    |  30|+    {
|    |  31|+        if (start > end)
|    |  32|+          {
|    |  33|+              return nullptr;
|    |  34|+          }
|  33|  35|         // The root's start and end is given by build method.
|  34|    |-        SegmentTreeNode *root = new SegmentTreeNode(start, end, INT_MAX);
|    |  36|+        SegmentTreeNode *root = new SegmentTreeNode (start, end, INT_MAX);
|  35|  37| 
|  36|  38|         // If start equals to end, there will be no children for this node.
|  37|  39|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  34|  34|         SegmentTreeNode *root = new SegmentTreeNode(start, end, INT_MAX);
|  35|  35| 
|  36|  36|         // If start equals to end, there will be no children for this node.
|  37|    |-        if (start == end) {
|  38|    |-            root->max = A[start];
|  39|    |-            return root;
|  40|    |-        }
|    |  37|+        if (start == end)
|    |  38|+          {
|    |  39|+              root->max = A[start];
|    |  40|+              return root;
|    |  41|+          }
|  41|  42| 
|  42|  43|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  43|  44|         root->left = buildRecu(A, start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  40|  40|         }
|  41|  41| 
|  42|  42|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  43|    |-        root->left = buildRecu(A, start, (start + end) / 2);
|    |  43|+        root->left = buildRecu (A, start, (start + end) / 2);
|  44|  44| 
|  45|  45|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  46|  46|         root->right = buildRecu(A, (start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  43|  43|         root->left = buildRecu(A, start, (start + end) / 2);
|  44|  44| 
|  45|  45|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  46|    |-        root->right = buildRecu(A, (start + end) / 2 + 1, end);
|    |  46|+        root->right = buildRecu (A, (start + end) / 2 + 1, end);
|  47|  47| 
|  48|  48|         const int left_max = root->left != nullptr ? root->left->max : INT_MAX;
|  49|  49|         const int right_max = root->right != nullptr ? root->right->max : INT_MAX;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  46|  46|         root->right = buildRecu(A, (start + end) / 2 + 1, end);
|  47|  47| 
|  48|  48|         const int left_max = root->left != nullptr ? root->left->max : INT_MAX;
|  49|    |-        const int right_max = root->right != nullptr ? root->right->max : INT_MAX;
|    |  49|+        const int right_max =
|    |  50|+            root->right != nullptr ? root->right->max : INT_MAX;
|  50|  51| 
|  51|  52|         // Update max.
|  52|  53|         root->max = max(left_max, right_max);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build-ii.cpp
|    |++++| /app/C++/segment-tree-build-ii.cpp
|  49|  49|         const int right_max = root->right != nullptr ? root->right->max : INT_MAX;
|  50|  50| 
|  51|  51|         // Update max.
|  52|    |-        root->max = max(left_max, right_max);
|    |  52|+        root->max = max (left_max, right_max);
|  53|  53|         return root;
|  54|  54|     }
|  55|  55| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Only using integer type.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param dividend the dividend
|   9|  10|      * @param divisor the divisor
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|   9|   9|      * @param divisor the divisor
|  10|  10|      * @return the result
|  11|  11|      */
|  12|    |-    int divide(int dividend, int divisor) {
|    |  12|+    int divide (int dividend, int divisor)
|    |  13|+    {
|  13|  14|         // Handle corner case.
|  14|    |-        if (dividend == numeric_limits<int>::min() && divisor == -1) {
|  15|    |-            return numeric_limits<int>::max();
|  16|    |-        }
|    |  15|+        if (dividend == numeric_limits < int >::min () && divisor == -1)
|    |  16|+          {
|    |  17|+              return numeric_limits < int >::max ();
|    |  18|+          }
|  17|  19| 
|  18|  20|         int a = dividend > 0 ? -dividend : dividend;
|  19|  21|         int b = divisor > 0 ? -divisor : divisor;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  19|  19|         int b = divisor > 0 ? -divisor : divisor;
|  20|  20| 
|  21|  21|         int shift = 0;
|  22|    |-        while (b << shift < 0 && shift < 32) {
|  23|    |-            ++shift;
|  24|    |-        }
|    |  22|+        while (b << shift < 0 && shift < 32)
|    |  23|+          {
|    |  24|+              ++shift;
|    |  25|+          }
|  25|  26|         shift -= 1;
|  26|  27| 
|  27|  28|         int result = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  25|  25|         shift -= 1;
|  26|  26| 
|  27|  27|         int result = 0;
|  28|    |-        while (shift >= 0) {
|  29|    |-            if (a <= b << shift) {
|  30|    |-                a -= b << shift;
|  31|    |-                result += 1 << shift;
|  32|    |-            }
|  33|    |-            --shift;
|  34|    |-        }
|    |  28|+        while (shift >= 0)
|    |  29|+          {
|    |  30|+              if (a <= b << shift)
|    |  31|+                {
|    |  32|+                    a -= b << shift;
|    |  33|+                    result += 1 << shift;
|    |  34|+                }
|    |  35|+              --shift;
|    |  36|+          }
|  35|  37| 
|  36|    |-        result =  (dividend ^ divisor) >> 31 ? -result : result;
|    |  38|+        result = (dividend ^ divisor) >> 31 ? -result : result;
|  37|  39|         return result;
|  38|  40|     }
|  39|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  41|  41| // Time:  O(logn) = O(1)
|  42|  42| // Space: O(1)
|  43|  43| // Using long long type.
|  44|    |-class Solution2 {
|  45|    |-public:
|    |  44|+class Solution2
|    |  45|+{
|    |  46|+  public:
|  46|  47|     /**
|  47|  48|      * @param dividend the dividend
|  48|  49|      * @param divisor the divisor
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  48|  48|      * @param divisor the divisor
|  49|  49|      * @return the result
|  50|  50|      */
|  51|    |-    int divide(int dividend, int divisor) {
|    |  51|+    int divide (int dividend, int divisor)
|    |  52|+    {
|  52|  53|         long long result = 0;
|  53|    |-        long long a = llabs(dividend);
|  54|    |-        long long b = llabs(divisor);
|    |  54|+        long long a = llabs (dividend);
|    |  55|+        long long b = llabs (divisor);
|  55|  56| 
|  56|  57|         int shift = 31;
|  57|  58|         while (shift >= 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  54|  54|         long long b = llabs(divisor);
|  55|  55| 
|  56|  56|         int shift = 31;
|  57|    |-        while (shift >= 0) {
|  58|    |-            if (a >= b << shift) {
|  59|    |-                a -= b << shift;
|  60|    |-                result += 1LL << shift;
|  61|    |-            }
|  62|    |-            --shift;
|  63|    |-        }
|    |  57|+        while (shift >= 0)
|    |  58|+          {
|    |  59|+              if (a >= b << shift)
|    |  60|+                {
|    |  61|+                    a -= b << shift;
|    |  62|+                    result += 1LL << shift;
|    |  63|+                }
|    |  64|+              --shift;
|    |  65|+          }
|  64|  66| 
|  65|  67|         result = ((dividend ^ divisor) >> 31) ? -result : result;
|  66|  68|         return min(result, static_cast<long long>(numeric_limits<int>::max()));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  63|  63|         }
|  64|  64| 
|  65|  65|         result = ((dividend ^ divisor) >> 31) ? -result : result;
|  66|    |-        return min(result, static_cast<long long>(numeric_limits<int>::max()));
|    |  66|+        return min (result,
|    |  67|+                    static_cast < long long >(numeric_limits < int >::max ()));
|  67|  68|     }
|  68|  69| };
|  69|  70| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  70|  70| // Time:  O(logn) = O(1)
|  71|  71| // Space: O(1)
|  72|  72| // a / b = exp^(ln(a) - ln(b))
|  73|    |-class Solution3 {
|  74|    |-public:
|    |  73|+class Solution3
|    |  74|+{
|    |  75|+  public:
|  75|  76|     /**
|  76|  77|      * @param dividend the dividend
|  77|  78|      * @param divisor the divisor
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  77|  77|      * @param divisor the divisor
|  78|  78|      * @return the result
|  79|  79|      */
|  80|    |-    int divide(int dividend, int divisor) {
|  81|    |-        if (dividend == 0) { 
|  82|    |-            return 0;
|  83|    |-        }
|  84|    |-        if (divisor == 0) {
|  85|    |-            return numeric_limits<int>::max();
|  86|    |-        }
|    |  80|+    int divide (int dividend, int divisor)
|    |  81|+    {
|    |  82|+        if (dividend == 0)
|    |  83|+          {
|    |  84|+              return 0;
|    |  85|+          }
|    |  86|+        if (divisor == 0)
|    |  87|+          {
|    |  88|+              return numeric_limits < int >::max ();
|    |  89|+          }
|  87|  90| 
|  88|    |-        long long result = exp(log(fabs(dividend)) - log(fabs(divisor)));
|    |  91|+        long long result = exp (log (fabs (dividend)) - log (fabs (divisor)));
|  89|  92| 
|  90|  93|         result = ((dividend ^ divisor) >> 31) ? -result : result;
|  91|  94|         return min(result, static_cast<long long>(numeric_limits<int>::max()));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/divide-two-integers.cpp
|    |++++| /app/C++/divide-two-integers.cpp
|  88|  88|         long long result = exp(log(fabs(dividend)) - log(fabs(divisor)));
|  89|  89| 
|  90|  90|         result = ((dividend ^ divisor) >> 31) ? -result : result;
|  91|    |-        return min(result, static_cast<long long>(numeric_limits<int>::max()));
|    |  91|+        return min (result,
|    |  92|+                    static_cast < long long >(numeric_limits < int >::max ()));
|  92|  93|     }
|  93|  94| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-palindromic-substring.cpp
|    |++++| /app/C++/longest-palindromic-substring.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s input string
|   8|   9|      * @return the longest palindromic substring
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-palindromic-substring.cpp
|    |++++| /app/C++/longest-palindromic-substring.cpp
|   7|   7|      * @param s input string
|   8|   8|      * @return the longest palindromic substring
|   9|   9|      */
|  10|    |-    string longestPalindrome(string& s) {
|  11|    |-        string T = preProcess(s);
|  12|    |-        const int n = T.length();
|  13|    |-        vector<int> P(n);
|    |  10|+    string longestPalindrome (string & s)
|    |  11|+    {
|    |  12|+        string T = preProcess (s);
|    |  13|+        const int n = T.length ();
|    |  14|+          vector < int >P (n);
|  14|  15|         int C = 0, R = 0;
|  15|    |-        for (int i = 1; i < n - 1; ++i) {
|  16|    |-            int i_mirror = 2 * C - i; // equals to i' = C - (i-C)
|  17|    |-    
|  18|    |-            P[i] = (R > i) ? min(R - i, P[i_mirror]) : 0;
|  19|    |-    
|  20|    |-            // Attempt to expand palindrome centered at i
|  21|    |-            while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {
|  22|    |-                ++P[i];
|  23|    |-            }
|  24|    |-    
|  25|    |-            // If palindrome centered at i expands the past R,
|  26|    |-            // adjust center based on expanded palindrome.
|  27|    |-            if (i + P[i] > R) {
|  28|    |-                C = i;
|  29|    |-                R = i + P[i];
|  30|    |-            }
|  31|    |-        }
|  32|    |-    
|    |  16|+        for (int i = 1; i < n - 1; ++i)
|    |  17|+          {
|    |  18|+              int i_mirror = 2 * C - i; // equals to i' = C - (i-C)
|    |  19|+
|    |  20|+                P[i] = (R > i) ? min (R - i, P[i_mirror]) : 0;
|    |  21|+
|    |  22|+              // Attempt to expand palindrome centered at i
|    |  23|+              while (T[i + 1 + P[i]] == T[i - 1 - P[i]])
|    |  24|+                {
|    |  25|+                    ++P[i];
|    |  26|+                }
|    |  27|+
|    |  28|+              // If palindrome centered at i expands the past R,
|    |  29|+              // adjust center based on expanded palindrome.
|    |  30|+              if (i + P[i] > R)
|    |  31|+                {
|    |  32|+                    C = i;
|    |  33|+                    R = i + P[i];
|    |  34|+                }
|    |  35|+          }
|    |  36|+
|  33|  37|         // Find the maximum element in P.
|  34|  38|         int max_len = 0, center_index = 0;
|  35|  39|         for (int i = 1; i < n - 1; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-palindromic-substring.cpp
|    |++++| /app/C++/longest-palindromic-substring.cpp
|  32|  32|     
|  33|  33|         // Find the maximum element in P.
|  34|  34|         int max_len = 0, center_index = 0;
|  35|    |-        for (int i = 1; i < n - 1; ++i) {
|  36|    |-            if (P[i] > max_len) {
|  37|    |-                max_len = P[i];
|  38|    |-                center_index = i;
|  39|    |-            }
|  40|    |-        }
|  41|    |-    
|  42|    |-        return s.substr((center_index - 1 - max_len) / 2, max_len);
|    |  35|+        for (int i = 1; i < n - 1; ++i)
|    |  36|+          {
|    |  37|+              if (P[i] > max_len)
|    |  38|+                {
|    |  39|+                    max_len = P[i];
|    |  40|+                    center_index = i;
|    |  41|+                }
|    |  42|+          }
|    |  43|+
|    |  44|+        return s.substr ((center_index - 1 - max_len) / 2, max_len);
|  43|  45|     }
|  44|  46| 
|  45|  47| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-palindromic-substring.cpp
|    |++++| /app/C++/longest-palindromic-substring.cpp
|  42|  42|         return s.substr((center_index - 1 - max_len) / 2, max_len);
|  43|  43|     }
|  44|  44| 
|  45|    |-private:
|  46|    |-    string preProcess(const string& s) {
|  47|    |-        if (s.empty()) {
|  48|    |-            return "^$";
|  49|    |-        }
|    |  45|+  private:
|    |  46|+    string preProcess (const string & s)
|    |  47|+    {
|    |  48|+        if (s.empty ())
|    |  49|+          {
|    |  50|+              return "^$";
|    |  51|+          }
|  50|  52|         string ret = "^";
|  51|    |-        for (int i = 0; i < s.length(); ++i) {
|  52|    |-            ret += "#" + s.substr(i, 1);
|  53|    |-        }
|    |  53|+        for (int i = 0; i < s.length (); ++i)
|    |  54|+          {
|    |  55|+              ret += "#" + s.substr (i, 1);
|    |  56|+          }
|  54|  57|         ret += "#$";
|  55|  58|         return ret;
|  56|  59|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/perfect-squares.cpp
|    |++++| /app/C++/perfect-squares.cpp
|   1|   1| // Time:  O(n * sqrt(n))
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n a positive integer
|   8|   9|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/perfect-squares.cpp
|    |++++| /app/C++/perfect-squares.cpp
|   7|   7|      * @param n a positive integer
|   8|   8|      * @return an integer
|   9|   9|      */
|  10|    |-    int numSquares(int n) {
|  11|    |-        static vector<int> num{0};
|  12|    |-        while (num.size() <= n) {
|  13|    |-            int squares = numeric_limits<int>::max();
|  14|    |-            for (int i = 1; i * i <= num.size(); ++i) {
|  15|    |-                squares = min(squares, num[num.size() - i * i] + 1);
|  16|    |-            }
|  17|    |-            num.emplace_back(squares);
|  18|    |-        }
|    |  10|+    int numSquares (int n)
|    |  11|+    {
|    |  12|+        static vector < int >num
|    |  13|+        {
|    |  14|+        0};
|    |  15|+        while (num.size () <= n)
|    |  16|+          {
|    |  17|+              int squares = numeric_limits < int >::max ();
|    |  18|+              for (int i = 1; i * i <= num.size (); ++i)
|    |  19|+                {
|    |  20|+                    squares = min (squares, num[num.size () - i * i] + 1);
|    |  21|+                }
|    |  22|+              num.emplace_back (squares);
|    |  23|+          }
|  19|  24|         return num[n];
|  20|  25|     }
|  21|  26| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/perfect-squares.cpp
|    |++++| /app/C++/perfect-squares.cpp
|  20|  20|     }
|  21|  21| };
|  22|  22| 
|  23|    |-
|  24|  23| // Time:  O(n * sqrt(n))
|  25|  24| // Space: O(n)
|  26|  25| class Solution2 {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/perfect-squares.cpp
|    |++++| /app/C++/perfect-squares.cpp
|  23|  23| 
|  24|  24| // Time:  O(n * sqrt(n))
|  25|  25| // Space: O(n)
|  26|    |-class Solution2 {
|  27|    |-public:
|    |  26|+class Solution2
|    |  27|+{
|    |  28|+  public:
|  28|  29|     /**
|  29|  30|      * @param n a positive integer
|  30|  31|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/perfect-squares.cpp
|    |++++| /app/C++/perfect-squares.cpp
|  29|  29|      * @param n a positive integer
|  30|  30|      * @return an integer
|  31|  31|      */
|  32|    |-    int numSquares(int n) {
|  33|    |-        vector<int> num(n + 1, numeric_limits<int>::max());
|  34|    |-        num[0] = 0;
|  35|    |-        for (int i = 0; i <= n; ++i) {
|  36|    |-            for (int j = i - 1, k = 1; j >= 0; ++k, j = i - k * k) {
|  37|    |-                num[i] = min(num[i], num[j] + 1);
|  38|    |-            }
|  39|    |-        }
|    |  32|+    int numSquares (int n)
|    |  33|+    {
|    |  34|+        vector < int >num (n + 1, numeric_limits < int >::max ());
|    |  35|+          num[0] = 0;
|    |  36|+        for (int i = 0; i <= n; ++i)
|    |  37|+          {
|    |  38|+              for (int j = i - 1, k = 1; j >= 0; ++k, j = i - k * k)
|    |  39|+                {
|    |  40|+                    num[i] = min (num[i], num[j] + 1);
|    |  41|+                }
|    |  42|+          }
|  40|  43|         return num[n];
|  41|  44|     }
|  42|  45| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/scramble-string.cpp
|    |++++| /app/C++/scramble-string.cpp
|   1|   1| // Time:  O(n^4)
|   2|   2| // Space: O(n^3)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s1 A string
|   8|   9|      * @param s2 Another string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/scramble-string.cpp
|    |++++| /app/C++/scramble-string.cpp
|   8|   8|      * @param s2 Another string
|   9|   9|      * @return whether s2 is a scrambled string of s1
|  10|  10|      */
|  11|    |-    bool isScramble(string& s1, string& s2) {
|  12|    |-        if (s1.length() != s2.length()) {
|  13|    |-            return false;
|  14|    |-        }
|    |  11|+    bool isScramble (string & s1, string & s2)
|    |  12|+    {
|    |  13|+        if (s1.length () != s2.length ())
|    |  14|+          {
|    |  15|+              return false;
|    |  16|+          }
|  15|  17| 
|  16|    |-        if (s1 == s2) {
|  17|    |-            return true;
|  18|    |-        }
|    |  18|+        if (s1 == s2)
|    |  19|+          {
|    |  20|+              return true;
|    |  21|+          }
|  19|  22| 
|  20|    |-        const auto n = s1.length();
|    |  23|+        const auto n = s1.length ();
|  21|  24| 
|  22|  25|         // is_cramble[l][i][j] denoted as s1[i:i+l], s2[j:j+l] are scramble.
|  23|  26|         vector<vector<vector<bool>>> 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/scramble-string.cpp
|    |++++| /app/C++/scramble-string.cpp
|  20|  20|         const auto n = s1.length();
|  21|  21| 
|  22|  22|         // is_cramble[l][i][j] denoted as s1[i:i+l], s2[j:j+l] are scramble.
|  23|    |-        vector<vector<vector<bool>>> 
|  24|    |-            is_scramble(n + 1, vector<vector<bool>>(n, vector<bool>(n, false)));
|    |  23|+        vector < vector < vector < bool >>>
|    |  24|+            is_scramble (n + 1,
|    |  25|+                         vector < vector < bool >> (n,
|    |  26|+                                                    vector < bool > (n,
|    |  27|+                                                                     false)));
|  25|  28| 
|  26|    |-        for (int i = 0; i < n; ++i) {
|  27|    |-            for (int j = 0; j < n; ++j) {
|  28|    |-                if (s1[i] == s2[j]) {
|  29|    |-                    is_scramble[1][i][j] = true;
|    |  29|+        for (int i = 0; i < n; ++i)
|    |  30|+          {
|    |  31|+              for (int j = 0; j < n; ++j)
|    |  32|+                {
|    |  33|+                    if (s1[i] == s2[j])
|    |  34|+                      {
|    |  35|+                          is_scramble[1][i][j] = true;
|    |  36|+                      }
|  30|  37|                 }
|  31|    |-            }
|  32|    |-        }
|    |  38|+          }
|  33|  39| 
|  34|  40|         // Compute by each length.
|  35|  41|         for (int l = 2; l <= n; ++l) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/scramble-string.cpp
|    |++++| /app/C++/scramble-string.cpp
|  32|  32|         }
|  33|  33| 
|  34|  34|         // Compute by each length.
|  35|    |-        for (int l = 2; l <= n; ++l) {
|  36|    |-            for (int i = 0; i <  n - l + 1; ++i) {
|  37|    |-                for (int j = 0; j < n - l + 1; ++j) {
|  38|    |-                    for (int k = 1; k < l; ++k) {
|  39|    |-                        if ((is_scramble[k][i][j] &&
|  40|    |-                             is_scramble[l - k][i + k][j + k]) ||
|  41|    |-                            (is_scramble[k][i][j + l - k] &&
|  42|    |-                             is_scramble[l - k][i + k][j])) {
|  43|    |-                            is_scramble[l][i][j] = true;
|  44|    |-                            break; // Pruning.
|  45|    |-                        }
|  46|    |-                    }
|    |  35|+        for (int l = 2; l <= n; ++l)
|    |  36|+          {
|    |  37|+              for (int i = 0; i < n - l + 1; ++i)
|    |  38|+                {
|    |  39|+                    for (int j = 0; j < n - l + 1; ++j)
|    |  40|+                      {
|    |  41|+                          for (int k = 1; k < l; ++k)
|    |  42|+                            {
|    |  43|+                                if ((is_scramble[k][i][j] &&
|    |  44|+                                     is_scramble[l - k][i + k][j + k]) ||
|    |  45|+                                    (is_scramble[k][i][j + l - k] &&
|    |  46|+                                     is_scramble[l - k][i + k][j]))
|    |  47|+                                  {
|    |  48|+                                      is_scramble[l][i][j] = true;
|    |  49|+                                      break;    // Pruning.
|    |  50|+                                  }
|    |  51|+                            }
|    |  52|+                      }
|  47|  53|                 }
|  48|    |-            }
|  49|    |-        }
|    |  54|+          }
|  50|  55| 
|  51|  56|         return is_scramble[n][0][0];
|  52|  57|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/length-of-last-word.cpp
|    |++++| /app/C++/length-of-last-word.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s A string
|   8|   9|      * @return the length of last word
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/length-of-last-word.cpp
|    |++++| /app/C++/length-of-last-word.cpp
|   7|   7|      * @param s A string
|   8|   8|      * @return the length of last word
|   9|   9|      */
|  10|    |-    int lengthOfLastWord(string& s) {
|    |  10|+    int lengthOfLastWord (string & s)
|    |  11|+    {
|  11|  12|         int counter = 0;
|  12|    |-        for (int i = s.length() - 1; i >= 0; --i) {
|  13|    |-            if(s[i] == ' ') {
|  14|    |-                if (counter > 0) {
|  15|    |-                    break;
|    |  13|+        for (int i = s.length () - 1; i >= 0; --i)
|    |  14|+          {
|    |  15|+              if (s[i] == ' ')
|    |  16|+                {
|    |  17|+                    if (counter > 0)
|    |  18|+                      {
|    |  19|+                          break;
|    |  20|+                      }
|  16|  21|                 }
|  17|    |-            } else {
|  18|    |-                ++counter;
|  19|    |-            }
|  20|    |-        }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    ++counter;
|    |  25|+                }
|    |  26|+          }
|  21|  27|         return counter;
|  22|  28|     }
|  23|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/max-tree.cpp
|    |++++| /app/C++/max-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |- public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param A: Given an integer array with no duplicates.
|  20|  21|      * @return: The root of max tree.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/max-tree.cpp
|    |++++| /app/C++/max-tree.cpp
|  19|  19|      * @param A: Given an integer array with no duplicates.
|  20|  20|      * @return: The root of max tree.
|  21|  21|      */
|  22|    |-    TreeNode* maxTree(vector<int> A) {
|  23|    |-        vector<TreeNode *> nodeStack;
|  24|    |-        for (int i = 0; i < A.size(); ++i) {
|  25|    |-            auto node = new TreeNode(A[i]);
|  26|    |-            while (!nodeStack.empty() && A[i] > nodeStack.back()->val) {
|  27|    |-                node->left = nodeStack.back();
|  28|    |-                nodeStack.pop_back();
|  29|    |-            }
|  30|    |-            if (!nodeStack.empty()) {
|  31|    |-                nodeStack.back()->right = node;
|  32|    |-            }
|  33|    |-            nodeStack.emplace_back(node);
|  34|    |-        }
|  35|    |-        return nodeStack.front();
|    |  22|+    TreeNode * maxTree (vector < int >A)
|    |  23|+    {
|    |  24|+        vector < TreeNode * >nodeStack;
|    |  25|+        for (int i = 0; i < A.size (); ++i)
|    |  26|+          {
|    |  27|+              auto node = new TreeNode (A[i]);
|    |  28|+              while (!nodeStack.empty () && A[i] > nodeStack.back ()->val)
|    |  29|+                {
|    |  30|+                    node->left = nodeStack.back ();
|    |  31|+                    nodeStack.pop_back ();
|    |  32|+                }
|    |  33|+              if (!nodeStack.empty ())
|    |  34|+                {
|    |  35|+                    nodeStack.back ()->right = node;
|    |  36|+                }
|    |  37|+              nodeStack.emplace_back (node);
|    |  38|+          }
|    |  39|+        return nodeStack.front ();
|  36|  40|     }
|  37|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning.cpp
|    |++++| /app/C++/palindrome-partitioning.cpp
|   1|   1| // Time:  O(n * 2^n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s: A string
|   8|   9|      * @return: A list of lists of string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning.cpp
|    |++++| /app/C++/palindrome-partitioning.cpp
|   7|   7|      * @param s: A string
|   8|   8|      * @return: A list of lists of string
|   9|   9|      */
|  10|    |-    vector<vector<string>> partition(string s) {
|  11|    |-        vector<vector<string>> result;
|  12|    |-        vector<string> partition;
|  13|    |-        PalindromePartitioningHelper(s, 0, &partition, &result);
|    |  10|+    vector < vector < string >> partition (string s)
|    |  11|+    {
|    |  12|+        vector < vector < string >> result;
|    |  13|+        vector < string > partition;
|    |  14|+        PalindromePartitioningHelper (s, 0, &partition, &result);
|  14|  15|         return result;
|  15|  16|     }
|  16|  17| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning.cpp
|    |++++| /app/C++/palindrome-partitioning.cpp
|  14|  14|         return result;
|  15|  15|     }
|  16|  16| 
|  17|    |-    void PalindromePartitioningHelper(const string& s, size_t begin,
|  18|    |-                                      vector<string>* partition,
|  19|    |-                                      vector<vector<string>>* result) {
|  20|    |-        if (begin == s.size()) {
|  21|    |-            result->emplace_back(*partition);
|  22|    |-            return;
|  23|    |-        }
|    |  17|+    void PalindromePartitioningHelper (const string & s, size_t begin,
|    |  18|+                                       vector < string > *partition,
|    |  19|+                                       vector < vector < string >> *result)
|    |  20|+    {
|    |  21|+        if (begin == s.size ())
|    |  22|+          {
|    |  23|+              result->emplace_back (*partition);
|    |  24|+              return;
|    |  25|+          }
|  24|  26| 
|  25|    |-        for (size_t i = begin + 1; i <= s.size(); ++i) {
|  26|    |-            string prefix = s.substr(begin, i - begin);
|  27|    |-            if (IsPalindrome(prefix)) {
|  28|    |-                partition->emplace_back(prefix);
|  29|    |-                PalindromePartitioningHelper(s, i, partition, result);
|  30|    |-                partition->pop_back();
|  31|    |-            }
|  32|    |-        }
|    |  27|+        for (size_t i = begin + 1; i <= s.size (); ++i)
|    |  28|+          {
|    |  29|+              string prefix = s.substr (begin, i - begin);
|    |  30|+              if (IsPalindrome (prefix))
|    |  31|+                {
|    |  32|+                    partition->emplace_back (prefix);
|    |  33|+                    PalindromePartitioningHelper (s, i, partition, result);
|    |  34|+                    partition->pop_back ();
|    |  35|+                }
|    |  36|+          }
|  33|  37|     }
|  34|  38| 
|  35|  39|     bool IsPalindrome(const string& s) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-partitioning.cpp
|    |++++| /app/C++/palindrome-partitioning.cpp
|  32|  32|         }
|  33|  33|     }
|  34|  34| 
|  35|    |-    bool IsPalindrome(const string& s) {
|  36|    |-        for (int i = 0, j = s.size() - 1; i < j; ++i, --j) {
|  37|    |-            if (s[i] != s[j]) {
|  38|    |-                return false;
|  39|    |-            }
|  40|    |-        }
|    |  35|+    bool IsPalindrome (const string & s)
|    |  36|+    {
|    |  37|+        for (int i = 0, j = s.size () - 1; i < j; ++i, --j)
|    |  38|+          {
|    |  39|+              if (s[i] != s[j])
|    |  40|+                {
|    |  41|+                    return false;
|    |  42|+                }
|    |  43|+          }
|  41|  44|         return true;
|  42|  45|     }
|  43|  46| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder-ii.cpp
|    |++++| /app/C++/word-ladder-ii.cpp
|   1|   1| // Time:  O(n * d), n is length of the string, d is size of the dictionary
|   2|   2| // Space: O(d)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param start, a string
|   8|   9|      * @param end, a string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder-ii.cpp
|    |++++| /app/C++/word-ladder-ii.cpp
|   9|   9|      * @param dict, a set of string
|  10|  10|      * @return a list of lists of string
|  11|  11|      */
|  12|    |-    vector<vector<string>> findLadders(string start, string end, unordered_set<string> &dict) {
|  13|    |-        unordered_map<string, unordered_set<string>> trace;
|    |  12|+    vector < vector < string >> findLadders (string start, string end,
|    |  13|+                                             unordered_set < string > &dict)
|    |  14|+    {
|    |  15|+        unordered_map < string, unordered_set < string >> trace;
|  14|  16| 
|  15|  17|         // BFS, each round is a level
|  16|  18|         unordered_set<string> levels[2];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder-ii.cpp
|    |++++| /app/C++/word-ladder-ii.cpp
|  13|  13|         unordered_map<string, unordered_set<string>> trace;
|  14|  14| 
|  15|  15|         // BFS, each round is a level
|  16|    |-        unordered_set<string> levels[2];
|    |  16|+        unordered_set < string > levels[2];
|  17|  17|         int cur_level = 0;
|  18|  18| 
|  19|  19|         levels[cur_level].emplace(start);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder-ii.cpp
|    |++++| /app/C++/word-ladder-ii.cpp
|  16|  16|         unordered_set<string> levels[2];
|  17|  17|         int cur_level = 0;
|  18|  18| 
|  19|    |-        levels[cur_level].emplace(start);
|  20|    |-        while (dict.size() > 0 && levels[cur_level % 2].size() > 0) {
|  21|    |-            // end is in current level, stop
|  22|    |-            if (trace.count(end) == 1) {
|  23|    |-                ++cur_level;
|  24|    |-                break;
|  25|    |-            }
|    |  19|+          levels[cur_level].emplace (start);
|    |  20|+        while (dict.size () > 0 && levels[cur_level % 2].size () > 0)
|    |  21|+          {
|    |  22|+              // end is in current level, stop
|    |  23|+              if (trace.count (end) == 1)
|    |  24|+                {
|    |  25|+                    ++cur_level;
|    |  26|+                    break;
|    |  27|+                }
|  26|  28| 
|  27|    |-            // clear words from the dictionary to avoid it' apear in future level again
|  28|    |-            for (auto& word : levels[cur_level % 2]) {
|  29|    |-                dict.erase(word);
|  30|    |-            }
|    |  29|+              // clear words from the dictionary to avoid it' apear in future level again
|    |  30|+              for (auto & word:levels[cur_level % 2])
|    |  31|+                {
|    |  32|+                    dict.erase (word);
|    |  33|+                }
|  31|  34| 
|  32|    |-            levels[(cur_level + 1) % 2].clear();
|  33|    |-            for (auto& from : levels[cur_level % 2]) {
|  34|    |-                string new_word = from;
|  35|    |-                for (int i = 0; i < new_word.length(); ++i) {
|  36|    |-                    char orig_c = from[i];
|  37|    |-                    for (char c = 'a'; c <= 'z'; ++c) {
|  38|    |-                        new_word[i] = c;
|  39|    |-                        if (dict.count(new_word) == 1) {
|  40|    |-                            trace[new_word].emplace(from);
|  41|    |-                            levels[(cur_level + 1) % 2].emplace(new_word);
|  42|    |-                        }
|  43|    |-                    }
|  44|    |-                    new_word[i] = orig_c;
|    |  35|+              levels[(cur_level + 1) % 2].clear ();
|    |  36|+            for (auto & from:levels[cur_level % 2])
|    |  37|+                {
|    |  38|+                    string new_word = from;
|    |  39|+                    for (int i = 0; i < new_word.length (); ++i)
|    |  40|+                      {
|    |  41|+                          char orig_c = from[i];
|    |  42|+                          for (char c = 'a'; c <= 'z'; ++c)
|    |  43|+                            {
|    |  44|+                                new_word[i] = c;
|    |  45|+                                if (dict.count (new_word) == 1)
|    |  46|+                                  {
|    |  47|+                                      trace[new_word].emplace (from);
|    |  48|+                                      levels[(cur_level +
|    |  49|+                                              1) % 2].emplace (new_word);
|    |  50|+                                  }
|    |  51|+                            }
|    |  52|+                          new_word[i] = orig_c;
|    |  53|+                      }
|  45|  54|                 }
|  46|    |-            }
|  47|  55| 
|  48|    |-            ++cur_level;
|  49|    |-        }
|    |  56|+              ++cur_level;
|    |  57|+          }
|  50|  58| 
|  51|    |-        vector<vector<string>> result;
|  52|    |-        vector<string> temp;
|  53|    |-        traceBack(trace, temp, end, result);
|    |  59|+        vector < vector < string >> result;
|    |  60|+        vector < string > temp;
|    |  61|+        traceBack (trace, temp, end, result);
|  54|  62|         return result;
|  55|  63|     }
|  56|  64| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder-ii.cpp
|    |++++| /app/C++/word-ladder-ii.cpp
|  54|  54|         return result;
|  55|  55|     }
|  56|  56| 
|  57|    |-    void traceBack(
|  58|    |-                   unordered_map<string, unordered_set<string>> &trace,
|  59|    |-                   vector<string> &temp,
|  60|    |-                   string end,
|  61|    |-                   vector<vector<string>> &result) {
|  62|    |-        temp.emplace_back(end);
|  63|    |-        if (trace.count(end) != 1) {
|  64|    |-            vector<string> path = temp;
|  65|    |-            reverse(path.begin(), path.end());
|  66|    |-            result.emplace_back(move(path));
|  67|    |-        }
|  68|    |-        else {
|  69|    |-            for (auto& word: trace[end]) {
|  70|    |-                traceBack(trace, temp, word, result);
|  71|    |-            }
|  72|    |-        }
|  73|    |-        temp.pop_back();
|    |  57|+    void traceBack (unordered_map < string, unordered_set < string >> &trace,
|    |  58|+                    vector < string > &temp,
|    |  59|+                    string end, vector < vector < string >> &result)
|    |  60|+    {
|    |  61|+        temp.emplace_back (end);
|    |  62|+        if (trace.count (end) != 1)
|    |  63|+          {
|    |  64|+              vector < string > path = temp;
|    |  65|+              reverse (path.begin (), path.end ());
|    |  66|+              result.emplace_back (move (path));
|    |  67|+          }
|    |  68|+        else
|    |  69|+          {
|    |  70|+            for (auto & word:trace[end])
|    |  71|+                {
|    |  72|+                    traceBack (trace, temp, word, result);
|    |  73|+                }
|    |  74|+          }
|    |  75|+        temp.pop_back ();
|  74|  76|     }
|  75|  77| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/generate-parentheses.cpp
|    |++++| /app/C++/generate-parentheses.cpp
|   1|   1| // Time:  O(n * (C(2n, n) - C(2n, n - 1))) = Catalan numbers
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n n pairs
|   8|   9|      * @return All combinations of well-formed parentheses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/generate-parentheses.cpp
|    |++++| /app/C++/generate-parentheses.cpp
|   7|   7|      * @param n n pairs
|   8|   8|      * @return All combinations of well-formed parentheses
|   9|   9|      */
|  10|    |-    vector<string> generateParenthesis(int n) {
|  11|    |-        vector<string> result;
|    |  10|+    vector < string > generateParenthesis (int n)
|    |  11|+    {
|    |  12|+        vector < string > result;
|  12|  13|         string cur;
|  13|    |-        generateParenthesisHelper(n, n, &cur, &result);
|  14|    |-        return result;
|    |  14|+          generateParenthesisHelper (n, n, &cur, &result);
|    |  15|+          return result;
|  15|  16|     }
|  16|  17| 
|  17|  18|     void generateParenthesisHelper(
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/generate-parentheses.cpp
|    |++++| /app/C++/generate-parentheses.cpp
|  14|  14|         return result;
|  15|  15|     }
|  16|  16| 
|  17|    |-    void generateParenthesisHelper(
|  18|    |-        int left, int right,
|  19|    |-        string *cur, vector<string> *result) {
|    |  17|+    void generateParenthesisHelper (int left, int right,
|    |  18|+                                    string * cur, vector < string > *result)
|    |  19|+    {
|  20|  20| 
|  21|    |-        if (!left && !right) {
|  22|    |-            result->emplace_back(*cur);
|  23|    |-        }
|  24|    |-        if (left > 0) {
|  25|    |-            cur->push_back('(');
|  26|    |-            generateParenthesisHelper(left - 1, right, cur, result);
|  27|    |-            cur->pop_back();
|  28|    |-        }
|  29|    |-        if (left < right) {
|  30|    |-            cur->push_back(')');
|  31|    |-            generateParenthesisHelper(left, right - 1, cur, result);
|  32|    |-            cur->pop_back();
|  33|    |-        }
|    |  21|+        if (!left && !right)
|    |  22|+          {
|    |  23|+              result->emplace_back (*cur);
|    |  24|+          }
|    |  25|+        if (left > 0)
|    |  26|+          {
|    |  27|+              cur->push_back ('(');
|    |  28|+              generateParenthesisHelper (left - 1, right, cur, result);
|    |  29|+              cur->pop_back ();
|    |  30|+          }
|    |  31|+        if (left < right)
|    |  32|+          {
|    |  33|+              cur->push_back (')');
|    |  34|+              generateParenthesisHelper (left, right - 1, cur, result);
|    |  35|+              cur->pop_back ();
|    |  36|+          }
|  34|  37|     }
|  35|  38| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/graph-valid-tree.cpp
|    |++++| /app/C++/graph-valid-tree.cpp
|   1|   1| // Time:  O(|V| + |E|)
|   2|   2| // Space: O(|V| + |E|)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|   6|    |-    struct node {
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|    |   7|+    struct node
|    |   8|+    {
|   7|   9|         int parent = -1;
|   8|    |-        vector<int>neighbors;
|    |  10|+          vector < int >neighbors;
|   9|  11|     };
|  10|  12| 
|  11|  13|     bool validTree(int n, vector<vector<int>>& edges) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/graph-valid-tree.cpp
|    |++++| /app/C++/graph-valid-tree.cpp
|   8|   8|         vector<int>neighbors;
|   9|   9|     };
|  10|  10| 
|  11|    |-    bool validTree(int n, vector<vector<int>>& edges) {
|  12|    |-        if (edges.size() != n - 1) {
|  13|    |-            return false;
|  14|    |-        } else if (n == 1) {
|  15|    |-            return true;
|  16|    |-        }
|    |  11|+    bool validTree (int n, vector < vector < int >>&edges)
|    |  12|+    {
|    |  13|+        if (edges.size () != n - 1)
|    |  14|+          {
|    |  15|+              return false;
|    |  16|+          }
|    |  17|+        else if (n == 1)
|    |  18|+          {
|    |  19|+              return true;
|    |  20|+          }
|  17|  21| 
|  18|    |-        unordered_map<int, node> nodes;
|  19|    |-        for (const auto& edge : edges) {
|  20|    |-            nodes[edge.front()].neighbors.emplace_back(edge.back());
|  21|    |-            nodes[edge.back()].neighbors.emplace_back(edge.front());
|  22|    |-        }
|    |  22|+        unordered_map < int, node > nodes;
|    |  23|+      for (const auto & edge:edges)
|    |  24|+          {
|    |  25|+              nodes[edge.front ()].neighbors.emplace_back (edge.back ());
|    |  26|+              nodes[edge.back ()].neighbors.emplace_back (edge.front ());
|    |  27|+          }
|  23|  28| 
|  24|    |-        if (nodes.size() != n) {
|  25|    |-            return false;
|  26|    |-        }
|    |  29|+        if (nodes.size () != n)
|    |  30|+          {
|    |  31|+              return false;
|    |  32|+          }
|  27|  33| 
|  28|    |-        unordered_set<int> visited;
|  29|    |-        queue<int> q;
|  30|    |-        q.emplace(0);
|  31|    |-        while (!q.empty()) {
|  32|    |-            const int i = q.front();
|  33|    |-            q.pop();
|  34|    |-            visited.emplace(i);
|  35|    |-            for (const auto& node : nodes[i].neighbors) {
|  36|    |-                if (node != nodes[i].parent) {
|  37|    |-                    if (visited.find(node) != visited.end()) {
|  38|    |-                        return false;
|  39|    |-                    } else {
|  40|    |-                        visited.emplace(node);
|  41|    |-                        nodes[node].parent = i;
|  42|    |-                        q.emplace(node);
|  43|    |-                    }
|    |  34|+        unordered_set < int >visited;
|    |  35|+        queue < int >q;
|    |  36|+        q.emplace (0);
|    |  37|+        while (!q.empty ())
|    |  38|+          {
|    |  39|+              const int i = q.front ();
|    |  40|+              q.pop ();
|    |  41|+              visited.emplace (i);
|    |  42|+            for (const auto & node:nodes[i].neighbors)
|    |  43|+                {
|    |  44|+                    if (node != nodes[i].parent)
|    |  45|+                      {
|    |  46|+                          if (visited.find (node) != visited.end ())
|    |  47|+                            {
|    |  48|+                                return false;
|    |  49|+                            }
|    |  50|+                          else
|    |  51|+                            {
|    |  52|+                                visited.emplace (node);
|    |  53|+                                nodes[node].parent = i;
|    |  54|+                                q.emplace (node);
|    |  55|+                            }
|    |  56|+                      }
|  44|  57|                 }
|  45|    |-            }
|  46|    |-        }
|  47|    |-        return visited.size() == n;
|    |  58|+          }
|    |  59|+        return visited.size () == n;
|  48|  60|     }
|  49|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house-ii.cpp
|    |++++| /app/C++/paint-house-ii.cpp
|   1|   1| // Time:  O(n * k)
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param costs n x k cost matrix
|   8|   9|      * @return an integer, the minimum cost to paint all houses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house-ii.cpp
|    |++++| /app/C++/paint-house-ii.cpp
|   7|   7|      * @param costs n x k cost matrix
|   8|   8|      * @return an integer, the minimum cost to paint all houses
|   9|   9|      */
|  10|    |-    int minCostII(vector<vector<int>>& costs) {
|  11|    |-        if (costs.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int minCostII (vector < vector < int >>&costs)
|    |  11|+    {
|    |  12|+        if (costs.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|    |-        vector<vector<int>> min_cost(2, costs[0]);
|    |  17|+        vector < vector < int >>min_cost (2, costs[0]);
|  16|  18| 
|  17|    |-        const int n = costs.size();
|  18|    |-        const int k = costs[0].size();
|  19|    |-        for (int i = 1; i < n; ++i) {
|  20|    |-            int smallest = numeric_limits<int>::max(),
|  21|    |-                second_smallest = numeric_limits<int>::max();
|  22|    |-            for (int j = 0; j < k; ++j) {
|  23|    |-                if (min_cost[(i - 1) % 2][j] < smallest) {
|  24|    |-                    second_smallest = smallest;
|  25|    |-                    smallest = min_cost[(i - 1) % 2][j];
|  26|    |-                } else if (min_cost[(i - 1) % 2][j] < second_smallest) {
|  27|    |-                    second_smallest = min_cost[(i - 1) % 2][j];
|    |  19|+        const int n = costs.size ();
|    |  20|+        const int k = costs[0].size ();
|    |  21|+        for (int i = 1; i < n; ++i)
|    |  22|+          {
|    |  23|+              int smallest = numeric_limits < int >::max (),
|    |  24|+                  second_smallest = numeric_limits < int >::max ();
|    |  25|+              for (int j = 0; j < k; ++j)
|    |  26|+                {
|    |  27|+                    if (min_cost[(i - 1) % 2][j] < smallest)
|    |  28|+                      {
|    |  29|+                          second_smallest = smallest;
|    |  30|+                          smallest = min_cost[(i - 1) % 2][j];
|    |  31|+                      }
|    |  32|+                    else if (min_cost[(i - 1) % 2][j] < second_smallest)
|    |  33|+                      {
|    |  34|+                          second_smallest = min_cost[(i - 1) % 2][j];
|    |  35|+                      }
|  28|  36|                 }
|  29|    |-            }
|  30|    |-            for (int j = 0; j < k; ++j) {
|  31|    |-                const int min_j = (min_cost[(i - 1) % 2][j] != smallest) ?
|  32|    |-                                  smallest : second_smallest;
|  33|    |-                min_cost[i % 2][j] = costs[i][j] + min_j;
|  34|    |-            }
|  35|    |-        }
|    |  37|+              for (int j = 0; j < k; ++j)
|    |  38|+                {
|    |  39|+                    const int min_j = (min_cost[(i - 1) % 2][j] != smallest) ?
|    |  40|+                        smallest : second_smallest;
|    |  41|+                    min_cost[i % 2][j] = costs[i][j] + min_j;
|    |  42|+                }
|    |  43|+          }
|  36|  44| 
|  37|    |-        return *min_element(min_cost[(n - 1) % 2].cbegin(),
|  38|    |-                            min_cost[(n - 1) % 2].cend());
|    |  45|+        return *min_element (min_cost[(n - 1) % 2].cbegin (),
|    |  46|+                             min_cost[(n - 1) % 2].cend ());
|  39|  47|     }
|  40|  48| };
|  41|  49| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house-ii.cpp
|    |++++| /app/C++/paint-house-ii.cpp
|  41|  41| 
|  42|  42| // Time:  O(n * k)
|  43|  43| // Space: O(k)
|  44|    |-class Solution2 {
|  45|    |-public:
|    |  44|+class Solution2
|    |  45|+{
|    |  46|+  public:
|  46|  47|     /**
|  47|  48|      * @param costs n x k cost matrix
|  48|  49|      * @return an integer, the minimum cost to paint all houses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-house-ii.cpp
|    |++++| /app/C++/paint-house-ii.cpp
|  47|  47|      * @param costs n x k cost matrix
|  48|  48|      * @return an integer, the minimum cost to paint all houses
|  49|  49|      */
|  50|    |-    int minCostII(vector<vector<int>>& costs) {
|  51|    |-        if (costs.empty()) {
|  52|    |-            return 0;
|  53|    |-        }
|  54|    |-        auto combine = [](const vector<int>& tmp, const vector<int>& house) {
|  55|    |-                            const int smallest = *min_element(tmp.cbegin(),
|  56|    |-                                                              tmp.cend());
|  57|    |-                            const int i =
|  58|    |-                                distance(tmp.begin(), find(tmp.cbegin(),
|  59|    |-                                                           tmp.cend(),
|  60|    |-                                                           smallest));
|  61|    |-                            vector<int> tmp2(tmp);
|  62|    |-                            tmp2.erase(tmp2.begin() + i);
|  63|    |-                            const int second_smallest =
|  64|    |-                                          *min_element(tmp2.cbegin(),
|  65|    |-                                                       tmp2.cend());
|  66|    |-                            vector<int> min_cost(tmp.size(), smallest);
|  67|    |-                            min_cost[i] = second_smallest;
|  68|    |-                            transform(min_cost.cbegin(),
|  69|    |-                                      min_cost.cend(),
|  70|    |-                                      house.cbegin(),
|  71|    |-                                      min_cost.begin(),
|  72|    |-                                      std::plus<int>());
|  73|    |-                            return min_cost;
|  74|    |-                        };
|  75|    |-        vector<int> min_cost =
|  76|    |-            accumulate(costs.cbegin(), costs.cend(),
|  77|    |-                       vector<int>(costs[0].size(), 0), combine);
|  78|    |-        return *min_element(min_cost.cbegin(), min_cost.cend());
|    |  50|+    int minCostII (vector < vector < int >>&costs)
|    |  51|+    {
|    |  52|+        if (costs.empty ())
|    |  53|+          {
|    |  54|+              return 0;
|    |  55|+          }
|    |  56|+        auto combine =[](const vector < int >&tmp, const vector < int >&house) {
|    |  57|+            const int smallest = *min_element (tmp.cbegin (),
|    |  58|+                                               tmp.cend ());
|    |  59|+            const int i = distance (tmp.begin (), find (tmp.cbegin (),
|    |  60|+                                                        tmp.cend (),
|    |  61|+                                                        smallest));
|    |  62|+            vector < int >tmp2 (tmp);
|    |  63|+            tmp2.erase (tmp2.begin () + i);
|    |  64|+            const int second_smallest = *min_element (tmp2.cbegin (),
|    |  65|+                                                      tmp2.cend ());
|    |  66|+            vector < int >min_cost (tmp.size (), smallest);
|    |  67|+            min_cost[i] = second_smallest;
|    |  68|+            transform (min_cost.cbegin (),
|    |  69|+                       min_cost.cend (),
|    |  70|+                       house.cbegin (),
|    |  71|+                       min_cost.begin (), std::plus < int >());
|    |  72|+            return min_cost;
|    |  73|+        };
|    |  74|+        vector < int >min_cost = accumulate (costs.cbegin (), costs.cend (),
|    |  75|+                                             vector < int >(costs[0].size (),
|    |  76|+                                                            0), combine);
|    |  77|+        return *min_element (min_cost.cbegin (), min_cost.cend ());
|  79|  78|     }
|  80|  79| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  15|  15|  */
|  16|  16| 
|  17|  17| // Recursive solution.
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      * @param root: The root of the binary search tree.
|  22|  23|      * @param k1 and k2: range k1 to k2.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  22|  22|      * @param k1 and k2: range k1 to k2.
|  23|  23|      * @return: Return all keys that k1<=key<=k2 in ascending order.
|  24|  24|      */
|  25|    |-    vector<int> searchRange(TreeNode* root, int k1, int k2) {
|  26|    |-        vector<int> result;
|  27|    |-        pair<int, int> interval{k1, k2};
|  28|    |-        RangeLookupInBSTHelper(root, interval, &result);
|  29|    |-        return result;
|    |  25|+    vector < int >searchRange (TreeNode * root, int k1, int k2)
|    |  26|+    {
|    |  27|+        vector < int >result;
|    |  28|+          pair < int, int >interval
|    |  29|+        {
|    |  30|+        k1, k2};
|    |  31|+          RangeLookupInBSTHelper (root, interval, &result);
|    |  32|+          return result;
|  30|  33|     }
|  31|  34| 
|  32|  35|     void RangeLookupInBSTHelper(const TreeNode* tree,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  29|  29|         return result;
|  30|  30|     }
|  31|  31| 
|  32|    |-    void RangeLookupInBSTHelper(const TreeNode* tree,
|  33|    |-                                const pair<int, int>& interval,
|  34|    |-                                vector<int>* result) {
|  35|    |-        if (tree == nullptr) {
|  36|    |-            return;
|  37|    |-        }
|  38|    |-        if (interval.first <= tree->val && tree->val <= interval.second) {
|  39|    |-            // tree->data lies in the interval.
|  40|    |-            RangeLookupInBSTHelper(tree->left, interval, result);
|  41|    |-            result->emplace_back(tree->val);
|  42|    |-            RangeLookupInBSTHelper(tree->right, interval, result);
|  43|    |-        } else if (interval.first > tree->val) {
|  44|    |-            RangeLookupInBSTHelper(tree->right, interval, result);
|  45|    |-        } else {  // interval.second > tree->val
|  46|    |-            RangeLookupInBSTHelper(tree->left, interval, result);
|  47|    |-        }
|    |  32|+    void RangeLookupInBSTHelper (const TreeNode * tree,
|    |  33|+                                 const pair < int, int >&interval,
|    |  34|+                                 vector < int >*result)
|    |  35|+    {
|    |  36|+        if (tree == nullptr)
|    |  37|+          {
|    |  38|+              return;
|    |  39|+          }
|    |  40|+        if (interval.first <= tree->val && tree->val <= interval.second)
|    |  41|+          {
|    |  42|+              // tree->data lies in the interval.
|    |  43|+              RangeLookupInBSTHelper (tree->left, interval, result);
|    |  44|+              result->emplace_back (tree->val);
|    |  45|+              RangeLookupInBSTHelper (tree->right, interval, result);
|    |  46|+          }
|    |  47|+        else if (interval.first > tree->val)
|    |  48|+          {
|    |  49|+              RangeLookupInBSTHelper (tree->right, interval, result);
|    |  50|+          }
|    |  51|+        else
|    |  52|+          {                     // interval.second > tree->val
|    |  53|+              RangeLookupInBSTHelper (tree->left, interval, result);
|    |  54|+          }
|  48|  55|     }
|  49|  56| };
|  50|  57| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  49|  49| };
|  50|  50| 
|  51|  51| // Iterative solution.
|  52|    |-class Solution2 {
|  53|    |-public:
|    |  52|+class Solution2
|    |  53|+{
|    |  54|+  public:
|  54|  55|     /**
|  55|  56|      * @param root: The root of the binary search tree.
|  56|  57|      * @param k1 and k2: range k1 to k2.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  56|  56|      * @param k1 and k2: range k1 to k2.
|  57|  57|      * @return: Return all keys that k1<=key<=k2 in ascending order.
|  58|  58|      */
|  59|    |-    vector<int> searchRange(TreeNode* root, int k1, int k2) {
|  60|    |-        stack<TreeNode *> st;
|  61|    |-        vector<int> output;
|    |  59|+    vector < int >searchRange (TreeNode * root, int k1, int k2)
|    |  60|+    {
|    |  61|+        stack < TreeNode * >st;
|    |  62|+        vector < int >output;
|  62|  63| 
|  63|    |-        pushLeft(st, root, k1);
|    |  64|+          pushLeft (st, root, k1);
|  64|  65| 
|  65|    |-        while (st.size() > 0) {
|  66|    |-            TreeNode *t = st.top();
|  67|    |-            st.pop();
|    |  66|+        while (st.size () > 0)
|    |  67|+          {
|    |  68|+              TreeNode *t = st.top ();
|    |  69|+                st.pop ();
|  68|  70| 
|  69|    |-            // Add valid nodes to the stack.
|  70|    |-            if (t->val >= k1 && t->val <= k2) {
|  71|    |-                output.emplace_back(t->val);
|  72|    |-            }
|    |  71|+              // Add valid nodes to the stack.
|    |  72|+              if (t->val >= k1 && t->val <= k2)
|    |  73|+                {
|    |  74|+                    output.emplace_back (t->val);
|    |  75|+                }
|  73|  76| 
|  74|    |-            // Push until the min of right descendant.
|  75|    |-            if (t->val <= k2)  {
|  76|    |-                pushLeft(st, t->right, k1);
|  77|    |-            }
|  78|    |-        }
|    |  77|+              // Push until the min of right descendant.
|    |  78|+              if (t->val <= k2)
|    |  79|+                {
|    |  80|+                    pushLeft (st, t->right, k1);
|    |  81|+                }
|    |  82|+          }
|  79|  83| 
|  80|  84|         return output;
|  81|  85|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-range-in-binary-search-tree.cpp
|    |++++| /app/C++/search-range-in-binary-search-tree.cpp
|  79|  79| 
|  80|  80|         return output;
|  81|  81|     }
|  82|    |-private:
|    |  82|+  private:
|  83|  83|     // Add each valid node to the stack until invalid value appears.
|  84|    |-    void pushLeft(stack<TreeNode *> &st, TreeNode *root, int k1) {
|  85|    |-        while (root != nullptr) {  // Push until invalid.
|  86|    |-            st.emplace(root);
|  87|    |-            if (root->val < k1) {
|  88|    |-                break;
|  89|    |-            }
|  90|    |-            root = root->left;
|  91|    |-        }
|    |  84|+    void pushLeft (stack < TreeNode * >&st, TreeNode * root, int k1)
|    |  85|+    {
|    |  86|+        while (root != nullptr)
|    |  87|+          {                     // Push until invalid.
|    |  88|+              st.emplace (root);
|    |  89|+              if (root->val < k1)
|    |  90|+                {
|    |  91|+                    break;
|    |  92|+                }
|    |  93|+              root = root->left;
|    |  94|+          }
|  92|  95|     }
|  93|  96| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-list.cpp
|    |++++| /app/C++/partition-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @param x: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-list.cpp
|    |++++| /app/C++/partition-list.cpp
|  20|  20|      * @param x: an integer
|  21|  21|      * @return: a ListNode
|  22|  22|      */
|  23|    |-    ListNode *partition(ListNode *head, int x) {
|  24|    |-        ListNode dummy_smaller{0};
|  25|    |-        ListNode dummy_larger{0};
|    |  23|+    ListNode * partition (ListNode * head, int x)
|    |  24|+    {
|    |  25|+        ListNode dummy_smaller
|    |  26|+        {
|    |  27|+        0};
|    |  28|+        ListNode dummy_larger
|    |  29|+        {
|    |  30|+        0};
|  26|  31|         auto smaller = &dummy_smaller;
|  27|  32|         auto larger = &dummy_larger;
|  28|  33| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/partition-list.cpp
|    |++++| /app/C++/partition-list.cpp
|  26|  26|         auto smaller = &dummy_smaller;
|  27|  27|         auto larger = &dummy_larger;
|  28|  28| 
|  29|    |-        while (head) {
|  30|    |-            if (head->val < x) {
|  31|    |-                smaller->next = head;
|  32|    |-                smaller = smaller->next;
|  33|    |-            } else {
|  34|    |-                larger->next = head;
|  35|    |-                larger = larger->next;
|  36|    |-            }
|  37|    |-            head = head->next;
|  38|    |-        }
|    |  29|+        while (head)
|    |  30|+          {
|    |  31|+              if (head->val < x)
|    |  32|+                {
|    |  33|+                    smaller->next = head;
|    |  34|+                    smaller = smaller->next;
|    |  35|+                }
|    |  36|+              else
|    |  37|+                {
|    |  38|+                    larger->next = head;
|    |  39|+                    larger = larger->next;
|    |  40|+                }
|    |  41|+              head = head->next;
|    |  42|+          }
|  39|  43|         smaller->next = dummy_larger.next;
|  40|  44|         larger->next = nullptr;
|  41|  45| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16| 
|  17|    |-class Solution {
|  18|    |-public:
|    |  17|+class Solution
|    |  18|+{
|    |  19|+  public:
|  19|  20|     /**
|  20|  21|      * @param expression: A string array
|  21|  22|      * @return: The root of expression tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  20|  20|      * @param expression: A string array
|  21|  21|      * @return: The root of expression tree
|  22|  22|      */
|  23|    |-    ExpressionTreeNode* build(vector<string> &expression) {
|  24|    |-        if (expression.empty()) {
|  25|    |-            return 0;
|  26|    |-        }
|  27|    |-        vector<string> prefix;
|  28|    |-        infixToPrefix(expression, prefix);
|    |  23|+    ExpressionTreeNode * build (vector < string > &expression)
|    |  24|+    {
|    |  25|+        if (expression.empty ())
|    |  26|+          {
|    |  27|+              return 0;
|    |  28|+          }
|    |  29|+        vector < string > prefix;
|    |  30|+        infixToPrefix (expression, prefix);
|  29|  31|         int start = 0;
|  30|    |-        return buildExpressionTree(prefix, start);
|    |  32|+        return buildExpressionTree (prefix, start);
|  31|  33|     }
|  32|  34| 
|  33|  35|     // Build expression tree by prefix expression.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  31|  31|     }
|  32|  32| 
|  33|  33|     // Build expression tree by prefix expression.
|  34|    |-    ExpressionTreeNode* buildExpressionTree(vector<string>& prefix, int& start) {
|  35|    |-        if (prefix.empty()) {
|  36|    |-            return nullptr;
|  37|    |-        }
|  38|    |-        ExpressionTreeNode *node = new ExpressionTreeNode(prefix[start++]);
|  39|    |-        if (is_operator(prefix[start - 1])) {
|  40|    |-            node->left = buildExpressionTree(prefix, start);
|  41|    |-            node->right = buildExpressionTree(prefix, start);
|  42|    |-        }
|    |  34|+    ExpressionTreeNode *buildExpressionTree (vector < string > &prefix,
|    |  35|+                                             int &start)
|    |  36|+    {
|    |  37|+        if (prefix.empty ())
|    |  38|+          {
|    |  39|+              return nullptr;
|    |  40|+          }
|    |  41|+        ExpressionTreeNode *node = new ExpressionTreeNode (prefix[start++]);
|    |  42|+        if (is_operator (prefix[start - 1]))
|    |  43|+          {
|    |  44|+              node->left = buildExpressionTree (prefix, start);
|    |  45|+              node->right = buildExpressionTree (prefix, start);
|    |  46|+          }
|  43|  47|         return node;
|  44|  48|     }
|  45|  49| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  43|  43|         return node;
|  44|  44|     }
|  45|  45| 
|  46|    |-    bool is_operator(const string &op) {
|  47|    |-        return op.length() == 1 && string("+-*/").find(op) != string::npos;
|    |  46|+    bool is_operator (const string & op)
|    |  47|+    {
|    |  48|+        return op.length () == 1 && string ("+-*/").find (op) != string::npos;
|  48|  49|     }
|  49|  50| 
|  50|  51|     // Convert Infix to Prefix Expression.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  48|  48|     }
|  49|  49| 
|  50|  50|     // Convert Infix to Prefix Expression.
|  51|    |-    void infixToPrefix(vector<string>& infix, vector<string>& prefix) {
|  52|    |-        reverse(infix.begin(), infix.end());
|  53|    |-        stack<string> s;
|  54|    |-        for (auto& tok : infix) {
|  55|    |-            if (atoi(tok.c_str())) {
|  56|    |-                prefix.emplace_back(tok);
|  57|    |-            } else if (tok == ")") {
|  58|    |-                s.emplace(tok);
|  59|    |-            } else if (tok == "(") {
|  60|    |-                while (!s.empty()) {
|  61|    |-                    tok = s.top();
|  62|    |-                    s.pop();
|  63|    |-                    if (tok == ")") {
|  64|    |-                        break;
|  65|    |-                    }
|  66|    |-                    prefix.emplace_back(tok);
|    |  51|+    void infixToPrefix (vector < string > &infix, vector < string > &prefix)
|    |  52|+    {
|    |  53|+        reverse (infix.begin (), infix.end ());
|    |  54|+        stack < string > s;
|    |  55|+      for (auto & tok:infix)
|    |  56|+          {
|    |  57|+              if (atoi (tok.c_str ()))
|    |  58|+                {
|    |  59|+                    prefix.emplace_back (tok);
|  67|  60|                 }
|  68|    |-            } else {
|  69|    |-                while (!s.empty() && precedence(tok) < precedence(s.top())) {
|  70|    |-                    prefix.emplace_back(s.top());
|  71|    |-                    s.pop();
|    |  61|+              else if (tok == ")")
|    |  62|+                {
|    |  63|+                    s.emplace (tok);
|  72|  64|                 }
|  73|    |-                s.emplace(tok);
|  74|    |-            }
|  75|    |-        }
|  76|    |-        while (!s.empty()) {
|  77|    |-            prefix.emplace_back(s.top());
|  78|    |-            s.pop();
|  79|    |-        }
|  80|    |-        reverse(prefix.begin(), prefix.end());
|    |  65|+              else if (tok == "(")
|    |  66|+                {
|    |  67|+                    while (!s.empty ())
|    |  68|+                      {
|    |  69|+                          tok = s.top ();
|    |  70|+                          s.pop ();
|    |  71|+                          if (tok == ")")
|    |  72|+                            {
|    |  73|+                                break;
|    |  74|+                            }
|    |  75|+                          prefix.emplace_back (tok);
|    |  76|+                      }
|    |  77|+                }
|    |  78|+              else
|    |  79|+                {
|    |  80|+                    while (!s.empty ()
|    |  81|+                           && precedence (tok) < precedence (s.top ()))
|    |  82|+                      {
|    |  83|+                          prefix.emplace_back (s.top ());
|    |  84|+                          s.pop ();
|    |  85|+                      }
|    |  86|+                    s.emplace (tok);
|    |  87|+                }
|    |  88|+          }
|    |  89|+        while (!s.empty ())
|    |  90|+          {
|    |  91|+              prefix.emplace_back (s.top ());
|    |  92|+              s.pop ();
|    |  93|+          }
|    |  94|+        reverse (prefix.begin (), prefix.end ());
|  81|  95|     }
|  82|  96| 
|  83|  97|     int precedence(string x) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-tree-build.cpp
|    |++++| /app/C++/expression-tree-build.cpp
|  80|  80|         reverse(prefix.begin(), prefix.end());
|  81|  81|     }
|  82|  82| 
|  83|    |-    int precedence(string x) {
|  84|    |-        if (x == ")") {
|  85|    |-            return 0;
|  86|    |-        } else if (x == "+" || x == "-") {
|  87|    |-            return 1;
|  88|    |-        } else if (x == "*" || x == "/") {
|  89|    |-            return 2;
|  90|    |-        }
|    |  83|+    int precedence (string x)
|    |  84|+    {
|    |  85|+        if (x == ")")
|    |  86|+          {
|    |  87|+              return 0;
|    |  88|+          }
|    |  89|+        else if (x == "+" || x == "-")
|    |  90|+          {
|    |  91|+              return 1;
|    |  92|+          }
|    |  93|+        else if (x == "*" || x == "/")
|    |  94|+          {
|    |  95|+              return 2;
|    |  96|+          }
|  91|  97|         return 3;
|  92|  98|     }
|  93|  99| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens-ii.cpp
|    |++++| /app/C++/n-queens-ii.cpp
|   1|   1| // Time:  O(n * n!)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * Calculate the total number of distinct N-Queen solutions.
|   8|   9|      * @param n: The number of queens.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens-ii.cpp
|    |++++| /app/C++/n-queens-ii.cpp
|   8|   8|      * @param n: The number of queens.
|   9|   9|      * @return: The total number of distinct solutions.
|  10|  10|      */
|  11|    |-    int totalNQueens(int n) {
|  12|    |-        vector<int> placement(n);
|  13|    |-        return n_queens_helper(n, 0, &placement);
|    |  11|+    int totalNQueens (int n)
|    |  12|+    {
|    |  13|+        vector < int >placement (n);
|    |  14|+          return n_queens_helper (n, 0, &placement);
|  14|  15|     }
|  15|  16| 
|  16|  17|     bool is_feasible(const vector<int>& col_placement, int row) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens-ii.cpp
|    |++++| /app/C++/n-queens-ii.cpp
|  13|  13|         return n_queens_helper(n, 0, &placement);
|  14|  14|     }
|  15|  15| 
|  16|    |-    bool is_feasible(const vector<int>& col_placement, int row) {
|  17|    |-        for (int i = 0; i < row; ++i) {
|  18|    |-            int diff = abs(col_placement[i] - col_placement[row]);
|  19|    |-            if (diff == 0 || diff == row - i) {
|  20|    |-                return false;
|  21|    |-            }
|  22|    |-        }
|    |  16|+    bool is_feasible (const vector < int >&col_placement, int row)
|    |  17|+    {
|    |  18|+        for (int i = 0; i < row; ++i)
|    |  19|+          {
|    |  20|+              int diff = abs (col_placement[i] - col_placement[row]);
|    |  21|+              if (diff == 0 || diff == row - i)
|    |  22|+                {
|    |  23|+                    return false;
|    |  24|+                }
|    |  25|+          }
|  23|  26|         return true;
|  24|  27|     }
|  25|  28| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens-ii.cpp
|    |++++| /app/C++/n-queens-ii.cpp
|  23|  23|         return true;
|  24|  24|     }
|  25|  25| 
|  26|    |-    int n_queens_helper(int n, int row, vector<int>* col_placement) {
|  27|    |-        if (row == n) {
|  28|    |-            return 1;
|  29|    |-        } else {
|  30|    |-            int sum = 0;
|  31|    |-            for (int col = 0; col < n; ++col) {
|  32|    |-                (*col_placement)[row] = col;
|  33|    |-                if (is_feasible(*col_placement, row)) {
|  34|    |-                    sum += n_queens_helper(n, row + 1, col_placement);
|    |  26|+    int n_queens_helper (int n, int row, vector < int >*col_placement)
|    |  27|+    {
|    |  28|+        if (row == n)
|    |  29|+          {
|    |  30|+              return 1;
|    |  31|+          }
|    |  32|+        else
|    |  33|+          {
|    |  34|+              int sum = 0;
|    |  35|+              for (int col = 0; col < n; ++col)
|    |  36|+                {
|    |  37|+                    (*col_placement)[row] = col;
|    |  38|+                    if (is_feasible (*col_placement, row))
|    |  39|+                      {
|    |  40|+                          sum += n_queens_helper (n, row + 1, col_placement);
|    |  41|+                      }
|  35|  42|                 }
|  36|    |-            }
|  37|    |-            return sum;
|  38|    |-        }
|    |  43|+              return sum;
|    |  44|+          }
|  39|  45|     }
|  40|  46| };
|  41|  47| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens-ii.cpp
|    |++++| /app/C++/n-queens-ii.cpp
|  38|  38|         }
|  39|  39|     }
|  40|  40| };
|  41|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-nodes-in-k-group.cpp
|    |++++| /app/C++/reverse-nodes-in-k-group.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head a ListNode
|  16|  17|      * @param k an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-nodes-in-k-group.cpp
|    |++++| /app/C++/reverse-nodes-in-k-group.cpp
|  16|  16|      * @param k an integer
|  17|  17|      * @return a ListNode
|  18|  18|      */
|  19|    |-    ListNode *reverseKGroup(ListNode *head, int k) {
|  20|    |-        ListNode dummy{0};
|  21|    |-        dummy.next = head;
|    |  19|+    ListNode * reverseKGroup (ListNode * head, int k)
|    |  20|+    {
|    |  21|+        ListNode dummy
|    |  22|+        {
|    |  23|+        0};
|    |  24|+          dummy.next = head;
|  22|  25|         auto curr = head, curr_dummy = &dummy;
|  23|  26|         int length = 0;
|  24|  27| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-nodes-in-k-group.cpp
|    |++++| /app/C++/reverse-nodes-in-k-group.cpp
|  22|  22|         auto curr = head, curr_dummy = &dummy;
|  23|  23|         int length = 0;
|  24|  24| 
|  25|    |-        while (curr) {
|  26|    |-            ListNode *next_curr = curr->next;
|  27|    |-            length = (length + 1) % k;
|    |  25|+        while (curr)
|    |  26|+          {
|    |  27|+              ListNode *next_curr = curr->next;
|    |  28|+                length = (length + 1) % k;
|  28|  29| 
|  29|    |-            if (length == 0) {
|  30|    |-                ListNode *next_dummy = curr_dummy->next;
|  31|    |-                reverse(&curr_dummy, curr->next);
|  32|    |-                curr_dummy = next_dummy;
|  33|    |-            }
|  34|    |-            curr = next_curr;
|  35|    |-        }
|    |  30|+              if (length == 0)
|    |  31|+                {
|    |  32|+                    ListNode *next_dummy = curr_dummy->next;
|    |  33|+                      reverse (&curr_dummy, curr->next);
|    |  34|+                      curr_dummy = next_dummy;
|    |  35|+                }
|    |  36|+              curr = next_curr;
|    |  37|+          }
|  36|  38|         return dummy.next;
|  37|  39|     }
|  38|  40| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-nodes-in-k-group.cpp
|    |++++| /app/C++/reverse-nodes-in-k-group.cpp
|  36|  36|         return dummy.next;
|  37|  37|     }
|  38|  38| 
|  39|    |-    void reverse(ListNode **begin, const ListNode *end) {
|    |  39|+    void reverse (ListNode ** begin, const ListNode * end)
|    |  40|+    {
|  40|  41|         auto first = (*begin)->next, curr = first->next;
|  41|  42| 
|  42|  43|         while (curr != end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-nodes-in-k-group.cpp
|    |++++| /app/C++/reverse-nodes-in-k-group.cpp
|  39|  39|     void reverse(ListNode **begin, const ListNode *end) {
|  40|  40|         auto first = (*begin)->next, curr = first->next;
|  41|  41| 
|  42|    |-        while (curr != end) {
|  43|    |-            first->next = curr->next;
|  44|    |-            curr->next = (*begin)->next;
|  45|    |-            (*begin)->next = curr;
|  46|    |-            curr = first->next;
|  47|    |-        }
|    |  42|+        while (curr != end)
|    |  43|+          {
|    |  44|+              first->next = curr->next;
|    |  45|+              curr->next = (*begin)->next;
|    |  46|+              (*begin)->next = curr;
|    |  47|+              curr = first->next;
|    |  48|+          }
|  48|  49|     }
|  49|  50| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|   4| // Hash solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums1 an integer array
|   9|  10|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|   9|   9|      * @param nums2 an integer array
|  10|  10|      * @return an integer array
|  11|  11|      */
|  12|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  13|    |-        if (nums1.size() > nums2.size()) {
|  14|    |-            return intersection(nums2, nums1);
|  15|    |-        }
|    |  12|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  13|+    {
|    |  14|+        if (nums1.size () > nums2.size ())
|    |  15|+          {
|    |  16|+              return intersection (nums2, nums1);
|    |  17|+          }
|  16|  18| 
|  17|    |-        unordered_set<int> lookup{nums1.cbegin(), nums1.cend()};
|    |  19|+        unordered_set < int >lookup
|    |  20|+        {
|    |  21|+        nums1.cbegin (), nums1.cend ()};
|  18|  22| 
|  19|    |-        vector<int> result;
|  20|    |-        for (const auto& i : nums2) {
|  21|    |-            if (lookup.count(i)) {
|  22|    |-                result.emplace_back(i);
|  23|    |-                lookup.erase(i);
|  24|    |-            }
|  25|    |-        }
|    |  23|+        vector < int >result;
|    |  24|+      for (const auto & i:nums2)
|    |  25|+          {
|    |  26|+              if (lookup.count (i))
|    |  27|+                {
|    |  28|+                    result.emplace_back (i);
|    |  29|+                    lookup.erase (i);
|    |  30|+                }
|    |  31|+          }
|  26|  32| 
|  27|  33|         return result;
|  28|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  27|  27|         return result;
|  28|  28|     }
|  29|  29| };
|  30|    |-
|  31|  30| 
|  32|  31| // Time:  O(max(m, n) * log(max(m, n)))
|  33|  32| // Space: O(1)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  32|  32| // Time:  O(max(m, n) * log(max(m, n)))
|  33|  33| // Space: O(1)
|  34|  34| // Binary search solution.
|  35|    |-class Solution2 {
|  36|    |-public:
|    |  35|+class Solution2
|    |  36|+{
|    |  37|+  public:
|  37|  38|     /**
|  38|  39|      * @param nums1 an integer array
|  39|  40|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  39|  39|      * @param nums2 an integer array
|  40|  40|      * @return an integer array
|  41|  41|      */
|  42|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  43|    |-        if (nums1.size() > nums2.size()) {
|  44|    |-            return intersection(nums2, nums1);
|  45|    |-        }
|    |  42|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  43|+    {
|    |  44|+        if (nums1.size () > nums2.size ())
|    |  45|+          {
|    |  46|+              return intersection (nums2, nums1);
|    |  47|+          }
|  46|  48| 
|  47|    |-        sort(nums1.begin(), nums1.end());
|  48|    |-        sort(nums2.begin(), nums2.end());
|    |  49|+        sort (nums1.begin (), nums1.end ());
|    |  50|+        sort (nums2.begin (), nums2.end ());
|  49|  51| 
|  50|    |-        vector<int> result;
|  51|    |-        auto it = nums2.cbegin();
|  52|    |-        for (const auto& i : nums1) {
|  53|    |-            it = lower_bound(it, nums2.cend(), i);
|  54|    |-            if (it != nums2.end() && *it == i) {
|  55|    |-                result.emplace_back(*it);
|  56|    |-                it = upper_bound(it, nums2.cend(), i);
|  57|    |-            }
|  58|    |-        }
|  59|    |-        
|    |  52|+        vector < int >result;
|    |  53|+        auto it = nums2.cbegin ();
|    |  54|+      for (const auto & i:nums1)
|    |  55|+          {
|    |  56|+              it = lower_bound (it, nums2.cend (), i);
|    |  57|+              if (it != nums2.end () && *it == i)
|    |  58|+                {
|    |  59|+                    result.emplace_back (*it);
|    |  60|+                    it = upper_bound (it, nums2.cend (), i);
|    |  61|+                }
|    |  62|+          }
|    |  63|+
|  60|  64|         return result;
|  61|  65|     }
|  62|  66| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  61|  61|     }
|  62|  62| };
|  63|  63| 
|  64|    |-
|  65|  64| // Time:  O(max(m, n) * log(max(m, n)))
|  66|  65| // Space: O(1)
|  67|  66| // Two pointers solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  65|  65| // Time:  O(max(m, n) * log(max(m, n)))
|  66|  66| // Space: O(1)
|  67|  67| // Two pointers solution.
|  68|    |-class Solution3 {
|  69|    |-public:
|    |  68|+class Solution3
|    |  69|+{
|    |  70|+  public:
|  70|  71|     /**
|  71|  72|      * @param nums1 an integer array
|  72|  73|      * @param nums2 an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-arrays.cpp
|    |++++| /app/C++/intersection-of-two-arrays.cpp
|  72|  72|      * @param nums2 an integer array
|  73|  73|      * @return an integer array
|  74|  74|      */
|  75|    |-    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
|  76|    |-        vector<int> result;
|  77|    |-        sort(nums1.begin(), nums1.end());
|  78|    |-        sort(nums2.begin(), nums2.end());
|  79|    |-        auto it1 = nums1.cbegin(), it2 = nums2.cbegin();
|  80|    |-        while (it1 != nums1.cend() && it2 != nums2.cend()) {
|  81|    |-            if (*it1 < *it2) {
|  82|    |-                ++it1;
|  83|    |-            } else if (*it1 > *it2) {
|  84|    |-                ++it2;
|  85|    |-            } else {
|  86|    |-                if (result.empty() || result.back() != *it1) {
|  87|    |-                    result.emplace_back(*it1);
|    |  75|+    vector < int >intersection (vector < int >&nums1, vector < int >&nums2)
|    |  76|+    {
|    |  77|+        vector < int >result;
|    |  78|+          sort (nums1.begin (), nums1.end ());
|    |  79|+          sort (nums2.begin (), nums2.end ());
|    |  80|+        auto it1 = nums1.cbegin (), it2 = nums2.cbegin ();
|    |  81|+        while (it1 != nums1.cend () && it2 != nums2.cend ())
|    |  82|+          {
|    |  83|+              if (*it1 < *it2)
|    |  84|+                {
|    |  85|+                    ++it1;
|  88|  86|                 }
|  89|    |-                ++it1, ++it2;
|  90|    |-            }
|  91|    |-        }
|    |  87|+              else if (*it1 > *it2)
|    |  88|+                {
|    |  89|+                    ++it2;
|    |  90|+                }
|    |  91|+              else
|    |  92|+                {
|    |  93|+                    if (result.empty () || result.back () != *it1)
|    |  94|+                      {
|    |  95|+                          result.emplace_back (*it1);
|    |  96|+                      }
|    |  97|+                    ++it1, ++it2;
|    |  98|+                }
|    |  99|+          }
|  92| 100|         return result;
|  93| 101|     }
|  94| 102| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-integer.cpp
|    |++++| /app/C++/reverse-integer.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n the integer to be reversed
|   8|   9|      * @return the reversed integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-integer.cpp
|    |++++| /app/C++/reverse-integer.cpp
|   7|   7|      * @param n the integer to be reversed
|   8|   8|      * @return the reversed integer
|   9|   9|      */
|  10|    |-    int reverseInteger(int n) {
|    |  10|+    int reverseInteger (int n)
|    |  11|+    {
|  11|  12|         int result = 0;
|  12|    |-        while (n) {
|  13|    |-            auto prev = result;
|  14|    |-            result *= 10;
|  15|    |-            result += n % 10;
|  16|    |-            if (result / 10 != prev) {
|  17|    |-                result = 0;
|  18|    |-                break;
|  19|    |-            }
|  20|    |-            n /= 10;
|  21|    |-        }
|    |  13|+        while (n)
|    |  14|+          {
|    |  15|+              auto prev = result;
|    |  16|+                result *= 10;
|    |  17|+                result += n % 10;
|    |  18|+              if (result / 10 != prev)
|    |  19|+                {
|    |  20|+                    result = 0;
|    |  21|+                    break;
|    |  22|+                }
|    |  23|+              n /= 10;
|    |  24|+          }
|  22|  25|         return result;
|  23|  26|     }
|  24|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/integer-to-roman.cpp
|    |++++| /app/C++/integer-to-roman.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n The integer
|   8|   9|      * @return Roman representation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/integer-to-roman.cpp
|    |++++| /app/C++/integer-to-roman.cpp
|   7|   7|      * @param n The integer
|   8|   8|      * @return Roman representation
|   9|   9|      */
|  10|    |-    string intToRoman(int n) {
|  11|    |-        const vector<int> nums{1000, 900, 500, 400, 100, 90,
|  12|    |-                               50, 40, 10, 9, 5, 4, 1};
|  13|    |-        const vector<string> romans{"M", "CM", "D", "CD", "C", "XC", "L",
|  14|    |-                                    "XL", "X", "IX", "V", "IV", "I"};
|    |  10|+    string intToRoman (int n)
|    |  11|+    {
|    |  12|+        const vector < int >nums
|    |  13|+        {
|    |  14|+        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
|    |  15|+        const vector < string > romans
|    |  16|+        {
|    |  17|+        "M", "CM", "D", "CD", "C", "XC", "L",
|    |  18|+                "XL", "X", "IX", "V", "IV", "I"};
|  15|  19| 
|  16|  20|         string result;
|  17|  21|         int i = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/integer-to-roman.cpp
|    |++++| /app/C++/integer-to-roman.cpp
|  15|  15| 
|  16|  16|         string result;
|  17|  17|         int i = 0;
|  18|    |-        while (n > 0) {
|  19|    |-            int times = n / nums[i];
|  20|    |-            while (times--) {
|  21|    |-                n -= nums[i];
|  22|    |-                result.append(romans[i]);
|  23|    |-            }
|  24|    |-            ++i;
|  25|    |-        }        
|    |  18|+        while (n > 0)
|    |  19|+          {
|    |  20|+              int times = n / nums[i];
|    |  21|+              while (times--)
|    |  22|+                {
|    |  23|+                    n -= nums[i];
|    |  24|+                    result.append (romans[i]);
|    |  25|+                }
|    |  26|+              ++i;
|    |  27|+          }
|  26|  28|         return result;
|  27|  29|     }
|  28|  30| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-string.cpp
|    |++++| /app/C++/interleaving-string.cpp
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|   4| // DP with rolling window.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * Determine whether s3 is formed by interleaving of s1 and s2.
|   9|  10|      * @param s1, s2, s3: As description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-string.cpp
|    |++++| /app/C++/interleaving-string.cpp
|   9|   9|      * @param s1, s2, s3: As description.
|  10|  10|      * @return: true of false.
|  11|  11|      */
|  12|    |-    bool isInterleave(string s1, string s2, string s3) {
|    |  12|+    bool isInterleave (string s1, string s2, string s3)
|    |  13|+    {
|  13|  14|         // Early return if |s1| + |s2| != |s3|.
|  14|    |-        if (s1.size() + s2.size() != s3.size()) {
|  15|    |-            return false;
|  16|    |-        }
|    |  15|+        if (s1.size () + s2.size () != s3.size ())
|    |  16|+          {
|    |  17|+              return false;
|    |  18|+          }
|  17|  19| 
|  18|    |-        if (s1.size() < s2.size()) {
|  19|    |-            return isInterleave(s2, s1, s3);
|  20|    |-        }
|    |  20|+        if (s1.size () < s2.size ())
|    |  21|+          {
|    |  22|+              return isInterleave (s2, s1, s3);
|    |  23|+          }
|  21|  24| 
|  22|    |-        vector<deque<bool>> T(2, deque<bool>(s2.size() + 1));
|  23|    |-        T[0][0] = true;  // Base case.
|    |  25|+        vector < deque < bool >> T (2, deque < bool > (s2.size () + 1));
|    |  26|+        T[0][0] = true;         // Base case.
|  24|  27| 
|  25|  28|         // Uses chars from s2 only to match s3.
|  26|  29|         for (size_t j = 0; j < s2.size(); ++j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-string.cpp
|    |++++| /app/C++/interleaving-string.cpp
|  23|  23|         T[0][0] = true;  // Base case.
|  24|  24| 
|  25|  25|         // Uses chars from s2 only to match s3.
|  26|    |-        for (size_t j = 0; j < s2.size(); ++j) {
|  27|    |-            if (s2[j] == s3[j]) {
|  28|    |-                T[0][j + 1] = true;
|  29|    |-            } else {
|  30|    |-                break;
|  31|    |-            }
|  32|    |-        }
|    |  26|+        for (size_t j = 0; j < s2.size (); ++j)
|    |  27|+          {
|    |  28|+              if (s2[j] == s3[j])
|    |  29|+                {
|    |  30|+                    T[0][j + 1] = true;
|    |  31|+                }
|    |  32|+              else
|    |  33|+                {
|    |  34|+                    break;
|    |  35|+                }
|    |  36|+          }
|  33|  37| 
|  34|    |-        for (size_t i = 0; i < s1.size(); ++i) {
|  35|    |-            // Uses chars from s1 only to match s3.
|  36|    |-            T[(i + 1) % 2][0] = T[i % 2][0] && s1[i] == s3[i];
|    |  38|+        for (size_t i = 0; i < s1.size (); ++i)
|    |  39|+          {
|    |  40|+              // Uses chars from s1 only to match s3.
|    |  41|+              T[(i + 1) % 2][0] = T[i % 2][0] && s1[i] == s3[i];
|  37|  42| 
|  38|    |-            for (size_t j = 0; j < s2.size(); ++j) {
|  39|    |-                T[(i + 1) % 2][j + 1] = (T[i % 2][j + 1] && s1[i] == s3[i + j + 1]) ||
|  40|    |-                                        (T[(i + 1) % 2][j] && s2[j] == s3[i + j + 1]);
|  41|    |-            }
|  42|    |-        }
|    |  43|+              for (size_t j = 0; j < s2.size (); ++j)
|    |  44|+                {
|    |  45|+                    T[(i + 1) % 2][j + 1] = (T[i % 2][j + 1]
|    |  46|+                                             && s1[i] == s3[i + j + 1])
|    |  47|+                        || (T[(i + 1) % 2][j] && s2[j] == s3[i + j + 1]);
|    |  48|+                }
|    |  49|+          }
|  43|  50| 
|  44|    |-        return T[s1.size() % 2][s2.size()];
|    |  51|+        return T[s1.size () % 2][s2.size ()];
|  45|  52|     }
|  46|  53| };
|  47|  54| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-string.cpp
|    |++++| /app/C++/interleaving-string.cpp
|  48|  48| // Time:  O(m * n)
|  49|  49| // Space: O(m * n)
|  50|  50| // DP
|  51|    |-class Solution2 {
|  52|    |-public:
|    |  51|+class Solution2
|    |  52|+{
|    |  53|+  public:
|  53|  54|     /**
|  54|  55|      * Determine whether s3 is formed by interleaving of s1 and s2.
|  55|  56|      * @param s1, s2, s3: As description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interleaving-string.cpp
|    |++++| /app/C++/interleaving-string.cpp
|  55|  55|      * @param s1, s2, s3: As description.
|  56|  56|      * @return: true of false.
|  57|  57|      */
|  58|    |-    bool isInterleave(string s1, string s2, string s3) {
|    |  58|+    bool isInterleave (string s1, string s2, string s3)
|    |  59|+    {
|  59|  60|         // Early return if |s1| + |s2| != |s3|.
|  60|    |-        if (s1.size() + s2.size() != s3.size()) {
|  61|    |-            return false;
|  62|    |-        }
|    |  61|+        if (s1.size () + s2.size () != s3.size ())
|    |  62|+          {
|    |  63|+              return false;
|    |  64|+          }
|  63|  65| 
|  64|    |-        vector<deque<bool>> T(s1.size() + 1, deque<bool>(s2.size() + 1));
|  65|    |-        T[0][0] = true;  // Base case.
|    |  66|+        vector < deque < bool >> T (s1.size () + 1,
|    |  67|+                                    deque < bool > (s2.size () + 1));
|    |  68|+        T[0][0] = true;         // Base case.
|  66|  69|         // Uses chars from s1 only to match s3.
|  67|    |-        for (size_t i = 0; i < s1.size(); ++i) {
|  68|    |-            if (s1[i] == s3[i]) {
|  69|    |-                T[i + 1][0] = true;
|  70|    |-            } else {
|  71|    |-                break;
|  72|    |-            }
|  73|    |-        }
|    |  70|+        for (size_t i = 0; i < s1.size (); ++i)
|    |  71|+          {
|    |  72|+              if (s1[i] == s3[i])
|    |  73|+                {
|    |  74|+                    T[i + 1][0] = true;
|    |  75|+                }
|    |  76|+              else
|    |  77|+                {
|    |  78|+                    break;
|    |  79|+                }
|    |  80|+          }
|  74|  81|         // Uses chars from s2 only to match s3.
|  75|    |-        for (size_t j = 0; j < s2.size(); ++j) {
|  76|    |-            if (s2[j] == s3[j]) {
|  77|    |-                T[0][j + 1] = true;
|  78|    |-            } else {
|  79|    |-                break;
|  80|    |-            }
|  81|    |-        }
|    |  82|+        for (size_t j = 0; j < s2.size (); ++j)
|    |  83|+          {
|    |  84|+              if (s2[j] == s3[j])
|    |  85|+                {
|    |  86|+                    T[0][j + 1] = true;
|    |  87|+                }
|    |  88|+              else
|    |  89|+                {
|    |  90|+                    break;
|    |  91|+                }
|    |  92|+          }
|  82|  93| 
|  83|    |-        for (size_t i = 0; i < s1.size(); ++i) {
|  84|    |-            for (size_t j = 0; j < s2.size(); ++j) {
|  85|    |-                T[i + 1][j + 1] = (T[i][j + 1] && s1[i] == s3[i + j + 1]) ||
|  86|    |-                                  (T[i + 1][j] && s2[j] == s3[i + j + 1]);
|  87|    |-            }
|  88|    |-        }
|    |  94|+        for (size_t i = 0; i < s1.size (); ++i)
|    |  95|+          {
|    |  96|+              for (size_t j = 0; j < s2.size (); ++j)
|    |  97|+                {
|    |  98|+                    T[i + 1][j + 1] = (T[i][j + 1] && s1[i] == s3[i + j + 1])
|    |  99|+                        || (T[i + 1][j] && s2[j] == s3[i + j + 1]);
|    | 100|+                }
|    | 101|+          }
|  89| 102| 
|  90|    |-        return T[s1.size()][s2.size()];
|    | 103|+        return T[s1.size ()][s2.size ()];
|  91| 104|     }
|  92| 105| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  10|  10|  *         this->end = end;
|  11|  11|  *     }
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param intervals: An interval array
|  17|  18|      * @return: Count of airplanes are in the sky.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  16|  16|      * @param intervals: An interval array
|  17|  17|      * @return: Count of airplanes are in the sky.
|  18|  18|      */
|  19|    |-    int countOfAirplanes(vector<Interval> &airplanes) {
|    |  19|+    int countOfAirplanes (vector < Interval > &airplanes)
|    |  20|+    {
|  20|  21|         int max_planes = 0;
|  21|  22|         int planes = 0;
|  22|  23| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  20|  20|         int max_planes = 0;
|  21|  21|         int planes = 0;
|  22|  22| 
|  23|    |-        vector<int> starts, ends;
|  24|    |-        for (const auto& i : airplanes) {
|  25|    |-            starts.emplace_back(i.start);
|  26|    |-            ends.emplace_back(i.end);
|  27|    |-        }
|    |  23|+          vector < int >starts, ends;
|    |  24|+        for (const auto & i:airplanes)
|    |  25|+          {
|    |  26|+              starts.emplace_back (i.start);
|    |  27|+              ends.emplace_back (i.end);
|    |  28|+          }
|  28|  29| 
|  29|    |-
|  30|    |-        sort(starts.begin(), starts.end());
|  31|    |-        sort(ends.begin(), ends.end());
|    |  30|+        sort (starts.begin (), starts.end ());
|    |  31|+        sort (ends.begin (), ends.end ());
|  32|  32| 
|  33|  33|         int s = 0, e = 0;
|  34|  34|         while (s < starts.size()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  31|  31|         sort(ends.begin(), ends.end());
|  32|  32| 
|  33|  33|         int s = 0, e = 0;
|  34|    |-        while (s < starts.size()) {
|  35|    |-            if (starts[s] < ends[e]) {
|  36|    |-                ++planes;
|  37|    |-                max_planes = max(max_planes, planes);
|  38|    |-                ++s;
|  39|    |-            } else {
|  40|    |-                --planes;
|  41|    |-                ++e;
|  42|    |-            }
|  43|    |-        }
|    |  34|+        while (s < starts.size ())
|    |  35|+          {
|    |  36|+              if (starts[s] < ends[e])
|    |  37|+                {
|    |  38|+                    ++planes;
|    |  39|+                    max_planes = max (max_planes, planes);
|    |  40|+                    ++s;
|    |  41|+                }
|    |  42|+              else
|    |  43|+                {
|    |  44|+                    --planes;
|    |  45|+                    ++e;
|    |  46|+                }
|    |  47|+          }
|  44|  48| 
|  45|  49|         return max_planes;
|  46|  50|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  46|  46|     }
|  47|  47| };
|  48|  48| 
|  49|    |-class Solution2 {
|  50|    |-public:
|  51|    |-    using Endpoint = enum {START, END};
|    |  49|+class Solution2
|    |  50|+{
|    |  51|+  public:
|    |  52|+    using Endpoint = enum
|    |  53|+    { START, END };
|  52|  54| 
|  53|    |-    struct Point {
|    |  55|+    struct Point
|    |  56|+    {
|  54|  57|         Endpoint type;
|  55|  58|         int time;
|  56|  59|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  55|  55|         int time;
|  56|  56|     };
|  57|  57| 
|  58|    |-    struct Compare {
|  59|    |-        bool operator() (const Point&a, const Point&b) {
|    |  58|+    struct Compare
|    |  59|+    {
|    |  60|+        bool operator () (const Point & a, const Point & b)
|    |  61|+        {
|  60|  62|             return a.time != b.time ? a.time < b.time : a.type > b.type;
|  61|  63|         }
|  62|  64|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  65|  65|      * @param intervals: An interval array
|  66|  66|      * @return: Count of airplanes are in the sky.
|  67|  67|      */
|  68|    |-    int countOfAirplanes(vector<Interval> &airplanes) {
|    |  68|+    int countOfAirplanes (vector < Interval > &airplanes)
|    |  69|+    {
|  69|  70|         int max_planes = 0;
|  70|  71|         int planes = 0;
|  71|  72| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  69|  69|         int max_planes = 0;
|  70|  70|         int planes = 0;
|  71|  71| 
|  72|    |-        vector<Point> points;
|  73|    |-        for (const auto& i : airplanes) {
|  74|    |-            points.emplace_back(Point{START, i.start});
|  75|    |-            points.emplace_back(Point{END, i.end});
|  76|    |-        }
|  77|    |-        sort(points.begin(), points.end(), Compare());
|    |  72|+        vector < Point > points;
|    |  73|+      for (const auto & i:airplanes)
|    |  74|+          {
|    |  75|+              points.emplace_back (Point
|    |  76|+                                   {
|    |  77|+                                   START, i.start});
|    |  78|+              points.emplace_back (Point
|    |  79|+                                   {
|    |  80|+                                   END, i.end});
|    |  81|+          }
|    |  82|+        sort (points.begin (), points.end (), Compare ());
|  78|  83| 
|  79|    |-        for (const auto& i : points) {
|  80|    |-            if (i.type == START) {
|  81|    |-                ++planes;
|  82|    |-                max_planes = max(max_planes, planes);
|  83|    |-            } else {
|  84|    |-                --planes;
|  85|    |-            }
|  86|    |-        }
|    |  84|+      for (const auto & i:points)
|    |  85|+          {
|    |  86|+              if (i.type == START)
|    |  87|+                {
|    |  88|+                    ++planes;
|    |  89|+                    max_planes = max (max_planes, planes);
|    |  90|+                }
|    |  91|+              else
|    |  92|+                {
|    |  93|+                    --planes;
|    |  94|+                }
|    |  95|+          }
|  87|  96|         return max_planes;
|  88|  97|     }
|  89|  98| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
|  89|  89| };
|  90|  90| 
|  91|  91| // BST solution.
|  92|    |-class Solution3 {
|  93|    |-public:
|  94|    |-    struct Compare {
|  95|    |-        bool operator() (const Interval&a, const Interval&b) {
|    |  92|+class Solution3
|    |  93|+{
|    |  94|+  public:
|    |  95|+    struct Compare
|    |  96|+    {
|    |  97|+        bool operator () (const Interval & a, const Interval & b)
|    |  98|+        {
|  96|  99|             return a.start != b.start ? a.start < b.start : a.end < b.end;
|  97| 100|         }
|  98| 101|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
| 100| 100|      * @param intervals: An interval array
| 101| 101|      * @return: Count of airplanes are in the sky.
| 102| 102|      */
| 103|    |-    int countOfAirplanes(vector<Interval> &airplanes) {
|    | 103|+    int countOfAirplanes (vector < Interval > &airplanes)
|    | 104|+    {
| 104| 105|         int max_planes = 0;
| 105|    |-        multiset<int> bst;
| 106|    |-        sort(airplanes.begin(), airplanes.end(), Compare());
|    | 106|+        multiset < int >bst;
|    | 107|+        sort (airplanes.begin (), airplanes.end (), Compare ());
| 107| 108| 
| 108|    |-        for (const auto& i : airplanes) {
| 109|    |-            bst.emplace(i.end);
| 110|    |-            while (*bst.begin() <= i.start) {
| 111|    |-                bst.erase((bst.begin()));
| 112|    |-            }
| 113|    |-            if (bst.size() > max_planes) {
| 114|    |-                max_planes = bst.size();
| 115|    |-            }
| 116|    |-        }
|    | 109|+      for (const auto & i:airplanes)
|    | 110|+          {
|    | 111|+              bst.emplace (i.end);
|    | 112|+              while (*bst.begin () <= i.start)
|    | 113|+                {
|    | 114|+                    bst.erase ((bst.begin ()));
|    | 115|+                }
|    | 116|+              if (bst.size () > max_planes)
|    | 117|+                {
|    | 118|+                    max_planes = bst.size ();
|    | 119|+                }
|    | 120|+          }
| 117| 121|         return max_planes;
| 118| 122|     }
| 119| 123| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
| 119| 119| };
| 120| 120| 
| 121| 121| // Heap solution.
| 122|    |-class Solution4 {
| 123|    |-public:
| 124|    |-    struct Compare {
| 125|    |-        bool operator() (const Interval&a, const Interval&b) {
|    | 122|+class Solution4
|    | 123|+{
|    | 124|+  public:
|    | 125|+    struct Compare
|    | 126|+    {
|    | 127|+        bool operator () (const Interval & a, const Interval & b)
|    | 128|+        {
| 126| 129|             return a.start != b.start ? a.start < b.start : a.end < b.end;
| 127| 130|         }
| 128| 131|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-airplanes-in-the-sky.cpp
|    |++++| /app/C++/number-of-airplanes-in-the-sky.cpp
| 130| 130|      * @param intervals: An interval array
| 131| 131|      * @return: Count of airplanes are in the sky.
| 132| 132|      */
| 133|    |-    int countOfAirplanes(vector<Interval> &airplanes) {
|    | 133|+    int countOfAirplanes (vector < Interval > &airplanes)
|    | 134|+    {
| 134| 135|         int max_planes = 0;
| 135|    |-        priority_queue<int, vector<int>, greater<int>> min_heap;
| 136|    |-        sort(airplanes.begin(), airplanes.end(), Compare());
|    | 136|+        priority_queue < int, vector < int >, greater < int >>min_heap;
|    | 137|+        sort (airplanes.begin (), airplanes.end (), Compare ());
| 137| 138| 
| 138|    |-        for (const auto& i : airplanes) {
| 139|    |-            min_heap.emplace(i.end);
| 140|    |-            while (min_heap.top() <= i.start) {
| 141|    |-                min_heap.pop();
| 142|    |-            }
| 143|    |-            if (min_heap.size() > max_planes) {
| 144|    |-                max_planes = min_heap.size();
| 145|    |-            }
| 146|    |-        }
|    | 139|+      for (const auto & i:airplanes)
|    | 140|+          {
|    | 141|+              min_heap.emplace (i.end);
|    | 142|+              while (min_heap.top () <= i.start)
|    | 143|+                {
|    | 144|+                    min_heap.pop ();
|    | 145|+                }
|    | 146|+              if (min_heap.size () > max_planes)
|    | 147|+                {
|    | 148|+                    max_planes = min_heap.size ();
|    | 149|+                }
|    | 150|+          }
| 147| 151|         return max_planes;
| 148| 152|     }
| 149| 153| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/dices-sum.cpp
|    |++++| /app/C++/dices-sum.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n an integer
|   8|   9|      * @return a list of pair<sum, probability>
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/dices-sum.cpp
|    |++++| /app/C++/dices-sum.cpp
|   7|   7|      * @param n an integer
|   8|   8|      * @return a list of pair<sum, probability>
|   9|   9|      */
|  10|    |-    vector<pair<int, double>> dicesSum(int n) {
|  11|    |-        vector<pair<int, double>> result;
|  12|    |-        vector<vector<double>> dp(2, vector<double>(6 * n + 1));
|    |  10|+    vector < pair < int, double >>dicesSum (int n)
|    |  11|+    {
|    |  12|+        vector < pair < int, double >>result;
|    |  13|+          vector < vector < double >>dp (2, vector < double >(6 * n + 1));
|  13|  14| 
|  14|    |-        for (int i = 1; i <= 6; ++i) {
|  15|    |-            dp[1][i] = 1.0 / 6;
|  16|    |-        }
|  17|    |-        
|  18|    |-        for (int i = 2; i <= n; ++i) {
|  19|    |-            for (int j = 1; j <= 6 * i; ++j) {
|  20|    |-                dp[i % 2][j] = 0.0;
|  21|    |-                for (int k = 1; k <= 6; ++k) {
|  22|    |-                    if (j > k) {
|  23|    |-                        dp[i % 2][j] += dp[(i - 1) % 2][j - k];
|  24|    |-                    }
|    |  15|+        for (int i = 1; i <= 6; ++i)
|    |  16|+          {
|    |  17|+              dp[1][i] = 1.0 / 6;
|    |  18|+          }
|    |  19|+
|    |  20|+        for (int i = 2; i <= n; ++i)
|    |  21|+          {
|    |  22|+              for (int j = 1; j <= 6 * i; ++j)
|    |  23|+                {
|    |  24|+                    dp[i % 2][j] = 0.0;
|    |  25|+                    for (int k = 1; k <= 6; ++k)
|    |  26|+                      {
|    |  27|+                          if (j > k)
|    |  28|+                            {
|    |  29|+                                dp[i % 2][j] += dp[(i - 1) % 2][j - k];
|    |  30|+                            }
|    |  31|+                      }
|    |  32|+                    dp[i % 2][j] /= 6.0;
|  25|  33|                 }
|  26|    |-                dp[i % 2][j] /= 6.0;
|  27|    |-            }
|  28|    |-        }
|    |  34|+          }
|  29|  35| 
|  30|    |-        for (int i = n; i <= 6 * n; ++i) {
|  31|    |-            result.emplace_back(i, dp[n % 2][i]);
|  32|    |-        }
|    |  36|+        for (int i = n; i <= 6 * n; ++i)
|    |  37|+          {
|    |  38|+              result.emplace_back (i, dp[n % 2][i]);
|    |  39|+          }
|  33|  40| 
|  34|  41|         return result;
|  35|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|   1|   1| // Time:  O(k * n)
|   2|   2| // Space: O(k * n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @param k: An integer denote to find k non-overlapping subarrays
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|   8|   8|      * @param k: An integer denote to find k non-overlapping subarrays
|   9|   9|      * @return: An integer denote the sum of max k non-overlapping subarrays
|  10|  10|      */
|  11|    |-    int maxSubArray(vector<int> nums, int k) {
|  12|    |-        const int n = nums.size();
|    |  11|+    int maxSubArray (vector < int >nums, int k)
|    |  12|+    {
|    |  13|+        const int n = nums.size ();
|  13|  14|         // local_max[x][y] means the max sum in range [0, x - 1] include nums[x-1]
|  14|  15|         // with y non-overlapping subarrays.
|  15|  16|         vector<vector<int>> local_max(n + 1,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  12|  12|         const int n = nums.size();
|  13|  13|         // local_max[x][y] means the max sum in range [0, x - 1] include nums[x-1]
|  14|  14|         // with y non-overlapping subarrays.
|  15|    |-        vector<vector<int>> local_max(n + 1,
|  16|    |-                            vector<int>(k + 1, numeric_limits<int>::min()));
|    |  15|+          vector < vector < int >>local_max (n + 1,
|    |  16|+                                             vector < int >(k + 1,
|    |  17|+                                                            numeric_limits <
|    |  18|+                                                            int >::min ()));
|  17|  19|         // global_max[x][y] means the max sum in range [0, x - 1]
|  18|  20|         // with y non-overlapping subarrays.
|  19|  21|         vector<vector<int>> global_max(n + 1,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  16|  16|                             vector<int>(k + 1, numeric_limits<int>::min()));
|  17|  17|         // global_max[x][y] means the max sum in range [0, x - 1]
|  18|  18|         // with y non-overlapping subarrays.
|  19|    |-        vector<vector<int>> global_max(n + 1,
|  20|    |-                            vector<int>(k + 1, numeric_limits<int>::min()));
|    |  19|+          vector < vector < int >>global_max (n + 1,
|    |  20|+                                              vector < int >(k + 1,
|    |  21|+                                                             numeric_limits <
|    |  22|+                                                             int >::min ()));
|  21|  23| 
|  22|    |-        for (int i = 0; i <= n; ++i) {
|  23|    |-            global_max[i][0] = 0;
|  24|    |-        }
|    |  24|+        for (int i = 0; i <= n; ++i)
|    |  25|+          {
|    |  26|+              global_max[i][0] = 0;
|    |  27|+          }
|  25|  28| 
|  26|    |-        for (int i = 1; i <= n; ++i) {
|  27|    |-            for (int j = 1; j <= min(i, k); ++j) {
|  28|    |-                local_max[i][j] = max(local_max[i - 1][j],
|  29|    |-                                      global_max[i - 1][j - 1]) + nums[i - 1];
|  30|    |-                if (j == i) {
|  31|    |-                    global_max[i][j] = local_max[i][j];
|  32|    |-                } else {
|  33|    |-                    global_max[i][j] = max(global_max[i - 1][j],
|  34|    |-                                           local_max[i][j]);
|    |  29|+        for (int i = 1; i <= n; ++i)
|    |  30|+          {
|    |  31|+              for (int j = 1; j <= min (i, k); ++j)
|    |  32|+                {
|    |  33|+                    local_max[i][j] = max (local_max[i - 1][j],
|    |  34|+                                           global_max[i - 1][j - 1]) + nums[i -
|    |  35|+                                                                            1];
|    |  36|+                    if (j == i)
|    |  37|+                      {
|    |  38|+                          global_max[i][j] = local_max[i][j];
|    |  39|+                      }
|    |  40|+                    else
|    |  41|+                      {
|    |  42|+                          global_max[i][j] = max (global_max[i - 1][j],
|    |  43|+                                                  local_max[i][j]);
|    |  44|+                      }
|  35|  45|                 }
|  36|    |-            }
|  37|    |-        }
|    |  46|+          }
|  38|  47| 
|  39|  48|         return global_max[n][k];
|  40|  49|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  42|  42| 
|  43|  43| // Time:  O(k * n^2)
|  44|  44| // Space: O(k * n)
|  45|    |-class Solution2 {
|  46|    |-public:
|    |  45|+class Solution2
|    |  46|+{
|    |  47|+  public:
|  47|  48|     /**
|  48|  49|      * @param nums: A list of integers
|  49|  50|      * @param k: An integer denote to find k non-overlapping subarrays
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  49|  49|      * @param k: An integer denote to find k non-overlapping subarrays
|  50|  50|      * @return: An integer denote the sum of max k non-overlapping subarrays
|  51|  51|      */
|  52|    |-    int maxSubArray(vector<int> nums, int k) {
|  53|    |-        const int n = nums.size();
|    |  52|+    int maxSubArray (vector < int >nums, int k)
|    |  53|+    {
|    |  54|+        const int n = nums.size ();
|  54|  55| 
|  55|  56|         // sums[x][y] means the max sum in range [0, x - 1] with y non-overlapping subarrays
|  56|  57|         vector<vector<int>> sums(n + 1, vector<int>(k + 1, INT_MIN));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  53|  53|         const int n = nums.size();
|  54|  54| 
|  55|  55|         // sums[x][y] means the max sum in range [0, x - 1] with y non-overlapping subarrays
|  56|    |-        vector<vector<int>> sums(n + 1, vector<int>(k + 1, INT_MIN));
|    |  56|+          vector < vector < int >>sums (n + 1, vector < int >(k + 1, INT_MIN));
|  57|  57| 
|  58|    |-        for (int i = 0; i <= n; ++i) {
|  59|    |-            sums[i][0] = 0;
|  60|    |-        }
|    |  58|+        for (int i = 0; i <= n; ++i)
|    |  59|+          {
|    |  60|+              sums[i][0] = 0;
|    |  61|+          }
|  61|  62| 
|  62|    |-        for (int i = 1; i <= n; ++i) {
|  63|    |-            for (int j = 1; j <= min(i, k); ++j) {
|  64|    |-                sums[i][j] = sums[i - 1][j];
|  65|    |-                int max_sum_from_p = 0;
|  66|    |-                for (int p = i; p > j - 1; --p) {
|  67|    |-                    max_sum_from_p = max(0, max_sum_from_p) + nums[p - 1];
|  68|    |-                    // max sum in range[0, i - 1] with j subarrays equals to
|  69|    |-                    // max sum in max(range [0, p - 2] with j - 1 subarrys plus
|  70|    |-                    // max sum of the subarray which starts from p - 1 
|  71|    |-                    sums[i][j] = max(sums[i][j], sums[p - 1][j - 1] + max_sum_from_p);
|    |  63|+        for (int i = 1; i <= n; ++i)
|    |  64|+          {
|    |  65|+              for (int j = 1; j <= min (i, k); ++j)
|    |  66|+                {
|    |  67|+                    sums[i][j] = sums[i - 1][j];
|    |  68|+                    int max_sum_from_p = 0;
|    |  69|+                    for (int p = i; p > j - 1; --p)
|    |  70|+                      {
|    |  71|+                          max_sum_from_p =
|    |  72|+                              max (0, max_sum_from_p) + nums[p - 1];
|    |  73|+                          // max sum in range[0, i - 1] with j subarrays equals to
|    |  74|+                          // max sum in max(range [0, p - 2] with j - 1 subarrys plus
|    |  75|+                          // max sum of the subarray which starts from p - 1 
|    |  76|+                          sums[i][j] =
|    |  77|+                              max (sums[i][j],
|    |  78|+                                   sums[p - 1][j - 1] + max_sum_from_p);
|    |  79|+                      }
|  72|  80|                 }
|  73|    |-            }
|  74|    |-        }
|    |  81|+          }
|  75|  82| 
|  76|  83|         return sums[n][k];
|  77|  84|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  79|  79| 
|  80|  80| // Time:  O(k * n^2)
|  81|  81| // Space: O(k * n)
|  82|    |-class Solution3 {
|  83|    |-public:
|    |  82|+class Solution3
|    |  83|+{
|    |  84|+  public:
|  84|  85|     /**
|  85|  86|      * @param nums: A list of integers
|  86|  87|      * @param k: An integer denote to find k non-overlapping subarrays
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  86|  86|      * @param k: An integer denote to find k non-overlapping subarrays
|  87|  87|      * @return: An integer denote the sum of max k non-overlapping subarrays
|  88|  88|      */
|  89|    |-    int maxSubArray(vector<int> nums, int k) {
|  90|    |-        const int n = nums.size();
|    |  89|+    int maxSubArray (vector < int >nums, int k)
|    |  90|+    {
|    |  91|+        const int n = nums.size ();
|  91|  92| 
|  92|  93|         // sums[x][y] means the max sum in range [0, x - 1] with y non-overlapping subarrays
|  93|  94|         vector<vector<int>> sums(n + 1, vector<int>(k + 1, INT_MIN));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-iii.cpp
|    |++++| /app/C++/maximum-subarray-iii.cpp
|  90|  90|         const int n = nums.size();
|  91|  91| 
|  92|  92|         // sums[x][y] means the max sum in range [0, x - 1] with y non-overlapping subarrays
|  93|    |-        vector<vector<int>> sums(n + 1, vector<int>(k + 1, INT_MIN));
|    |  93|+          vector < vector < int >>sums (n + 1, vector < int >(k + 1, INT_MIN));
|  94|  94| 
|  95|    |-        for (int i = 0; i <= n; ++i) {
|  96|    |-            sums[i][0] = 0;
|  97|    |-        }
|    |  95|+        for (int i = 0; i <= n; ++i)
|    |  96|+          {
|    |  97|+              sums[i][0] = 0;
|    |  98|+          }
|  98|  99| 
|  99|    |-        for (int i = 1; i <= n; ++i) {
| 100|    |-            for (int j = 1; j <= min(i, k); ++j) {
| 101|    |-                sums[i][j] = sums[i - 1][j];
| 102|    |-                int sum = 0, max_sum = INT_MIN;
| 103|    |-                for (int p = i; p > j - 1; --p) {
| 104|    |-                    sum += nums[p - 1];
| 105|    |-                    max_sum = max(max_sum, sum);
| 106|    |-                    sum = max(0, sum);
| 107|    |-                    // max sum in range[0, i - 1] with j subarrays equals to
| 108|    |-                    // max sum in max(range [0, p - 2] with j - 1 subarrys plus
| 109|    |-                    // max sum in range [p - 1, i - 1] with 1 subarray 
| 110|    |-                    sums[i][j] = max(sums[i][j], sums[p - 1][j - 1] + max_sum);
|    | 100|+        for (int i = 1; i <= n; ++i)
|    | 101|+          {
|    | 102|+              for (int j = 1; j <= min (i, k); ++j)
|    | 103|+                {
|    | 104|+                    sums[i][j] = sums[i - 1][j];
|    | 105|+                    int sum = 0, max_sum = INT_MIN;
|    | 106|+                    for (int p = i; p > j - 1; --p)
|    | 107|+                      {
|    | 108|+                          sum += nums[p - 1];
|    | 109|+                          max_sum = max (max_sum, sum);
|    | 110|+                          sum = max (0, sum);
|    | 111|+                          // max sum in range[0, i - 1] with j subarrays equals to
|    | 112|+                          // max sum in max(range [0, p - 2] with j - 1 subarrys plus
|    | 113|+                          // max sum in range [p - 1, i - 1] with 1 subarray 
|    | 114|+                          sums[i][j] =
|    | 115|+                              max (sums[i][j], sums[p - 1][j - 1] + max_sum);
|    | 116|+                      }
| 111| 117|                 }
| 112|    |-            }
| 113|    |-        }
|    | 118|+          }
| 114| 119| 
| 115| 120|         return sums[n][k];
| 116| 121|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nuts-bolts-problem.cpp
|    |++++| /app/C++/nuts-bolts-problem.cpp
|  12|  12|  * When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.
|  13|  13| */
|  14|  14| 
|  15|    |-class Solution {
|  16|    |-public:
|  17|    |-    using CompareResult = enum { SMALLER = -1, EQUAL = 0,
|  18|    |-                                 BIGGER = 1, REVERSE = 2 };
|    |  15|+class Solution
|    |  16|+{
|    |  17|+  public:
|    |  18|+    using CompareResult = enum
|    |  19|+    { SMALLER = -1, EQUAL = 0,
|    |  20|+        BIGGER = 1, REVERSE = 2
|    |  21|+    };
|  19|  22|     /**
|  20|  23|      * @param nuts: a vector of integers
|  21|  24|      * @param bolts: a vector of integers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nuts-bolts-problem.cpp
|    |++++| /app/C++/nuts-bolts-problem.cpp
|  22|  22|      * @param compare: a instance of Comparator
|  23|  23|      * @return: nothing
|  24|  24|      */
|  25|    |-    void sortNutsAndBolts(vector<string> &nuts, vector<string> &bolts,
|  26|    |-                          Comparator compare) {
|  27|    |-        quickSort(nuts, bolts, 0, nuts.size() - 1, compare);
|    |  25|+    void sortNutsAndBolts (vector < string > &nuts, vector < string > &bolts,
|    |  26|+                           Comparator compare)
|    |  27|+    {
|    |  28|+        quickSort (nuts, bolts, 0, nuts.size () - 1, compare);
|  28|  29|     }
|  29|  30| 
|  30|  31|     // Method which works just like quick sort
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nuts-bolts-problem.cpp
|    |++++| /app/C++/nuts-bolts-problem.cpp
|  28|  28|     }
|  29|  29| 
|  30|  30|     // Method which works just like quick sort
|  31|    |-    void quickSort(vector<string>& nuts, vector<string>& bolts,
|  32|    |-                   int left, int right,
|  33|    |-                   Comparator& compare) {
|  34|    |-        if (left < right) {
|  35|    |-            // Randomly choose a bolt as a pivot for nuts partition.
|  36|    |-            default_random_engine gen((random_device())());
|  37|    |-            uniform_int_distribution<int> dis(left, right);
|  38|    |-            int pivot = dis(gen);
|    |  31|+    void quickSort (vector < string > &nuts, vector < string > &bolts,
|    |  32|+                    int left, int right, Comparator & compare)
|    |  33|+    {
|    |  34|+        if (left < right)
|    |  35|+          {
|    |  36|+              // Randomly choose a bolt as a pivot for nuts partition.
|    |  37|+              default_random_engine gen ((random_device ())());
|    |  38|+              uniform_int_distribution < int >dis (left, right);
|    |  39|+              int pivot = dis (gen);
|  39|  40| 
|  40|    |-            // Use the pivot bolt to make a partition of nuts.
|  41|    |-            // The we could know the index where the pivot (bolt, nut)
|  42|    |-            // pair should be in sorted order.
|  43|    |-            pivot = partition(nuts, left, right, bolts[pivot], compare);
|    |  41|+              // Use the pivot bolt to make a partition of nuts.
|    |  42|+              // The we could know the index where the pivot (bolt, nut)
|    |  43|+              // pair should be in sorted order.
|    |  44|+              pivot = partition (nuts, left, right, bolts[pivot], compare);
|  44|  45| 
|  45|    |-            // Using the nut in the pivot bolt to make a partition of bolts.
|  46|    |-            partition(bolts, left, right, nuts[pivot], compare);
|    |  46|+              // Using the nut in the pivot bolt to make a partition of bolts.
|    |  47|+              partition (bolts, left, right, nuts[pivot], compare);
|  47|  48| 
|  48|    |-            // Now, both nuts and bolts are partitioned by the pivot nut-bolt pair.
|  49|    |-            // The pivot nut-bolt pair is also in the correct index of the sorted order.
|  50|    |-            // Recursively do the same thing in the left and right side of the pivot.
|  51|    |-            quickSort(nuts, bolts, left, pivot - 1, compare);
|  52|    |-            quickSort(nuts, bolts, pivot + 1, right, compare);
|  53|    |-        }
|    |  49|+              // Now, both nuts and bolts are partitioned by the pivot nut-bolt pair.
|    |  50|+              // The pivot nut-bolt pair is also in the correct index of the sorted order.
|    |  51|+              // Recursively do the same thing in the left and right side of the pivot.
|    |  52|+              quickSort (nuts, bolts, left, pivot - 1, compare);
|    |  53|+              quickSort (nuts, bolts, pivot + 1, right, compare);
|    |  54|+          }
|  54|  55|     }
|  55|  56| 
|  56|  57|     // All the smaller elements should be in the left side of the pivot,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nuts-bolts-problem.cpp
|    |++++| /app/C++/nuts-bolts-problem.cpp
|  55|  55| 
|  56|  56|     // All the smaller elements should be in the left side of the pivot,
|  57|  57|     // and all the bigger elements should in the right side of the pivot.
|  58|    |-    int partition(vector<string>& arr,
|  59|    |-                  int left, int right, const string& pivot,
|  60|    |-                  Comparator& compare) {
|  61|    |-        for (int i = left; i < right; ) {
|  62|    |-            if (compare.cmp(arr[i], pivot) == SMALLER ||  // Smaller.
|  63|    |-                (compare.cmp(arr[i], pivot) == REVERSE &&
|  64|    |-                 compare.cmp(pivot, arr[i]) == BIGGER)) {
|  65|    |-                swap(arr[left++], arr[i++]);
|  66|    |-            } else if (compare.cmp(arr[i], pivot) == BIGGER ||  // Bigger.
|  67|    |-                      (compare.cmp(arr[i], pivot) == REVERSE &&
|  68|    |-                       compare.cmp(pivot, arr[i]) == SMALLER)) {
|  69|    |-                ++i;
|  70|    |-            } else {  // Equal.
|  71|    |-                swap(arr[i], arr[right]);
|  72|    |-            }
|  73|    |-        }
|    |  58|+    int partition (vector < string > &arr,
|    |  59|+                   int left, int right, const string & pivot,
|    |  60|+                   Comparator & compare)
|    |  61|+    {
|    |  62|+        for (int i = left; i < right;)
|    |  63|+          {
|    |  64|+              if (compare.cmp (arr[i], pivot) == SMALLER || // Smaller.
|    |  65|+                  (compare.cmp (arr[i], pivot) == REVERSE &&
|    |  66|+                   compare.cmp (pivot, arr[i]) == BIGGER))
|    |  67|+                {
|    |  68|+                    swap (arr[left++], arr[i++]);
|    |  69|+                }
|    |  70|+              else if (compare.cmp (arr[i], pivot) == BIGGER || // Bigger.
|    |  71|+                       (compare.cmp (arr[i], pivot) == REVERSE &&
|    |  72|+                        compare.cmp (pivot, arr[i]) == SMALLER))
|    |  73|+                {
|    |  74|+                    ++i;
|    |  75|+                }
|    |  76|+              else
|    |  77|+                {               // Equal.
|    |  78|+                    swap (arr[i], arr[right]);
|    |  79|+                }
|    |  80|+          }
|  74|  81|         // Put the pivot to the partition index.
|  75|    |-        swap(arr[left], arr[right]);
|    |  82|+        swap (arr[left], arr[right]);
|  76|  83| 
|  77|  84|         // Return the partition index of an array.
|  78|  85|         return left;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-level-order-traversal.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |- 
|  17|    |-class Solution {
|    |  16|+
|    |  17|+class Solution
|    |  18|+{
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: Level order a list of lists of integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-level-order-traversal.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: Level order a list of lists of integer
|  21|  21|      */
|  22|    |-public:
|  23|    |-    vector<vector<int>> levelOrder(TreeNode *root) {
|  24|    |-        vector<vector<int>> result;
|  25|    |-        queue<TreeNode *> que;
|    |  22|+  public:
|    |  23|+    vector < vector < int >>levelOrder (TreeNode * root)
|    |  24|+    {
|    |  25|+        vector < vector < int >>result;
|    |  26|+          queue < TreeNode * >que;
|  26|  27| 
|  27|    |-        if (root != nullptr) {
|  28|    |-            que.emplace(root);
|  29|    |-        }
|    |  28|+        if (root != nullptr)
|    |  29|+          {
|    |  30|+              que.emplace (root);
|    |  31|+          }
|  30|  32| 
|  31|    |-        while (!que.empty()) {
|  32|    |-            vector<int> level;
|  33|    |-            int size = que.size();
|  34|    |-            for (int i = 0; i < size; i++) {
|  35|    |-                auto *front = que.front();
|  36|    |-                que.pop();
|  37|    |-                level.emplace_back(front->val);
|  38|    |-                if (front->left != nullptr) {
|  39|    |-                    que.emplace(front->left);
|    |  33|+        while (!que.empty ())
|    |  34|+          {
|    |  35|+              vector < int >level;
|    |  36|+              int size = que.size ();
|    |  37|+              for (int i = 0; i < size; i++)
|    |  38|+                {
|    |  39|+                    auto *front = que.front ();
|    |  40|+                    que.pop ();
|    |  41|+                    level.emplace_back (front->val);
|    |  42|+                    if (front->left != nullptr)
|    |  43|+                      {
|    |  44|+                          que.emplace (front->left);
|    |  45|+                      }
|    |  46|+                    if (front->right != nullptr)
|    |  47|+                      {
|    |  48|+                          que.emplace (front->right);
|    |  49|+                      }
|  40|  50|                 }
|  41|    |-                if (front->right != nullptr) {
|  42|    |-                    que.emplace(front->right);
|  43|    |-                }
|  44|    |-            }
|  45|    |-            result.emplace_back(move(level));
|  46|    |-        }
|    |  51|+              result.emplace_back (move (level));
|    |  52|+          }
|  47|  53| 
|  48|  54|         return result;
|  49|  55|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/a-b-problem.cpp
|    |++++| /app/C++/a-b-problem.cpp
|   1|   1| // Time:  O(logn) = O(32)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /*
|   7|   8|      * @param a: The first integer
|   8|   9|      * @param b: The second integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/a-b-problem.cpp
|    |++++| /app/C++/a-b-problem.cpp
|   8|   8|      * @param b: The second integer
|   9|   9|      * @return: The sum of a and b
|  10|  10|      */
|  11|    |-    int aplusb(int a, int b) {
|  12|    |-        while (b != 0) {
|  13|    |-            int carry = a & b;
|  14|    |-            a ^= b;
|  15|    |-            b = carry << 1;
|  16|    |-        }
|    |  11|+    int aplusb (int a, int b)
|    |  12|+    {
|    |  13|+        while (b != 0)
|    |  14|+          {
|    |  15|+              int carry = a & b;
|    |  16|+                a ^= b;
|    |  17|+                b = carry << 1;
|    |  18|+          }
|  17|  19|         return a;
|  18|  20|     }
|  19|  21| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/a-b-problem.cpp
|    |++++| /app/C++/a-b-problem.cpp
|  18|  18|     }
|  19|  19| };
|  20|  20| 
|  21|    |-class Solution2 {
|  22|    |-public:
|    |  21|+class Solution2
|    |  22|+{
|    |  23|+  public:
|  23|  24|     /*
|  24|  25|      * @param a: The first integer
|  25|  26|      * @param b: The second integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/a-b-problem.cpp
|    |++++| /app/C++/a-b-problem.cpp
|  25|  25|      * @param b: The second integer
|  26|  26|      * @return: The sum of a and b
|  27|  27|      */
|  28|    |-    int aplusb(int a, int b) {
|  29|    |-        if (b == 0) {
|  30|    |-            return a;
|  31|    |-        }
|  32|    |-        return aplusb(a ^ b, (a & b) << 1);
|    |  28|+    int aplusb (int a, int b)
|    |  29|+    {
|    |  30|+        if (b == 0)
|    |  31|+          {
|    |  32|+              return a;
|    |  33|+          }
|    |  34|+        return aplusb (a ^ b, (a & b) << 1);
|  33|  35|     }
|  34|  36| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/happy-number.cpp
|    |++++| /app/C++/happy-number.cpp
|   1|   1| // Time:  O(k), where k is the steps to be happy number
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n an integer
|   8|   9|      * @return true if this is a happy number or false
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/happy-number.cpp
|    |++++| /app/C++/happy-number.cpp
|   7|   7|      * @param n an integer
|   8|   8|      * @return true if this is a happy number or false
|   9|   9|      */
|  10|    |-    bool isHappy(int n) {
|  11|    |-        unordered_set<int> visited;
|  12|    |-        while (n != 1 && !visited.count(n)) {
|  13|    |-            visited.emplace(n);
|  14|    |-            n = nextNumber(n);
|  15|    |-        }
|    |  10|+    bool isHappy (int n)
|    |  11|+    {
|    |  12|+        unordered_set < int >visited;
|    |  13|+        while (n != 1 && !visited.count (n))
|    |  14|+          {
|    |  15|+              visited.emplace (n);
|    |  16|+              n = nextNumber (n);
|    |  17|+          }
|  16|  18|         return n == 1;
|  17|  19|     }
|  18|  20| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/happy-number.cpp
|    |++++| /app/C++/happy-number.cpp
|  16|  16|         return n == 1;
|  17|  17|     }
|  18|  18| 
|  19|    |-    int nextNumber(int n) {
|    |  19|+    int nextNumber (int n)
|    |  20|+    {
|  20|  21|         int sum = 0;
|  21|    |-        while (n) {
|  22|    |-            sum += pow(n % 10, 2);
|  23|    |-            n /= 10;
|  24|    |-        }
|    |  22|+        while (n)
|    |  23|+          {
|    |  24|+              sum += pow (n % 10, 2);
|    |  25|+              n /= 10;
|    |  26|+          }
|  25|  27|         return sum;
|  26|  28|     }
|  27|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  14|  14|  */
|  15|  15| 
|  16|  16| // Segment Tree solution.
|  17|    |-class SegmentTreeSumNode {
|  18|    |-public:
|    |  17|+class SegmentTreeSumNode
|    |  18|+{
|    |  19|+  public:
|  19|  20|     int start, end;
|  20|  21|     long long sum;
|  21|  22|     SegmentTreeSumNode *left, *right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  19|  19|     int start, end;
|  20|  20|     long long sum;
|  21|  21|     SegmentTreeSumNode *left, *right;
|  22|    |-    SegmentTreeSumNode(int start, int end, long long sum) {
|    |  22|+      SegmentTreeSumNode (int start, int end, long long sum)
|    |  23|+    {
|  23|  24|         this->start = start;
|  24|  25|         this->end = end;
|  25|  26|         this->sum = sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  27|  27|     }
|  28|  28| };
|  29|  29| 
|  30|    |-class Solution {
|  31|    |-public:
|    |  30|+class Solution
|    |  31|+{
|    |  32|+  public:
|  32|  33|     /* you may need to use some attributes here */
|  33|    |-    SegmentTreeSumNode *root_;
|    |  34|+    SegmentTreeSumNode * root_;
|  34|  35| 
|  35|  36|     /**
|  36|  37|      * @param A: An integer vector
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  35|  35|     /**
|  36|  36|      * @param A: An integer vector
|  37|  37|      */
|  38|    |-    Solution(vector<int> A) {
|  39|    |-        root_ = build(A, 0, A.size() - 1);
|    |  38|+    Solution (vector < int >A)
|    |  39|+    {
|    |  40|+        root_ = build (A, 0, A.size () - 1);
|  40|  41|     }
|  41|  42| 
|  42|  43|     /**
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  43|  43|      * @param start, end: Indices
|  44|  44|      * @return: The sum from start to end
|  45|  45|      */
|  46|    |-    long long query(int start, int end) {
|  47|    |-        queryTree(root_, start, end);
|    |  46|+    long long query (int start, int end)
|    |  47|+    {
|    |  48|+        queryTree (root_, start, end);
|  48|  49|     }
|  49|  50| 
|  50|  51|     /**
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  50|  50|     /**
|  51|  51|      * @param index, value: modify A[index] to value.
|  52|  52|      */
|  53|    |-    void modify(int index, int value) {
|  54|    |-        modifyTree(root_, index, value);
|    |  53|+    void modify (int index, int value)
|    |  54|+    {
|    |  55|+        modifyTree (root_, index, value);
|  55|  56|     }
|  56|  57| 
|  57|  58|     // Query Sum in given range.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  55|  55|     }
|  56|  56| 
|  57|  57|     // Query Sum in given range.
|  58|    |-    long long queryTree(SegmentTreeSumNode *root, int start, int end) {
|    |  58|+    long long queryTree (SegmentTreeSumNode * root, int start, int end)
|    |  59|+    {
|  59|  60|         // Out of range.
|  60|    |-        if (root == nullptr || root->start > end || root->end <  start) {
|  61|    |-            return 0;
|  62|    |-        }
|    |  61|+        if (root == nullptr || root->start > end || root->end < start)
|    |  62|+          {
|    |  63|+              return 0;
|    |  64|+          }
|  63|  65| 
|  64|  66|         // Current segment is totally within range [start, end]
|  65|  67|         if (root->start >= start && root->end <= end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  62|  62|         }
|  63|  63| 
|  64|  64|         // Current segment is totally within range [start, end]
|  65|    |-        if (root->start >= start && root->end <= end) {
|  66|    |-            return root->sum;
|  67|    |-        }
|  68|    |-
|  69|    |-        long long left = queryTree(root->left, start, end);
|  70|    |-        long long right = queryTree(root->right, start, end);
|    |  65|+        if (root->start >= start && root->end <= end)
|    |  66|+          {
|    |  67|+              return root->sum;
|    |  68|+          }
|    |  69|+
|    |  70|+        long long left = queryTree (root->left, start, end);
|    |  71|+        long long right = queryTree (root->right, start, end);
|  71|  72| 
|  72|  73|         // Find sum in the children.
|  73|  74|         return left + right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  73|  73|         return left + right;
|  74|  74|     }
|  75|  75| 
|  76|    |-
|  77|    |-    void modifyTree(SegmentTreeSumNode *root, int index, int value) {
|    |  76|+    void modifyTree (SegmentTreeSumNode * root, int index, int value)
|    |  77|+    {
|  78|  78|         // Out of range.
|  79|    |-        if (root == nullptr || root->start > index || root->end < index) {
|  80|    |-            return;
|  81|    |-        }
|    |  79|+        if (root == nullptr || root->start > index || root->end < index)
|    |  80|+          {
|    |  81|+              return;
|    |  82|+          }
|  82|  83| 
|  83|  84|         // Change the node's value with [index, index] to the new given value.
|  84|  85|         if (root->start == index && root->end == index) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  81|  81|         }
|  82|  82| 
|  83|  83|         // Change the node's value with [index, index] to the new given value.
|  84|    |-        if (root->start == index && root->end == index) {
|  85|    |-            root->sum = value;
|  86|    |-            return;
|  87|    |-        }
|  88|    |-
|  89|    |-        modifyTree(root->left, index, value);
|  90|    |-        modifyTree(root->right, index, value);
|  91|    |-
|  92|    |-        int left_sum = root->left != nullptr? root->left->sum : 0;
|  93|    |-        int right_sum = root->right != nullptr? root->right->sum : 0;
|    |  84|+        if (root->start == index && root->end == index)
|    |  85|+          {
|    |  86|+              root->sum = value;
|    |  87|+              return;
|    |  88|+          }
|    |  89|+
|    |  90|+        modifyTree (root->left, index, value);
|    |  91|+        modifyTree (root->right, index, value);
|    |  92|+
|    |  93|+        int left_sum = root->left != nullptr ? root->left->sum : 0;
|    |  94|+        int right_sum = root->right != nullptr ? root->right->sum : 0;
|  94|  95| 
|  95|  96|         // Update sum.
|  96|  97|         root->sum = left_sum + right_sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
|  97|  97|     }
|  98|  98| 
|  99|  99|     // Build segment tree.
| 100|    |-    SegmentTreeSumNode *build(vector<int> &A, int start, int end) {
| 101|    |-        if (start > end) {
| 102|    |-            return nullptr;
| 103|    |-        }
|    | 100|+    SegmentTreeSumNode *build (vector < int >&A, int start, int end)
|    | 101|+    {
|    | 102|+        if (start > end)
|    | 103|+          {
|    | 104|+              return nullptr;
|    | 105|+          }
| 104| 106| 
| 105| 107|         // The root's start and end is given by build method.
| 106| 108|         SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 103| 103|         }
| 104| 104| 
| 105| 105|         // The root's start and end is given by build method.
| 106|    |-        SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
|    | 106|+        SegmentTreeSumNode *root = new SegmentTreeSumNode (start, end, 0);
| 107| 107| 
| 108| 108|         // If start equals to end, there will be no children for this node.
| 109| 109|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 106| 106|         SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
| 107| 107| 
| 108| 108|         // If start equals to end, there will be no children for this node.
| 109|    |-        if (start == end) {
| 110|    |-            root->sum = A[start];
| 111|    |-            return root;
| 112|    |-        }
|    | 109|+        if (start == end)
|    | 110|+          {
|    | 111|+              root->sum = A[start];
|    | 112|+              return root;
|    | 113|+          }
| 113| 114| 
| 114| 115|         // Left child: start=A.left, end=(A.left + A.right) / 2.
| 115| 116|         root->left = build(A, start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 112| 112|         }
| 113| 113| 
| 114| 114|         // Left child: start=A.left, end=(A.left + A.right) / 2.
| 115|    |-        root->left = build(A, start, (start + end) / 2);
|    | 115|+        root->left = build (A, start, (start + end) / 2);
| 116| 116| 
| 117| 117|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
| 118| 118|         root->right = build(A, (start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 115| 115|         root->left = build(A, start, (start + end) / 2);
| 116| 116| 
| 117| 117|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
| 118|    |-        root->right = build(A, (start + end) / 2 + 1, end);
| 119|    |-
| 120|    |-        long long left_sum = root->left != nullptr? root->left->sum : 0;
| 121|    |-        long long right_sum = root->right != nullptr? root->right->sum : 0;
|    | 118|+        root->right = build (A, (start + end) / 2 + 1, end);
|    | 119|+
|    | 120|+        long long left_sum = root->left != nullptr ? root->left->sum : 0;
|    | 121|+        long long right_sum = root->right != nullptr ? root->right->sum : 0;
| 122| 122| 
| 123| 123|         // Update sum.
| 124| 124|         root->sum = left_sum + right_sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 131| 131| //        modify: O(logn)
| 132| 132| // Space: O(n)
| 133| 133| // Binary Indexed Tree (BIT) solution.
| 134|    |-class Solution2 {
| 135|    |-public:
|    | 134|+class Solution2
|    | 135|+{
|    | 136|+  public:
| 136| 137|     /* you may need to use some attributes here */
| 137|    |-    
| 138| 138| 
| 139| 139|     /**
| 140| 140|      * @param A: An integer vector
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 139| 139|     /**
| 140| 140|      * @param A: An integer vector
| 141| 141|      */
| 142|    |-    Solution(vector<int> A) : nums_(A) {
| 143|    |-        bit_ = vector<int>(nums_.size() + 1);
| 144|    |-        for (int i = 1; i < bit_.size(); ++i) {
| 145|    |-            bit_[i] = A[i - 1] + bit_[i - 1];
| 146|    |-        }
| 147|    |-        for (int i = bit_.size() - 1; i >= 1; --i) {
| 148|    |-            int last_i = i - lower_bit(i);
| 149|    |-            bit_[i] -= bit_[last_i];
| 150|    |-        }
| 151|    |-    }
| 152|    |-    
|    | 142|+    Solution (vector < int >A):nums_ (A)
|    | 143|+    {
|    | 144|+        bit_ = vector < int >(nums_.size () + 1);
|    | 145|+        for (int i = 1; i < bit_.size (); ++i)
|    | 146|+          {
|    | 147|+              bit_[i] = A[i - 1] + bit_[i - 1];
|    | 148|+          }
|    | 149|+        for (int i = bit_.size () - 1; i >= 1; --i)
|    | 150|+          {
|    | 151|+              int last_i = i - lower_bit (i);
|    | 152|+              bit_[i] -= bit_[last_i];
|    | 153|+          }
|    | 154|+    }
|    | 155|+
| 153| 156|     /**
| 154| 157|      * @param start, end: Indices
| 155| 158|      * @return: The sum from start to end
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 154| 154|      * @param start, end: Indices
| 155| 155|      * @return: The sum from start to end
| 156| 156|      */
| 157|    |-    long long query(int start, int end) {
| 158|    |-        int sum = sumRegion_bit(end);
| 159|    |-        if (start > 0) {
| 160|    |-            sum -= sumRegion_bit(start - 1);
| 161|    |-        }
|    | 157|+    long long query (int start, int end)
|    | 158|+    {
|    | 159|+        int sum = sumRegion_bit (end);
|    | 160|+        if (start > 0)
|    | 161|+          {
|    | 162|+              sum -= sumRegion_bit (start - 1);
|    | 163|+          }
| 162| 164|         return sum;
| 163| 165|     }
| 164| 166|     
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 161| 161|         }
| 162| 162|         return sum;
| 163| 163|     }
| 164|    |-    
|    | 164|+
| 165| 165|     /**
| 166| 166|      * @param index, value: modify A[index] to value.
| 167| 167|      */
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 165| 165|     /**
| 166| 166|      * @param index, value: modify A[index] to value.
| 167| 167|      */
| 168|    |-    void modify(int index, int value) {
| 169|    |-        if (value - nums_[index]) {
| 170|    |-            add(index, value - nums_[index]);
| 171|    |-            nums_[index] = value;
| 172|    |-        }
| 173|    |-    }
| 174|    |-
| 175|    |-private:
| 176|    |-    vector<int> nums_;
| 177|    |-    vector<int> bit_;
| 178|    |-
| 179|    |-    int sumRegion_bit(int i) {
|    | 168|+    void modify (int index, int value)
|    | 169|+    {
|    | 170|+        if (value - nums_[index])
|    | 171|+          {
|    | 172|+              add (index, value - nums_[index]);
|    | 173|+              nums_[index] = value;
|    | 174|+          }
|    | 175|+    }
|    | 176|+
|    | 177|+  private:
|    | 178|+    vector < int >nums_;
|    | 179|+    vector < int >bit_;
|    | 180|+
|    | 181|+    int sumRegion_bit (int i)
|    | 182|+    {
| 180| 183|         ++i;
| 181| 184|         int sum = 0;
| 182| 185|         for (; i > 0; i -= lower_bit(i)) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 179| 179|     int sumRegion_bit(int i) {
| 180| 180|         ++i;
| 181| 181|         int sum = 0;
| 182|    |-        for (; i > 0; i -= lower_bit(i)) {
| 183|    |-            sum += bit_[i];
| 184|    |-        }
|    | 182|+        for (; i > 0; i -= lower_bit (i))
|    | 183|+          {
|    | 184|+              sum += bit_[i];
|    | 185|+          }
| 185| 186|         return sum;
| 186| 187|     }
| 187| 188| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 185| 185|         return sum;
| 186| 186|     }
| 187| 187| 
| 188|    |-    void add(int i, int val) {
|    | 188|+    void add (int i, int val)
|    | 189|+    {
| 189| 190|         ++i;
| 190|    |-        for (; i <= nums_.size(); i += lower_bit(i)) {
| 191|    |-            bit_[i] += val;
| 192|    |-        }
| 193|    |-    }
| 194|    |-
| 195|    |-    int lower_bit(int i) {
|    | 191|+        for (; i <= nums_.size (); i += lower_bit (i))
|    | 192|+          {
|    | 193|+              bit_[i] += val;
|    | 194|+          }
|    | 195|+    }
|    | 196|+
|    | 197|+    int lower_bit (int i)
|    | 198|+    {
| 196| 199|         return i & -i;
| 197| 200|     }
| 198| 201| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum-ii.cpp
|    |++++| /app/C++/interval-sum-ii.cpp
| 196| 196|         return i & -i;
| 197| 197|     }
| 198| 198| };
| 199|    |-
| 200|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|   1|   1| // Time:  O(logm + logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix, a list of lists of integers
|   8|   9|      * @param target, an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|   8|   8|      * @param target, an integer
|   9|   9|      * @return a boolean, indicate whether matrix contains target
|  10|  10|      */
|  11|    |-    bool searchMatrix(vector<vector<int>> &matrix, int target) {
|  12|    |-        if (matrix.empty()) {
|  13|    |-            return false;
|  14|    |-        }
|    |  11|+    bool searchMatrix (vector < vector < int >>&matrix, int target)
|    |  12|+    {
|    |  13|+        if (matrix.empty ())
|    |  14|+          {
|    |  15|+              return false;
|    |  16|+          }
|  15|  17| 
|  16|  18|         // Treat matrix as 1D array.
|  17|  19|         const int m = matrix.size();
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  14|  14|         }
|  15|  15| 
|  16|  16|         // Treat matrix as 1D array.
|  17|    |-        const int m = matrix.size();
|  18|    |-        const int n = matrix[0].size();
|    |  17|+        const int m = matrix.size ();
|    |  18|+        const int n = matrix[0].size ();
|  19|  19|         int left = 0;
|  20|  20|         int right = m * n - 1;
|  21|  21| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  20|  20|         int right = m * n - 1;
|  21|  21| 
|  22|  22|         // Find min of left s.t.  matrix[left / n][left % n] >= target
|  23|    |-        while (left <= right) {
|  24|    |-            int mid = left + (right - left) / 2;
|  25|    |-            if (matrix[mid / n][mid % n] >= target) {
|  26|    |-                right = mid - 1;
|  27|    |-            } else {
|  28|    |-                left = mid + 1;
|  29|    |-            }
|  30|    |-        }
|    |  23|+        while (left <= right)
|    |  24|+          {
|    |  25|+              int mid = left + (right - left) / 2;
|    |  26|+              if (matrix[mid / n][mid % n] >= target)
|    |  27|+                {
|    |  28|+                    right = mid - 1;
|    |  29|+                }
|    |  30|+              else
|    |  31|+                {
|    |  32|+                    left = mid + 1;
|    |  33|+                }
|    |  34|+          }
|  31|  35| 
|  32|  36|         // Check if matrix[left / n][left % n] equals to target.
|  33|  37|         if (left != m * n && matrix[left / n][left % n] == target) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  30|  30|         }
|  31|  31| 
|  32|  32|         // Check if matrix[left / n][left % n] equals to target.
|  33|    |-        if (left != m * n && matrix[left / n][left % n] == target) {
|  34|    |-            return true;
|  35|    |-        }
|    |  33|+        if (left != m * n && matrix[left / n][left % n] == target)
|    |  34|+          {
|    |  35|+              return true;
|    |  36|+          }
|  36|  37| 
|  37|  38|         return false;
|  38|  39|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  38|  38|     }
|  39|  39| };
|  40|  40| 
|  41|    |-
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  41|+class Solution2
|    |  42|+{
|    |  43|+  public:
|  44|  44|     /**
|  45|  45|      * @param matrix, a list of lists of integers
|  46|  46|      * @param target, an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  46|  46|      * @param target, an integer
|  47|  47|      * @return a boolean, indicate whether matrix contains target
|  48|  48|      */
|  49|    |-    bool searchMatrix(vector<vector<int>> &matrix, int target) {
|  50|    |-        if (matrix.empty()) {
|  51|    |-            return false;
|  52|    |-        }
|    |  49|+    bool searchMatrix (vector < vector < int >>&matrix, int target)
|    |  50|+    {
|    |  51|+        if (matrix.empty ())
|    |  52|+          {
|    |  53|+              return false;
|    |  54|+          }
|  53|  55| 
|  54|  56|         // Treat matrix as 1D array.
|  55|  57|         const int m = matrix.size();
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  52|  52|         }
|  53|  53| 
|  54|  54|         // Treat matrix as 1D array.
|  55|    |-        const int m = matrix.size();
|  56|    |-        const int n = matrix[0].size();
|    |  55|+        const int m = matrix.size ();
|    |  56|+        const int n = matrix[0].size ();
|  57|  57|         int left = 0;
|  58|  58|         int right = m * n;
|  59|  59| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  58|  58|         int right = m * n;
|  59|  59| 
|  60|  60|         // Find min of left s.t.  matrix[left / n][left % n] >= target
|  61|    |-        while (left < right) {
|  62|    |-            int mid = left + (right - left) / 2;
|  63|    |-            if (matrix[mid / n][mid % n] >= target) {
|  64|    |-                right = mid;
|  65|    |-            } else {
|  66|    |-                left = mid + 1;
|  67|    |-            }
|  68|    |-        }
|    |  61|+        while (left < right)
|    |  62|+          {
|    |  63|+              int mid = left + (right - left) / 2;
|    |  64|+              if (matrix[mid / n][mid % n] >= target)
|    |  65|+                {
|    |  66|+                    right = mid;
|    |  67|+                }
|    |  68|+              else
|    |  69|+                {
|    |  70|+                    left = mid + 1;
|    |  71|+                }
|    |  72|+          }
|  69|  73| 
|  70|  74|         // Check if matrix[left / n][left % n] equals to target.
|  71|  75|         if (left != m * n && matrix[left / n][left % n] == target) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  68|  68|         }
|  69|  69| 
|  70|  70|         // Check if matrix[left / n][left % n] equals to target.
|  71|    |-        if (left != m * n && matrix[left / n][left % n] == target) {
|  72|    |-            return true;
|  73|    |-        }
|    |  71|+        if (left != m * n && matrix[left / n][left % n] == target)
|    |  72|+          {
|    |  73|+              return true;
|    |  74|+          }
|  74|  75| 
|  75|  76|         return false;
|  76|  77|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  76|  76|     }
|  77|  77| };
|  78|  78| 
|  79|    |-class Solution3 {
|  80|    |-public:
|    |  79|+class Solution3
|    |  80|+{
|    |  81|+  public:
|  81|  82|     /**
|  82|  83|      * @param matrix, a list of lists of integers
|  83|  84|      * @param target, an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  83|  83|      * @param target, an integer
|  84|  84|      * @return a boolean, indicate whether matrix contains target
|  85|  85|      */
|  86|    |-    bool searchMatrix(vector<vector<int>> &matrix, int target) {
|  87|    |-        if (matrix.empty()) {
|  88|    |-            return false;
|  89|    |-        }
|    |  86|+    bool searchMatrix (vector < vector < int >>&matrix, int target)
|    |  87|+    {
|    |  88|+        if (matrix.empty ())
|    |  89|+          {
|    |  90|+              return false;
|    |  91|+          }
|  90|  92| 
|  91|  93|         // Treat matrix as 1D array.
|  92|  94|         const int m = matrix.size();
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  89|  89|         }
|  90|  90| 
|  91|  91|         // Treat matrix as 1D array.
|  92|    |-        const int m = matrix.size();
|  93|    |-        const int n = matrix[0].size();
|    |  92|+        const int m = matrix.size ();
|    |  93|+        const int n = matrix[0].size ();
|  94|  94|         int left = -1;
|  95|  95|         int right = m * n;
|  96|  96| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
|  95|  95|         int right = m * n;
|  96|  96| 
|  97|  97|         // Find min of right s.t.  matrix[right / n][right % n] >= target
|  98|    |-        while (right - left > 1) {
|  99|    |-            int mid = left + (right - left) / 2;
| 100|    |-            if (matrix[mid / n][mid % n] >= target) {
| 101|    |-                right = mid;
| 102|    |-            } else {
| 103|    |-                left = mid;
| 104|    |-            }
| 105|    |-        }
|    |  98|+        while (right - left > 1)
|    |  99|+          {
|    | 100|+              int mid = left + (right - left) / 2;
|    | 101|+              if (matrix[mid / n][mid % n] >= target)
|    | 102|+                {
|    | 103|+                    right = mid;
|    | 104|+                }
|    | 105|+              else
|    | 106|+                {
|    | 107|+                    left = mid;
|    | 108|+                }
|    | 109|+          }
| 106| 110| 
| 107| 111|         // Check if matrix[right / n][right % n] equals to target.
| 108| 112|         if (right != m * n && matrix[right / n][right % n] == target) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
| 105| 105|         }
| 106| 106| 
| 107| 107|         // Check if matrix[right / n][right % n] equals to target.
| 108|    |-        if (right != m * n && matrix[right / n][right % n] == target) {
| 109|    |-            return true;
| 110|    |-        }
|    | 108|+        if (right != m * n && matrix[right / n][right % n] == target)
|    | 109|+          {
|    | 110|+              return true;
|    | 111|+          }
| 111| 112| 
| 112| 113|         return false;
| 113| 114|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix.cpp
|    |++++| /app/C++/search-a-2d-matrix.cpp
| 112| 112|         return false;
| 113| 113|     }
| 114| 114| };
| 115|    |-
| 116|    |-
| 117|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|   1|   1| // Time:  O(m * n * h), h is height of trie
|   2|   2| // Space: O(26^h)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-private:
|   6|    |-    struct TrieNode {
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  private:
|    |   7|+    struct TrieNode
|    |   8|+    {
|   7|   9|         bool isString = false;
|   8|    |-        unordered_map<char, TrieNode *> leaves;
|    |  10|+          unordered_map < char, TrieNode * >leaves;
|   9|  11| 
|  10|    |-        bool Insert(const string& s) {
|  11|    |-            auto* p = this;
|  12|    |-            for (const auto& c : s) {
|  13|    |-                if (p->leaves.find(c) == p->leaves.cend()) {
|  14|    |-                    p->leaves[c] = new TrieNode;
|  15|    |-                }
|  16|    |-                p = p->leaves[c];
|  17|    |-            }
|    |  12|+        bool Insert (const string & s)
|    |  13|+        {
|    |  14|+            auto *p = this;
|    |  15|+            for (const auto & c:s)
|    |  16|+              {
|    |  17|+                  if (p->leaves.find (c) == p->leaves.cend ())
|    |  18|+                    {
|    |  19|+                        p->leaves[c] = new TrieNode;
|    |  20|+                    }
|    |  21|+                  p = p->leaves[c];
|    |  22|+              }
|  18|  23| 
|  19|  24|             // s already existed in this trie.
|  20|  25|             if (p->isString) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  17|  17|             }
|  18|  18| 
|  19|  19|             // s already existed in this trie.
|  20|    |-            if (p->isString) {
|  21|    |-                return false;
|  22|    |-            } else {
|  23|    |-                p->isString = true;
|  24|    |-                return true;
|  25|    |-            }
|    |  20|+            if (p->isString)
|    |  21|+              {
|    |  22|+                  return false;
|    |  23|+              }
|    |  24|+            else
|    |  25|+              {
|    |  26|+                  p->isString = true;
|    |  27|+                  return true;
|    |  28|+              }
|  26|  29|         }
|  27|  30| 
|  28|  31|         ~TrieNode() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  25|  25|             }
|  26|  26|         }
|  27|  27| 
|  28|    |-        ~TrieNode() {
|  29|    |-            for (auto& kv : leaves) {
|  30|    |-                if (kv.second) {
|  31|    |-                    kv.second->~TrieNode();
|  32|    |-                }
|  33|    |-            }
|    |  28|+        ~TrieNode ()
|    |  29|+        {
|    |  30|+          for (auto & kv:leaves)
|    |  31|+              {
|    |  32|+                  if (kv.second)
|    |  33|+                    {
|    |  34|+                        kv.second->~TrieNode ();
|    |  35|+                    }
|    |  36|+              }
|  34|  37|         }
|  35|  38|     };
|  36|  39| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  34|  34|         }
|  35|  35|     };
|  36|  36| 
|  37|    |-public:
|    |  37|+  public:
|  38|  38|     /**
|  39|  39|      * @param board: A list of lists of character
|  40|  40|      * @param words: A list of string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  40|  40|      * @param words: A list of string
|  41|  41|      * @return: A list of string
|  42|  42|      */
|  43|    |-    vector<string> wordSearchII(vector<vector<char>> &board, vector<string> &words) {
|  44|    |-        unordered_set<string> ret;
|  45|    |-        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
|    |  43|+    vector < string > wordSearchII (vector < vector < char >>&board,
|    |  44|+                                    vector < string > &words)
|    |  45|+    {
|    |  46|+        unordered_set < string > ret;
|    |  47|+        vector < vector < bool >> visited (board.size (),
|    |  48|+                                           vector < bool > (board[0].size (),
|    |  49|+                                                            false));
|  46|  50|         string cur;
|  47|  51|         TrieNode trie;
|  48|  52|         for (const auto& word : words) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  45|  45|         vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
|  46|  46|         string cur;
|  47|  47|         TrieNode trie;
|  48|    |-        for (const auto& word : words) {
|  49|    |-            trie.Insert(word);
|  50|    |-        }
|    |  48|+      for (const auto & word:words)
|    |  49|+          {
|    |  50|+              trie.Insert (word);
|    |  51|+          }
|  51|  52| 
|  52|    |-        for (int i = 0; i < board.size(); ++i) {
|  53|    |-            for (int j = 0; j < board[0].size(); ++j) {
|  54|    |-                wordSearchDFS(board, visited, &trie, i, j, cur,  ret);
|  55|    |-            }
|  56|    |-        }
|    |  53|+        for (int i = 0; i < board.size (); ++i)
|    |  54|+          {
|    |  55|+              for (int j = 0; j < board[0].size (); ++j)
|    |  56|+                {
|    |  57|+                    wordSearchDFS (board, visited, &trie, i, j, cur, ret);
|    |  58|+                }
|    |  59|+          }
|  57|  60| 
|  58|    |-        return vector<string>(ret.begin(), ret.end());
|    |  61|+        return vector < string > (ret.begin (), ret.end ());
|  59|  62|     }
|  60|  63| 
|  61|  64|     void wordSearchDFS(vector<vector<char>> &grid,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  58|  58|         return vector<string>(ret.begin(), ret.end());
|  59|  59|     }
|  60|  60| 
|  61|    |-    void wordSearchDFS(vector<vector<char>> &grid,
|  62|    |-             vector<vector<bool>> &visited,
|  63|    |-             TrieNode *trie,
|  64|    |-             int i,
|  65|    |-             int j,
|  66|    |-             string cur,
|  67|    |-             unordered_set<string> &ret) {
|    |  61|+    void wordSearchDFS (vector < vector < char >>&grid,
|    |  62|+                        vector < vector < bool >> &visited,
|    |  63|+                        TrieNode * trie,
|    |  64|+                        int i,
|    |  65|+                        int j, string cur, unordered_set < string > &ret)
|    |  66|+    {
|  68|  67|         // Invalid state.
|  69|    |-        if (!trie || i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {
|  70|    |-            return;
|  71|    |-        }
|    |  68|+        if (!trie || i < 0 || i >= grid.size () || j < 0
|    |  69|+            || j >= grid[0].size ())
|    |  70|+          {
|    |  71|+              return;
|    |  72|+          }
|  72|  73| 
|  73|  74|         // Not in trie or visited.
|  74|  75|         if (!trie->leaves[grid[i][j] ] || visited[i][j]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  71|  71|         }
|  72|  72| 
|  73|  73|         // Not in trie or visited.
|  74|    |-        if (!trie->leaves[grid[i][j] ] || visited[i][j]) {
|  75|    |-            return;
|  76|    |-        }
|    |  74|+        if (!trie->leaves[grid[i][j]] || visited[i][j])
|    |  75|+          {
|    |  76|+              return;
|    |  77|+          }
|  77|  78| 
|  78|  79|         // Get next trie nodes.
|  79|  80|         TrieNode *nextNode = trie->leaves[grid[i][j]];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  79|  79|         TrieNode *nextNode = trie->leaves[grid[i][j]];
|  80|  80| 
|  81|  81|         // Update current string.
|  82|    |-        cur.push_back(grid[i][j]);
|    |  82|+        cur.push_back (grid[i][j]);
|  83|  83| 
|  84|  84|         // Find the string, add to the answers.
|  85|  85|         if (nextNode->isString) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  82|  82|         cur.push_back(grid[i][j]);
|  83|  83| 
|  84|  84|         // Find the string, add to the answers.
|  85|    |-        if (nextNode->isString) {
|  86|    |-            ret.insert(cur);
|  87|    |-        }
|    |  85|+        if (nextNode->isString)
|    |  86|+          {
|    |  87|+              ret.insert (cur);
|    |  88|+          }
|  88|  89| 
|  89|  90|         // Marked as visited.
|  90|  91|         visited[i][j] = true;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search-ii.cpp
|    |++++| /app/C++/word-search-ii.cpp
|  90|  90|         visited[i][j] = true;
|  91|  91| 
|  92|  92|         // Try each curtion.
|  93|    |-        const vector<pair<int, int>> directions{{0, -1}, {0, 1},
|  94|    |-                                                {-1, 0}, {1, 0}};
|  95|    |-        for (const auto& d : directions) {
|  96|    |-            wordSearchDFS(grid, visited, nextNode,
|  97|    |-                          i + d.first, j + d.second, cur, ret);
|  98|    |-        }
|    |  93|+        const vector < pair < int, int >>directions
|    |  94|+        {
|    |  95|+            {
|    |  96|+            0, -1},
|    |  97|+            {
|    |  98|+            0, 1},
|    |  99|+            {
|    | 100|+            -1, 0},
|    | 101|+            {
|    | 102|+        1, 0}};
|    | 103|+      for (const auto & d:directions)
|    | 104|+          {
|    | 105|+              wordSearchDFS (grid, visited, nextNode,
|    | 106|+                             i + d.first, j + d.second, cur, ret);
|    | 107|+          }
|  99| 108| 
| 100| 109|         visited[i][j] = false;
| 101| 110|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array-ii.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|     /**
|   6|   7|      * param A : an integer ratated sorted array and duplicates are allowed
|   7|   8|      * param target :  an integer to be search
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array-ii.cpp
|   7|   7|      * param target :  an integer to be search
|   8|   8|      * return : a boolean
|   9|   9|      */
|  10|    |-public:
|  11|    |-    bool search(vector<int> &A, int target) {
|  12|    |-        int left = 0, right = A.size() - 1;
|    |  10|+  public:
|    |  11|+    bool search (vector < int >&A, int target)
|    |  12|+    {
|    |  13|+        int left = 0, right = A.size () - 1;
|  13|  14| 
|  14|    |-        while (left <= right) {
|  15|    |-            int mid = left + (right - left) / 2;
|  16|    |-            if (A[mid] == target) {
|  17|    |-                return true;
|  18|    |-            } else if (A[mid] == A[left]) {
|  19|    |-                ++left;
|  20|    |-            } else if ((A[mid] > A[left] && A[left] <= target && target < A[mid]) ||
|  21|    |-                       (A[mid] < A[left] && !(A[mid] < target && target <= A[right]))) {
|  22|    |-                right = mid - 1;
|  23|    |-            } else {
|  24|    |-                left = mid + 1;
|  25|    |-            }
|  26|    |-        }
|    |  15|+        while (left <= right)
|    |  16|+          {
|    |  17|+              int mid = left + (right - left) / 2;
|    |  18|+              if (A[mid] == target)
|    |  19|+                {
|    |  20|+                    return true;
|    |  21|+                }
|    |  22|+              else if (A[mid] == A[left])
|    |  23|+                {
|    |  24|+                    ++left;
|    |  25|+                }
|    |  26|+              else if ((A[mid] > A[left] && A[left] <= target
|    |  27|+                        && target < A[mid]) || (A[mid] < A[left]
|    |  28|+                                                && !(A[mid] < target
|    |  29|+                                                     && target <= A[right])))
|    |  30|+                {
|    |  31|+                    right = mid - 1;
|    |  32|+                }
|    |  33|+              else
|    |  34|+                {
|    |  35|+                    left = mid + 1;
|    |  36|+                }
|    |  37|+          }
|  27|  38| 
|  28|  39|         return false;
|  29|  40|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array-ii.cpp
|  29|  29|     }
|  30|  30| };
|  31|  31| 
|  32|    |-class Solution2 {
|    |  32|+class Solution2
|    |  33|+{
|  33|  34|     /**
|  34|  35|      * param A : an integer ratated sorted array and duplicates are allowed
|  35|  36|      * param target :  an integer to be search
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/search-in-rotated-sorted-array-ii.cpp
|  35|  35|      * param target :  an integer to be search
|  36|  36|      * return : a boolean
|  37|  37|      */
|  38|    |-public:
|  39|    |-    bool search(vector<int> &A, int target) {
|  40|    |-        int left = 0, right = A.size();
|    |  38|+  public:
|    |  39|+    bool search (vector < int >&A, int target)
|    |  40|+    {
|    |  41|+        int left = 0, right = A.size ();
|  41|  42| 
|  42|    |-        while (left < right) {
|  43|    |-            int mid = left + (right - left) / 2;
|  44|    |-            if (A[mid] == target) {
|  45|    |-                return true;
|  46|    |-            } else if (A[mid] == A[left]) {
|  47|    |-                ++left;
|  48|    |-            } else if ((A[left] <= A[mid] && A[left] <= target && target < A[mid]) ||
|  49|    |-                       (A[left] > A[mid] && !(A[mid] < target && target <= A[right - 1]))) {
|  50|    |-                right = mid;
|  51|    |-            } else {
|  52|    |-                left = mid + 1;
|  53|    |-            }
|  54|    |-        }
|    |  43|+        while (left < right)
|    |  44|+          {
|    |  45|+              int mid = left + (right - left) / 2;
|    |  46|+              if (A[mid] == target)
|    |  47|+                {
|    |  48|+                    return true;
|    |  49|+                }
|    |  50|+              else if (A[mid] == A[left])
|    |  51|+                {
|    |  52|+                    ++left;
|    |  53|+                }
|    |  54|+              else if ((A[left] <= A[mid] && A[left] <= target
|    |  55|+                        && target < A[mid]) || (A[left] > A[mid]
|    |  56|+                                                && !(A[mid] < target
|    |  57|+                                                     && target <=
|    |  58|+                                                     A[right - 1])))
|    |  59|+                {
|    |  60|+                    right = mid;
|    |  61|+                }
|    |  62|+              else
|    |  63|+                {
|    |  64|+                    left = mid + 1;
|    |  65|+                }
|    |  66|+          }
|  55|  67| 
|  56|  68|         return false;
|  57|  69|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum.cpp
|    |++++| /app/C++/combination-sum.cpp
|   1|   1| // Time:  O(k * n^k), k is max length of combination
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num: Given the candidate numbers
|   8|   9|      * @param target: Given the target number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum.cpp
|    |++++| /app/C++/combination-sum.cpp
|   8|   8|      * @param target: Given the target number
|   9|   9|      * @return: All the combinations that sum to target
|  10|  10|      */
|  11|    |-    vector<vector<int>> combinationSum(vector<int> &num, int target) {
|  12|    |-        sort(num.begin(), num.end());
|  13|    |-        vector<vector<int>> ans;
|  14|    |-        vector<int> v;
|  15|    |-        combinationSumHelper(num, target, 0, v, ans);
|  16|    |-        return ans;
|    |  11|+    vector < vector < int >>combinationSum (vector < int >&num, int target)
|    |  12|+    {
|    |  13|+        sort (num.begin (), num.end ());
|    |  14|+        vector < vector < int >>ans;
|    |  15|+          vector < int >v;
|    |  16|+          combinationSumHelper (num, target, 0, v, ans);
|    |  17|+          return ans;
|  17|  18|     }
|  18|  19| 
|  19|  20| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum.cpp
|    |++++| /app/C++/combination-sum.cpp
|  16|  16|         return ans;
|  17|  17|     }
|  18|  18| 
|  19|    |-private:
|  20|    |-    void combinationSumHelper(vector<int>& num, int gap, int begin,
|  21|    |-                              vector<int>& v,vector<vector<int>> &ans) {
|  22|    |-        if (gap == 0) {
|  23|    |-            ans.emplace_back(v);
|  24|    |-            return;
|  25|    |-        }
|    |  19|+  private:
|    |  20|+    void combinationSumHelper (vector < int >&num, int gap, int begin,
|    |  21|+                               vector < int >&v, vector < vector < int >>&ans)
|    |  22|+    {
|    |  23|+        if (gap == 0)
|    |  24|+          {
|    |  25|+              ans.emplace_back (v);
|    |  26|+              return;
|    |  27|+          }
|  26|  28| 
|  27|    |-        for (size_t i = begin; i < num.size() && num[i] <= gap; ++i) {
|  28|    |-            v.emplace_back(num[i]);
|  29|    |-            combinationSumHelper(num, gap - num[i], i, v, ans);
|  30|    |-            v.pop_back();
|  31|    |-        }
|    |  29|+        for (size_t i = begin; i < num.size () && num[i] <= gap; ++i)
|    |  30|+          {
|    |  31|+              v.emplace_back (num[i]);
|    |  32|+              combinationSumHelper (num, gap - num[i], i, v, ans);
|    |  33|+              v.pop_back ();
|    |  34|+          }
|  32|  35|     }
|  33|  36| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: You should return the head of the sorted linked list,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  20|  20|      * @return: You should return the head of the sorted linked list,
|  21|  21|      using constant space complexity.
|  22|  22|      */
|  23|    |-    ListNode *sortList(ListNode *head) {
|  24|    |-        if (!head || !head->next) {
|  25|    |-            return head;
|  26|    |-        }
|    |  23|+    ListNode * sortList (ListNode * head)
|    |  24|+    {
|    |  25|+        if (!head || !head->next)
|    |  26|+          {
|    |  27|+              return head;
|    |  28|+          }
|  27|  29| 
|  28|  30|         auto slow = head, fast = head;
|  29|  31|         while (fast->next && fast->next->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  26|  26|         }
|  27|  27| 
|  28|  28|         auto slow = head, fast = head;
|  29|    |-        while (fast->next && fast->next->next) {
|  30|    |-            slow = slow->next;
|  31|    |-            fast = fast->next->next;
|  32|    |-        }
|    |  29|+        while (fast->next && fast->next->next)
|    |  30|+          {
|    |  31|+              slow = slow->next;
|    |  32|+              fast = fast->next->next;
|    |  33|+          }
|  33|  34| 
|  34|  35|         // Split linked list.
|  35|  36|         fast = slow;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  36|  36|         slow = slow->next;
|  37|  37|         fast->next = nullptr;
|  38|  38| 
|  39|    |-        return mergeTwoLists(sortList(head), sortList(slow));
|    |  39|+        return mergeTwoLists (sortList (head), sortList (slow));
|  40|  40|     }
|  41|  41| 
|  42|  42| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  39|  39|         return mergeTwoLists(sortList(head), sortList(slow));
|  40|  40|     }
|  41|  41| 
|  42|    |-private:
|  43|    |-    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
|  44|    |-        ListNode dummy{0};
|    |  42|+  private:
|    |  43|+    ListNode * mergeTwoLists (ListNode * l1, ListNode * l2)
|    |  44|+    {
|    |  45|+        ListNode dummy
|    |  46|+        {
|    |  47|+        0};
|  45|  48|         auto curr = &dummy;
|  46|  49| 
|  47|  50|         while (l1 && l2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-list.cpp
|    |++++| /app/C++/sort-list.cpp
|  44|  44|         ListNode dummy{0};
|  45|  45|         auto curr = &dummy;
|  46|  46| 
|  47|    |-        while (l1 && l2) {
|  48|    |-            if (l1->val <= l2->val) {
|  49|    |-                curr->next = l1;
|  50|    |-                l1 = l1->next;
|  51|    |-            } else {
|  52|    |-                curr->next = l2;
|  53|    |-                l2 = l2->next;
|  54|    |-            }
|  55|    |-            curr = curr->next;
|  56|    |-        }
|    |  47|+        while (l1 && l2)
|    |  48|+          {
|    |  49|+              if (l1->val <= l2->val)
|    |  50|+                {
|    |  51|+                    curr->next = l1;
|    |  52|+                    l1 = l1->next;
|    |  53|+                }
|    |  54|+              else
|    |  55|+                {
|    |  56|+                    curr->next = l2;
|    |  57|+                    l2 = l2->next;
|    |  58|+                }
|    |  59|+              curr = curr->next;
|    |  60|+          }
|  57|  61|         curr->next = l1 ? l1 : l2;
|  58|  62| 
|  59|  63|         return dummy.next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-substring-without-repeating-characters.cpp
|    |++++| /app/C++/longest-substring-without-repeating-characters.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s: a string
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-substring-without-repeating-characters.cpp
|    |++++| /app/C++/longest-substring-without-repeating-characters.cpp
|   7|   7|      * @param s: a string
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int lengthOfLongestSubstring(string s) {
|    |  10|+    int lengthOfLongestSubstring (string s)
|    |  11|+    {
|  11|  12|         // Record the last occurrence of each char.
|  12|    |-        unordered_map<char, size_t> last_occurrence;
|    |  13|+        unordered_map < char, size_t > last_occurrence;
|  13|  14|         size_t starting_idx = 0, ans = 0;
|  14|    |-        for (size_t i = 0; i < s.size(); ++i) {
|  15|    |-            auto it(last_occurrence.find(s[i]));
|  16|    |-            if (it == last_occurrence.cend()) {
|  17|    |-                last_occurrence.emplace_hint(it, s[i], i);
|  18|    |-            } else {  // s[i] appeared before. Check its validity.
|  19|    |-                if (it->second >= starting_idx) {
|  20|    |-                    ans = max(ans, i - starting_idx);
|  21|    |-                    starting_idx = it->second + 1;
|    |  15|+        for (size_t i = 0; i < s.size (); ++i)
|    |  16|+          {
|    |  17|+              auto it (last_occurrence.find (s[i]));
|    |  18|+              if (it == last_occurrence.cend ())
|    |  19|+                {
|    |  20|+                    last_occurrence.emplace_hint (it, s[i], i);
|  22|  21|                 }
|  23|    |-                it->second = i;
|  24|    |-            }
|  25|    |-        }
|  26|    |-        ans = max(ans, s.size() - starting_idx);
|    |  22|+              else
|    |  23|+                {               // s[i] appeared before. Check its validity.
|    |  24|+                    if (it->second >= starting_idx)
|    |  25|+                      {
|    |  26|+                          ans = max (ans, i - starting_idx);
|    |  27|+                          starting_idx = it->second + 1;
|    |  28|+                      }
|    |  29|+                    it->second = i;
|    |  30|+                }
|    |  31|+          }
|    |  32|+        ans = max (ans, s.size () - starting_idx);
|  27|  33|         return ans;
|  28|  34|     }
|  29|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix a matrix of m x n elements
|   8|   9|      * @return an integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|   7|   7|      * @param matrix a matrix of m x n elements
|   8|   8|      * @return an integer array
|   9|   9|      */
|  10|    |-    vector<int> spiralOrder(vector<vector<int>>& matrix) {
|  11|    |-        vector<int> res;
|  12|    |-        if (matrix.empty()) {
|  13|    |-            return res;
|  14|    |-        }
|    |  10|+    vector < int >spiralOrder (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        vector < int >res;
|    |  13|+        if (matrix.empty ())
|    |  14|+          {
|    |  15|+              return res;
|    |  16|+          }
|  15|  17| 
|  16|    |-        for (int left = 0, right = matrix[0].size() - 1,
|  17|    |-                 top = 0, bottom = matrix.size() - 1;
|  18|    |-             left <= right && top <= bottom;
|  19|    |-             ++left, --right, ++top, --bottom) {
|    |  18|+        for (int left = 0, right = matrix[0].size () - 1,
|    |  19|+             top = 0, bottom = matrix.size () - 1;
|    |  20|+             left <= right && top <= bottom; ++left, --right, ++top, --bottom)
|    |  21|+          {
|  20|  22| 
|  21|    |-            for (int j = left; j <= right; ++j) {
|  22|    |-                res.emplace_back(matrix[top][j]);
|  23|    |-            }
|  24|    |-            for (int i = top + 1; i < bottom; ++i) {
|  25|    |-                res.emplace_back(matrix[i][right]);
|  26|    |-            }
|  27|    |-            for (int j = right; top < bottom && j >= left; --j) {
|  28|    |-                res.emplace_back(matrix[bottom][j]);
|  29|    |-            }
|  30|    |-            for (int i = bottom - 1; left < right && i > top; --i) {
|  31|    |-                res.emplace_back(matrix[i][left]);
|  32|    |-            }
|  33|    |-        }
|    |  23|+              for (int j = left; j <= right; ++j)
|    |  24|+                {
|    |  25|+                    res.emplace_back (matrix[top][j]);
|    |  26|+                }
|    |  27|+              for (int i = top + 1; i < bottom; ++i)
|    |  28|+                {
|    |  29|+                    res.emplace_back (matrix[i][right]);
|    |  30|+                }
|    |  31|+              for (int j = right; top < bottom && j >= left; --j)
|    |  32|+                {
|    |  33|+                    res.emplace_back (matrix[bottom][j]);
|    |  34|+                }
|    |  35|+              for (int i = bottom - 1; left < right && i > top; --i)
|    |  36|+                {
|    |  37|+                    res.emplace_back (matrix[i][left]);
|    |  38|+                }
|    |  39|+          }
|  34|  40| 
|  35|  41|         return res;
|  36|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  38|  38| 
|  39|  39| // Time:  O(m * n)
|  40|  40| // Space: O(1)
|  41|    |-class Solution2 {
|  42|    |-public:
|  43|    |-    vector<int> spiralOrder(vector<vector<int>>& matrix) {
|  44|    |-        const int m = matrix.size();
|  45|    |-        vector<int> res;
|  46|    |-        if (m == 0) {
|  47|    |-            return res;
|  48|    |-        }
|    |  41|+class Solution2
|    |  42|+{
|    |  43|+  public:
|    |  44|+    vector < int >spiralOrder (vector < vector < int >>&matrix)
|    |  45|+    {
|    |  46|+        const int m = matrix.size ();
|    |  47|+          vector < int >res;
|    |  48|+        if (m == 0)
|    |  49|+          {
|    |  50|+              return res;
|    |  51|+          }
|  49|  52| 
|  50|    |-        const int n = matrix.front().size();
|  51|    |-        enum Action {RIGHT, DOWN, LEFT, UP};
|    |  53|+        const int n = matrix.front ().size ();
|    |  54|+        enum Action
|    |  55|+        { RIGHT, DOWN, LEFT, UP };
|  52|  56|         Action action = RIGHT;
|  53|  57|         for (int i = 0, j = 0, begini = 0, beginj = 0, endi = m,
|  54|  58|              endj = n, cnt = 0, total = m * n; cnt < total; ++cnt) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  51|  51|         enum Action {RIGHT, DOWN, LEFT, UP};
|  52|  52|         Action action = RIGHT;
|  53|  53|         for (int i = 0, j = 0, begini = 0, beginj = 0, endi = m,
|  54|    |-             endj = n, cnt = 0, total = m * n; cnt < total; ++cnt) {
|    |  54|+             endj = n, cnt = 0, total = m * n; cnt < total; ++cnt)
|    |  55|+          {
|  55|  56| 
|  56|    |-            res.emplace_back(matrix[i][j]);
|    |  57|+              res.emplace_back (matrix[i][j]);
|  57|  58| 
|  58|    |-            switch (action) {
|    |  59|+              switch (action)
|    |  60|+                {
|  59|  61|                 case RIGHT:
|  60|    |-                    if (j + 1 < endj) {
|  61|    |-                        ++j;
|  62|    |-                    } else {
|  63|    |-                        action = DOWN, ++begini, ++i;
|  64|    |-                    }
|    |  62|+                    if (j + 1 < endj)
|    |  63|+                      {
|    |  64|+                          ++j;
|    |  65|+                      }
|    |  66|+                    else
|    |  67|+                      {
|    |  68|+                          action = DOWN, ++begini, ++i;
|    |  69|+                      }
|  65|  70|                     break;
|  66|  71|                 case DOWN:
|  67|  72|                     if (i + 1 < endi) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  64|  64|                     }
|  65|  65|                     break;
|  66|  66|                 case DOWN:
|  67|    |-                    if (i + 1 < endi) {
|  68|    |-                        ++i;
|  69|    |-                    } else {
|  70|    |-                        action = LEFT, --endj, --j;
|  71|    |-                    }
|    |  67|+                    if (i + 1 < endi)
|    |  68|+                      {
|    |  69|+                          ++i;
|    |  70|+                      }
|    |  71|+                    else
|    |  72|+                      {
|    |  73|+                          action = LEFT, --endj, --j;
|    |  74|+                      }
|  72|  75|                     break;
|  73|  76|                 case LEFT:
|  74|  77|                     if (j - 1 >= beginj) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  71|  71|                     }
|  72|  72|                     break;
|  73|  73|                 case LEFT:
|  74|    |-                    if (j - 1 >= beginj) {
|  75|    |-                        --j;
|  76|    |-                    } else {
|  77|    |-                        action = UP, --endi, --i;
|  78|    |-                    }
|    |  74|+                    if (j - 1 >= beginj)
|    |  75|+                      {
|    |  76|+                          --j;
|    |  77|+                      }
|    |  78|+                    else
|    |  79|+                      {
|    |  80|+                          action = UP, --endi, --i;
|    |  81|+                      }
|  79|  82|                     break;
|  80|  83|                 case UP:
|  81|  84|                     if (i - 1 >= begini) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  78|  78|                     }
|  79|  79|                     break;
|  80|  80|                 case UP:
|  81|    |-                    if (i - 1 >= begini) {
|  82|    |-                        --i;
|  83|    |-                    } else {
|  84|    |-                        action = RIGHT, ++beginj, ++j;
|  85|    |-                    }
|    |  81|+                    if (i - 1 >= begini)
|    |  82|+                      {
|    |  83|+                          --i;
|    |  84|+                      }
|    |  85|+                    else
|    |  86|+                      {
|    |  87|+                          action = RIGHT, ++beginj, ++j;
|    |  88|+                      }
|  86|  89|                     break;
|  87|  90|                 default:
|  88|  91|                     break;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix.cpp
|    |++++| /app/C++/spiral-matrix.cpp
|  86|  86|                     break;
|  87|  87|                 default:
|  88|  88|                     break;
|  89|    |-            }
|  90|    |-        }
|    |  89|+                }
|    |  90|+          }
|  91|  91|         return res;
|  92|  92|     }
|  93|  93| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum-ii.cpp
|    |++++| /app/C++/combination-sum-ii.cpp
|   1|   1| // Time:  O(k * C(n, k)), k is max length of combination
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num: Given the candidate numbers
|   8|   9|      * @param target: Given the target number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum-ii.cpp
|    |++++| /app/C++/combination-sum-ii.cpp
|   8|   8|      * @param target: Given the target number
|   9|   9|      * @return: All the combinations that sum to target
|  10|  10|      */
|  11|    |-    vector<vector<int>> combinationSum2(vector<int> &num, int target) {
|  12|    |-        sort(num.begin(), num.end());
|  13|    |-        vector<vector<int>> ans;
|  14|    |-        vector<int> v;
|  15|    |-        combinationSum2Helper(num, target, 0, v, ans);
|  16|    |-        return ans;
|    |  11|+    vector < vector < int >>combinationSum2 (vector < int >&num, int target)
|    |  12|+    {
|    |  13|+        sort (num.begin (), num.end ());
|    |  14|+        vector < vector < int >>ans;
|    |  15|+          vector < int >v;
|    |  16|+          combinationSum2Helper (num, target, 0, v, ans);
|    |  17|+          return ans;
|  17|  18|     }
|  18|  19| 
|  19|  20| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combination-sum-ii.cpp
|    |++++| /app/C++/combination-sum-ii.cpp
|  16|  16|         return ans;
|  17|  17|     }
|  18|  18| 
|  19|    |-private:
|  20|    |-    void combinationSum2Helper(vector<int>& num, int gap, int begin,
|  21|    |-                               vector<int>& v,vector<vector<int>> &ans) {
|  22|    |-        if (gap == 0) {
|  23|    |-            ans.emplace_back(v);
|  24|    |-            return;
|  25|    |-        }
|    |  19|+  private:
|    |  20|+    void combinationSum2Helper (vector < int >&num, int gap, int begin,
|    |  21|+                                vector < int >&v, vector < vector < int >>&ans)
|    |  22|+    {
|    |  23|+        if (gap == 0)
|    |  24|+          {
|    |  25|+              ans.emplace_back (v);
|    |  26|+              return;
|    |  27|+          }
|  26|  28| 
|  27|    |-        for (size_t i = begin; i < num.size() && num[i] <= gap; ++i) {
|  28|    |-            if ( i == begin || num[i] != num[i - 1]) {  // Skip duplicates.
|  29|    |-                // Each same element could be chosen only once
|  30|    |-                // with the same previous nums.
|  31|    |-                v.emplace_back(num[i]);
|  32|    |-                combinationSum2Helper(num, gap - num[i], i + 1, v, ans);
|  33|    |-                v.pop_back();
|  34|    |-            }
|  35|    |-        }
|    |  29|+        for (size_t i = begin; i < num.size () && num[i] <= gap; ++i)
|    |  30|+          {
|    |  31|+              if (i == begin || num[i] != num[i - 1])
|    |  32|+                {               // Skip duplicates.
|    |  33|+                    // Each same element could be chosen only once
|    |  34|+                    // with the same previous nums.
|    |  35|+                    v.emplace_back (num[i]);
|    |  36|+                    combinationSum2Helper (num, gap - num[i], i + 1, v, ans);
|    |  37|+                    v.pop_back ();
|    |  38|+                }
|    |  39|+          }
|  36|  40|     }
|  37|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-missing-number.cpp
|    |++++| /app/C++/find-the-missing-number.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**    
|   7|   8|      * @param nums: a vector of integers
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-missing-number.cpp
|    |++++| /app/C++/find-the-missing-number.cpp
|   7|   7|      * @param nums: a vector of integers
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int findMissing(vector<int> &nums) {
|    |  10|+    int findMissing (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int missing_num = 0;
|  12|  13|         // xor all nums <= N.
|  13|  14|         for (int num = 0; num <= nums.size(); ++num) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-missing-number.cpp
|    |++++| /app/C++/find-the-missing-number.cpp
|  10|  10|     int findMissing(vector<int> &nums) {
|  11|  11|         int missing_num = 0;
|  12|  12|         // xor all nums <= N.
|  13|    |-        for (int num = 0; num <= nums.size(); ++num) {
|  14|    |-            missing_num ^= num;
|  15|    |-        }
|    |  13|+        for (int num = 0; num <= nums.size (); ++num)
|    |  14|+          {
|    |  15|+              missing_num ^= num;
|    |  16|+          }
|  16|  17|         // Delete num in nums.
|  17|    |-        for (const auto& num : nums) {
|  18|    |-            missing_num ^= num;
|  19|    |-        }
|    |  18|+        for (const auto & num:nums)
|    |  19|+          {
|    |  20|+              missing_num ^= num;
|    |  21|+          }
|  20|  22|         // The remaining num would be missing num.
|  21|  23|         return missing_num;
|  22|  24|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-missing-number.cpp
|    |++++| /app/C++/find-the-missing-number.cpp
|  24|  24| 
|  25|  25| // Time:  O(n)
|  26|  26| // Space: O(n)
|  27|    |-class Solution2 {
|  28|    |-public:
|  29|    |-    int findMissing(vector<int> &nums) {
|  30|    |-        vector<int> expected(nums.size()); 
|  31|    |-        iota(expected.begin(), expected.end(), 1);  // Costs extra space O(n)
|  32|    |-        return accumulate(nums.cbegin(), nums.cend(), 0, bit_xor<int>()) ^
|  33|    |-               accumulate(expected.cbegin(), expected.cend(), 0, bit_xor<int>());
|    |  27|+class Solution2
|    |  28|+{
|    |  29|+  public:
|    |  30|+    int findMissing (vector < int >&nums)
|    |  31|+    {
|    |  32|+        vector < int >expected (nums.size ());
|    |  33|+          iota (expected.begin (), expected.end (), 1); // Costs extra space O(n)
|    |  34|+          return accumulate (nums.cbegin (), nums.cend (), 0,
|    |  35|+                             bit_xor <
|    |  36|+                             int >()) ^accumulate (expected.cbegin (),
|    |  37|+                                                   expected.cend (), 0,
|    |  38|+                                                   bit_xor < int >());
|  34|  39|     }
|  35|  40| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fizz-buzz.cpp
|    |++++| /app/C++/fizz-buzz.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * param n: As description.
|   8|   9|      * return: A list of strings.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fizz-buzz.cpp
|    |++++| /app/C++/fizz-buzz.cpp
|   7|   7|      * param n: As description.
|   8|   8|      * return: A list of strings.
|   9|   9|      */
|  10|    |-    vector<string> fizzBuzz(int n) {
|  11|    |-        vector<string> result;
|    |  10|+    vector < string > fizzBuzz (int n)
|    |  11|+    {
|    |  12|+        vector < string > result;
|  12|  13| 
|  13|    |-        for (int i = 1; i <= n; ++i) {
|  14|    |-            if (i % 15 == 0) {
|  15|    |-                result.emplace_back("fizz buzz");
|  16|    |-            } else if (i % 5 == 0) {
|  17|    |-                result.emplace_back("buzz");
|  18|    |-            } else if (i % 3 == 0) {
|  19|    |-                result.emplace_back("fizz");
|  20|    |-            } else {
|  21|    |-                result.emplace_back(to_string(i));
|  22|    |-            }
|  23|    |-        }
|    |  14|+        for (int i = 1; i <= n; ++i)
|    |  15|+          {
|    |  16|+              if (i % 15 == 0)
|    |  17|+                {
|    |  18|+                    result.emplace_back ("fizz buzz");
|    |  19|+                }
|    |  20|+              else if (i % 5 == 0)
|    |  21|+                {
|    |  22|+                    result.emplace_back ("buzz");
|    |  23|+                }
|    |  24|+              else if (i % 3 == 0)
|    |  25|+                {
|    |  26|+                    result.emplace_back ("fizz");
|    |  27|+                }
|    |  28|+              else
|    |  29|+                {
|    |  30|+                    result.emplace_back (to_string (i));
|    |  31|+                }
|    |  32|+          }
|  24|  33| 
|  25|  34|         return result;
|  26|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-node-in-the-middle-of-singly-linked-list.cpp
|    |++++| /app/C++/delete-node-in-the-middle-of-singly-linked-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param node: a node in the list should be deleted
|  20|  21|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-node-in-the-middle-of-singly-linked-list.cpp
|    |++++| /app/C++/delete-node-in-the-middle-of-singly-linked-list.cpp
|  19|  19|      * @param node: a node in the list should be deleted
|  20|  20|      * @return: nothing
|  21|  21|      */
|  22|    |-    void deleteNode(ListNode *node) {
|  23|    |-        if (!node || !node->next) {
|  24|    |-            return;
|  25|    |-        }
|    |  22|+    void deleteNode (ListNode * node)
|    |  23|+    {
|    |  24|+        if (!node || !node->next)
|    |  25|+          {
|    |  26|+              return;
|    |  27|+          }
|  26|  28|         auto node_to_delete = node->next;
|  27|  29|         node->val = node->next->val;
|  28|  30|         node->next = node->next->next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation-ii.cpp
|    |++++| /app/C++/next-permutation-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: a vector of integers
|   8|   9|      * @return: return nothing (void), do not return anything, modify nums in-place instead
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation-ii.cpp
|    |++++| /app/C++/next-permutation-ii.cpp
|   7|   7|      * @param nums: a vector of integers
|   8|   8|      * @return: return nothing (void), do not return anything, modify nums in-place instead
|   9|   9|      */
|  10|    |-    void nextPermutation(vector<int> &nums) {
|    |  10|+    void nextPermutation (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int k = -1, l = 0;
|  12|    |-        for (int i = 0; i < nums.size() - 1; ++i) {
|  13|    |-            if (nums[i] < nums[i + 1]) {
|  14|    |-                k = i;
|  15|    |-            }
|  16|    |-        }
|    |  13|+        for (int i = 0; i < nums.size () - 1; ++i)
|    |  14|+          {
|    |  15|+              if (nums[i] < nums[i + 1])
|    |  16|+                {
|    |  17|+                    k = i;
|    |  18|+                }
|    |  19|+          }
|  17|  20| 
|  18|    |-        if (k >= 0) {
|  19|    |-            for (int i = 0; i < nums.size(); ++i) {
|  20|    |-                if (nums[i] > nums[k]) {
|  21|    |-                    l = i;
|    |  21|+        if (k >= 0)
|    |  22|+          {
|    |  23|+              for (int i = 0; i < nums.size (); ++i)
|    |  24|+                {
|    |  25|+                    if (nums[i] > nums[k])
|    |  26|+                      {
|    |  27|+                          l = i;
|    |  28|+                      }
|  22|  29|                 }
|  23|    |-            }
|  24|    |-            swap(nums[k], nums[l]);
|  25|    |-        }
|  26|    |-        reverse(nums.begin() + k + 1, nums.end());
|    |  30|+              swap (nums[k], nums[l]);
|    |  31|+          }
|    |  32|+        reverse (nums.begin () + k + 1, nums.end ());
|  27|  33|     }
|  28|  34| };
|  29|  35| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation-ii.cpp
|    |++++| /app/C++/next-permutation-ii.cpp
|  27|  27|     }
|  28|  28| };
|  29|  29| 
|  30|    |-class Solution2 {
|  31|    |-public:
|    |  30|+class Solution2
|    |  31|+{
|    |  32|+  public:
|  32|  33|     /**
|  33|  34|      * @param nums: a vector of integers
|  34|  35|      * @return: return nothing (void), do not return anything, modify nums in-place instead
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/next-permutation-ii.cpp
|    |++++| /app/C++/next-permutation-ii.cpp
|  33|  33|      * @param nums: a vector of integers
|  34|  34|      * @return: return nothing (void), do not return anything, modify nums in-place instead
|  35|  35|      */
|  36|    |-    void nextPermutation(vector<int> &nums) {
|  37|    |-        next_permutation(nums.begin(), nums.end());
|    |  36|+    void nextPermutation (vector < int >&nums)
|    |  37|+    {
|    |  38|+        next_permutation (nums.begin (), nums.end ());
|  38|  39|     }
|  39|  40| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|   2|   2| // Space: O(m + n + k^2)
|   3|   3| 
|   4|   4| // DP + Greedy solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums1 an integer array of length m with digits 0-9
|   9|  10|      * @param nums2 an integer array of length n with digits 0-9
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  10|  10|      * @param k an integer and k <= m + n
|  11|  11|      * @return an integer array
|  12|  12|      */
|  13|    |-    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
|  14|    |-        const int m = nums1.size(), n = nums2.size();
|  15|    |-        vector<vector<int>> max_numbers1(k + 1), max_numbers2(k + 1);
|  16|    |-        maxNumberDP(nums1, max(0, k - n), min(k, m), &max_numbers1);
|  17|    |-        maxNumberDP(nums2, max(0, k - m), min(k, n), &max_numbers2);
|    |  13|+    vector < int >maxNumber (vector < int >&nums1, vector < int >&nums2, int k)
|    |  14|+    {
|    |  15|+        const int m = nums1.size (), n = nums2.size ();
|    |  16|+          vector < vector < int >>max_numbers1 (k + 1), max_numbers2 (k + 1);
|    |  17|+          maxNumberDP (nums1, max (0, k - n), min (k, m), &max_numbers1);
|    |  18|+          maxNumberDP (nums2, max (0, k - m), min (k, n), &max_numbers2);
|  18|  19| 
|  19|    |-        vector<int> res(k);
|  20|    |-        for (int i = max(0, k - n); i <= min(k, m); ++i) {
|  21|    |-            vector<int> tmp(k);
|  22|    |-            merge(max_numbers1[i], max_numbers2[k - i], &tmp);
|  23|    |-            if (tmp > res) {
|  24|    |-                res = move(tmp);
|  25|    |-            }
|  26|    |-        }
|    |  20|+          vector < int >res (k);
|    |  21|+        for (int i = max (0, k - n); i <= min (k, m); ++i)
|    |  22|+          {
|    |  23|+              vector < int >tmp (k);
|    |  24|+                merge (max_numbers1[i], max_numbers2[k - i], &tmp);
|    |  25|+              if (tmp > res)
|    |  26|+                {
|    |  27|+                    res = move (tmp);
|    |  28|+                }
|    |  29|+          }
|  27|  30|         return res;
|  28|  31|     }
|  29|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  27|  27|         return res;
|  28|  28|     }
|  29|  29| 
|  30|    |-private:
|  31|    |-    void maxNumberDP(vector<int> nums, int start, int end, vector<vector<int>> *max_numbers) {
|  32|    |-        (*max_numbers)[end] = maxNumber(nums, end);
|  33|    |-        for (int i = end - 1; i >= start; --i) {
|  34|    |-            (*max_numbers)[i] = deleteNumber((*max_numbers)[i + 1]);
|  35|    |-        }
|    |  30|+  private:
|    |  31|+    void maxNumberDP (vector < int >nums, int start, int end,
|    |  32|+                      vector < vector < int >>*max_numbers)
|    |  33|+    {
|    |  34|+        (*max_numbers)[end] = maxNumber (nums, end);
|    |  35|+        for (int i = end - 1; i >= start; --i)
|    |  36|+          {
|    |  37|+              (*max_numbers)[i] = deleteNumber ((*max_numbers)[i + 1]);
|    |  38|+          }
|  36|  39|     }
|  37|  40| 
|  38|  41|     vector<int> maxNumber(const vector<int>& nums, int k) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  35|  35|         }
|  36|  36|     }
|  37|  37| 
|  38|    |-    vector<int> maxNumber(const vector<int>& nums, int k) {
|  39|    |-        vector<int> res;
|  40|    |-        int drop = nums.size() - k;
|  41|    |-        for (const auto& num : nums) {
|  42|    |-            while (drop > 0 && !res.empty() && res.back() < num) {
|  43|    |-                res.pop_back();
|  44|    |-                --drop;
|  45|    |-            }
|  46|    |-            res.emplace_back(num);
|  47|    |-        }
|  48|    |-        res.resize(k);
|    |  38|+    vector < int >maxNumber (const vector < int >&nums, int k)
|    |  39|+    {
|    |  40|+        vector < int >res;
|    |  41|+        int drop = nums.size () - k;
|    |  42|+      for (const auto & num:nums)
|    |  43|+          {
|    |  44|+              while (drop > 0 && !res.empty () && res.back () < num)
|    |  45|+                {
|    |  46|+                    res.pop_back ();
|    |  47|+                    --drop;
|    |  48|+                }
|    |  49|+              res.emplace_back (num);
|    |  50|+          }
|    |  51|+        res.resize (k);
|  49|  52|         return res;
|  50|  53|     }
|  51|  54| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  49|  49|         return res;
|  50|  50|     }
|  51|  51| 
|  52|    |-    vector<int> deleteNumber(const vector<int>& nums) {
|  53|    |-        vector<int> res(nums);
|  54|    |-        for (int i = 0; i < res.size(); ++i) {
|  55|    |-            if (i == res.size() - 1 || res[i] < res[i + 1]) {
|  56|    |-                res.erase(res.begin() + i);
|  57|    |-                break;
|  58|    |-            }
|  59|    |-        }
|    |  52|+    vector < int >deleteNumber (const vector < int >&nums)
|    |  53|+    {
|    |  54|+        vector < int >res (nums);
|    |  55|+        for (int i = 0; i < res.size (); ++i)
|    |  56|+          {
|    |  57|+              if (i == res.size () - 1 || res[i] < res[i + 1])
|    |  58|+                {
|    |  59|+                    res.erase (res.begin () + i);
|    |  60|+                    break;
|    |  61|+                }
|    |  62|+          }
|  60|  63|         return res;
|  61|  64|     }
|  62|  65| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  60|  60|         return res;
|  61|  61|     }
|  62|  62| 
|  63|    |-    void merge(const vector<int>& vec1, const vector<int>& vec2, vector<int> *res) {
|  64|    |-        auto first1 = vec1.begin(), last1 = vec1.end(),
|  65|    |-             first2 = vec2.begin(), last2 = vec2.end();
|  66|    |-        auto result = res->begin();
|  67|    |-        while (first1 != last1 || first2 != last2) {
|  68|    |-            if (greater(first1, last1, first2, last2)) {
|  69|    |-                *result++ = *first1++;
|  70|    |-            } else {
|  71|    |-                *result++ = *first2++;
|  72|    |-            }
|  73|    |-        }
|    |  63|+    void merge (const vector < int >&vec1, const vector < int >&vec2,
|    |  64|+                vector < int >*res)
|    |  65|+    {
|    |  66|+        auto first1 = vec1.begin (), last1 = vec1.end (),
|    |  67|+            first2 = vec2.begin (), last2 = vec2.end ();
|    |  68|+        auto result = res->begin ();
|    |  69|+        while (first1 != last1 || first2 != last2)
|    |  70|+          {
|    |  71|+              if (greater (first1, last1, first2, last2))
|    |  72|+                {
|    |  73|+                    *result++ = *first1++;
|    |  74|+                }
|    |  75|+              else
|    |  76|+                {
|    |  77|+                    *result++ = *first2++;
|    |  78|+                }
|    |  79|+          }
|  74|  80|     }
|  75|  81| 
|  76|  82|     template<typename IT>
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/create-maximum-number.cpp
|    |++++| /app/C++/create-maximum-number.cpp
|  73|  73|         }
|  74|  74|     }
|  75|  75| 
|  76|    |-    template<typename IT>
|  77|    |-    bool greater(IT first1, IT last1, IT first2, IT last2) {
|  78|    |-        while (first1 != last1 && first2 != last2 && *first1 == *first2) {
|  79|    |-            ++first1;
|  80|    |-            ++first2;
|  81|    |-        }
|    |  76|+    template < typename IT >
|    |  77|+        bool greater (IT first1, IT last1, IT first2, IT last2)
|    |  78|+    {
|    |  79|+        while (first1 != last1 && first2 != last2 && *first1 == *first2)
|    |  80|+          {
|    |  81|+              ++first1;
|    |  82|+              ++first2;
|    |  83|+          }
|  82|  84|         return (first2 == last2) || (first1 != last1 && *first1 > *first2);
|  83|  85|     }
|  84|  86| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/powx-n.cpp
|    |++++| /app/C++/powx-n.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Iterative solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param x the base number
|   9|  10|      * @param n the power number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/powx-n.cpp
|    |++++| /app/C++/powx-n.cpp
|   9|   9|      * @param n the power number
|  10|  10|      * @return the result
|  11|  11|      */
|  12|    |-    double myPow(double x, int n) {
|    |  12|+    double myPow (double x, int n)
|    |  13|+    {
|  13|  14|         double result = 1;
|  14|    |-        long long abs_n = abs(static_cast<long long>(n));
|  15|    |-        while (abs_n > 0) {
|  16|    |-            if (abs_n & 1) {
|  17|    |-                result *= x;
|  18|    |-            }
|  19|    |-            abs_n >>= 1;
|  20|    |-            x *= x;
|  21|    |-        }
|    |  15|+        long long abs_n = abs (static_cast < long long >(n));
|    |  16|+        while (abs_n > 0)
|    |  17|+          {
|    |  18|+              if (abs_n & 1)
|    |  19|+                {
|    |  20|+                    result *= x;
|    |  21|+                }
|    |  22|+              abs_n >>= 1;
|    |  23|+              x *= x;
|    |  24|+          }
|  22|  25|         return n < 0 ? 1 / result : result;
|  23|  26|     }
|  24|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/powx-n.cpp
|    |++++| /app/C++/powx-n.cpp
|  26|  26| // Time:  O(logn) = O(1)
|  27|  27| // Space: O(logn) = O(1)
|  28|  28| // Recursive solution.
|  29|    |-class Solution2 {
|  30|    |-public:
|    |  29|+class Solution2
|    |  30|+{
|    |  31|+  public:
|  31|  32|     /**
|  32|  33|      * @param x the base number
|  33|  34|      * @param n the power number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/powx-n.cpp
|    |++++| /app/C++/powx-n.cpp
|  33|  33|      * @param n the power number
|  34|  34|      * @return the resultult
|  35|  35|      */
|  36|    |-    double myPow(double x, int n) {
|  37|    |-        if (n < 0 && n != -n) {
|  38|    |-            return 1.0 / myPow(x, -n);
|  39|    |-        }
|  40|    |-        if (n == 0) {
|  41|    |-            return 1;
|  42|    |-        }
|  43|    |-        double v = myPow(x, n / 2);
|  44|    |-        if (n % 2 == 0) {
|  45|    |-            return v * v;
|  46|    |-        } else {
|  47|    |-            return v * v * x;
|  48|    |-        }
|    |  36|+    double myPow (double x, int n)
|    |  37|+    {
|    |  38|+        if (n < 0 && n != -n)
|    |  39|+          {
|    |  40|+              return 1.0 / myPow (x, -n);
|    |  41|+          }
|    |  42|+        if (n == 0)
|    |  43|+          {
|    |  44|+              return 1;
|    |  45|+          }
|    |  46|+        double v = myPow (x, n / 2);
|    |  47|+        if (n % 2 == 0)
|    |  48|+          {
|    |  49|+              return v * v;
|    |  50|+          }
|    |  51|+        else
|    |  52|+          {
|    |  53|+              return v * v * x;
|    |  54|+          }
|  49|  55|     }
|  50|  56| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-reverse-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-reverse-polish-notation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param expression: A string array
|   8|   9|      * @return: The Reverse Polish notation of this expression
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-reverse-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-reverse-polish-notation.cpp
|   7|   7|      * @param expression: A string array
|   8|   8|      * @return: The Reverse Polish notation of this expression
|   9|   9|      */
|  10|    |-    vector<string> convertToRPN(vector<string> &expression) {
|  11|    |-        vector<string> output;
|  12|    |-        infixToPostfix(expression, output);
|    |  10|+    vector < string > convertToRPN (vector < string > &expression)
|    |  11|+    {
|    |  12|+        vector < string > output;
|    |  13|+        infixToPostfix (expression, output);
|  13|  14|         return output;
|  14|  15|     }
|  15|  16| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-reverse-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-reverse-polish-notation.cpp
|  14|  14|     }
|  15|  15| 
|  16|  16|     // Convert Infix to Postfix Expression.
|  17|    |-    void infixToPostfix(const vector<string>& infix, vector<string>& postfix) {
|  18|    |-        stack<string> s;
|  19|    |-        for (auto tok : infix) {
|  20|    |-            if (atoi(tok.c_str())) {
|  21|    |-                postfix.emplace_back(tok);
|  22|    |-            } else if (tok == "(") {
|  23|    |-                s.emplace(tok);
|  24|    |-            } else if (tok == ")") {
|  25|    |-                while (!s.empty()) {
|  26|    |-                    tok = s.top();
|  27|    |-                    s.pop();
|  28|    |-                    if (tok == "(") {
|  29|    |-                        break;
|  30|    |-                    }
|  31|    |-                    postfix.emplace_back(tok);
|    |  17|+    void infixToPostfix (const vector < string > &infix,
|    |  18|+                         vector < string > &postfix)
|    |  19|+    {
|    |  20|+        stack < string > s;
|    |  21|+      for (auto tok:infix)
|    |  22|+          {
|    |  23|+              if (atoi (tok.c_str ()))
|    |  24|+                {
|    |  25|+                    postfix.emplace_back (tok);
|  32|  26|                 }
|  33|    |-            } else {
|  34|    |-                while (!s.empty() && precedence(tok) <= precedence(s.top())) {
|  35|    |-                    postfix.emplace_back(s.top());
|  36|    |-                    s.pop();
|    |  27|+              else if (tok == "(")
|    |  28|+                {
|    |  29|+                    s.emplace (tok);
|  37|  30|                 }
|  38|    |-                s.emplace(tok);
|  39|    |-            }
|  40|    |-        }
|  41|    |-        while (!s.empty()) {
|  42|    |-            postfix.emplace_back(s.top());
|  43|    |-            s.pop();
|  44|    |-        }
|    |  31|+              else if (tok == ")")
|    |  32|+                {
|    |  33|+                    while (!s.empty ())
|    |  34|+                      {
|    |  35|+                          tok = s.top ();
|    |  36|+                          s.pop ();
|    |  37|+                          if (tok == "(")
|    |  38|+                            {
|    |  39|+                                break;
|    |  40|+                            }
|    |  41|+                          postfix.emplace_back (tok);
|    |  42|+                      }
|    |  43|+                }
|    |  44|+              else
|    |  45|+                {
|    |  46|+                    while (!s.empty ()
|    |  47|+                           && precedence (tok) <= precedence (s.top ()))
|    |  48|+                      {
|    |  49|+                          postfix.emplace_back (s.top ());
|    |  50|+                          s.pop ();
|    |  51|+                      }
|    |  52|+                    s.emplace (tok);
|    |  53|+                }
|    |  54|+          }
|    |  55|+        while (!s.empty ())
|    |  56|+          {
|    |  57|+              postfix.emplace_back (s.top ());
|    |  58|+              s.pop ();
|    |  59|+          }
|  45|  60|     }
|  46|  61| 
|  47|  62|     int precedence(string x) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-reverse-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-reverse-polish-notation.cpp
|  44|  44|         }
|  45|  45|     }
|  46|  46| 
|  47|    |-    int precedence(string x) {
|  48|    |-        if (x == "(") {
|  49|    |-            return 0;
|  50|    |-        } else if (x == "+" || x == "-") {
|  51|    |-            return 1;
|  52|    |-        } else if (x == "*" || x == "/") {
|  53|    |-            return 2;
|  54|    |-        }
|    |  47|+    int precedence (string x)
|    |  48|+    {
|    |  49|+        if (x == "(")
|    |  50|+          {
|    |  51|+              return 0;
|    |  52|+          }
|    |  53|+        else if (x == "+" || x == "-")
|    |  54|+          {
|    |  55|+              return 1;
|    |  56|+          }
|    |  57|+        else if (x == "*" || x == "/")
|    |  58|+          {
|    |  59|+              return 2;
|    |  60|+          }
|  55|  61|         return 3;
|  56|  62|     }
|  57|  63| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  14|  14| // return a string "12"
|  15|  15| //
|  16|  16| 
|  17|    |-class Solution {
|  18|    |-public:
|    |  17|+class Solution
|    |  18|+{
|    |  19|+  public:
|  19|  20|     /**
|  20|  21|      *@param A: A positive integer which has N digits, A is a string.
|  21|  22|      *@param k: Remove k digits.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  21|  21|      *@param k: Remove k digits.
|  22|  22|      *@return: A string
|  23|  23|      */
|  24|    |-    string DeleteDigits(string A, int k) {
|    |  24|+    string DeleteDigits (string A, int k)
|    |  25|+    {
|  25|  26|         // If a digit is greater than next one, delete it.
|  26|  27|         string s;
|  27|  28|         for (const auto c : A) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  24|  24|     string DeleteDigits(string A, int k) {
|  25|  25|         // If a digit is greater than next one, delete it.
|  26|  26|         string s;
|  27|    |-        for (const auto c : A) {
|  28|    |-            while (k > 0 && !s.empty() && s.back() > c) {
|  29|    |-                s.pop_back();
|  30|    |-                --k;
|  31|    |-            }
|  32|    |-            s.push_back(c);
|  33|    |-        }
|    |  27|+        for (const auto c:A)
|    |  28|+          {
|    |  29|+              while (k > 0 && !s.empty () && s.back () > c)
|    |  30|+                {
|    |  31|+                    s.pop_back ();
|    |  32|+                    --k;
|    |  33|+                }
|    |  34|+              s.push_back (c);
|    |  35|+          }
|  34|  36| 
|  35|  37|         // If all digits are increasingly sorted, delete last.
|  36|  38|         s.resize(s.length() - k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  33|  33|         }
|  34|  34| 
|  35|  35|         // If all digits are increasingly sorted, delete last.
|  36|    |-        s.resize(s.length() - k);
|    |  36|+        s.resize (s.length () - k);
|  37|  37| 
|  38|  38|         // Strip all leading '0'
|  39|  39|         return s.empty() || s == "0" ? "0" : s.substr(s.find_first_not_of('0'));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  36|  36|         s.resize(s.length() - k);
|  37|  37| 
|  38|  38|         // Strip all leading '0'
|  39|    |-        return s.empty() || s == "0" ? "0" : s.substr(s.find_first_not_of('0'));
|    |  39|+        return s.empty ()
|    |  40|+            || s == "0" ? "0" : s.substr (s.find_first_not_of ('0'));
|  40|  41|     }
|  41|  42| };
|  42|  43| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  43|  43| // Time:  O(k * n)
|  44|  44| // Space: O(1)
|  45|  45| // Greedy method
|  46|    |-class Solution2 {
|  47|    |-public:
|    |  46|+class Solution2
|    |  47|+{
|    |  48|+  public:
|  48|  49|     /**
|  49|  50|      *@param A: A positive integer which has N digits, A is a string.
|  50|  51|      *@param k: Remove k digits.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  50|  50|      *@param k: Remove k digits.
|  51|  51|      *@return: A string
|  52|  52|      */
|  53|    |-    string DeleteDigits(string A, int k) {
|    |  53|+    string DeleteDigits (string A, int k)
|    |  54|+    {
|  54|  55|         // If a digit is greater than next one, delete it.
|  55|    |-        for (int i = 0; i + 1 <= A.size() && k > 0;) {
|  56|    |-            if (A[i] > A[i + 1]) {
|  57|    |-                A.erase(A.begin() + i); // Not efficient, linear time
|  58|    |-                i = max(0, i - 1);
|  59|    |-                --k;
|  60|    |-            } else {
|  61|    |-                ++i;
|  62|    |-            }
|  63|    |-        }
|    |  56|+        for (int i = 0; i + 1 <= A.size () && k > 0;)
|    |  57|+          {
|    |  58|+              if (A[i] > A[i + 1])
|    |  59|+                {
|    |  60|+                    A.erase (A.begin () + i);   // Not efficient, linear time
|    |  61|+                    i = max (0, i - 1);
|    |  62|+                    --k;
|    |  63|+                }
|    |  64|+              else
|    |  65|+                {
|    |  66|+                    ++i;
|    |  67|+                }
|    |  68|+          }
|  64|  69| 
|  65|  70|         // If all digits are increasingly sorted, delete last.
|  66|  71|         A.resize(A.length() - k);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  63|  63|         }
|  64|  64| 
|  65|  65|         // If all digits are increasingly sorted, delete last.
|  66|    |-        A.resize(A.length() - k);
|    |  66|+        A.resize (A.length () - k);
|  67|  67| 
|  68|  68|         // Strip all leading '0'
|  69|  69|         return A.empty() || A == "0" ? "0" : A.substr(A.find_first_not_of('0'));
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  66|  66|         A.resize(A.length() - k);
|  67|  67| 
|  68|  68|         // Strip all leading '0'
|  69|    |-        return A.empty() || A == "0" ? "0" : A.substr(A.find_first_not_of('0'));
|    |  69|+        return A.empty ()
|    |  70|+            || A == "0" ? "0" : A.substr (A.find_first_not_of ('0'));
|  70|  71|     }
|  71|  72| };
|  72|  73| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/delete-digits.cpp
|    |++++| /app/C++/delete-digits.cpp
|  69|  69|         return A.empty() || A == "0" ? "0" : A.substr(A.find_first_not_of('0'));
|  70|  70|     }
|  71|  71| };
|  72|    |-
|  73|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // BST solution.
|   5|    |-class Solution {
|   6|    |-public:
|   7|    |-    enum {start, end, height};
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|    |   8|+    enum
|    |   9|+    { start, end, height };
|   8|  10| 
|   9|    |-    struct Endpoint {
|    |  11|+    struct Endpoint
|    |  12|+    {
|  10|  13|         int height;
|  11|  14|         bool isStart;
|  12|  15|     };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  15|  15|      * @param buildings: A list of lists of integers
|  16|  16|      * @return: Find the outline of those buildings
|  17|  17|      */
|  18|    |-    vector<vector<int>> buildingOutline(vector<vector<int>> &buildings) {
|  19|    |-        map<int, vector<Endpoint>> point_to_height;  // Ordered, no duplicates.
|  20|    |-        for (const auto& building : buildings) {
|  21|    |-            point_to_height[building[start]].push_back({building[height], true});
|  22|    |-            point_to_height[building[end]].push_back({building[height], false});
|  23|    |-        }
|    |  18|+      vector < vector < int >>buildingOutline (vector < vector <
|    |  19|+                                               int >>&buildings)
|    |  20|+    {
|    |  21|+        map < int, vector < Endpoint >> point_to_height;    // Ordered, no duplicates.
|    |  22|+        for (const auto & building:buildings)
|    |  23|+          {
|    |  24|+              point_to_height[building[start]].push_back (
|    |  25|+                                                             {
|    |  26|+                                                             building[height],
|    |  27|+                                                             true});
|    |  28|+              point_to_height[building[end]].push_back (
|    |  29|+                                                           {
|    |  30|+                                                           building[height],
|    |  31|+                                                           false});
|    |  32|+          }
|  24|  33| 
|  25|    |-        vector<vector<int>> res;
|  26|    |-        map<int, int> height_to_count;  // BST.
|    |  34|+        vector < vector < int >>res;
|    |  35|+        map < int, int >height_to_count;    // BST.
|  27|  36|         int curr_start = -1;
|  28|  37|         int curr_max = 0;
|  29|  38|         // Enumerate each point in increasing order.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  27|  27|         int curr_start = -1;
|  28|  28|         int curr_max = 0;
|  29|  29|         // Enumerate each point in increasing order.
|  30|    |-        for (const auto& kvp : point_to_height) {
|  31|    |-            const auto& point = kvp.first;
|  32|    |-            const auto& heights = kvp.second;
|    |  30|+      for (const auto & kvp:point_to_height)
|    |  31|+          {
|    |  32|+              const auto & point = kvp.first;
|    |  33|+              const auto & heights = kvp.second;
|  33|  34| 
|  34|    |-            for (const auto& h : heights) {
|  35|    |-                if (h.isStart) {
|  36|    |-                    ++height_to_count[h.height];
|  37|    |-                } else {
|  38|    |-                    --height_to_count[h.height];
|  39|    |-                    if (height_to_count[h.height] == 0) {
|  40|    |-                        height_to_count.erase(h.height);
|  41|    |-                    }
|    |  35|+            for (const auto & h:heights)
|    |  36|+                {
|    |  37|+                    if (h.isStart)
|    |  38|+                      {
|    |  39|+                          ++height_to_count[h.height];
|    |  40|+                      }
|    |  41|+                    else
|    |  42|+                      {
|    |  43|+                          --height_to_count[h.height];
|    |  44|+                          if (height_to_count[h.height] == 0)
|    |  45|+                            {
|    |  46|+                                height_to_count.erase (h.height);
|    |  47|+                            }
|    |  48|+                      }
|  42|  49|                 }
|  43|    |-            }
|  44|  50| 
|  45|    |-            if (height_to_count.empty() ||
|  46|    |-                curr_max != height_to_count.crbegin()->first) {
|  47|    |-                if (curr_max > 0) {
|  48|    |-                    res.push_back({curr_start, point, curr_max});
|    |  51|+              if (height_to_count.empty () ||
|    |  52|+                  curr_max != height_to_count.crbegin ()->first)
|    |  53|+                {
|    |  54|+                    if (curr_max > 0)
|    |  55|+                      {
|    |  56|+                          res.push_back (
|    |  57|+                                            {
|    |  58|+                                            curr_start, point, curr_max}
|    |  59|+                          );
|    |  60|+                      }
|    |  61|+                    curr_start = point;
|    |  62|+                    curr_max = height_to_count.empty ()?
|    |  63|+                        0 : height_to_count.crbegin ()->first;
|  49|  64|                 }
|  50|    |-                curr_start = point;
|  51|    |-                curr_max = height_to_count.empty() ?
|  52|    |-                           0 : height_to_count.crbegin()->first;
|  53|    |-            }
|  54|    |-        }
|    |  65|+          }
|  55|  66|         return res;
|  56|  67|     }
|  57|  68| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  59|  59| // Time:  O(nlogn)
|  60|  60| // Space: O(n)
|  61|  61| // Divide and conquer solution.
|  62|    |-class Solution2 {
|  63|    |-public:
|  64|    |-    enum {start, end, height};
|    |  62|+class Solution2
|    |  63|+{
|    |  64|+  public:
|    |  65|+    enum
|    |  66|+    { start, end, height };
|  65|  67|     /**
|  66|  68|      * @param buildings: A list of lists of integers
|  67|  69|      * @return: Find the outline of those buildings
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  66|  66|      * @param buildings: A list of lists of integers
|  67|  67|      * @return: Find the outline of those buildings
|  68|  68|      */
|  69|    |-    vector<vector<int>> buildingOutline(vector<vector<int>> &buildings) {
|  70|    |-        return ComputeSkylineInInterval(buildings, 0, buildings.size());
|    |  69|+      vector < vector < int >>buildingOutline (vector < vector <
|    |  70|+                                               int >>&buildings)
|    |  71|+    {
|    |  72|+        return ComputeSkylineInInterval (buildings, 0, buildings.size ());
|  71|  73|     }
|  72|  74| 
|  73|  75|     // Divide and Conquer.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  71|  71|     }
|  72|  72| 
|  73|  73|     // Divide and Conquer.
|  74|    |-    vector<vector<int>> ComputeSkylineInInterval(const vector<vector<int>>& buildings,
|  75|    |-                                                 int left_endpoint, int right_endpoint) {
|  76|    |-        if (right_endpoint - left_endpoint <= 1) {  // 0 or 1 skyline, just copy it.
|  77|    |-            return {buildings.cbegin() + left_endpoint,
|  78|    |-                    buildings.cbegin() + right_endpoint};
|  79|    |-        }
|    |  74|+    vector < vector < int >>ComputeSkylineInInterval (const vector < vector <
|    |  75|+                                                      int >>&buildings,
|    |  76|+                                                      int left_endpoint,
|    |  77|+                                                      int right_endpoint)
|    |  78|+    {
|    |  79|+        if (right_endpoint - left_endpoint <= 1)
|    |  80|+          {                     // 0 or 1 skyline, just copy it.
|    |  81|+              return
|    |  82|+              {
|    |  83|+              buildings.cbegin () + left_endpoint,
|    |  84|+                      buildings.cbegin () + right_endpoint};
|    |  85|+          }
|  80|  86|         int mid = left_endpoint + ((right_endpoint - left_endpoint) / 2);
|  81|    |-        auto left_skyline = ComputeSkylineInInterval(buildings, left_endpoint, mid);
|  82|    |-        auto right_skyline = ComputeSkylineInInterval(buildings, mid, right_endpoint);
|  83|    |-        return MergeSkylines(&left_skyline, &right_skyline);
|    |  87|+        auto left_skyline =
|    |  88|+            ComputeSkylineInInterval (buildings, left_endpoint, mid);
|    |  89|+        auto right_skyline =
|    |  90|+            ComputeSkylineInInterval (buildings, mid, right_endpoint);
|    |  91|+        return MergeSkylines (&left_skyline, &right_skyline);
|  84|  92|     }
|  85|  93| 
|  86|  94|     // Merge Sort
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
|  84|  84|     }
|  85|  85| 
|  86|  86|     // Merge Sort
|  87|    |-    vector<vector<int>> MergeSkylines(vector<vector<int>> *left_skyline, vector<vector<int>> *right_skyline) {
|    |  87|+    vector < vector < int >>MergeSkylines (vector < vector <
|    |  88|+                                           int >>*left_skyline,
|    |  89|+                                           vector < vector <
|    |  90|+                                           int >>*right_skyline)
|    |  91|+    {
|  88|  92|         int i = 0, j = 0;
|  89|    |-        vector<vector<int>> merged;
|    |  93|+        vector < vector < int >>merged;
|  90|  94| 
|  91|    |-        while (i < left_skyline->size() && j < right_skyline->size()) {
|  92|    |-            if ((*left_skyline)[i][end] < (*right_skyline)[j][start]) {
|  93|    |-                merged.emplace_back(move((*left_skyline)[i++]));
|  94|    |-            } else if ((*right_skyline)[j][end] < (*left_skyline)[i][start]) {
|  95|    |-                merged.emplace_back(move((*right_skyline)[j++]));
|  96|    |-            } else if ((*left_skyline)[i][start] <= (*right_skyline)[j][start]) {
|  97|    |-                MergeIntersectSkylines(&merged,
|  98|    |-                                        &(*left_skyline)[i], &i,
|  99|    |-                                        &(*right_skyline)[j], &j);
| 100|    |-            } else {  // (*left_skyline)[i][start] > (*right_skyline)[j][start].
| 101|    |-                MergeIntersectSkylines(&merged,
| 102|    |-                                        &(*right_skyline)[j], &j,
| 103|    |-                                        &(*left_skyline)[i], &i);
| 104|    |-            }
| 105|    |-        }
|    |  95|+        while (i < left_skyline->size () && j < right_skyline->size ())
|    |  96|+          {
|    |  97|+              if ((*left_skyline)[i][end] < (*right_skyline)[j][start])
|    |  98|+                {
|    |  99|+                    merged.emplace_back (move ((*left_skyline)[i++]));
|    | 100|+                }
|    | 101|+              else if ((*right_skyline)[j][end] < (*left_skyline)[i][start])
|    | 102|+                {
|    | 103|+                    merged.emplace_back (move ((*right_skyline)[j++]));
|    | 104|+                }
|    | 105|+              else if ((*left_skyline)[i][start] <= (*right_skyline)[j][start])
|    | 106|+                {
|    | 107|+                    MergeIntersectSkylines (&merged,
|    | 108|+                                            &(*left_skyline)[i], &i,
|    | 109|+                                            &(*right_skyline)[j], &j);
|    | 110|+                }
|    | 111|+              else
|    | 112|+                {               // (*left_skyline)[i][start] > (*right_skyline)[j][start].
|    | 113|+                    MergeIntersectSkylines (&merged,
|    | 114|+                                            &(*right_skyline)[j], &j,
|    | 115|+                                            &(*left_skyline)[i], &i);
|    | 116|+                }
|    | 117|+          }
| 106| 118| 
| 107| 119|         // Insert the remaining skylines.
| 108| 120|         merged.insert(merged.end(),
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
| 105| 105|         }
| 106| 106| 
| 107| 107|         // Insert the remaining skylines.
| 108|    |-        merged.insert(merged.end(),
| 109|    |-                        left_skyline->begin() + i, left_skyline->end());
| 110|    |-        merged.insert(merged.end(),
| 111|    |-                        right_skyline->begin() + j, right_skyline->end());
|    | 108|+        merged.insert (merged.end (),
|    | 109|+                       left_skyline->begin () + i, left_skyline->end ());
|    | 110|+        merged.insert (merged.end (),
|    | 111|+                       right_skyline->begin () + j, right_skyline->end ());
| 112| 112|         return merged;
| 113| 113|     }
| 114| 114| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/building-outline.cpp
|    |++++| /app/C++/building-outline.cpp
| 113| 113|     }
| 114| 114| 
| 115| 115|     // (*a)[start] <= (*b)[start]
| 116|    |-    void MergeIntersectSkylines(vector<vector<int>> *merged,
| 117|    |-                                vector<int> *a, int *a_idx,
| 118|    |-                                vector<int> *b, int *b_idx) {
| 119|    |-        if ((*a)[end] <= (*b)[end]) {
| 120|    |-            if ((*a)[height] > (*b)[height]) {  // |aaa|
| 121|    |-                if ((*b)[end] != (*a)[end]) {   // |abb|b
| 122|    |-                    (*b)[start] = (*a)[end];
| 123|    |-                    merged->emplace_back(move(*a)), ++(*a_idx);
| 124|    |-                } else {         // aaa
| 125|    |-                    ++(*b_idx);  // abb
|    | 116|+    void MergeIntersectSkylines (vector < vector < int >>*merged,
|    | 117|+                                 vector < int >*a, int *a_idx,
|    | 118|+                                 vector < int >*b, int *b_idx)
|    | 119|+    {
|    | 120|+        if ((*a)[end] <= (*b)[end])
|    | 121|+          {
|    | 122|+              if ((*a)[height] > (*b)[height])
|    | 123|+                {               // |aaa|
|    | 124|+                    if ((*b)[end] != (*a)[end])
|    | 125|+                      {         // |abb|b
|    | 126|+                          (*b)[start] = (*a)[end];
|    | 127|+                          merged->emplace_back (move (*a)), ++(*a_idx);
|    | 128|+                      }
|    | 129|+                    else
|    | 130|+                      {         // aaa
|    | 131|+                          ++(*b_idx);   // abb
|    | 132|+                      }
| 126| 133|                 }
| 127|    |-            } else if ((*a)[height] == (*b)[height]) {  // abb
| 128|    |-                (*b)[start] = (*a)[start], ++(*a_idx);  // abb
| 129|    |-            } else {  // (*a)[height] < (*b)[height].
| 130|    |-                if ((*a)[start] != (*b)[start]) {                                 //    bb
| 131|    |-                    merged->push_back({(*a)[start], (*b)[start], (*a)[height]});  // |a|bb
|    | 134|+              else if ((*a)[height] == (*b)[height])
|    | 135|+                {               // abb
|    | 136|+                    (*b)[start] = (*a)[start], ++(*a_idx);  // abb
| 132| 137|                 }
| 133|    |-                ++(*a_idx);
| 134|    |-            }
| 135|    |-        } else {  // (*a)[end] > (*b)[end].
| 136|    |-            if ((*a)[height] >= (*b)[height]) {  // aaaa
| 137|    |-                ++(*b_idx);                      // abba
| 138|    |-            } else {
| 139|    |-                //    |bb|
| 140|    |-                // |a||bb|a
| 141|    |-                if ((*a)[start] != (*b)[start]) {
| 142|    |-                    merged->push_back({(*a)[start], (*b)[start], (*a)[height]});
|    | 138|+              else
|    | 139|+                {               // (*a)[height] < (*b)[height].
|    | 140|+                    if ((*a)[start] != (*b)[start])
|    | 141|+                      {         //    bb
|    | 142|+                          merged->push_back (
|    | 143|+                                                {
|    | 144|+                                                (*a)[start], (*b)[start],
|    | 145|+                                                (*a)[height]}
|    | 146|+                          );    // |a|bb
|    | 147|+                      }
|    | 148|+                    ++(*a_idx);
| 143| 149|                 }
| 144|    |-                (*a)[start] = (*b)[end];
| 145|    |-                merged->emplace_back(move(*b)), ++(*b_idx);
| 146|    |-            }
| 147|    |-        }
|    | 150|+          }
|    | 151|+        else
|    | 152|+          {                     // (*a)[end] > (*b)[end].
|    | 153|+              if ((*a)[height] >= (*b)[height])
|    | 154|+                {               // aaaa
|    | 155|+                    ++(*b_idx); // abba
|    | 156|+                }
|    | 157|+              else
|    | 158|+                {
|    | 159|+                    //    |bb|
|    | 160|+                    // |a||bb|a
|    | 161|+                    if ((*a)[start] != (*b)[start])
|    | 162|+                      {
|    | 163|+                          merged->push_back (
|    | 164|+                                                {
|    | 165|+                                                (*a)[start], (*b)[start],
|    | 166|+                                                (*a)[height]}
|    | 167|+                          );
|    | 168|+                      }
|    | 169|+                    (*a)[start] = (*b)[end];
|    | 170|+                    merged->emplace_back (move (*b)), ++(*b_idx);
|    | 171|+                }
|    | 172|+          }
| 148| 173|     }
| 149| 174| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray.cpp
|    |++++| /app/C++/maximum-subarray.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: A integer indicate the sum of max subarray
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray.cpp
|    |++++| /app/C++/maximum-subarray.cpp
|   7|   7|      * @param nums: A list of integers
|   8|   8|      * @return: A integer indicate the sum of max subarray
|   9|   9|      */
|  10|    |-    int maxSubArray(vector<int> nums) {
|    |  10|+    int maxSubArray (vector < int >nums)
|    |  11|+    {
|  11|  12|         int max_sum = INT_MIN, sum = 0;
|  12|    |-        for (const auto& i : nums) {
|  13|    |-            sum += i;
|  14|    |-            max_sum = max(max_sum, sum);
|  15|    |-            sum = max(sum, 0);
|  16|    |-        }
|    |  13|+        for (const auto & i:nums)
|    |  14|+          {
|    |  15|+              sum += i;
|    |  16|+              max_sum = max (max_sum, sum);
|    |  17|+              sum = max (sum, 0);
|    |  18|+          }
|  17|  19|         return max_sum;
|  18|  20|     }
|  19|  21| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray.cpp
|    |++++| /app/C++/maximum-subarray.cpp
|  17|  17|         return max_sum;
|  18|  18|     }
|  19|  19| };
|  20|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num: a rotated sorted array
|   8|   9|      * @return: the minimum number in the array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|   7|   7|      * @param num: a rotated sorted array
|   8|   8|      * @return: the minimum number in the array
|   9|   9|      */
|  10|    |-    int findMin(vector<int> &num) {
|  11|    |-        int left = 0, right = num.size() - 1;
|  12|    |-        const auto target = num.back();
|    |  10|+    int findMin (vector < int >&num)
|    |  11|+    {
|    |  12|+        int left = 0, right = num.size () - 1;
|    |  13|+        const auto target = num.back ();
|  13|  14| 
|  14|    |-        while (left <= right) {
|  15|    |-            const auto  mid = left + (right - left) / 2;
|  16|    |-            if (num[mid] <= target) {
|  17|    |-                right = mid - 1;
|  18|    |-            } else {
|  19|    |-                left = mid + 1;
|  20|    |-            }
|  21|    |-        }
|    |  15|+        while (left <= right)
|    |  16|+          {
|    |  17|+              const auto mid = left + (right - left) / 2;
|    |  18|+              if (num[mid] <= target)
|    |  19|+                {
|    |  20|+                    right = mid - 1;
|    |  21|+                }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    left = mid + 1;
|    |  25|+                }
|    |  26|+          }
|  22|  27| 
|  23|  28|         return num[left];
|  24|  29|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|  24|  24|     }
|  25|  25| };
|  26|  26| 
|  27|    |-class Solution2 {
|  28|    |-public:
|    |  27|+class Solution2
|    |  28|+{
|    |  29|+  public:
|  29|  30|     /**
|  30|  31|      * @param num: a rotated sorted array
|  31|  32|      * @return: the minimum number in the array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|  30|  30|      * @param num: a rotated sorted array
|  31|  31|      * @return: the minimum number in the array
|  32|  32|      */
|  33|    |-    int findMin(vector<int> &num) {
|  34|    |-        int left = 0, right = num.size() - 1;
|    |  33|+    int findMin (vector < int >&num)
|    |  34|+    {
|    |  35|+        int left = 0, right = num.size () - 1;
|  35|  36| 
|  36|  37|         // Find min left s.t. num[left] < num[left'].
|  37|  38|         while (left < right && num[left] >= num[right]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|  34|  34|         int left = 0, right = num.size() - 1;
|  35|  35| 
|  36|  36|         // Find min left s.t. num[left] < num[left'].
|  37|    |-        while (left < right && num[left] >= num[right]) {
|  38|    |-            const auto mid = left + (right - left) / 2;
|  39|    |-            if (num[mid] < num[left]) {
|  40|    |-                right = mid;
|  41|    |-            } else {
|  42|    |-                left = mid + 1;
|  43|    |-            }
|  44|    |-        }
|    |  37|+        while (left < right && num[left] >= num[right])
|    |  38|+          {
|    |  39|+              const auto mid = left + (right - left) / 2;
|    |  40|+              if (num[mid] < num[left])
|    |  41|+                {
|    |  42|+                    right = mid;
|    |  43|+                }
|    |  44|+              else
|    |  45|+                {
|    |  46|+                    left = mid + 1;
|    |  47|+                }
|    |  48|+          }
|  45|  49| 
|  46|  50|         return num[left];
|  47|  51|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array.cpp
|  46|  46|         return num[left];
|  47|  47|     }
|  48|  48| };
|  49|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/print-numbers-by-recursion.cpp
|    |++++| /app/C++/print-numbers-by-recursion.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: An integer.
|   8|   9|      * return : An array storing 1 to the largest number with n digits.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/print-numbers-by-recursion.cpp
|    |++++| /app/C++/print-numbers-by-recursion.cpp
|   7|   7|      * @param n: An integer.
|   8|   8|      * return : An array storing 1 to the largest number with n digits.
|   9|   9|      */
|  10|    |-    vector<int> numbersByRecursion(int n) {
|  11|    |-        vector<int> result;
|  12|    |-        numbersByRecursionHelper(0, n, result);
|  13|    |-        return result;
|    |  10|+    vector < int >numbersByRecursion (int n)
|    |  11|+    {
|    |  12|+        vector < int >result;
|    |  13|+          numbersByRecursionHelper (0, n, result);
|    |  14|+          return result;
|  14|  15|     }
|  15|  16| 
|  16|  17|     // Construct the numbers by the current digit count.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/print-numbers-by-recursion.cpp
|    |++++| /app/C++/print-numbers-by-recursion.cpp
|  14|  14|     }
|  15|  15| 
|  16|  16|     // Construct the numbers by the current digit count.
|  17|    |-    void numbersByRecursionHelper(int depth, int n, vector<int>& result) {
|  18|    |-        if (depth == n) {
|  19|    |-            return;
|  20|    |-        }
|    |  17|+    void numbersByRecursionHelper (int depth, int n, vector < int >&result)
|    |  18|+    {
|    |  19|+        if (depth == n)
|    |  20|+          {
|    |  21|+              return;
|    |  22|+          }
|  21|  23| 
|  22|    |-        if (depth == 0) {  // Initiate the result.
|  23|    |-            for (size_t d = 1; d <= 9; ++d) {
|  24|    |-                result.emplace_back(d);
|  25|    |-            }
|  26|    |-        } else {  // Construct the numbers by the previous result.
|  27|    |-            const size_t count = result.size();
|  28|    |-            for (size_t d = 1; d <= 9; ++d) {
|  29|    |-                result.emplace_back(d * pow(10, depth));
|  30|    |-                for (size_t i = 0; i < count; ++i) {
|  31|    |-                    result.emplace_back(result[i] + d * pow(10, depth));
|    |  24|+        if (depth == 0)
|    |  25|+          {                     // Initiate the result.
|    |  26|+              for (size_t d = 1; d <= 9; ++d)
|    |  27|+                {
|    |  28|+                    result.emplace_back (d);
|  32|  29|                 }
|  33|    |-            }
|  34|    |-        }
|    |  30|+          }
|    |  31|+        else
|    |  32|+          {                     // Construct the numbers by the previous result.
|    |  33|+              const size_t count = result.size ();
|    |  34|+              for (size_t d = 1; d <= 9; ++d)
|    |  35|+                {
|    |  36|+                    result.emplace_back (d * pow (10, depth));
|    |  37|+                    for (size_t i = 0; i < count; ++i)
|    |  38|+                      {
|    |  39|+                          result.emplace_back (result[i] +
|    |  40|+                                               d * pow (10, depth));
|    |  41|+                      }
|    |  42|+                }
|    |  43|+          }
|  35|  44|         // Construct the numbers in the next depth.
|  36|    |-        numbersByRecursionHelper(depth + 1, n, result);
|    |  45|+        numbersByRecursionHelper (depth + 1, n, result);
|  37|  46|     }
|  38|  47| 
|  39|  48| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  16|  16|  *     }
|  17|  17|  * }
|  18|  18|  */
|  19|    |-class MiniTwitter {
|  20|    |-public:
|  21|    |-    MiniTwitter() : time_(0) {
|    |  19|+class MiniTwitter
|    |  20|+{
|    |  21|+  public:
|    |  22|+    MiniTwitter ():time_ (0)
|    |  23|+    {
|  22|  24|     }
|  23|  25| 
|  24|  26|     // @param user_id an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  24|  24|     // @param user_id an integer
|  25|  25|     // @param tweet a string
|  26|  26|     // return a tweet
|  27|    |-    Tweet postTweet(int user_id, string tweet_text) {
|  28|    |-        const auto& tweet = Tweet::create(user_id, tweet_text);
|  29|    |-        messages_[user_id].emplace_back(make_pair(++time_, tweet));
|    |  27|+    Tweet postTweet (int user_id, string tweet_text)
|    |  28|+    {
|    |  29|+        const auto & tweet = Tweet::create (user_id, tweet_text);
|    |  30|+        messages_[user_id].emplace_back (make_pair (++time_, tweet));
|  30|  31|         return tweet;
|  31|  32|     }
|  32|  33| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  33|  33|     // @param user_id an integer
|  34|  34|     // return a list of 10 new feeds recently
|  35|  35|     // and sort by timeline
|  36|    |-    vector<Tweet> getNewsFeed(int user_id) {
|  37|    |-        using RIT = deque<pair<size_t, Tweet>>::reverse_iterator;
|  38|    |-        priority_queue<tuple<size_t, RIT, RIT>> heap;
|    |  36|+    vector < Tweet > getNewsFeed (int user_id)
|    |  37|+    {
|    |  38|+        using RIT = deque < pair < size_t, Tweet >>::reverse_iterator;
|    |  39|+        priority_queue < tuple < size_t, RIT, RIT >> heap;
|  39|  40| 
|  40|    |-        if (messages_[user_id].size()) {
|  41|    |-            heap.emplace(make_tuple(messages_[user_id].rbegin()->first,
|  42|    |-                                    messages_[user_id].rbegin(),
|  43|    |-                                    messages_[user_id].rend()));
|  44|    |-        }
|  45|    |-        for (const auto& id : followings_[user_id]) {
|  46|    |-            if (messages_[id].size()) {
|  47|    |-                heap.emplace(make_tuple(messages_[id].rbegin()->first,
|  48|    |-                                        messages_[id].rbegin(),
|  49|    |-                                        messages_[id].rend()));
|  50|    |-            }
|  51|    |-        }
|  52|    |-        vector<Tweet> res;
|  53|    |-        while (!heap.empty() && res.size() < number_of_most_recent_tweets_) {
|  54|    |-            const auto& top = heap.top();
|  55|    |-            size_t t;
|  56|    |-            RIT begin, end;
|  57|    |-            tie(t, begin, end) = top;
|  58|    |-            heap.pop();
|    |  41|+        if (messages_[user_id].size ())
|    |  42|+          {
|    |  43|+              heap.emplace (make_tuple (messages_[user_id].rbegin ()->first,
|    |  44|+                                        messages_[user_id].rbegin (),
|    |  45|+                                        messages_[user_id].rend ()));
|    |  46|+          }
|    |  47|+      for (const auto & id:followings_[user_id])
|    |  48|+          {
|    |  49|+              if (messages_[id].size ())
|    |  50|+                {
|    |  51|+                    heap.emplace (make_tuple (messages_[id].rbegin ()->first,
|    |  52|+                                              messages_[id].rbegin (),
|    |  53|+                                              messages_[id].rend ()));
|    |  54|+                }
|    |  55|+          }
|    |  56|+        vector < Tweet > res;
|    |  57|+        while (!heap.empty () && res.size () < number_of_most_recent_tweets_)
|    |  58|+          {
|    |  59|+              const auto & top = heap.top ();
|    |  60|+              size_t t;
|    |  61|+              RIT begin, end;
|    |  62|+              tie (t, begin, end) = top;
|    |  63|+              heap.pop ();
|  59|  64| 
|  60|    |-            auto next = begin + 1;
|  61|    |-            if (next != end) {
|  62|    |-                heap.emplace(make_tuple(next->first, next, end));
|  63|    |-            }
|    |  65|+              auto next = begin + 1;
|    |  66|+              if (next != end)
|    |  67|+                {
|    |  68|+                    heap.emplace (make_tuple (next->first, next, end));
|    |  69|+                }
|  64|  70| 
|  65|    |-            res.emplace_back(begin->second);
|  66|    |-        }
|    |  71|+              res.emplace_back (begin->second);
|    |  72|+          }
|  67|  73|         return res;
|  68|  74|     }
|  69|  75| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  70|  70|     // @param user_id an integer
|  71|  71|     // return a list of 10 new posts recently
|  72|  72|     // and sort by timeline
|  73|    |-    vector<Tweet>  getTimeline(int user_id) {
|  74|    |-        vector<Tweet> res;
|  75|    |-        for (auto it = messages_[user_id].rbegin();
|  76|    |-             it != messages_[user_id].rend() &&
|  77|    |-             res.size() < number_of_most_recent_tweets_; ++it) {
|  78|    |-            res.emplace_back(it->second);
|  79|    |-        }
|    |  73|+    vector < Tweet > getTimeline (int user_id)
|    |  74|+    {
|    |  75|+        vector < Tweet > res;
|    |  76|+        for (auto it = messages_[user_id].rbegin ();
|    |  77|+             it != messages_[user_id].rend () &&
|    |  78|+             res.size () < number_of_most_recent_tweets_; ++it)
|    |  79|+          {
|    |  80|+              res.emplace_back (it->second);
|    |  81|+          }
|  80|  82|         return res;
|  81|  83|     }
|  82|  84| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  83|  83|     // @param from_user_id an integer
|  84|  84|     // @param to_user_id an integer
|  85|  85|     // from user_id follows to_user_id
|  86|    |-    void follow(int from_user_id, int to_user_id) {
|    |  86|+    void follow (int from_user_id, int to_user_id)
|    |  87|+    {
|  87|  88|         if (from_user_id != to_user_id &&
|  88|    |-            !followings_[from_user_id].count(to_user_id)) {
|  89|    |-            followings_[from_user_id].emplace(to_user_id);
|  90|    |-        }
|    |  89|+            !followings_[from_user_id].count (to_user_id))
|    |  90|+          {
|    |  91|+              followings_[from_user_id].emplace (to_user_id);
|    |  92|+          }
|  91|  93|     }
|  92|  94| 
|  93|  95|     // @param from_user_id an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  93|  93|     // @param from_user_id an integer
|  94|  94|     // @param to_user_id an integer
|  95|  95|     // from user_id unfollows to_user_id
|  96|    |-    void unfollow(int from_user_id, int to_user_id) {
|  97|    |-        if (followings_[from_user_id].count(to_user_id)) {
|  98|    |-            followings_[from_user_id].erase(to_user_id);
|  99|    |-        }
|    |  96|+    void unfollow (int from_user_id, int to_user_id)
|    |  97|+    {
|    |  98|+        if (followings_[from_user_id].count (to_user_id))
|    |  99|+          {
|    | 100|+              followings_[from_user_id].erase (to_user_id);
|    | 101|+          }
| 100| 102|     }
| 101| 103| 
| 102| 104| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/mini-twitter.cpp
|    |++++| /app/C++/mini-twitter.cpp
|  99|  99|         }
| 100| 100|     }
| 101| 101| 
| 102|    |-private:
|    | 102|+  private:
| 103| 103|     const size_t number_of_most_recent_tweets_ = 10;
| 104|    |-    unordered_map<int, unordered_set<int>> followings_;
| 105|    |-    unordered_map<int, deque<pair<size_t, Tweet>>> messages_;
|    | 104|+    unordered_map < int, unordered_set < int >>followings_;
|    | 105|+    unordered_map < int, deque < pair < size_t, Tweet >>> messages_;
| 106| 106|     size_t time_;
| 107| 107| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations-ii.cpp
|    |++++| /app/C++/permutations-ii.cpp
|   1|   1| // Time:  O(n * n!)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers.
|   8|   9|      * @return: A list of unique permutations.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations-ii.cpp
|    |++++| /app/C++/permutations-ii.cpp
|   7|   7|      * @param nums: A list of integers.
|   8|   8|      * @return: A list of unique permutations.
|   9|   9|      */
|  10|    |-    vector<vector<int>> permuteUnique(vector<int> &nums) {
|  11|    |-        vector<vector<int>> result;
|  12|    |-        vector<bool> used(nums.size(), false);
|  13|    |-        vector<int> ans;
|    |  10|+    vector < vector < int >>permuteUnique (vector < int >&nums)
|    |  11|+    {
|    |  12|+        vector < vector < int >>result;
|    |  13|+          vector < bool > used (nums.size (), false);
|    |  14|+          vector < int >ans;
|  14|  15| 
|  15|    |-        sort(nums.begin(), nums.end());
|  16|    |-        permuteUniqueHelper(nums, &used, &ans, &result);
|  17|    |-        return result;
|    |  16|+          sort (nums.begin (), nums.end ());
|    |  17|+          permuteUniqueHelper (nums, &used, &ans, &result);
|    |  18|+          return result;
|  18|  19|     }
|  19|  20| 
|  20|  21|     void permuteUniqueHelper(const vector<int> &A, vector<bool> *used,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutations-ii.cpp
|    |++++| /app/C++/permutations-ii.cpp
|  17|  17|         return result;
|  18|  18|     }
|  19|  19| 
|  20|    |-    void permuteUniqueHelper(const vector<int> &A, vector<bool> *used,
|  21|    |-                           vector<int> *ans, vector<vector<int>> *result) {
|  22|    |-        if (ans->size() == A.size()) {
|  23|    |-            result->emplace_back(*ans);
|  24|    |-            return;
|  25|    |-        }
|    |  20|+    void permuteUniqueHelper (const vector < int >&A, vector < bool > *used,
|    |  21|+                              vector < int >*ans,
|    |  22|+                              vector < vector < int >>*result)
|    |  23|+    {
|    |  24|+        if (ans->size () == A.size ())
|    |  25|+          {
|    |  26|+              result->emplace_back (*ans);
|    |  27|+              return;
|    |  28|+          }
|  26|  29| 
|  27|    |-        for (size_t i = 0; i < A.size(); ++i) {
|  28|    |-            if ((*used)[i] || (i != 0 && A[i - 1] == A[i] && !(*used)[i - 1])) {
|  29|    |-                continue;
|  30|    |-            }
|  31|    |-            (*used)[i] = true;
|  32|    |-            ans->emplace_back(A[i]);
|  33|    |-            permuteUniqueHelper(A, used, ans, result);
|  34|    |-            ans->pop_back();
|  35|    |-            (*used)[i] = false;
|  36|    |-        }
|    |  30|+        for (size_t i = 0; i < A.size (); ++i)
|    |  31|+          {
|    |  32|+              if ((*used)[i]
|    |  33|+                  || (i != 0 && A[i - 1] == A[i] && !(*used)[i - 1]))
|    |  34|+                {
|    |  35|+                    continue;
|    |  36|+                }
|    |  37|+              (*used)[i] = true;
|    |  38|+              ans->emplace_back (A[i]);
|    |  39|+              permuteUniqueHelper (A, used, ans, result);
|    |  40|+              ans->pop_back ();
|    |  41|+              (*used)[i] = false;
|    |  42|+          }
|  37|  43|     }
|  38|  44| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: An integer indicate the value of maximum difference between two
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|   8|   8|      * @return: An integer indicate the value of maximum difference between two
|   9|   9|      *          Subarrays
|  10|  10|      */
|  11|    |-    int maxDiffSubArrays(vector<int> nums) {
|  12|    |-        int n = nums.size();
|  13|    |-        vector<int> max_LR(n), min_LR(n);
|  14|    |-        vector<int> max_RL(n), min_RL(n);
|    |  11|+    int maxDiffSubArrays (vector < int >nums)
|    |  12|+    {
|    |  13|+        int n = nums.size ();
|    |  14|+          vector < int >max_LR (n), min_LR (n);
|    |  15|+          vector < int >max_RL (n), min_RL (n);
|  15|  16| 
|  16|  17|         // Compute the max sum of subarray from left to right.
|  17|  18|         int max_LR_sum = INT_MIN, LR_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  15|  15| 
|  16|  16|         // Compute the max sum of subarray from left to right.
|  17|  17|         int max_LR_sum = INT_MIN, LR_sum = 0;
|  18|    |-        for (int i = 0; i < n; ++i) {
|  19|    |-            LR_sum += nums[i];
|  20|    |-            max_LR_sum = max(max_LR_sum, LR_sum);
|  21|    |-            max_LR[i] = max_LR_sum;
|  22|    |-            if (LR_sum < 0) {
|  23|    |-                LR_sum = 0;
|  24|    |-            }
|  25|    |-        }
|    |  18|+        for (int i = 0; i < n; ++i)
|    |  19|+          {
|    |  20|+              LR_sum += nums[i];
|    |  21|+              max_LR_sum = max (max_LR_sum, LR_sum);
|    |  22|+              max_LR[i] = max_LR_sum;
|    |  23|+              if (LR_sum < 0)
|    |  24|+                {
|    |  25|+                    LR_sum = 0;
|    |  26|+                }
|    |  27|+          }
|  26|  28| 
|  27|  29|         // Compute the min sum of subarray from left to right.
|  28|  30|         int min_LR_sum = INT_MAX;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  27|  27|         // Compute the min sum of subarray from left to right.
|  28|  28|         int min_LR_sum = INT_MAX;
|  29|  29|         LR_sum = 0;
|  30|    |-        for (int i = 0; i < n; ++i) {
|  31|    |-            LR_sum += nums[i];
|  32|    |-            min_LR_sum = min(min_LR_sum, LR_sum);
|  33|    |-            min_LR[i] = min_LR_sum;
|  34|    |-            if (LR_sum > 0) {
|  35|    |-                LR_sum = 0;
|  36|    |-            }
|  37|    |-        }
|    |  30|+        for (int i = 0; i < n; ++i)
|    |  31|+          {
|    |  32|+              LR_sum += nums[i];
|    |  33|+              min_LR_sum = min (min_LR_sum, LR_sum);
|    |  34|+              min_LR[i] = min_LR_sum;
|    |  35|+              if (LR_sum > 0)
|    |  36|+                {
|    |  37|+                    LR_sum = 0;
|    |  38|+                }
|    |  39|+          }
|  38|  40| 
|  39|  41|         // Compute the max sum of subarray from right to left.
|  40|  42|         int max_RL_sum = INT_MIN, RL_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  38|  38| 
|  39|  39|         // Compute the max sum of subarray from right to left.
|  40|  40|         int max_RL_sum = INT_MIN, RL_sum = 0;
|  41|    |-        for (int i = n - 1; i >= 0; --i) {
|  42|    |-            RL_sum += nums[i];
|  43|    |-            max_RL_sum = max(max_RL_sum, RL_sum);
|  44|    |-            max_RL[i] = max_RL_sum;
|  45|    |-            if (RL_sum < 0) {
|  46|    |-                RL_sum = 0;
|  47|    |-            }
|  48|    |-        }
|    |  41|+        for (int i = n - 1; i >= 0; --i)
|    |  42|+          {
|    |  43|+              RL_sum += nums[i];
|    |  44|+              max_RL_sum = max (max_RL_sum, RL_sum);
|    |  45|+              max_RL[i] = max_RL_sum;
|    |  46|+              if (RL_sum < 0)
|    |  47|+                {
|    |  48|+                    RL_sum = 0;
|    |  49|+                }
|    |  50|+          }
|  49|  51| 
|  50|  52|         // Compute the min sum of subarray from right to left.
|  51|  53|         int min_RL_sum = INT_MAX;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  50|  50|         // Compute the min sum of subarray from right to left.
|  51|  51|         int min_RL_sum = INT_MAX;
|  52|  52|         RL_sum = 0;
|  53|    |-        for (int i = n - 1; i >= 0; --i) {
|  54|    |-            RL_sum += nums[i];
|  55|    |-            min_RL_sum = min(min_RL_sum, RL_sum);
|  56|    |-            min_RL[i] = min_RL_sum;
|  57|    |-            if (RL_sum > 0) {
|  58|    |-                RL_sum = 0;
|  59|    |-            }
|  60|    |-        }
|    |  53|+        for (int i = n - 1; i >= 0; --i)
|    |  54|+          {
|    |  55|+              RL_sum += nums[i];
|    |  56|+              min_RL_sum = min (min_RL_sum, RL_sum);
|    |  57|+              min_RL[i] = min_RL_sum;
|    |  58|+              if (RL_sum > 0)
|    |  59|+                {
|    |  60|+                    RL_sum = 0;
|    |  61|+                }
|    |  62|+          }
|  61|  63| 
|  62|  64|         // Compute the max diff of two non-overlapping subarrays.
|  63|  65|         int max_diff = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  61|  61| 
|  62|  62|         // Compute the max diff of two non-overlapping subarrays.
|  63|  63|         int max_diff = 0;
|  64|    |-        for (int i = 0; i < n - 1; ++i) {
|  65|    |-            max_diff = max(max_diff, abs(max_LR[i] - min_RL[i+1]));
|  66|    |-            max_diff = max(max_diff, abs(min_LR[i] - max_RL[i+1]));
|  67|    |-        }
|    |  64|+        for (int i = 0; i < n - 1; ++i)
|    |  65|+          {
|    |  66|+              max_diff = max (max_diff, abs (max_LR[i] - min_RL[i + 1]));
|    |  67|+              max_diff = max (max_diff, abs (min_LR[i] - max_RL[i + 1]));
|    |  68|+          }
|  68|  69| 
|  69|  70|         return max_diff;
|  70|  71|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-difference.cpp
|    |++++| /app/C++/maximum-subarray-difference.cpp
|  69|  69|         return max_diff;
|  70|  70|     }
|  71|  71| };
|  72|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: An integer denotes the sum of max two non-overlapping subarrays
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|   7|   7|      * @param nums: A list of integers
|   8|   8|      * @return: An integer denotes the sum of max two non-overlapping subarrays
|   9|   9|      */
|  10|    |-    int maxTwoSubArrays(vector<int> nums) {
|  11|    |-        int n = nums.size();
|  12|    |-        vector<int> max_LR(n);
|  13|    |-        vector<int> max_RL(n);
|    |  10|+    int maxTwoSubArrays (vector < int >nums)
|    |  11|+    {
|    |  12|+        int n = nums.size ();
|    |  13|+          vector < int >max_LR (n);
|    |  14|+          vector < int >max_RL (n);
|  14|  15| 
|  15|  16|         // Compute the max sum of subarray from left to right.
|  16|  17|         int max_LR_sum = INT_MIN, LR_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|  14|  14| 
|  15|  15|         // Compute the max sum of subarray from left to right.
|  16|  16|         int max_LR_sum = INT_MIN, LR_sum = 0;
|  17|    |-        for (int i = 0; i < n; ++i) {
|  18|    |-            LR_sum += nums[i];
|  19|    |-            max_LR_sum = max(max_LR_sum, LR_sum);
|  20|    |-            max_LR[i] = max_LR_sum;
|  21|    |-            LR_sum = max(LR_sum, 0);
|  22|    |-        }
|    |  17|+        for (int i = 0; i < n; ++i)
|    |  18|+          {
|    |  19|+              LR_sum += nums[i];
|    |  20|+              max_LR_sum = max (max_LR_sum, LR_sum);
|    |  21|+              max_LR[i] = max_LR_sum;
|    |  22|+              LR_sum = max (LR_sum, 0);
|    |  23|+          }
|  23|  24| 
|  24|  25|         // Compute the max sum of subarray from right to left.
|  25|  26|         int max_RL_sum = INT_MIN, RL_sum = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|  23|  23| 
|  24|  24|         // Compute the max sum of subarray from right to left.
|  25|  25|         int max_RL_sum = INT_MIN, RL_sum = 0;
|  26|    |-        for (int i = n - 1; i >= 0; --i) {
|  27|    |-            RL_sum += nums[i];
|  28|    |-            max_RL_sum = max(max_RL_sum, RL_sum);
|  29|    |-            max_RL[i] = max_RL_sum;
|  30|    |-            RL_sum = max(RL_sum, 0);
|  31|    |-        }
|    |  26|+        for (int i = n - 1; i >= 0; --i)
|    |  27|+          {
|    |  28|+              RL_sum += nums[i];
|    |  29|+              max_RL_sum = max (max_RL_sum, RL_sum);
|    |  30|+              max_RL[i] = max_RL_sum;
|    |  31|+              RL_sum = max (RL_sum, 0);
|    |  32|+          }
|  32|  33| 
|  33|  34|         // Compute the max sum of two non-overlapping subarrays.
|  34|  35|         int max_sum = INT_MIN;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|  32|  32| 
|  33|  33|         // Compute the max sum of two non-overlapping subarrays.
|  34|  34|         int max_sum = INT_MIN;
|  35|    |-        for (int i = 0; i < n - 1; ++i) {
|  36|    |-            max_sum = max(max_sum, max_LR[i] + max_RL[i+1]);
|  37|    |-        }
|    |  35|+        for (int i = 0; i < n - 1; ++i)
|    |  36|+          {
|    |  37|+              max_sum = max (max_sum, max_LR[i] + max_RL[i + 1]);
|    |  38|+          }
|  38|  39| 
|  39|  40|         return max_sum;
|  40|  41|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-subarray-ii.cpp
|    |++++| /app/C++/maximum-subarray-ii.cpp
|  39|  39|         return max_sum;
|  40|  40|     }
|  41|  41| };
|  42|    |-
|  43|    |-
|  44|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/swap-nodes-in-pairs.cpp
|    |++++| /app/C++/swap-nodes-in-pairs.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head a ListNode
|  16|  17|      * @return a ListNode
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/swap-nodes-in-pairs.cpp
|    |++++| /app/C++/swap-nodes-in-pairs.cpp
|  15|  15|      * @param head a ListNode
|  16|  16|      * @return a ListNode
|  17|  17|      */
|  18|    |-    ListNode* swapPairs(ListNode* head) {
|  19|    |-        ListNode dummy{0};
|  20|    |-        dummy.next = head;
|    |  18|+    ListNode * swapPairs (ListNode * head)
|    |  19|+    {
|    |  20|+        ListNode dummy
|    |  21|+        {
|    |  22|+        0};
|    |  23|+          dummy.next = head;
|  21|  24|         auto curr = &dummy;
|  22|  25| 
|  23|  26|         while (curr->next && curr->next->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/swap-nodes-in-pairs.cpp
|    |++++| /app/C++/swap-nodes-in-pairs.cpp
|  20|  20|         dummy.next = head;
|  21|  21|         auto curr = &dummy;
|  22|  22| 
|  23|    |-        while (curr->next && curr->next->next) {
|  24|    |-            auto next_one = curr->next;
|  25|    |-            auto next_two = next_one->next;
|  26|    |-            auto next_three = next_two->next;
|  27|    |-            curr->next = next_two;
|  28|    |-            next_two->next = next_one;
|  29|    |-            next_one->next = next_three;
|  30|    |-            curr = next_one;
|  31|    |-        }
|    |  23|+        while (curr->next && curr->next->next)
|    |  24|+          {
|    |  25|+              auto next_one = curr->next;
|    |  26|+              auto next_two = next_one->next;
|    |  27|+              auto next_three = next_two->next;
|    |  28|+                curr->next = next_two;
|    |  29|+                next_two->next = next_one;
|    |  30|+                next_one->next = next_three;
|    |  31|+                curr = next_one;
|    |  32|+          }
|  32|  33| 
|  33|  34|         return dummy.next;
|  34|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-ii.cpp
|    |++++| /app/C++/house-robber-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: An array of non-negative integers.
|   8|   9|      * return: The maximum amount of money you can rob tonight
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-ii.cpp
|    |++++| /app/C++/house-robber-ii.cpp
|   7|   7|      * @param nums: An array of non-negative integers.
|   8|   8|      * return: The maximum amount of money you can rob tonight
|   9|   9|      */
|  10|    |-    int houseRobber2(vector<int>& nums) {
|  11|    |-        if (nums.size() == 0) {
|  12|    |-            return 0;
|  13|    |-        }
|  14|    |-        if (nums.size() == 1) {
|  15|    |-            return nums[0];
|  16|    |-        }
|    |  10|+    int houseRobber2 (vector < int >&nums)
|    |  11|+    {
|    |  12|+        if (nums.size () == 0)
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|    |  16|+        if (nums.size () == 1)
|    |  17|+          {
|    |  18|+              return nums[0];
|    |  19|+          }
|  17|  20| 
|  18|    |-        return max(robRange(nums, 0, nums.size() - 1), // Include the first one of nums without the last one.
|  19|    |-                   robRange(nums, 1, nums.size()));    // Include the last one of nums without the first one.
|    |  21|+        return max (robRange (nums, 0, nums.size () - 1),   // Include the first one of nums without the last one.
|    |  22|+                    robRange (nums, 1, nums.size ()));  // Include the last one of nums without the first one.
|  20|  23|     }
|  21|  24| 
|  22|  25|     int robRange(vector<int>& nums, int start, int end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-ii.cpp
|    |++++| /app/C++/house-robber-ii.cpp
|  19|  19|                    robRange(nums, 1, nums.size()));    // Include the last one of nums without the first one.
|  20|  20|     }
|  21|  21| 
|  22|    |-    int robRange(vector<int>& nums, int start, int end) {
|    |  22|+    int robRange (vector < int >&nums, int start, int end)
|    |  23|+    {
|  23|  24|         int num_i = nums[start], num_i_1 = 0, num_i_2 = 0;
|  24|    |-        for (int i = start + 1; i < end; ++i) {
|  25|    |-            num_i_2 = num_i_1;
|  26|    |-            num_i_1 = num_i;
|  27|    |-            num_i = max(nums[i] + num_i_2, num_i_1);
|  28|    |-        }
|    |  25|+        for (int i = start + 1; i < end; ++i)
|    |  26|+          {
|    |  27|+              num_i_2 = num_i_1;
|    |  28|+              num_i_1 = num_i;
|    |  29|+              num_i = max (nums[i] + num_i_2, num_i_1);
|    |  30|+          }
|  29|  31|         return num_i;
|  30|  32|     }
|  31|  33| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-words.cpp
|    |++++| /app/C++/longest-words.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param dictionary: a vector of strings
|   8|   9|      * @return: a vector of strings
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-words.cpp
|    |++++| /app/C++/longest-words.cpp
|   7|   7|      * @param dictionary: a vector of strings
|   8|   8|      * @return: a vector of strings
|   9|   9|      */
|  10|    |-    vector<string> longestWords(vector<string> &dictionary) {
|  11|    |-        vector<string> longest_words;
|  12|    |-        for (const auto& word : dictionary) {
|  13|    |-            if (!longest_words.empty() &&
|  14|    |-                word.length() > longest_words[0].length()) {
|  15|    |-                longest_words = move(vector<string>{word});
|  16|    |-            } else if (longest_words.empty() ||
|  17|    |-                       word.length() == longest_words[0].length()) {
|  18|    |-                longest_words.emplace_back(word);
|  19|    |-            }
|  20|    |-        }
|    |  10|+    vector < string > longestWords (vector < string > &dictionary)
|    |  11|+    {
|    |  12|+        vector < string > longest_words;
|    |  13|+        for (const auto & word:dictionary)
|    |  14|+          {
|    |  15|+              if (!longest_words.empty () &&
|    |  16|+                  word.length () > longest_words[0].length ())
|    |  17|+                {
|    |  18|+                    longest_words = move (vector < string >
|    |  19|+                                          {
|    |  20|+                                          word}
|    |  21|+                    );
|    |  22|+                }
|    |  23|+              else if (longest_words.empty () ||
|    |  24|+                       word.length () == longest_words[0].length ())
|    |  25|+                {
|    |  26|+                    longest_words.emplace_back (word);
|    |  27|+                }
|    |  28|+          }
|  21|  29|         return longest_words;
|  22|  30|     }
|  23|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-1-in-binary.cpp
|    |++++| /app/C++/count-1-in-binary.cpp
|   1|   1| // Time:  O(logn) = O(32)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num: an integer
|   8|   9|      * @return: an integer, the number of ones in num
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-1-in-binary.cpp
|    |++++| /app/C++/count-1-in-binary.cpp
|   7|   7|      * @param num: an integer
|   8|   8|      * @return: an integer, the number of ones in num
|   9|   9|      */
|  10|    |-    int countOnes(int num) {
|    |  10|+    int countOnes (int num)
|    |  11|+    {
|  11|  12|         int count = 0;
|  12|    |-        for (; num; num &= num - 1) {
|  13|    |-            ++count;
|  14|    |-        }
|    |  13|+        for (; num; num &= num - 1)
|    |  14|+          {
|    |  15|+              ++count;
|    |  16|+          }
|  15|  17|         return count;
|  16|  18|     }
|  17|  19| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  11|  11|  *     }
|  12|  12|  */
|  13|  13| 
|  14|    |-class SegmentTreeMinNode {
|  15|    |-public:
|    |  14|+class SegmentTreeMinNode
|    |  15|+{
|    |  16|+  public:
|  16|  17|     int start, end, min;
|  17|  18|     SegmentTreeMinNode *left, *right;
|  18|  19|     SegmentTreeMinNode(int start, int end, int min) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  15|  15| public:
|  16|  16|     int start, end, min;
|  17|  17|     SegmentTreeMinNode *left, *right;
|  18|    |-    SegmentTreeMinNode(int start, int end, int min) {
|    |  18|+      SegmentTreeMinNode (int start, int end, int min)
|    |  19|+    {
|  19|  20|         this->start = start;
|  20|  21|         this->end = end;
|  21|  22|         this->min = min;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  23|  23|     }
|  24|  24| };
|  25|  25| 
|  26|    |-class Solution {
|  27|    |-public:
|    |  26|+class Solution
|    |  27|+{
|    |  28|+  public:
|  28|  29|     /**
|  29|  30|      *@param A, queries: Given an integer array and an query list
|  30|  31|      *@return: The result list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  29|  29|      *@param A, queries: Given an integer array and an query list
|  30|  30|      *@return: The result list
|  31|  31|      */
|  32|    |-    vector<int> intervalMinNumber(vector<int> &A, vector<Interval> &queries) {
|  33|    |-        vector<int> res;
|    |  32|+    vector < int >intervalMinNumber (vector < int >&A,
|    |  33|+                                     vector < Interval > &queries)
|    |  34|+    {
|    |  35|+        vector < int >res;
|  34|  36| 
|  35|  37|         // Build segment tree.
|  36|  38|         SegmentTreeMinNode *root = build(A, 0, A.size() - 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  33|  33|         vector<int> res;
|  34|  34| 
|  35|  35|         // Build segment tree.
|  36|    |-        SegmentTreeMinNode *root = build(A, 0, A.size() - 1);
|    |  36|+        SegmentTreeMinNode *root = build (A, 0, A.size () - 1);
|  37|  37| 
|  38|  38|         // Do each query.
|  39|  39|         for (const auto& q : queries) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  36|  36|         SegmentTreeMinNode *root = build(A, 0, A.size() - 1);
|  37|  37| 
|  38|  38|         // Do each query.
|  39|    |-        for (const auto& q : queries) {
|  40|    |-            res.emplace_back(query(root, q.start, q.end));
|  41|    |-        }
|    |  39|+        for (const auto & q:queries)
|    |  40|+          {
|    |  41|+              res.emplace_back (query (root, q.start, q.end));
|    |  42|+          }
|  42|  43| 
|  43|  44|         return res;
|  44|  45|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  43|  43|         return res;
|  44|  44|     }
|  45|  45| 
|  46|    |-
|  47|  46|     // Build segment tree.
|  48|    |-    SegmentTreeMinNode *build(vector<int> &A, int start, int end) {
|  49|    |-        if (start > end) {
|  50|    |-            return nullptr;
|  51|    |-        }
|    |  47|+    SegmentTreeMinNode *build (vector < int >&A, int start, int end)
|    |  48|+    {
|    |  49|+        if (start > end)
|    |  50|+          {
|    |  51|+              return nullptr;
|    |  52|+          }
|  52|  53| 
|  53|  54|         // The root's start and end is given by build method.
|  54|  55|         SegmentTreeMinNode *root = new SegmentTreeMinNode(start, end, INT_MAX);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  51|  51|         }
|  52|  52| 
|  53|  53|         // The root's start and end is given by build method.
|  54|    |-        SegmentTreeMinNode *root = new SegmentTreeMinNode(start, end, INT_MAX);
|    |  54|+        SegmentTreeMinNode *root =
|    |  55|+            new SegmentTreeMinNode (start, end, INT_MAX);
|  55|  56| 
|  56|  57|         // If start equals to end, there will be no children for this node.
|  57|  58|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  54|  54|         SegmentTreeMinNode *root = new SegmentTreeMinNode(start, end, INT_MAX);
|  55|  55| 
|  56|  56|         // If start equals to end, there will be no children for this node.
|  57|    |-        if (start == end) {
|  58|    |-            root->min = A[start];
|  59|    |-            return root;
|  60|    |-        }
|    |  57|+        if (start == end)
|    |  58|+          {
|    |  59|+              root->min = A[start];
|    |  60|+              return root;
|    |  61|+          }
|  61|  62| 
|  62|  63|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  63|  64|         root->left = build(A, start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  60|  60|         }
|  61|  61| 
|  62|  62|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  63|    |-        root->left = build(A, start, (start + end) / 2);
|    |  63|+        root->left = build (A, start, (start + end) / 2);
|  64|  64| 
|  65|  65|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  66|  66|         root->right = build(A, (start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  63|  63|         root->left = build(A, start, (start + end) / 2);
|  64|  64| 
|  65|  65|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  66|    |-        root->right = build(A, (start + end) / 2 + 1, end);
|    |  66|+        root->right = build (A, (start + end) / 2 + 1, end);
|  67|  67| 
|  68|  68|         int left_min = root->left != nullptr ? root->left->min : INT_MAX;
|  69|  69|         int right_min = root->right != nullptr ? root->right->min : INT_MAX;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  69|  69|         int right_min = root->right != nullptr ? root->right->min : INT_MAX;
|  70|  70| 
|  71|  71|         // Update min.
|  72|    |-        root->min = min(left_min, right_min);
|    |  72|+        root->min = min (left_min, right_min);
|  73|  73|         return root;
|  74|  74|     }
|  75|  75| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  73|  73|         return root;
|  74|  74|     }
|  75|  75| 
|  76|    |-
|  77|  76|     // Query min in given range.
|  78|    |-    int query(SegmentTreeMinNode *root, int start, int end) {
|    |  77|+    int query (SegmentTreeMinNode * root, int start, int end)
|    |  78|+    {
|  79|  79|         // Out of range.
|  80|    |-        if (root == nullptr || root->start > end || root->end < start) {
|  81|    |-            return INT_MAX;
|  82|    |-        }
|    |  80|+        if (root == nullptr || root->start > end || root->end < start)
|    |  81|+          {
|    |  82|+              return INT_MAX;
|    |  83|+          }
|  83|  84| 
|  84|  85|         // Current segment is totally within range [start, end]
|  85|  86|         if (root->start >= start && root->end <= end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  82|  82|         }
|  83|  83| 
|  84|  84|         // Current segment is totally within range [start, end]
|  85|    |-        if (root->start >= start && root->end <= end) {
|  86|    |-            return root->min;
|  87|    |-        }
|    |  85|+        if (root->start >= start && root->end <= end)
|    |  86|+          {
|    |  87|+              return root->min;
|    |  88|+          }
|  88|  89| 
|  89|    |-        const int left = query(root->left, start, end);
|  90|    |-        const int right = query(root->right, start, end);
|    |  90|+        const int left = query (root->left, start, end);
|    |  91|+        const int right = query (root->right, start, end);
|  91|  92| 
|  92|  93|         // Find min in the children.
|  93|  94|         return min(left, right);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-minimum-number.cpp
|    |++++| /app/C++/interval-minimum-number.cpp
|  90|  90|         const int right = query(root->right, start, end);
|  91|  91| 
|  92|  92|         // Find min in the children.
|  93|    |-        return min(left, right);
|    |  93|+        return min (left, right);
|  94|  94|     }
|  95|  95| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // In-place insertion sort. (stable)
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A an integer array
|   9|  10|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|   8|   8|      * @param A an integer array
|   9|   9|      * @return void
|  10|  10|      */
|  11|    |-    void sortIntegers(vector<int>& A) {
|  12|    |-        for (int n = 0; n < A.size(); ++n) {
|  13|    |-            for (int i = n - 1; i >= 0 && A[i] > A[i + 1]; --i) {
|  14|    |-                swap(A[i], A[i + 1]);
|  15|    |-            }
|  16|    |-        }
|    |  11|+    void sortIntegers (vector < int >&A)
|    |  12|+    {
|    |  13|+        for (int n = 0; n < A.size (); ++n)
|    |  14|+          {
|    |  15|+              for (int i = n - 1; i >= 0 && A[i] > A[i + 1]; --i)
|    |  16|+                {
|    |  17|+                    swap (A[i], A[i + 1]);
|    |  18|+                }
|    |  19|+          }
|  17|  20|     }
|  18|  21| };
|  19|  22| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|  20|  20| // Time:  O(n^2)
|  21|  21| // Space: O(1)
|  22|  22| // Bubble sort. (stable)
|  23|    |-class Solution {
|  24|    |-public:
|    |  23|+class Solution
|    |  24|+{
|    |  25|+  public:
|  25|  26|     /**
|  26|  27|      * @param A an integer array
|  27|  28|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|  26|  26|      * @param A an integer array
|  27|  27|      * @return void
|  28|  28|      */
|  29|    |-    void sortIntegers(vector<int>& A) {
|  30|    |-        for (int n = 0; n < A.size(); ++n) {
|  31|    |-            for (int i = 0; i + 1 < static_cast<int>(A.size()) - n; ++i) {
|  32|    |-                if (A[i] > A[i + 1]) {
|  33|    |-                    swap(A[i], A[i + 1]);
|    |  29|+    void sortIntegers (vector < int >&A)
|    |  30|+    {
|    |  31|+        for (int n = 0; n < A.size (); ++n)
|    |  32|+          {
|    |  33|+              for (int i = 0; i + 1 < static_cast < int >(A.size ()) - n; ++i)
|    |  34|+                {
|    |  35|+                    if (A[i] > A[i + 1])
|    |  36|+                      {
|    |  37|+                          swap (A[i], A[i + 1]);
|    |  38|+                      }
|  34|  39|                 }
|  35|    |-            }
|  36|    |-        }
|    |  40|+          }
|  37|  41|     }
|  38|  42| };
|  39|  43| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|  40|  40| // Time:  O(n^2)
|  41|  41| // Space: O(1)
|  42|  42| // Selection sort. (unstable)
|  43|    |-class Solution {
|  44|    |-public:
|    |  43|+class Solution
|    |  44|+{
|    |  45|+  public:
|  45|  46|     /**
|  46|  47|      * @param A an integer array
|  47|  48|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-integers.cpp
|    |++++| /app/C++/sort-integers.cpp
|  46|  46|      * @param A an integer array
|  47|  47|      * @return void
|  48|  48|      */
|  49|    |-    void sortIntegers(vector<int>& A) {
|  50|    |-        for (int n = 0; n < A.size(); ++n) {
|  51|    |-            int min_idx = n;
|  52|    |-            for (int i = n + 1; i < A.size(); ++i) {
|  53|    |-                if (A[i] < A[min_idx]) {
|  54|    |-                    min_idx = i;
|    |  49|+    void sortIntegers (vector < int >&A)
|    |  50|+    {
|    |  51|+        for (int n = 0; n < A.size (); ++n)
|    |  52|+          {
|    |  53|+              int min_idx = n;
|    |  54|+              for (int i = n + 1; i < A.size (); ++i)
|    |  55|+                {
|    |  56|+                    if (A[i] < A[min_idx])
|    |  57|+                      {
|    |  58|+                          min_idx = i;
|    |  59|+                      }
|  55|  60|                 }
|  56|    |-            }
|  57|    |-            swap(A[n], A[min_idx]);
|  58|    |-        }
|    |  61|+              swap (A[n], A[min_idx]);
|    |  62|+          }
|  59|  63|     }
|  60|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(m * n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer matrix
|   8|   9|      * @return  an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|   7|   7|      * @param A an integer matrix
|   8|   8|      * @return  an integer
|   9|   9|      */
|  10|    |-    int longestIncreasingContinuousSubsequenceII(vector<vector<int>>& A) {
|  11|    |-        if (A.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int longestIncreasingContinuousSubsequenceII (vector < vector < int >>&A)
|    |  11|+    {
|    |  12|+        if (A.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|  17|         // max_inc_len[i][j] stores the length of longest increasing continuous 
|  16|  18|         // subsequence which starts with A[i][j]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  14|  14| 
|  15|  15|         // max_inc_len[i][j] stores the length of longest increasing continuous 
|  16|  16|         // subsequence which starts with A[i][j]
|  17|    |-        vector<vector<int>> max_inc_len(A.size(), vector<int>(A[0].size(), 0));
|    |  17|+        vector < vector < int >>max_inc_len (A.size (),
|    |  18|+                                             vector < int >(A[0].size (), 0));
|  18|  19|         int ans = 0;
|  19|  20| 
|  20|  21|         for (int i = 0; i < A.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  17|  17|         vector<vector<int>> max_inc_len(A.size(), vector<int>(A[0].size(), 0));
|  18|  18|         int ans = 0;
|  19|  19| 
|  20|    |-        for (int i = 0; i < A.size(); ++i) {
|  21|    |-            for (int j = 0; j < A[0].size(); ++j) {
|  22|    |-                // Not yet visited.
|  23|    |-                if (max_inc_len[i][j] == 0) {
|  24|    |-                    ans = max(ans, fill(A, i, j, INT_MIN, max_inc_len));
|    |  20|+        for (int i = 0; i < A.size (); ++i)
|    |  21|+          {
|    |  22|+              for (int j = 0; j < A[0].size (); ++j)
|    |  23|+                {
|    |  24|+                    // Not yet visited.
|    |  25|+                    if (max_inc_len[i][j] == 0)
|    |  26|+                      {
|    |  27|+                          ans =
|    |  28|+                              max (ans, fill (A, i, j, INT_MIN, max_inc_len));
|    |  29|+                      }
|  25|  30|                 }
|  26|    |-            }
|  27|    |-        }
|    |  31|+          }
|  28|  32| 
|  29|  33|         return ans;
|  30|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  29|  29|         return ans;
|  30|  30|     }
|  31|  31| 
|  32|    |-    int fill(const vector<vector<int>>& A, const int i, const int j,
|  33|    |-             const int prev_val,
|  34|    |-             vector<vector<int>>& max_inc_len) {
|    |  32|+    int fill (const vector < vector < int >>&A, const int i, const int j,
|    |  33|+              const int prev_val, vector < vector < int >>&max_inc_len)
|    |  34|+    {
|  35|  35|         // Invalid cases.
|  36|    |-        if (i < 0 || i >= A.size() || j < 0 || j >= A[0].size() ||
|  37|    |-            A[i][j] <= prev_val) {
|  38|    |-            return 0;
|  39|    |-        }
|    |  36|+        if (i < 0 || i >= A.size () || j < 0 || j >= A[0].size () ||
|    |  37|+            A[i][j] <= prev_val)
|    |  38|+          {
|    |  39|+              return 0;
|    |  40|+          }
|  40|  41| 
|  41|  42|         // Return max_inc_len if visited.
|  42|  43|         if (max_inc_len[i][j] > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  39|  39|         }
|  40|  40| 
|  41|  41|         // Return max_inc_len if visited.
|  42|    |-        if (max_inc_len[i][j] > 0) {
|  43|    |-            return max_inc_len[i][j];
|  44|    |-        }
|    |  42|+        if (max_inc_len[i][j] > 0)
|    |  43|+          {
|    |  44|+              return max_inc_len[i][j];
|    |  45|+          }
|  45|  46| 
|  46|  47|         // Try each direction to find the max of max_inc_len[i][j].
|  47|  48|         const vector<pair<int, int>> directions = {{0, 1}, {0, -1},
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  44|  44|         }
|  45|  45| 
|  46|  46|         // Try each direction to find the max of max_inc_len[i][j].
|  47|    |-        const vector<pair<int, int>> directions = {{0, 1}, {0, -1},
|  48|    |-                                                   {1, 0}, {-1, 0}};
|  49|    |-        for (const auto& d : directions) {
|  50|    |-            max_inc_len[i][j] = max(max_inc_len[i][j],
|  51|    |-                                    1 + fill(A, i + d.first, j + d.second,
|  52|    |-                                             A[i][j], max_inc_len));
|  53|    |-        }
|    |  47|+        const vector < pair < int, int >>directions = { {0, 1}, {0, -1},
|    |  48|+        {1, 0}, {-1, 0}
|    |  49|+        };
|    |  50|+      for (const auto & d:directions)
|    |  51|+          {
|    |  52|+              max_inc_len[i][j] = max (max_inc_len[i][j],
|    |  53|+                                       1 + fill (A, i + d.first, j + d.second,
|    |  54|+                                                 A[i][j], max_inc_len));
|    |  55|+          }
|  54|  56| 
|  55|  57|         return max_inc_len[i][j];
|  56|  58|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  56|  56|     }
|  57|  57| };
|  58|  58| 
|  59|    |-
|  60|  59| // Time:  O(m * n)
|  61|  60| // Space: O(m * n)
|  62|  61| class Solution2 {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  59|  59| 
|  60|  60| // Time:  O(m * n)
|  61|  61| // Space: O(m * n)
|  62|    |-class Solution2 {
|  63|    |-public:
|    |  62|+class Solution2
|    |  63|+{
|    |  64|+  public:
|  64|  65|     /**
|  65|  66|      * @param A an integer matrix
|  66|  67|      * @return  an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  65|  65|      * @param A an integer matrix
|  66|  66|      * @return  an integer
|  67|  67|      */
|  68|    |-    int longestIncreasingContinuousSubsequenceII(vector<vector<int>>& A) {
|  69|    |-        if (A.empty()) {
|  70|    |-            return 0;
|  71|    |-        }
|    |  68|+    int longestIncreasingContinuousSubsequenceII (vector < vector < int >>&A)
|    |  69|+    {
|    |  70|+        if (A.empty ())
|    |  71|+          {
|    |  72|+              return 0;
|    |  73|+          }
|  72|  74| 
|  73|  75|         // max_inc_len[i][j] stores the length of longest decreasing continuous 
|  74|  76|         // subsequence which starts with A[i][j]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  72|  72| 
|  73|  73|         // max_inc_len[i][j] stores the length of longest decreasing continuous 
|  74|  74|         // subsequence which starts with A[i][j]
|  75|    |-        vector<vector<int>> max_inc_len(A.size(), vector<int>(A[0].size(), 0));
|    |  75|+        vector < vector < int >>max_inc_len (A.size (),
|    |  76|+                                             vector < int >(A[0].size (), 0));
|  76|  77|         int ans = 0;
|  77|  78| 
|  78|  79|         for (int i = 0; i < A.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  75|  75|         vector<vector<int>> max_inc_len(A.size(), vector<int>(A[0].size(), 0));
|  76|  76|         int ans = 0;
|  77|  77| 
|  78|    |-        for (int i = 0; i < A.size(); ++i) {
|  79|    |-            for (int j = 0; j < A[0].size(); ++j) {
|  80|    |-                // Not yet visited.
|  81|    |-                if (max_inc_len[i][j] == 0) {
|  82|    |-                    ans = max(ans, fill(A, i, j, INT_MAX, max_inc_len));
|    |  78|+        for (int i = 0; i < A.size (); ++i)
|    |  79|+          {
|    |  80|+              for (int j = 0; j < A[0].size (); ++j)
|    |  81|+                {
|    |  82|+                    // Not yet visited.
|    |  83|+                    if (max_inc_len[i][j] == 0)
|    |  84|+                      {
|    |  85|+                          ans =
|    |  86|+                              max (ans, fill (A, i, j, INT_MAX, max_inc_len));
|    |  87|+                      }
|  83|  88|                 }
|  84|    |-            }
|  85|    |-        }
|    |  89|+          }
|  86|  90| 
|  87|  91|         return ans;
|  88|  92|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  87|  87|         return ans;
|  88|  88|     }
|  89|  89| 
|  90|    |-    int fill(const vector<vector<int>>& A, const int i, const int j,
|  91|    |-             const int prev_val,
|  92|    |-             vector<vector<int>>& max_inc_len) {
|    |  90|+    int fill (const vector < vector < int >>&A, const int i, const int j,
|    |  91|+              const int prev_val, vector < vector < int >>&max_inc_len)
|    |  92|+    {
|  93|  93|         // Invalid cases.
|  94|    |-        if (i < 0 || i >= A.size() || j < 0 || j >= A[0].size() ||
|  95|    |-            A[i][j] >= prev_val) {
|  96|    |-            return 0;
|  97|    |-        }
|    |  94|+        if (i < 0 || i >= A.size () || j < 0 || j >= A[0].size () ||
|    |  95|+            A[i][j] >= prev_val)
|    |  96|+          {
|    |  97|+              return 0;
|    |  98|+          }
|  98|  99| 
|  99| 100|         // Return max_inc_len if visited.
| 100| 101|         if (max_inc_len[i][j] > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|  97|  97|         }
|  98|  98| 
|  99|  99|         // Return max_inc_len if visited.
| 100|    |-        if (max_inc_len[i][j] > 0) {
| 101|    |-            return max_inc_len[i][j];
| 102|    |-        }
|    | 100|+        if (max_inc_len[i][j] > 0)
|    | 101|+          {
|    | 102|+              return max_inc_len[i][j];
|    | 103|+          }
| 103| 104| 
| 104| 105|         // Try each direction to find the max of max_inc_len[i][j].
| 105| 106|         const vector<pair<int, int>> directions = {{0, 1}, {0, -1},
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence-ii.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence-ii.cpp
| 102| 102|         }
| 103| 103| 
| 104| 104|         // Try each direction to find the max of max_inc_len[i][j].
| 105|    |-        const vector<pair<int, int>> directions = {{0, 1}, {0, -1},
| 106|    |-                                                   {1, 0}, {-1, 0}};
| 107|    |-        for (const auto& d : directions) {
| 108|    |-            max_inc_len[i][j] = max(max_inc_len[i][j],
| 109|    |-                                    1 + fill(A, i + d.first, j + d.second,
| 110|    |-                                             A[i][j], max_inc_len));
| 111|    |-        }
|    | 105|+        const vector < pair < int, int >>directions = { {0, 1}, {0, -1},
|    | 106|+        {1, 0}, {-1, 0}
|    | 107|+        };
|    | 108|+      for (const auto & d:directions)
|    | 109|+          {
|    | 110|+              max_inc_len[i][j] = max (max_inc_len[i][j],
|    | 111|+                                       1 + fill (A, i + d.first, j + d.second,
|    | 112|+                                                 A[i][j], max_inc_len));
|    | 113|+          }
| 112| 114| 
| 113| 115|         return max_inc_len[i][j];
| 114| 116|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/climbing-stairs.cpp
|    |++++| /app/C++/climbing-stairs.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: An integer
|   8|   9|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/climbing-stairs.cpp
|    |++++| /app/C++/climbing-stairs.cpp
|   7|   7|      * @param n: An integer
|   8|   8|      * @return: An integer
|   9|   9|      */
|  10|    |-    int climbStairs(int n) {
|  11|    |-        vector<int> steps(3, 0);
|  12|    |-        steps[0] = 1;
|  13|    |-        steps[1] = 1;
|  14|    |-        for (int i = 2; i <= n; ++i) {
|  15|    |-            steps[i % 3] = steps[(i - 1) % 3] + steps[(i - 2) % 3];
|  16|    |-        }
|    |  10|+    int climbStairs (int n)
|    |  11|+    {
|    |  12|+        vector < int >steps (3, 0);
|    |  13|+          steps[0] = 1;
|    |  14|+          steps[1] = 1;
|    |  15|+        for (int i = 2; i <= n; ++i)
|    |  16|+          {
|    |  17|+              steps[i % 3] = steps[(i - 1) % 3] + steps[(i - 2) % 3];
|    |  18|+          }
|  17|  19|         return steps[n % 3];
|  18|  20|     }
|  19|  21| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/climbing-stairs.cpp
|    |++++| /app/C++/climbing-stairs.cpp
|  17|  17|         return steps[n % 3];
|  18|  18|     }
|  19|  19| };
|  20|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|   1|   1| // Time:  O(n * n!)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * Get all distinct N-Queen solutions
|   8|   9|      * @param n: The number of queens
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|   9|   9|      * @return: All distinct solutions
|  10|  10|      * For example, A string '...Q' shows a queen on forth position
|  11|  11|      */
|  12|    |-    vector<vector<string>> solveNQueens(int n) {
|  13|    |-        vector<int> placement(n);
|  14|    |-        vector<vector<string>> result;
|  15|    |-        NQueensHelper(n, 0, &placement, &result);
|  16|    |-        return result;
|    |  12|+    vector < vector < string >> solveNQueens (int n)
|    |  13|+    {
|    |  14|+        vector < int >placement (n);
|    |  15|+          vector < vector < string >> result;
|    |  16|+          NQueensHelper (n, 0, &placement, &result);
|    |  17|+          return result;
|  17|  18|     }
|  18|  19| 
|  19|  20|     void NQueensHelper(int n, int row, vector<int>* col_placement,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|  16|  16|         return result;
|  17|  17|     }
|  18|  18| 
|  19|    |-    void NQueensHelper(int n, int row, vector<int>* col_placement,
|  20|    |-                       vector<vector<string>>* result) {
|  21|    |-        if (row == n) {
|  22|    |-            result->emplace_back(CreateOutput(*col_placement));
|  23|    |-        } else {
|  24|    |-            for (int col = 0; col < n; ++col) {
|  25|    |-                (*col_placement)[row] = col;
|  26|    |-                if (IsFeasible(*col_placement, row)) {
|  27|    |-                    NQueensHelper(n, row + 1, col_placement, result);
|    |  19|+    void NQueensHelper (int n, int row, vector < int >*col_placement,
|    |  20|+                        vector < vector < string >> *result)
|    |  21|+    {
|    |  22|+        if (row == n)
|    |  23|+          {
|    |  24|+              result->emplace_back (CreateOutput (*col_placement));
|    |  25|+          }
|    |  26|+        else
|    |  27|+          {
|    |  28|+              for (int col = 0; col < n; ++col)
|    |  29|+                {
|    |  30|+                    (*col_placement)[row] = col;
|    |  31|+                    if (IsFeasible (*col_placement, row))
|    |  32|+                      {
|    |  33|+                          NQueensHelper (n, row + 1, col_placement, result);
|    |  34|+                      }
|  28|  35|                 }
|  29|    |-            }
|  30|    |-        }
|    |  36|+          }
|  31|  37|     }
|  32|  38| 
|  33|  39|     vector<string> CreateOutput(const vector<int>& col_placement) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|  30|  30|         }
|  31|  31|     }
|  32|  32| 
|  33|    |-    vector<string> CreateOutput(const vector<int>& col_placement) {
|  34|    |-        vector<string> sol;
|  35|    |-        for (int row : col_placement) {
|  36|    |-            string line(col_placement.size(), '.');
|  37|    |-            line[row] = 'Q';
|  38|    |-            sol.emplace_back(line);
|  39|    |-        }
|    |  33|+    vector < string > CreateOutput (const vector < int >&col_placement)
|    |  34|+    {
|    |  35|+        vector < string > sol;
|    |  36|+      for (int row:col_placement)
|    |  37|+          {
|    |  38|+              string line (col_placement.size (), '.');
|    |  39|+              line[row] = 'Q';
|    |  40|+              sol.emplace_back (line);
|    |  41|+          }
|  40|  42|         return sol;
|  41|  43|     }
|  42|  44| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|  40|  40|         return sol;
|  41|  41|     }
|  42|  42| 
|  43|    |-    bool IsFeasible(const vector<int>& col_placement, int row) {
|  44|    |-        for (int i = 0; i < row; ++i) {
|  45|    |-            int diff = abs(col_placement[i] - col_placement[row]);
|  46|    |-            if (diff == 0 || diff == row - i) {
|  47|    |-                return false;
|  48|    |-            }
|  49|    |-        }
|    |  43|+    bool IsFeasible (const vector < int >&col_placement, int row)
|    |  44|+    {
|    |  45|+        for (int i = 0; i < row; ++i)
|    |  46|+          {
|    |  47|+              int diff = abs (col_placement[i] - col_placement[row]);
|    |  48|+              if (diff == 0 || diff == row - i)
|    |  49|+                {
|    |  50|+                    return false;
|    |  51|+                }
|    |  52|+          }
|  50|  53|         return true;
|  51|  54|     }
|  52|  55| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/n-queens.cpp
|    |++++| /app/C++/n-queens.cpp
|  50|  50|         return true;
|  51|  51|     }
|  52|  52| };
|  53|    |-
|  54|    |-
|  55|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-permutation.cpp
|    |++++| /app/C++/string-permutation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A a string
|   8|   9|      * @param B a string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-permutation.cpp
|    |++++| /app/C++/string-permutation.cpp
|   8|   8|      * @param B a string
|   9|   9|      * @return a boolean
|  10|  10|      */
|  11|    |-    bool stringPermutation(string& A, string& B) {
|  12|    |-        if (A.length() != B.length()) {
|  13|    |-            return false;
|  14|    |-        }
|  15|    |-        unordered_map<char, int> words;
|  16|    |-        for (const auto& c : A) {
|  17|    |-            ++words[c];
|  18|    |-        }
|  19|    |-        for (const auto& c : B) {
|  20|    |-            if (words[c]) {
|  21|    |-                --words[c];
|  22|    |-            } else {
|  23|    |-                return false;
|  24|    |-            }
|  25|    |-        }
|    |  11|+    bool stringPermutation (string & A, string & B)
|    |  12|+    {
|    |  13|+        if (A.length () != B.length ())
|    |  14|+          {
|    |  15|+              return false;
|    |  16|+          }
|    |  17|+        unordered_map < char, int >words;
|    |  18|+      for (const auto & c:A)
|    |  19|+          {
|    |  20|+              ++words[c];
|    |  21|+          }
|    |  22|+      for (const auto & c:B)
|    |  23|+          {
|    |  24|+              if (words[c])
|    |  25|+                {
|    |  26|+                    --words[c];
|    |  27|+                }
|    |  28|+              else
|    |  29|+                {
|    |  30|+                    return false;
|    |  31|+                }
|    |  32|+          }
|  26|  33|         return true;
|  27|  34|     }
|  28|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution{
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: head node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|  19|  19|      * @param head: The first node of linked list.
|  20|  20|      * @return: head node
|  21|  21|      */
|  22|    |-    ListNode * deleteDuplicates(ListNode *head) {
|  23|    |-        ListNode dummy{0};
|    |  22|+    ListNode * deleteDuplicates (ListNode * head)
|    |  23|+    {
|    |  24|+        ListNode dummy
|    |  25|+        {
|    |  26|+        0};
|  24|  27|         auto prev = &dummy;
|  25|    |-        while (head) {
|  26|    |-            if (head->next && head->next->val == head->val) {
|  27|    |-                auto val = head->val;
|  28|    |-                while (head && head->val == val) {
|    |  28|+        while (head)
|    |  29|+          {
|    |  30|+              if (head->next && head->next->val == head->val)
|    |  31|+                {
|    |  32|+                    auto val = head->val;
|    |  33|+                    while (head && head->val == val)
|    |  34|+                      {
|    |  35|+                          head = head->next;
|    |  36|+                      }
|    |  37|+                    prev->next = head;
|    |  38|+                }
|    |  39|+              else
|    |  40|+                {
|    |  41|+                    prev->next = head;
|    |  42|+                    prev = head;
|  29|  43|                     head = head->next;
|  30|  44|                 }
|  31|  45|                 prev->next = head;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-list-ii.cpp
|  28|  28|                 while (head && head->val == val) {
|  29|  29|                     head = head->next;
|  30|  30|                 }
|  31|    |-                prev->next = head;
|  32|    |-            } else {
|  33|    |-                prev->next = head;
|  34|    |-                prev = head;
|  35|    |-                head = head->next;
|  36|    |-            }
|  37|    |-        }
|    |  31|+          }
|  38|  32|         return dummy.next;
|  39|  33|     }
|  40|  34| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      *@param start, end: Denote an segment / interval
|  20|  21|      *@return: The root of Segment Tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  19|  19|      *@param start, end: Denote an segment / interval
|  20|  20|      *@return: The root of Segment Tree
|  21|  21|      */
|  22|    |-    SegmentTreeNode * build(int start, int end) {
|  23|    |-        if (start > end) {
|  24|    |-            return nullptr;
|  25|    |-        }
|    |  22|+    SegmentTreeNode * build (int start, int end)
|    |  23|+    {
|    |  24|+        if (start > end)
|    |  25|+          {
|    |  26|+              return nullptr;
|    |  27|+          }
|  26|  28| 
|  27|  29|         // The root's start and end is given by build method.
|  28|  30|         SegmentTreeNode *root = new SegmentTreeNode(start, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  25|  25|         }
|  26|  26| 
|  27|  27|         // The root's start and end is given by build method.
|  28|    |-        SegmentTreeNode *root = new SegmentTreeNode(start, end);
|    |  28|+        SegmentTreeNode *root = new SegmentTreeNode (start, end);
|  29|  29| 
|  30|  30|         // If start equals to end, there will be no children for this node.
|  31|  31|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  28|  28|         SegmentTreeNode *root = new SegmentTreeNode(start, end);
|  29|  29| 
|  30|  30|         // If start equals to end, there will be no children for this node.
|  31|    |-        if (start == end) {
|  32|    |-            return root;
|  33|    |-        }
|    |  31|+        if (start == end)
|    |  32|+          {
|    |  33|+              return root;
|    |  34|+          }
|  34|  35| 
|  35|  36|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  36|  37|         root->left = build(start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  33|  33|         }
|  34|  34| 
|  35|  35|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  36|    |-        root->left = build(start, (start + end) / 2);
|    |  36|+        root->left = build (start, (start + end) / 2);
|  37|  37| 
|  38|  38|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  39|  39|         root->right = build((start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-build.cpp
|    |++++| /app/C++/segment-tree-build.cpp
|  36|  36|         root->left = build(start, (start + end) / 2);
|  37|  37| 
|  38|  38|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  39|    |-        root->right = build((start + end) / 2 + 1, end);
|    |  39|+        root->right = build ((start + end) / 2 + 1, end);
|  40|  40| 
|  41|  41|         return root;
|  42|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum.cpp
|    |++++| /app/C++/continuous-subarray-sum.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer array
|   8|   9|      * @return  A list of integers includes the index of 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum.cpp
|    |++++| /app/C++/continuous-subarray-sum.cpp
|   8|   8|      * @return  A list of integers includes the index of 
|   9|   9|      *          the first number and the index of the last number
|  10|  10|      */
|  11|    |-    vector<int> continuousSubarraySum(vector<int>& A) {
|  12|    |-        if (A.empty()) {
|  13|    |-            return {-1, -1};
|  14|    |-        }
|    |  11|+    vector < int >continuousSubarraySum (vector < int >&A)
|    |  12|+    {
|    |  13|+        if (A.empty ())
|    |  14|+          {
|    |  15|+              return
|    |  16|+              {
|    |  17|+              -1, -1};
|    |  18|+          }
|  15|  19| 
|  16|  20|         int curr_sum = A[0];
|  17|  21|         int max_sum = curr_sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/continuous-subarray-sum.cpp
|    |++++| /app/C++/continuous-subarray-sum.cpp
|  15|  15| 
|  16|  16|         int curr_sum = A[0];
|  17|  17|         int max_sum = curr_sum;
|  18|    |-        vector<int> max_i_j{0, 0};
|  19|    |-        for (int i = 0, j = 1; j < A.size(); ++j) {
|  20|    |-            if (curr_sum < 0) {
|  21|    |-                i = j;
|  22|    |-                curr_sum = 0;
|  23|    |-            }
|    |  18|+        vector < int >max_i_j
|    |  19|+        {
|    |  20|+        0, 0};
|    |  21|+        for (int i = 0, j = 1; j < A.size (); ++j)
|    |  22|+          {
|    |  23|+              if (curr_sum < 0)
|    |  24|+                {
|    |  25|+                    i = j;
|    |  26|+                    curr_sum = 0;
|    |  27|+                }
|  24|  28| 
|  25|    |-            curr_sum += A[j];
|  26|    |-            if (curr_sum > max_sum) {
|  27|    |-                max_sum = curr_sum;
|  28|    |-                max_i_j[0] = i, max_i_j[1] = j;
|  29|    |-            }
|  30|    |-        }
|    |  29|+              curr_sum += A[j];
|    |  30|+              if (curr_sum > max_sum)
|    |  31|+                {
|    |  32|+                    max_sum = curr_sum;
|    |  33|+                    max_i_j[0] = i, max_i_j[1] = j;
|    |  34|+                }
|    |  35|+          }
|  31|  36| 
|  32|  37|         return max_i_j;
|  33|  38|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  11|  11|  */
|  12|  12| 
|  13|  13| // BFS
|  14|    |-class Solution {
|  15|    |-public:
|    |  14|+class Solution
|    |  15|+{
|    |  16|+  public:
|  16|  17|     /**
|  17|  18|      * @param graph: A list of Directed graph node
|  18|  19|      * @param s: the starting Directed graph node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  19|  19|      * @param t: the terminal Directed graph node
|  20|  20|      * @return: a boolean value
|  21|  21|      */
|  22|    |-    bool hasRoute(vector<DirectedGraphNode*> graph,
|  23|    |-                  DirectedGraphNode* s, DirectedGraphNode* t) {
|  24|    |-        unordered_set<DirectedGraphNode *> visited_node;
|  25|    |-        visited_node.emplace(s);
|  26|    |-        return BFS(s, t, visited_node);
|    |  22|+    bool hasRoute (vector < DirectedGraphNode * >graph,
|    |  23|+                   DirectedGraphNode * s, DirectedGraphNode * t)
|    |  24|+    {
|    |  25|+        unordered_set < DirectedGraphNode * >visited_node;
|    |  26|+        visited_node.emplace (s);
|    |  27|+        return BFS (s, t, visited_node);
|  27|  28|     }
|  28|    |-    bool BFS(DirectedGraphNode* s, const DirectedGraphNode* t,
|  29|    |-             unordered_set<DirectedGraphNode *> &visited_node) {
|  30|    |-        queue<DirectedGraphNode *> q;
|  31|    |-        q.emplace(s);
|  32|    |-        while (!q.empty()) {
|  33|    |-            s = q.front();
|  34|    |-            q.pop();
|    |  29|+    bool BFS (DirectedGraphNode * s, const DirectedGraphNode * t,
|    |  30|+              unordered_set < DirectedGraphNode * >&visited_node)
|    |  31|+    {
|    |  32|+        queue < DirectedGraphNode * >q;
|    |  33|+        q.emplace (s);
|    |  34|+        while (!q.empty ())
|    |  35|+          {
|    |  36|+              s = q.front ();
|    |  37|+              q.pop ();
|  35|  38| 
|  36|    |-            if (s == t) {
|  37|    |-                return true;
|  38|    |-            }
|    |  39|+              if (s == t)
|    |  40|+                {
|    |  41|+                    return true;
|    |  42|+                }
|  39|  43| 
|  40|    |-            // Add neighbors which are not visited into the queue
|  41|    |-            for (const auto& node: s->neighbors) {
|  42|    |-                if (visited_node.emplace(node).second) {
|  43|    |-                    q.emplace(node);
|    |  44|+              // Add neighbors which are not visited into the queue
|    |  45|+            for (const auto & node:s->neighbors)
|    |  46|+                {
|    |  47|+                    if (visited_node.emplace (node).second)
|    |  48|+                      {
|    |  49|+                          q.emplace (node);
|    |  50|+                      }
|  44|  51|                 }
|  45|    |-            }
|  46|    |-        }
|    |  52|+          }
|  47|  53| 
|  48|  54|         return false;
|  49|  55|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  50|  50| };
|  51|  51| 
|  52|  52| // DFS
|  53|    |-class Solution2 {
|  54|    |-public:
|    |  53|+class Solution2
|    |  54|+{
|    |  55|+  public:
|  55|  56|     /**
|  56|  57|      * @param graph: A list of Directed graph node
|  57|  58|      * @param s: the starting Directed graph node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  58|  58|      * @param t: the terminal Directed graph node
|  59|  59|      * @return: a boolean value
|  60|  60|      */
|  61|    |-    bool hasRoute(vector<DirectedGraphNode*> graph,
|  62|    |-                  DirectedGraphNode* s, DirectedGraphNode* t) {
|  63|    |-        unordered_set<DirectedGraphNode *> visited_node;
|  64|    |-        visited_node.emplace(s);
|  65|    |-        return DFS(s, t, visited_node);
|    |  61|+    bool hasRoute (vector < DirectedGraphNode * >graph,
|    |  62|+                   DirectedGraphNode * s, DirectedGraphNode * t)
|    |  63|+    {
|    |  64|+        unordered_set < DirectedGraphNode * >visited_node;
|    |  65|+        visited_node.emplace (s);
|    |  66|+        return DFS (s, t, visited_node);
|  66|  67|     }
|  67|    |-    bool DFS(DirectedGraphNode* s, const DirectedGraphNode* t,
|  68|    |-             unordered_set<DirectedGraphNode *> &visited_node) {
|  69|    |-        if (s == t) {
|  70|    |-            return true;
|  71|    |-        }
|    |  68|+    bool DFS (DirectedGraphNode * s, const DirectedGraphNode * t,
|    |  69|+              unordered_set < DirectedGraphNode * >&visited_node)
|    |  70|+    {
|    |  71|+        if (s == t)
|    |  72|+          {
|    |  73|+              return true;
|    |  74|+          }
|  72|  75| 
|  73|  76|         // Search neighbors which are not visted
|  74|  77|         for (const auto& node: s->neighbors) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  71|  71|         }
|  72|  72| 
|  73|  73|         // Search neighbors which are not visted
|  74|    |-        for (const auto& node: s->neighbors) {
|  75|    |-            if (visited_node.emplace(node).second) {
|  76|    |-                if (DFS(node, t, visited_node)) {
|  77|    |-                    return true;
|    |  74|+      for (const auto & node:s->neighbors)
|    |  75|+          {
|    |  76|+              if (visited_node.emplace (node).second)
|    |  77|+                {
|    |  78|+                    if (DFS (node, t, visited_node))
|    |  79|+                      {
|    |  80|+                          return true;
|    |  81|+                      }
|    |  82|+                    //visited_node.erase(node);
|  78|  83|                 }
|  79|    |-                //visited_node.erase(node);
|  80|    |-            }
|  81|    |-        }
|    |  84|+          }
|  82|  85|         return false;
|  83|  86|     }
|  84|  87| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/route-between-two-nodes-in-graph.cpp
|    |++++| /app/C++/route-between-two-nodes-in-graph.cpp
|  82|  82|         return false;
|  83|  83|     }
|  84|  84| };
|  85|    |-
|  86|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|   8|   8|  * trie.search("lint"); will return false
|   9|   9|  * trie.startsWith("lint"); will return true
|  10|  10|  */
|  11|    |-class TrieNode {
|  12|    |-public:
|    |  11|+class TrieNode
|    |  12|+{
|    |  13|+  public:
|  13|  14|     // Initialize your data structure here.
|  14|    |-    TrieNode():is_string(false) {
|    |  15|+    TrieNode ():is_string (false)
|    |  16|+    {
|  15|  17|     }
|  16|  18|     bool is_string;
|  17|  19|     unordered_map<char, TrieNode *> leaves;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  14|  14|     TrieNode():is_string(false) {
|  15|  15|     }
|  16|  16|     bool is_string;
|  17|    |-    unordered_map<char, TrieNode *> leaves;
|    |  17|+    unordered_map < char, TrieNode * >leaves;
|  18|  18| };
|  19|  19| 
|  20|  20| class Trie {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  17|  17|     unordered_map<char, TrieNode *> leaves;
|  18|  18| };
|  19|  19| 
|  20|    |-class Trie {
|  21|    |-public:
|  22|    |-    Trie() {
|  23|    |-        root = new TrieNode();
|    |  20|+class Trie
|    |  21|+{
|    |  22|+  public:
|    |  23|+    Trie ()
|    |  24|+    {
|    |  25|+        root = new TrieNode ();
|  24|  26|     }
|  25|  27| 
|  26|  28|     // Inserts a word into the trie.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  24|  24|     }
|  25|  25| 
|  26|  26|     // Inserts a word into the trie.
|  27|    |-    void insert(string word) {
|    |  27|+    void insert (string word)
|    |  28|+    {
|  28|  29|         TrieNode *cur = root;
|  29|    |-        for (const auto& c : word) {
|  30|    |-            if (!cur->leaves.count(c)) {
|  31|    |-                cur->leaves[c] = new TrieNode();
|  32|    |-            }
|  33|    |-            cur = cur->leaves[c];
|  34|    |-        }
|    |  30|+      for (const auto & c:word)
|    |  31|+          {
|    |  32|+              if (!cur->leaves.count (c))
|    |  33|+                {
|    |  34|+                    cur->leaves[c] = new TrieNode ();
|    |  35|+                }
|    |  36|+              cur = cur->leaves[c];
|    |  37|+          }
|  35|  38|         cur->is_string = true;
|  36|  39|     }
|  37|  40| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  36|  36|     }
|  37|  37| 
|  38|  38|     // Returns if the word is in the trie.
|  39|    |-    bool search(string word) {
|  40|    |-        TrieNode *node = childSearch(word);
|  41|    |-        if (node) {
|  42|    |-            return node->is_string;
|  43|    |-        }
|  44|    |-        return false;   
|    |  39|+    bool search (string word)
|    |  40|+    {
|    |  41|+        TrieNode *node = childSearch (word);
|    |  42|+        if (node)
|    |  43|+          {
|    |  44|+              return node->is_string;
|    |  45|+          }
|    |  46|+        return false;
|  45|  47|     }
|  46|  48| 
|  47|  49|     // Returns if there is any word in the trie
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  46|  46| 
|  47|  47|     // Returns if there is any word in the trie
|  48|  48|     // that starts with the given prefix.
|  49|    |-    bool startsWith(string prefix) {
|  50|    |-        return childSearch(prefix);
|    |  49|+    bool startsWith (string prefix)
|    |  50|+    {
|    |  51|+        return childSearch (prefix);
|  51|  52|     }
|  52|  53| 
|  53|  54|     TrieNode * childSearch(const string& word) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  50|  50|         return childSearch(prefix);
|  51|  51|     }
|  52|  52| 
|  53|    |-    TrieNode * childSearch(const string& word) {
|    |  53|+    TrieNode *childSearch (const string & word)
|    |  54|+    {
|  54|  55|         TrieNode *cur = root;
|  55|    |-        for (const auto& c : word) {
|  56|    |-            if (cur->leaves.count(c)) {
|  57|    |-                cur = cur->leaves[c];
|  58|    |-            } else {
|  59|    |-                return nullptr;
|  60|    |-            }
|  61|    |-        }
|    |  56|+      for (const auto & c:word)
|    |  57|+          {
|    |  58|+              if (cur->leaves.count (c))
|    |  59|+                {
|    |  60|+                    cur = cur->leaves[c];
|    |  61|+                }
|    |  62|+              else
|    |  63|+                {
|    |  64|+                    return nullptr;
|    |  65|+                }
|    |  66|+          }
|  62|  67|         return cur;
|  63|  68|     }
|  64|  69| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-trie.cpp
|    |++++| /app/C++/implement-trie.cpp
|  62|  62|         return cur;
|  63|  63|     }
|  64|  64| 
|  65|    |-private:
|  66|    |-    TrieNode* root;
|    |  65|+  private:
|    |  66|+    TrieNode * root;
|  67|  67| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: An integer
|  21|  21|      */
|  22|    |-    int maxPathSum(TreeNode *root) {
|  23|    |-        maxPathSumHelper(root);
|    |  22|+    int maxPathSum (TreeNode * root)
|    |  23|+    {
|    |  24|+        maxPathSumHelper (root);
|  24|  25|         return max_sum_;
|  25|  26|     }
|  26|  27| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  25|  25|     }
|  26|  26| 
|  27|  27|     // Return max height and update max path sum for each node.
|  28|    |-    int maxPathSumHelper(TreeNode *root) {
|  29|    |-        if (root == nullptr) {
|  30|    |-            return 0;
|  31|    |-        }
|    |  28|+    int maxPathSumHelper (TreeNode * root)
|    |  29|+    {
|    |  30|+        if (root == nullptr)
|    |  31|+          {
|    |  32|+              return 0;
|    |  33|+          }
|  32|  34| 
|  33|  35|         // Get max descendant sum of children.
|  34|  36|         // If the sum is less than zero, it can't be the path with max sum.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  32|  32| 
|  33|  33|         // Get max descendant sum of children.
|  34|  34|         // If the sum is less than zero, it can't be the path with max sum.
|  35|    |-        const auto left = max(0, maxPathSumHelper(root->left));
|  36|    |-        const auto right = max(0, maxPathSumHelper(root->right));
|    |  35|+        const auto left = max (0, maxPathSumHelper (root->left));
|    |  36|+        const auto right = max (0, maxPathSumHelper (root->right));
|  37|  37| 
|  38|  38|         // "max path sum" equals to:
|  39|  39|         // "max left descendant sum" -> root -> "max right descendant sum".
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  37|  37| 
|  38|  38|         // "max path sum" equals to:
|  39|  39|         // "max left descendant sum" -> root -> "max right descendant sum".
|  40|    |-        max_sum_ = max(max_sum_, root->val + left + right);
|    |  40|+        max_sum_ = max (max_sum_, root->val + left + right);
|  41|  41| 
|  42|  42|         // Return max descendant sum.
|  43|  43|         return root->val + max(left, right);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  40|  40|         max_sum_ = max(max_sum_, root->val + left + right);
|  41|  41| 
|  42|  42|         // Return max descendant sum.
|  43|    |-        return root->val + max(left, right);
|    |  43|+        return root->val + max (left, right);
|  44|  44|     }
|  45|  45| 
|  46|  46| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-maximum-path-sum.cpp
|    |++++| /app/C++/binary-tree-maximum-path-sum.cpp
|  43|  43|         return root->val + max(left, right);
|  44|  44|     }
|  45|  45| 
|  46|    |-private:
|  47|    |-    int max_sum_ = numeric_limits<int>::min();
|    |  46|+  private:
|    |  47|+    int max_sum_ = numeric_limits < int >::min ();
|  48|  48| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|   1|   1| // Time:  O(k * n * t)
|   2|   2| // Space: O(n * t)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: an integer array.
|   8|   9|      * @param k: a positive integer (k <= length(A))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|   9|   9|      * @param target: a integer
|  10|  10|      * @return an integer
|  11|  11|      */
|  12|    |-    int kSum(vector<int> A, int k, int target) {
|  13|    |-        const int n = A.size();
|    |  12|+    int kSum (vector < int >A, int k, int target)
|    |  13|+    {
|    |  14|+        const int n = A.size ();
|  14|  15| 
|  15|  16|         // table[i][j][t] denotes the number of ways to select,
|  16|  17|         // from first i elements, j elements whose sum equals to t
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  14|  14| 
|  15|  15|         // table[i][j][t] denotes the number of ways to select,
|  16|  16|         // from first i elements, j elements whose sum equals to t
|  17|    |-        vector<vector<vector<int>>> table(2, vector<vector<int>>(n + 1, vector<int>(target + 1, 0)));
|    |  17|+          vector < vector < vector < int >>>table (2,
|    |  18|+                                                   vector < vector <
|    |  19|+                                                   int >>(n + 1,
|    |  20|+                                                          vector <
|    |  21|+                                                          int >(target + 1,
|    |  22|+                                                                0)));
|  18|  23| 
|  19|    |-        for (int i = 1; i <= n; ++i) {
|  20|    |-            if (A[i - 1] <= target) {
|  21|    |-                for (int j = i; j <= n; ++j) {
|  22|    |-                    table[1][j][A[i - 1]] = 1;
|    |  24|+        for (int i = 1; i <= n; ++i)
|    |  25|+          {
|    |  26|+              if (A[i - 1] <= target)
|    |  27|+                {
|    |  28|+                    for (int j = i; j <= n; ++j)
|    |  29|+                      {
|    |  30|+                          table[1][j][A[i - 1]] = 1;
|    |  31|+                      }
|  23|  32|                 }
|  24|    |-            }
|  25|    |-        }
|    |  33|+          }
|  26|  34| 
|  27|    |-        for (int i = 2; i <= k; ++i) {
|  28|    |-            for (int j = i; j <= n; ++j) {
|  29|    |-                for (int p = 1; p <= target; ++p) {
|  30|    |-                    table[i % 2][j][p] = 0;
|  31|    |-                    if (i < j) {
|  32|    |-                        table[i % 2][j][p] = table[i % 2][j - 1][p];
|  33|    |-                    }
|  34|    |-                    if (p - A[j - 1] >= 0) {
|  35|    |-                        table[i % 2][j][p] += table[(i - 1) % 2][j - 1][p - A[j - 1]];
|  36|    |-                    }
|    |  35|+        for (int i = 2; i <= k; ++i)
|    |  36|+          {
|    |  37|+              for (int j = i; j <= n; ++j)
|    |  38|+                {
|    |  39|+                    for (int p = 1; p <= target; ++p)
|    |  40|+                      {
|    |  41|+                          table[i % 2][j][p] = 0;
|    |  42|+                          if (i < j)
|    |  43|+                            {
|    |  44|+                                table[i % 2][j][p] = table[i % 2][j - 1][p];
|    |  45|+                            }
|    |  46|+                          if (p - A[j - 1] >= 0)
|    |  47|+                            {
|    |  48|+                                table[i % 2][j][p] +=
|    |  49|+                                    table[(i - 1) % 2][j - 1][p - A[j - 1]];
|    |  50|+                            }
|    |  51|+                      }
|  37|  52|                 }
|  38|    |-            }
|  39|    |-        }
|    |  53|+          }
|  40|  54| 
|  41|  55|         return table[k % 2][n][target];
|  42|  56|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  44|  44| 
|  45|  45| // Time:  O(k * n * t)
|  46|  46| // Space: O(k * n * t)
|  47|    |-class Solution2 {
|  48|    |-public:
|    |  47|+class Solution2
|    |  48|+{
|    |  49|+  public:
|  49|  50|     /**
|  50|  51|      * @param A: an integer array.
|  51|  52|      * @param k: a positive integer (k <= length(A))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  52|  52|      * @param target: a integer
|  53|  53|      * @return an integer
|  54|  54|      */
|  55|    |-    int kSum(vector<int> A, int k, int target) {
|  56|    |-        const int n = A.size();
|    |  55|+    int kSum (vector < int >A, int k, int target)
|    |  56|+    {
|    |  57|+        const int n = A.size ();
|  57|  58| 
|  58|  59|         // table[i][j][t] denotes the number of ways to select,
|  59|  60|         // from first i elements, j elements whose sum equals to t
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  57|  57| 
|  58|  58|         // table[i][j][t] denotes the number of ways to select,
|  59|  59|         // from first i elements, j elements whose sum equals to t
|  60|    |-        vector<vector<vector<int>>> table(n+1, vector<vector<int>>(k + 1, vector<int>(target + 1, 0)));
|    |  60|+          vector < vector < vector < int >>>table (n + 1,
|    |  61|+                                                   vector < vector <
|    |  62|+                                                   int >>(k + 1,
|    |  63|+                                                          vector <
|    |  64|+                                                          int >(target + 1,
|    |  65|+                                                                0)));
|  61|  66| 
|  62|    |-        for (int i = 1; i <= n; ++i) {
|  63|    |-            if (A[i - 1] <= target)
|  64|    |-            {
|  65|    |-                for (int j = i; j <= n; ++j) {
|  66|    |-                    table[j][1][A[i - 1]] = 1;
|    |  67|+        for (int i = 1; i <= n; ++i)
|    |  68|+          {
|    |  69|+              if (A[i - 1] <= target)
|    |  70|+                {
|    |  71|+                    for (int j = i; j <= n; ++j)
|    |  72|+                      {
|    |  73|+                          table[j][1][A[i - 1]] = 1;
|    |  74|+                      }
|  67|  75|                 }
|  68|    |-            }
|  69|    |-        }
|    |  76|+          }
|  70|  77| 
|  71|    |-        for (int i = 1; i <= n; ++i) {
|  72|    |-            for (int j = min(i, k); j > 1; --j) {
|  73|    |-                for (int p = 1; p <= target; ++p) {
|  74|    |-                    table[i][j][p] = table[i - 1][j][p];
|  75|    |-                    if (p - A[i - 1] >= 0) {
|  76|    |-                        table[i][j][p] += table[i - 1][j - 1][p - A[i - 1]];
|  77|    |-                    }
|    |  78|+        for (int i = 1; i <= n; ++i)
|    |  79|+          {
|    |  80|+              for (int j = min (i, k); j > 1; --j)
|    |  81|+                {
|    |  82|+                    for (int p = 1; p <= target; ++p)
|    |  83|+                      {
|    |  84|+                          table[i][j][p] = table[i - 1][j][p];
|    |  85|+                          if (p - A[i - 1] >= 0)
|    |  86|+                            {
|    |  87|+                                table[i][j][p] +=
|    |  88|+                                    table[i - 1][j - 1][p - A[i - 1]];
|    |  89|+                            }
|    |  90|+                      }
|  78|  91|                 }
|  79|    |-            }
|  80|    |-        }
|    |  92|+          }
|  81|  93| 
|  82|  94|         return table[n][k][target];
|  83|  95|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  85|  85| 
|  86|  86| // Time:  O(C(n, k))
|  87|  87| // Space: O(k)
|  88|    |-class Solution_TLE {
|  89|    |-public:
|    |  88|+class Solution_TLE
|    |  89|+{
|    |  90|+  public:
|  90|  91|     /**
|  91|  92|      * @param A: an integer array.
|  92|  93|      * @param k: a positive integer (k <= length(A))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  93|  93|      * @param target: a integer
|  94|  94|      * @return an integer
|  95|  95|      */
|  96|    |-    int kSum(vector<int> A, int k, int target) {
|    |  96|+    int kSum (vector < int >A, int k, int target)
|    |  97|+    {
|  97|  98|         int ans = 0;
|  98|    |-        helper(A, k, 0, target, ans);
|  99|    |-        return ans;
|    |  99|+          helper (A, k, 0, target, ans);
|    | 100|+          return ans;
| 100| 101|     }
| 101| 102| 
| 102| 103|     void helper(vector<int> A, int k, int start, int target, int & ans) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum.cpp
|    |++++| /app/C++/k-sum.cpp
|  99|  99|         return ans;
| 100| 100|     }
| 101| 101| 
| 102|    |-    void helper(vector<int> A, int k, int start, int target, int & ans) {
| 103|    |-        if (k < 0 || target < 0) return;
|    | 102|+    void helper (vector < int >A, int k, int start, int target, int &ans)
|    | 103|+    {
|    | 104|+        if (k < 0 || target < 0)
|    | 105|+            return;
| 104| 106| 
| 105|    |-        if (k == 0 && target == 0) {
| 106|    |-            ++ans;
| 107|    |-            return;
| 108|    |-        }
|    | 107|+        if (k == 0 && target == 0)
|    | 108|+          {
|    | 109|+              ++ans;
|    | 110|+              return;
|    | 111|+          }
| 109| 112| 
| 110|    |-        for (int i = start; i <= A.size() - k; i++)
| 111|    |-            helper(A, k - 1, i + 1, target - A[i], ans);
|    | 113|+        for (int i = start; i <= A.size () - k; i++)
|    | 114|+            helper (A, k - 1, i + 1, target - A[i], ans);
| 112| 115|     }
| 113| 116| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list.cpp
|    |++++| /app/C++/reverse-linked-list.cpp
|  15|  15|  *     }
|  16|  16|  * }
|  17|  17|  */
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      * @param head: The first node of linked list.
|  22|  23|      * @return: The new head of reversed linked list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list.cpp
|    |++++| /app/C++/reverse-linked-list.cpp
|  21|  21|      * @param head: The first node of linked list.
|  22|  22|      * @return: The new head of reversed linked list.
|  23|  23|      */
|  24|    |-    ListNode *reverse(ListNode *head) {
|  25|    |-        ListNode dummy{0};
|    |  24|+    ListNode * reverse (ListNode * head)
|    |  25|+    {
|    |  26|+        ListNode dummy
|    |  27|+        {
|    |  28|+        0};
|  26|  29| 
|  27|    |-        while (head != nullptr) {
|  28|    |-            auto tmp = head->next;
|  29|    |-            head->next = dummy.next;
|  30|    |-            dummy.next = head;
|  31|    |-            head = tmp;
|  32|    |-        }
|    |  30|+        while (head != nullptr)
|    |  31|+          {
|    |  32|+              auto tmp = head->next;
|    |  33|+                head->next = dummy.next;
|    |  34|+                dummy.next = head;
|    |  35|+                head = tmp;
|    |  36|+          }
|  33|  37| 
|  34|  38|         return dummy.next;
|  35|  39|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list.cpp
|    |++++| /app/C++/reverse-linked-list.cpp
|  34|  34|         return dummy.next;
|  35|  35|     }
|  36|  36| };
|  37|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  15|  15|  */
|  16|  16| 
|  17|  17| // Morris Traversal.
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      * @param root: The root of binary tree.
|  22|  23|      * @return: Preorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  21|  21|      * @param root: The root of binary tree.
|  22|  22|      * @return: Preorder in vector which contains node values.
|  23|  23|      */
|  24|    |-    vector<int> preorderTraversal(TreeNode *root) {
|  25|    |-        vector<int> res;
|    |  24|+    vector < int >preorderTraversal (TreeNode * root)
|    |  25|+    {
|    |  26|+        vector < int >res;
|  26|  27|         TreeNode *prev = nullptr;
|  27|  28|         TreeNode *curr = root;
|  28|  29|         while (curr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  25|  25|         vector<int> res;
|  26|  26|         TreeNode *prev = nullptr;
|  27|  27|         TreeNode *curr = root;
|  28|    |-        while (curr) {
|  29|    |-            if (!curr->left) {
|  30|    |-                res.emplace_back(curr->val);
|  31|    |-                prev = curr;
|  32|    |-                curr = curr->right;
|  33|    |-            } else {
|  34|    |-                TreeNode *node = curr->left;
|  35|    |-                while (node->right && node->right != curr) {
|  36|    |-                    node = node->right;
|  37|    |-                }
|  38|    |-                if (!node->right) {
|  39|    |-                    res.emplace_back(curr->val);
|    |  28|+        while (curr)
|    |  29|+          {
|    |  30|+              if (!curr->left)
|    |  31|+                {
|    |  32|+                    res.emplace_back (curr->val);
|  40|  33|                     prev = curr;
|  41|    |-                    node->right = curr;
|  42|    |-                    curr = curr->left;
|  43|    |-                } else {
|  44|    |-                    node->right = nullptr;
|  45|  34|                     curr = curr->right;
|  46|  35|                 }
|  47|  36|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  44|  44|                     node->right = nullptr;
|  45|  45|                     curr = curr->right;
|  46|  46|                 }
|  47|    |-            }
|  48|    |-        }
|    |  47|+              else
|    |  48|+                {
|    |  49|+                    TreeNode *node = curr->left;
|    |  50|+                    while (node->right && node->right != curr)
|    |  51|+                      {
|    |  52|+                          node = node->right;
|    |  53|+                      }
|    |  54|+                    if (!node->right)
|    |  55|+                      {
|    |  56|+                          res.emplace_back (curr->val);
|    |  57|+                          prev = curr;
|    |  58|+                          node->right = curr;
|    |  59|+                          curr = curr->left;
|    |  60|+                      }
|    |  61|+                    else
|    |  62|+                      {
|    |  63|+                          node->right = nullptr;
|    |  64|+                          curr = curr->right;
|    |  65|+                      }
|    |  66|+                }
|    |  67|+          }
|  49|  68|         return res;
|  50|  69|     }
|  51|  70| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  50|  50|     }
|  51|  51| };
|  52|  52| 
|  53|    |-
|  54|  53| // Time:  O(n)
|  55|  54| // Space: O(h)
|  56|  55| // Stack solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  54|  54| // Time:  O(n)
|  55|  55| // Space: O(h)
|  56|  56| // Stack solution.
|  57|    |-class Solution2 {
|  58|    |-public:
|    |  57|+class Solution2
|    |  58|+{
|    |  59|+  public:
|  59|  60|     /**
|  60|  61|      * @param root: The root of binary tree.
|  61|  62|      * @return: Preorder in vector which contains node values.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-preorder-traversal.cpp
|    |++++| /app/C++/binary-tree-preorder-traversal.cpp
|  60|  60|      * @param root: The root of binary tree.
|  61|  61|      * @return: Preorder in vector which contains node values.
|  62|  62|      */
|  63|    |-    vector<int> preorderTraversal(TreeNode *root) {
|  64|    |-        vector<int> res;
|  65|    |-        stack<pair<TreeNode *, bool>> s;
|  66|    |-        s.emplace(root, false);
|  67|    |-        while (!s.empty()) {
|  68|    |-            bool visited;
|  69|    |-            tie(root, visited) = s.top();
|  70|    |-            s.pop();
|  71|    |-            if (root == nullptr) {
|  72|    |-                continue;
|  73|    |-            }
|  74|    |-            if (visited) {
|  75|    |-                res.emplace_back(root->val);
|  76|    |-            } else {
|  77|    |-                s.emplace(root->right, false);
|  78|    |-                s.emplace(root->left, false);
|  79|    |-                s.emplace(root, true);
|  80|    |-            }
|  81|    |-        }
|    |  63|+    vector < int >preorderTraversal (TreeNode * root)
|    |  64|+    {
|    |  65|+        vector < int >res;
|    |  66|+          stack < pair < TreeNode *, bool >> s;
|    |  67|+          s.emplace (root, false);
|    |  68|+        while (!s.empty ())
|    |  69|+          {
|    |  70|+              bool visited;
|    |  71|+                tie (root, visited) = s.top ();
|    |  72|+                s.pop ();
|    |  73|+              if (root == nullptr)
|    |  74|+                {
|    |  75|+                    continue;
|    |  76|+                }
|    |  77|+              if (visited)
|    |  78|+                {
|    |  79|+                    res.emplace_back (root->val);
|    |  80|+                }
|    |  81|+              else
|    |  82|+                {
|    |  83|+                    s.emplace (root->right, false);
|    |  84|+                    s.emplace (root->left, false);
|    |  85|+                    s.emplace (root, true);
|    |  86|+                }
|    |  87|+          }
|  82|  88|         return res;
|  83|  89|     }
|  84|  90| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param expression: a vector of strings;
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|   7|   7|      * @param expression: a vector of strings;
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int evaluateExpression(vector<string> &expression) {
|  11|    |-        stack<int> operands;
|  12|    |-        stack<string> operators;
|  13|    |-        if (expression.empty()) {
|  14|    |-            return 0;
|  15|    |-        }
|  16|    |-        for (int i = expression.size() - 1; i >= 0; --i) {
|  17|    |-            if (isdigit(expression[i][0])) {
|  18|    |-                operands.emplace(stoi(expression[i]));
|  19|    |-            } else if (expression[i] == ")" || expression[i] == "*" ||
|  20|    |-                       expression[i] == "/") {
|  21|    |-                operators.emplace(expression[i]);
|  22|    |-            } else if (expression[i] == "+" || expression[i] == "-") {
|  23|    |-                while (!operators.empty() && (operators.top() == "*" ||
|  24|    |-                       operators.top() == "/")) {
|  25|    |-                     compute(operands, operators);
|    |  10|+    int evaluateExpression (vector < string > &expression)
|    |  11|+    {
|    |  12|+        stack < int >operands;
|    |  13|+          stack < string > operators;
|    |  14|+        if (expression.empty ())
|    |  15|+          {
|    |  16|+              return 0;
|    |  17|+          }
|    |  18|+        for (int i = expression.size () - 1; i >= 0; --i)
|    |  19|+          {
|    |  20|+              if (isdigit (expression[i][0]))
|    |  21|+                {
|    |  22|+                    operands.emplace (stoi (expression[i]));
|  26|  23|                 }
|  27|    |-                operators.emplace(expression[i]);
|  28|    |-            } else if (expression[i] == "(") {
|  29|    |-                // operators at least one element, i.e. ")".
|  30|    |-                while (operators.top() != ")") {
|  31|    |-                    compute(operands, operators);
|    |  24|+              else if (expression[i] == ")" || expression[i] == "*" ||
|    |  25|+                       expression[i] == "/")
|    |  26|+                {
|    |  27|+                    operators.emplace (expression[i]);
|  32|  28|                 }
|  33|    |-                operators.pop();
|  34|    |-            }
|  35|    |-        }
|  36|    |-        while (!operators.empty()) {
|  37|    |-            compute(operands, operators);
|  38|    |-        }
|  39|    |-        return operands.top();
|    |  29|+              else if (expression[i] == "+" || expression[i] == "-")
|    |  30|+                {
|    |  31|+                    while (!operators.empty () && (operators.top () == "*" ||
|    |  32|+                                                   operators.top () == "/"))
|    |  33|+                      {
|    |  34|+                          compute (operands, operators);
|    |  35|+                      }
|    |  36|+                    operators.emplace (expression[i]);
|    |  37|+                }
|    |  38|+              else if (expression[i] == "(")
|    |  39|+                {
|    |  40|+                    // operators at least one element, i.e. ")".
|    |  41|+                    while (operators.top () != ")")
|    |  42|+                      {
|    |  43|+                          compute (operands, operators);
|    |  44|+                      }
|    |  45|+                    operators.pop ();
|    |  46|+                }
|    |  47|+          }
|    |  48|+        while (!operators.empty ())
|    |  49|+          {
|    |  50|+              compute (operands, operators);
|    |  51|+          }
|    |  52|+        return operands.top ();
|  40|  53|     }
|  41|  54| 
|  42|    |-    void compute(stack<int>& operands, stack<string>& operators) {
|  43|    |-        const int left = operands.top();
|  44|    |-        operands.pop();
|  45|    |-        const int right = operands.top();
|  46|    |-        operands.pop();
|  47|    |-        const string op = operators.top();
|  48|    |-        operators.pop();
|  49|    |-        if (op == "+") {
|  50|    |-            operands.emplace(left + right);
|  51|    |-        } else if (op == "-") {
|  52|    |-            operands.emplace(left - right);
|  53|    |-        } else if (op == "*") {
|  54|    |-            operands.emplace(left * right);
|  55|    |-        } else if (op == "/") {
|  56|    |-            operands.emplace(left / right);
|  57|    |-        }
|    |  55|+    void compute (stack < int >&operands, stack < string > &operators)
|    |  56|+    {
|    |  57|+        const int left = operands.top ();
|    |  58|+        operands.pop ();
|    |  59|+        const int right = operands.top ();
|    |  60|+        operands.pop ();
|    |  61|+        const string op = operators.top ();
|    |  62|+        operators.pop ();
|    |  63|+        if (op == "+")
|    |  64|+          {
|    |  65|+              operands.emplace (left + right);
|    |  66|+          }
|    |  67|+        else if (op == "-")
|    |  68|+          {
|    |  69|+              operands.emplace (left - right);
|    |  70|+          }
|    |  71|+        else if (op == "*")
|    |  72|+          {
|    |  73|+              operands.emplace (left * right);
|    |  74|+          }
|    |  75|+        else if (op == "/")
|    |  76|+          {
|    |  77|+              operands.emplace (left / right);
|    |  78|+          }
|  58|  79|     }
|  59|  80| };
|  60|  81| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|  57|  57|         }
|  58|  58|     }
|  59|  59| };
|  60|    |-
|  61|  60| 
|  62|  61| // Time:  O(n)
|  63|  62| // Space: O(n)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|  61|  61| 
|  62|  62| // Time:  O(n)
|  63|  63| // Space: O(n)
|  64|    |-class Solution2 {
|  65|    |-public:
|    |  64|+class Solution2
|    |  65|+{
|    |  66|+  public:
|  66|  67|     /**
|  67|  68|      * @param expression: a vector of strings;
|  68|  69|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|  67|  67|      * @param expression: a vector of strings;
|  68|  68|      * @return: an integer
|  69|  69|      */
|  70|    |-    int evaluateExpression(vector<string> &expression) {
|  71|    |-        if (expression.empty()) {
|  72|    |-            return 0;
|  73|    |-        }
|  74|    |-        vector<string> postfix;
|  75|    |-        infixToPostfix(expression, postfix);
|  76|    |-        return evaluatePostfixExpression(postfix);
|    |  70|+    int evaluateExpression (vector < string > &expression)
|    |  71|+    {
|    |  72|+        if (expression.empty ())
|    |  73|+          {
|    |  74|+              return 0;
|    |  75|+          }
|    |  76|+        vector < string > postfix;
|    |  77|+        infixToPostfix (expression, postfix);
|    |  78|+        return evaluatePostfixExpression (postfix);
|  77|  79|     }
|  78|  80| 
|  79|  81|     // Evaluate Postfix Expression.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
|  77|  77|     }
|  78|  78| 
|  79|  79|     // Evaluate Postfix Expression.
|  80|    |-    int evaluatePostfixExpression(const vector<string> &postfix) {
|  81|    |-        if (postfix.empty()) {
|  82|    |-            return 0;
|  83|    |-        }
|  84|    |-        stack<string> s;
|  85|    |-        for (const auto& tok : postfix) {
|  86|    |-            if (!is_operator(tok)) {
|  87|    |-                s.emplace(tok);
|  88|    |-            } else {
|  89|    |-                int y = stoi(s.top());
|  90|    |-                s.pop();
|  91|    |-                int x = stoi(s.top());
|  92|    |-                s.pop();
|  93|    |-                if (tok[0] == '+') {
|  94|    |-                    x += y;
|  95|    |-                } else if (tok[0] == '-') {
|  96|    |-                    x -= y;
|  97|    |-                } else if (tok[0] == '*') {
|  98|    |-                    x *= y;
|  99|    |-                } else {
| 100|    |-                    x /= y;
|    |  80|+    int evaluatePostfixExpression (const vector < string > &postfix)
|    |  81|+    {
|    |  82|+        if (postfix.empty ())
|    |  83|+          {
|    |  84|+              return 0;
|    |  85|+          }
|    |  86|+        stack < string > s;
|    |  87|+      for (const auto & tok:postfix)
|    |  88|+          {
|    |  89|+              if (!is_operator (tok))
|    |  90|+                {
|    |  91|+                    s.emplace (tok);
| 101|  92|                 }
| 102|    |-                s.emplace(to_string(x));
| 103|    |-            }
| 104|    |-        }
| 105|    |-        return stoi(s.top());
|    |  93|+              else
|    |  94|+                {
|    |  95|+                    int y = stoi (s.top ());
|    |  96|+                    s.pop ();
|    |  97|+                    int x = stoi (s.top ());
|    |  98|+                    s.pop ();
|    |  99|+                    if (tok[0] == '+')
|    | 100|+                      {
|    | 101|+                          x += y;
|    | 102|+                      }
|    | 103|+                    else if (tok[0] == '-')
|    | 104|+                      {
|    | 105|+                          x -= y;
|    | 106|+                      }
|    | 107|+                    else if (tok[0] == '*')
|    | 108|+                      {
|    | 109|+                          x *= y;
|    | 110|+                      }
|    | 111|+                    else
|    | 112|+                      {
|    | 113|+                          x /= y;
|    | 114|+                      }
|    | 115|+                    s.emplace (to_string (x));
|    | 116|+                }
|    | 117|+          }
|    | 118|+        return stoi (s.top ());
| 106| 119|     }
| 107| 120| 
| 108|    |-    bool is_operator(const string &op) {
| 109|    |-        return op.length() == 1 && string("+-*/").find(op) != string::npos;
|    | 121|+    bool is_operator (const string & op)
|    | 122|+    {
|    | 123|+        return op.length () == 1 && string ("+-*/").find (op) != string::npos;
| 110| 124|     }
| 111| 125| 
| 112| 126|     // Convert Infix to Postfix Expression.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/expression-evaluation.cpp
|    |++++| /app/C++/expression-evaluation.cpp
| 110| 110|     }
| 111| 111| 
| 112| 112|     // Convert Infix to Postfix Expression.
| 113|    |-    void infixToPostfix(vector<string>& infix, vector<string>& postfix) {
| 114|    |-        stack<string> s;
| 115|    |-        for (auto tok : infix) {
| 116|    |-            // Any number would be pushed into stack.
| 117|    |-            if (atoi(tok.c_str())) {
| 118|    |-                postfix.emplace_back(tok);
| 119|    |-            } else if (tok == "(") {
| 120|    |-                s.emplace(tok);
| 121|    |-            } else if (tok == ")") {
| 122|    |-                // Meet ")", then pop until "(".
| 123|    |-                while (!s.empty()) {
| 124|    |-                    tok = s.top();
| 125|    |-                    s.pop();
| 126|    |-                    if (tok == "(") {
| 127|    |-                        break;
| 128|    |-                    }
| 129|    |-                    postfix.emplace_back(tok);
|    | 113|+    void infixToPostfix (vector < string > &infix, vector < string > &postfix)
|    | 114|+    {
|    | 115|+        stack < string > s;
|    | 116|+      for (auto tok:infix)
|    | 117|+          {
|    | 118|+              // Any number would be pushed into stack.
|    | 119|+              if (atoi (tok.c_str ()))
|    | 120|+                {
|    | 121|+                    postfix.emplace_back (tok);
| 130| 122|                 }
| 131|    |-            } else {
| 132|    |-                // Order of tokens in stack should be like "(-*",
| 133|    |-                // The token will be added in an strictly increasing precedence order.
| 134|    |-                while (!s.empty() && precedence(tok) <= precedence(s.top())) {
| 135|    |-                    postfix.emplace_back(s.top());
| 136|    |-                    s.pop();
|    | 123|+              else if (tok == "(")
|    | 124|+                {
|    | 125|+                    s.emplace (tok);
| 137| 126|                 }
| 138|    |-                s.emplace(tok);
| 139|    |-            }
| 140|    |-        }
|    | 127|+              else if (tok == ")")
|    | 128|+                {
|    | 129|+                    // Meet ")", then pop until "(".
|    | 130|+                    while (!s.empty ())
|    | 131|+                      {
|    | 132|+                          tok = s.top ();
|    | 133|+                          s.pop ();
|    | 134|+                          if (tok == "(")
|    | 135|+                            {
|    | 136|+                                break;
|    | 137|+                            }
|    | 138|+                          postfix.emplace_back (tok);
|    | 139|+                      }
|    | 140|+                }
|    | 141|+              else
|    | 142|+                {
|    | 143|+                    // Order of tokens in stack should be like "(-*",
|    | 144|+                    // The token will be added in an strictly increasing precedence order.
|    | 145|+                    while (!s.empty ()
|    | 146|+                           && precedence (tok) <= precedence (s.top ()))
|    | 147|+                      {
|    | 148|+                          postfix.emplace_back (s.top ());
|    | 149|+                          s.pop ();
|    | 150|+                      }
|    | 151|+                    s.emplace (tok);
|    | 152|+                }
|    | 153|+          }
| 141| 154|         // Pop the remaining token and add them to the postfix.
| 142|    |-        while (!s.empty()) {
| 143|    |-            postfix.emplace_back(s.top());
| 144|    |-            s.pop();
| 145|    |-        }
|    | 155|+        while (!s.empty ())
|    | 156|+          {
|    | 157|+              postfix.emplace_back (s.top ());
|    | 158|+              s.pop ();
|    | 159|+          }
| 146| 160|     }
| 147| 161| 
| 148|    |-    int precedence(string x) {
| 149|    |-        if (x == "(") {  // The least precedence.
| 150|    |-            return 0;
| 151|    |-        } else if (x == "+" || x == "-") {
| 152|    |-            return 1;
| 153|    |-        } else if (x == "*" || x == "/") {
| 154|    |-            return 2;
| 155|    |-        }
|    | 162|+    int precedence (string x)
|    | 163|+    {
|    | 164|+        if (x == "(")
|    | 165|+          {                     // The least precedence.
|    | 166|+              return 0;
|    | 167|+          }
|    | 168|+        else if (x == "+" || x == "-")
|    | 169|+          {
|    | 170|+              return 1;
|    | 171|+          }
|    | 172|+        else if (x == "*" || x == "/")
|    | 173|+          {
|    | 174|+              return 2;
|    | 175|+          }
| 156| 176|         return 3;
| 157| 177|     }
| 158| 178| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-linked-list.cpp
|    |++++| /app/C++/palindrome-linked-list.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head a ListNode
|  16|  17|      * @return a boolean
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-linked-list.cpp
|    |++++| /app/C++/palindrome-linked-list.cpp
|  15|  15|      * @param head a ListNode
|  16|  16|      * @return a boolean
|  17|  17|      */
|  18|    |-    bool isPalindrome(ListNode* head) {
|    |  18|+    bool isPalindrome (ListNode * head)
|    |  19|+    {
|  19|  20|         // Reverse the first half list.
|  20|  21|         ListNode *reverse = nullptr, *fast = head;
|  21|  22|         while (fast && fast->next) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-linked-list.cpp
|    |++++| /app/C++/palindrome-linked-list.cpp
|  18|  18|     bool isPalindrome(ListNode* head) {
|  19|  19|         // Reverse the first half list.
|  20|  20|         ListNode *reverse = nullptr, *fast = head;
|  21|    |-        while (fast && fast->next) {
|  22|    |-            fast = fast->next->next;
|  23|    |-            const auto head_next = head->next;
|  24|    |-            head->next = reverse;
|  25|    |-            reverse = head;
|  26|    |-            head = head_next;
|  27|    |-        }
|    |  21|+        while (fast && fast->next)
|    |  22|+          {
|    |  23|+              fast = fast->next->next;
|    |  24|+              const auto head_next = head->next;
|    |  25|+                head->next = reverse;
|    |  26|+                reverse = head;
|    |  27|+                head = head_next;
|    |  28|+          }
|  28|  29| 
|  29|  30|         // If the number of the nodes is odd,
|  30|  31|         // set the head of the tail list to the next of the median node.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/palindrome-linked-list.cpp
|    |++++| /app/C++/palindrome-linked-list.cpp
|  33|  33|         // Compare the reversed first half list with the second half list.
|  34|  34|         // And restore the reversed first half list.
|  35|  35|         bool is_palindrome = true;
|  36|    |-        while (reverse) {
|  37|    |-            is_palindrome = is_palindrome && reverse->val == tail->val;
|  38|    |-            const auto reverse_next = reverse->next;
|  39|    |-            reverse->next = head;
|  40|    |-            head = reverse;
|  41|    |-            reverse = reverse_next;
|  42|    |-            tail = tail->next;
|  43|    |-        }
|  44|    |-            
|  45|    |-        return is_palindrome;   
|    |  36|+        while (reverse)
|    |  37|+          {
|    |  38|+              is_palindrome = is_palindrome && reverse->val == tail->val;
|    |  39|+              const auto reverse_next = reverse->next;
|    |  40|+              reverse->next = head;
|    |  41|+              head = reverse;
|    |  42|+              reverse = reverse_next;
|    |  43|+              tail = tail->next;
|    |  44|+          }
|    |  45|+
|    |  46|+        return is_palindrome;
|  46|  47|     }
|  47|  48| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber.cpp
|    |++++| /app/C++/house-robber.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An array of non-negative integers.
|   8|   9|      * return: The maximum amount of money you can rob tonight
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber.cpp
|    |++++| /app/C++/house-robber.cpp
|   7|   7|      * @param A: An array of non-negative integers.
|   8|   8|      * return: The maximum amount of money you can rob tonight
|   9|   9|      */
|  10|    |-    long long houseRobber(vector<int> nums) {
|  11|    |-        if (nums.size() == 0) {
|  12|    |-            return 0;
|  13|    |-        }
|  14|    |-        if (nums.size() == 1) {
|  15|    |-            return nums[0];
|  16|    |-        }
|    |  10|+    long long houseRobber (vector < int >nums)
|    |  11|+    {
|    |  12|+        if (nums.size () == 0)
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|    |  16|+        if (nums.size () == 1)
|    |  17|+          {
|    |  18|+              return nums[0];
|    |  19|+          }
|  17|  20| 
|  18|    |-        return robRange(nums, 0, nums.size());
|    |  21|+        return robRange (nums, 0, nums.size ());
|  19|  22| 
|  20|  23|     }
|  21|  24| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber.cpp
|    |++++| /app/C++/house-robber.cpp
|  19|  19| 
|  20|  20|     }
|  21|  21| 
|  22|    |-    long long robRange(const vector<int>& nums, const int start, const int end) {
|    |  22|+    long long robRange (const vector < int >&nums, const int start,
|    |  23|+                        const int end)
|    |  24|+    {
|  23|  25|         long long num_i = nums[start], num_i_1 = 0, num_i_2 = 0;
|  24|    |-        for (int i = start + 1; i < end; ++i) {
|  25|    |-            num_i_2 = num_i_1;
|  26|    |-            num_i_1 = num_i;
|  27|    |-            num_i = max(nums[i] + num_i_2, num_i_1);
|  28|    |-        }
|    |  26|+        for (int i = start + 1; i < end; ++i)
|    |  27|+          {
|    |  28|+              num_i_2 = num_i_1;
|    |  29|+              num_i_1 = num_i;
|    |  30|+              num_i = max (nums[i] + num_i_2, num_i_1);
|    |  31|+          }
|  29|  32|         return num_i;
|  30|  33|     }
|  31|  34| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-prefix.cpp
|    |++++| /app/C++/longest-common-prefix.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // BFS
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param strs: A list of strings
|   9|  10|      * @return: The longest common prefix
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-prefix.cpp
|    |++++| /app/C++/longest-common-prefix.cpp
|   8|   8|      * @param strs: A list of strings
|   9|   9|      * @return: The longest common prefix
|  10|  10|      */
|  11|    |-    string longestCommonPrefix(vector<string> &strs) {
|  12|    |-        if (strs.empty()) {
|  13|    |-            return "";
|  14|    |-        }
|    |  11|+    string longestCommonPrefix (vector < string > &strs)
|    |  12|+    {
|    |  13|+        if (strs.empty ())
|    |  14|+          {
|    |  15|+              return "";
|    |  16|+          }
|  15|  17| 
|  16|    |-        for (int i = 0; i < strs[0].length(); ++i) {
|  17|    |-            for (const auto& str : strs) {
|  18|    |-                if (i >= str.length() || str[i] != strs[0][i]) {
|  19|    |-                    return strs[0].substr(0, i);
|    |  18|+        for (int i = 0; i < strs[0].length (); ++i)
|    |  19|+          {
|    |  20|+            for (const auto & str:strs)
|    |  21|+                {
|    |  22|+                    if (i >= str.length () || str[i] != strs[0][i])
|    |  23|+                      {
|    |  24|+                          return strs[0].substr (0, i);
|    |  25|+                      }
|  20|  26|                 }
|  21|    |-            }
|  22|    |-        }
|    |  27|+          }
|  23|  28|         return strs[0];
|  24|  29|     }
|  25|  30| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-prefix.cpp
|    |++++| /app/C++/longest-common-prefix.cpp
|  28|  28| // Space: O(1)
|  29|  29| 
|  30|  30| // DFS
|  31|    |-class Solution2 {
|  32|    |-public:
|    |  31|+class Solution2
|    |  32|+{
|    |  33|+  public:
|  33|  34|     /**
|  34|  35|      * @param strs: A list of strings
|  35|  36|      * @return: The longest common prefix
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-prefix.cpp
|    |++++| /app/C++/longest-common-prefix.cpp
|  34|  34|      * @param strs: A list of strings
|  35|  35|      * @return: The longest common prefix
|  36|  36|      */
|  37|    |-    string longestCommonPrefix(vector<string> &strs) {
|  38|    |-        if (strs.empty()) {
|  39|    |-            return "";
|  40|    |-        }
|    |  37|+    string longestCommonPrefix (vector < string > &strs)
|    |  38|+    {
|    |  39|+        if (strs.empty ())
|    |  40|+          {
|    |  41|+              return "";
|    |  42|+          }
|  41|  43| 
|  42|    |-        auto prefix_len = strs[0].length();
|  43|    |-        for (const auto& str : strs) {
|  44|    |-            auto i = 0;
|  45|    |-            for (; i < str.length() && i < prefix_len && str[i] == strs[0][i]; ++i);
|  46|    |-            if (i < prefix_len) {
|  47|    |-                prefix_len = i;
|  48|    |-            }
|  49|    |-        }
|  50|    |-        return strs[0].substr(0, prefix_len);
|    |  44|+        auto prefix_len = strs[0].length ();
|    |  45|+      for (const auto & str:strs)
|    |  46|+          {
|    |  47|+              auto i = 0;
|    |  48|+              for (;
|    |  49|+                   i < str.length () && i < prefix_len && str[i] == strs[0][i];
|    |  50|+                   ++i) ;
|    |  51|+              if (i < prefix_len)
|    |  52|+                {
|    |  53|+                    prefix_len = i;
|    |  54|+                }
|    |  55|+          }
|    |  56|+        return strs[0].substr (0, prefix_len);
|  51|  57|     }
|  52|  58| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/two-strings-are-anagrams.cpp
|    |++++| /app/C++/two-strings-are-anagrams.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s: The first string
|   8|   9|      * @param b: The second string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/two-strings-are-anagrams.cpp
|    |++++| /app/C++/two-strings-are-anagrams.cpp
|   8|   8|      * @param b: The second string
|   9|   9|      * @return true or false
|  10|  10|      */
|  11|    |-    bool anagram(string s, string t) {
|  12|    |-        if (s.length() != t.length()) {
|  13|    |-            return false;
|  14|    |-        }
|    |  11|+    bool anagram (string s, string t)
|    |  12|+    {
|    |  13|+        if (s.length () != t.length ())
|    |  14|+          {
|    |  15|+              return false;
|    |  16|+          }
|  15|  17| 
|  16|    |-        unordered_map<char, int> count;
|    |  18|+        unordered_map < char, int >count;
|  17|  19| 
|  18|    |-        for (const auto& c: s) {
|  19|    |-            ++count[tolower(c)];
|  20|    |-        }
|    |  20|+      for (const auto & c:s)
|    |  21|+          {
|    |  22|+              ++count[tolower (c)];
|    |  23|+          }
|  21|  24| 
|  22|    |-        for (const auto& c: t) {
|  23|    |-            --count[tolower(c)];
|  24|    |-            if (count[tolower(c)] < 0) {
|  25|    |-                return false;
|  26|    |-            }
|  27|    |-        }
|    |  25|+      for (const auto & c:t)
|    |  26|+          {
|    |  27|+              --count[tolower (c)];
|    |  28|+              if (count[tolower (c)] < 0)
|    |  29|+                {
|    |  30|+                    return false;
|    |  31|+                }
|    |  32|+          }
|  28|  33| 
|  29|  34|         return true;
|  30|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-subarray.cpp
|    |++++| /app/C++/minimum-subarray.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: a list of integers
|   8|   9|      * @return: A integer denote the sum of minimum subarray
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-subarray.cpp
|    |++++| /app/C++/minimum-subarray.cpp
|   7|   7|      * @param nums: a list of integers
|   8|   8|      * @return: A integer denote the sum of minimum subarray
|   9|   9|      */
|  10|    |-    int minSubArray(vector<int> nums) {
|    |  10|+    int minSubArray (vector < int >nums)
|    |  11|+    {
|  11|  12|         int min_sum = INT_MAX, sum = 0;
|  12|    |-        for (auto& i : nums) {
|  13|    |-            sum += i;
|  14|    |-            min_sum = min(min_sum, sum);
|  15|    |-            if (sum > 0) {
|  16|    |-                sum = 0;
|  17|    |-            }
|  18|    |-        }
|    |  13|+        for (auto & i:nums)
|    |  14|+          {
|    |  15|+              sum += i;
|    |  16|+              min_sum = min (min_sum, sum);
|    |  17|+              if (sum > 0)
|    |  18|+                {
|    |  19|+                    sum = 0;
|    |  20|+                }
|    |  21|+          }
|  19|  22|         return min_sum;
|  20|  23|     }
|  21|  24| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element.cpp
|    |++++| /app/C++/find-peak-element.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An integers array.
|   8|   9|      * @return: return any of peek positions.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element.cpp
|    |++++| /app/C++/find-peak-element.cpp
|   7|   7|      * @param A: An integers array.
|   8|   8|      * @return: return any of peek positions.
|   9|   9|      */
|  10|    |-    int findPeak(vector<int> A) {
|  11|    |-        int left = 0, right = A.size() - 1;
|  12|    |-        
|  13|    |-        while (left < right) {
|  14|    |-            const auto mid = left + (right - left) / 2;
|  15|    |-            if ((mid == 0 || A[mid - 1] < A[mid]) &&
|  16|    |-               (mid + 1 == A.size() || A[mid] > A[mid + 1])) {
|  17|    |-                return mid;
|  18|    |-            } else if (!(mid == 0 || A[mid - 1] < A[mid])) {
|  19|    |-                right = mid;
|  20|    |-            } else {
|  21|    |-                left = mid + 1;
|  22|    |-            }
|  23|    |-        }
|  24|    |-       
|    |  10|+    int findPeak (vector < int >A)
|    |  11|+    {
|    |  12|+        int left = 0, right = A.size () - 1;
|    |  13|+
|    |  14|+        while (left < right)
|    |  15|+          {
|    |  16|+              const auto mid = left + (right - left) / 2;
|    |  17|+              if ((mid == 0 || A[mid - 1] < A[mid]) &&
|    |  18|+                  (mid + 1 == A.size () || A[mid] > A[mid + 1]))
|    |  19|+                {
|    |  20|+                    return mid;
|    |  21|+                }
|    |  22|+              else if (!(mid == 0 || A[mid - 1] < A[mid]))
|    |  23|+                {
|    |  24|+                    right = mid;
|    |  25|+                }
|    |  26|+              else
|    |  27|+                {
|    |  28|+                    left = mid + 1;
|    |  29|+                }
|    |  30|+          }
|    |  31|+
|  25|  32|         return left;
|  26|  33|     }
|  27|  34| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/set-matrix-zeroes.cpp
|    |++++| /app/C++/set-matrix-zeroes.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: A list of lists of integers
|   8|   9|      * @return: Void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/set-matrix-zeroes.cpp
|    |++++| /app/C++/set-matrix-zeroes.cpp
|   7|   7|      * @param matrix: A list of lists of integers
|   8|   8|      * @return: Void
|   9|   9|      */
|  10|    |-    void setZeroes(vector<vector<int>> &matrix) {
|  11|    |-        if (matrix.empty()) {
|  12|    |-            return;
|  13|    |-        }
|    |  10|+    void setZeroes (vector < vector < int >>&matrix)
|    |  11|+    {
|    |  12|+        if (matrix.empty ())
|    |  13|+          {
|    |  14|+              return;
|    |  15|+          }
|  14|  16| 
|  15|  17|         bool has_zero = false;
|  16|  18|         int zero_i = -1, zero_j = -1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/set-matrix-zeroes.cpp
|    |++++| /app/C++/set-matrix-zeroes.cpp
|  15|  15|         bool has_zero = false;
|  16|  16|         int zero_i = -1, zero_j = -1;
|  17|  17| 
|  18|    |-        for (int i = 0; i < matrix.size(); ++i) {
|  19|    |-            for (int j = 0; j < matrix[0].size(); ++j) {
|  20|    |-                if (matrix[i][j] == 0) {
|  21|    |-                    if (!has_zero) {
|  22|    |-                        zero_i = i;
|  23|    |-                        zero_j = j;
|  24|    |-                        has_zero = true;
|  25|    |-                    }
|  26|    |-                    matrix[zero_i][j] = 0;
|    |  18|+        for (int i = 0; i < matrix.size (); ++i)
|    |  19|+          {
|    |  20|+              for (int j = 0; j < matrix[0].size (); ++j)
|    |  21|+                {
|    |  22|+                    if (matrix[i][j] == 0)
|    |  23|+                      {
|    |  24|+                          if (!has_zero)
|    |  25|+                            {
|    |  26|+                                zero_i = i;
|    |  27|+                                zero_j = j;
|    |  28|+                                has_zero = true;
|    |  29|+                            }
|    |  30|+                          matrix[zero_i][j] = 0;
|    |  31|+                          matrix[i][zero_j] = 0;
|    |  32|+                      }
|    |  33|+                }
|    |  34|+          }
|    |  35|+
|    |  36|+        if (has_zero)
|    |  37|+          {
|    |  38|+              for (int i = 0; i < matrix.size (); ++i)
|    |  39|+                {
|    |  40|+                    if (i == zero_i)
|    |  41|+                      {
|    |  42|+                          continue;
|    |  43|+                      }
|    |  44|+                    for (int j = 0; j < matrix[0].size (); ++j)
|    |  45|+                      {
|    |  46|+                          if (j == zero_j)
|    |  47|+                            {
|    |  48|+                                continue;
|    |  49|+                            }
|    |  50|+                          if (matrix[zero_i][j] == 0 || matrix[i][zero_j] == 0)
|    |  51|+                            {
|    |  52|+                                matrix[i][j] = 0;
|    |  53|+                            }
|    |  54|+                      }
|    |  55|+                }
|    |  56|+              for (int i = 0; i < matrix.size (); ++i)
|    |  57|+                {
|  27|  58|                     matrix[i][zero_j] = 0;
|  28|  59|                 }
|  29|  60|             }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/set-matrix-zeroes.cpp
|    |++++| /app/C++/set-matrix-zeroes.cpp
|  26|  26|                     matrix[zero_i][j] = 0;
|  27|  27|                     matrix[i][zero_j] = 0;
|  28|  28|                 }
|  29|    |-            }
|  30|    |-        }
|  31|    |-
|  32|    |-        if (has_zero) {
|  33|    |-            for (int i = 0; i < matrix.size(); ++i) {
|  34|    |-                if (i == zero_i) {
|  35|    |-                    continue;
|    |  29|+              for (int j = 0; j < matrix[0].size (); ++j)
|    |  30|+                {
|    |  31|+                    matrix[zero_i][j] = 0;
|  36|  32|                 }
|  37|    |-                for (int j = 0; j < matrix[0].size(); ++j) {
|  38|    |-                    if (j == zero_j) {
|  39|    |-                        continue;
|  40|    |-                    }
|  41|    |-                    if (matrix[zero_i][j] == 0 || matrix[i][zero_j] == 0) {
|  42|    |-                        matrix[i][j] = 0;
|  43|    |-                    }
|  44|    |-                }
|  45|    |-            }
|  46|    |-            for (int i = 0; i < matrix.size(); ++i) {
|  47|    |-                matrix[i][zero_j] = 0;
|  48|    |-            }
|  49|    |-            for (int j = 0; j < matrix[0].size(); ++j) {
|  50|    |-                matrix[zero_i][j] = 0;
|  51|    |-            }
|  52|    |-        }
|    |  33|+          }
|  53|  34|     }
|  54|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  23|  23|  *     }
|  24|  24|  * }
|  25|  25|  */
|  26|    |-class Solution {
|  27|    |-public:
|    |  26|+class Solution
|    |  27|+{
|    |  28|+  public:
|  28|  29|     /**
|  29|  30|      * @param head: The first node of linked list.
|  30|  31|      * @return: a tree node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  29|  29|      * @param head: The first node of linked list.
|  30|  30|      * @return: a tree node
|  31|  31|      */
|  32|    |-    TreeNode *sortedListToBST(ListNode *L) {
|    |  32|+    TreeNode * sortedListToBST (ListNode * L)
|    |  33|+    {
|  33|  34|         auto curr = L;
|  34|  35|         int n = 0;
|  35|  36|         while (curr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  32|  32|     TreeNode *sortedListToBST(ListNode *L) {
|  33|  33|         auto curr = L;
|  34|  34|         int n = 0;
|  35|    |-        while (curr) {
|  36|    |-            curr = curr->next;
|  37|    |-            ++n;
|  38|    |-        }
|  39|    |-        return BuildBSTFromSortedDoublyListHelper(&L, 0, n);
|    |  35|+        while (curr)
|    |  36|+          {
|    |  37|+              curr = curr->next;
|    |  38|+              ++n;
|    |  39|+          }
|    |  40|+        return BuildBSTFromSortedDoublyListHelper (&L, 0, n);
|  40|  41|     }
|  41|  42| 
|  42|  43|     // Builds a BST from the (s + 1)-th to the e-th node in L, and returns the
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  41|  41| 
|  42|  42|     // Builds a BST from the (s + 1)-th to the e-th node in L, and returns the
|  43|  43|     // root. Node numbering is from 1 to n.
|  44|    |-    TreeNode * BuildBSTFromSortedDoublyListHelper(ListNode **L, int s, int e) {
|  45|    |-        if (s >= e) {
|  46|    |-            return nullptr;
|  47|    |-        }
|    |  44|+    TreeNode *BuildBSTFromSortedDoublyListHelper (ListNode ** L, int s, int e)
|    |  45|+    {
|    |  46|+        if (s >= e)
|    |  47|+          {
|    |  48|+              return nullptr;
|    |  49|+          }
|  48|  50| 
|  49|  51|         int m = s + ((e - s) / 2);
|  50|  52|         TreeNode *left = BuildBSTFromSortedDoublyListHelper(L, s, m);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  47|  47|         }
|  48|  48| 
|  49|  49|         int m = s + ((e - s) / 2);
|  50|    |-        TreeNode *left = BuildBSTFromSortedDoublyListHelper(L, s, m);
|  51|    |-        TreeNode *curr = new TreeNode((*L)->val);  // The last function call sets L to the successor of the
|  52|    |-                                                   // maximum node in the tree rooted at left.
|    |  50|+        TreeNode *left = BuildBSTFromSortedDoublyListHelper (L, s, m);
|    |  51|+        TreeNode *curr = new TreeNode ((*L)->val);  // The last function call sets L to the successor of the
|    |  52|+        // maximum node in the tree rooted at left.
|  53|  53|         *L = (*L)->next;
|  54|  54|         curr->left = left;
|  55|  55|         curr->right = BuildBSTFromSortedDoublyListHelper(L, m + 1, e);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|    |++++| /app/C++/convert-sorted-list-to-binary-search-tree.cpp
|  52|  52|                                                    // maximum node in the tree rooted at left.
|  53|  53|         *L = (*L)->next;
|  54|  54|         curr->left = left;
|  55|    |-        curr->right = BuildBSTFromSortedDoublyListHelper(L, m + 1, e);
|    |  55|+        curr->right = BuildBSTFromSortedDoublyListHelper (L, m + 1, e);
|  56|  56|         return curr;
|  57|  57|     }
|  58|  58| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wiggle-sort-ii.cpp
|    |++++| /app/C++/wiggle-sort-ii.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Tri Partition (aka Dutch National Flag Problem) with virtual index solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums a list of integer
|   9|  10|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wiggle-sort-ii.cpp
|    |++++| /app/C++/wiggle-sort-ii.cpp
|   7|   7|     /**
|   8|   8|      * @param nums a list of integer
|   9|   9|      * @return void
|  10|    |-     */  
|  11|    |-    void wiggleSort(vector<int>& nums) {
|  12|    |-        int mid = (nums.size() - 1) / 2;
|  13|    |-        nth_element(nums.begin(), nums.begin() + mid, nums.end());  // O(n) ~ O(n^2) time
|  14|    |-        reversedTriPartitionWithVI(nums, nums[mid]);  // O(n) time, O(1) space
|    |  10|+     */
|    |  11|+    void wiggleSort (vector < int >&nums)
|    |  12|+    {
|    |  13|+        int mid = (nums.size () - 1) / 2;
|    |  14|+          nth_element (nums.begin (), nums.begin () + mid, nums.end ());    // O(n) ~ O(n^2) time
|    |  15|+          reversedTriPartitionWithVI (nums, nums[mid]); // O(n) time, O(1) space
|  15|  16|     }
|  16|  17| 
|  17|  18|     void reversedTriPartitionWithVI(vector<int>& nums, int val) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wiggle-sort-ii.cpp
|    |++++| /app/C++/wiggle-sort-ii.cpp
|  14|  14|         reversedTriPartitionWithVI(nums, nums[mid]);  // O(n) time, O(1) space
|  15|  15|     }
|  16|  16| 
|  17|    |-    void reversedTriPartitionWithVI(vector<int>& nums, int val) {
|  18|    |-        const int N = nums.size() / 2 * 2 + 1;
|  19|    |-        #define Nums(i) nums[(1 + 2 * (i)) % N]
|  20|    |-        for (int i = 0, j = 0, n = nums.size() - 1; j <= n;) {
|  21|    |-            if (Nums(j) > val) {
|  22|    |-                swap(Nums(i++), Nums(j++));
|  23|    |-            } else if (Nums(j) < val) {
|  24|    |-                swap(Nums(j), Nums(n--));
|  25|    |-            } else {
|  26|    |-                ++j;
|  27|    |-            }
|  28|    |-        }
|    |  17|+    void reversedTriPartitionWithVI (vector < int >&nums, int val)
|    |  18|+    {
|    |  19|+        const int N = nums.size () / 2 * 2 + 1;
|    |  20|+#define Nums(i) nums[(1 + 2 * (i)) % N]
|    |  21|+        for (int i = 0, j = 0, n = nums.size () - 1; j <= n;)
|    |  22|+          {
|    |  23|+              if (Nums (j) > val)
|    |  24|+                {
|    |  25|+                    swap (Nums (i++), Nums (j++));
|    |  26|+                }
|    |  27|+              else if (Nums (j) < val)
|    |  28|+                {
|    |  29|+                    swap (Nums (j), Nums (n--));
|    |  30|+                }
|    |  31|+              else
|    |  32|+                {
|    |  33|+                    ++j;
|    |  34|+                }
|    |  35|+          }
|  29|  36|     }
|  30|  37| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-linked-lists.cpp
|    |++++| /app/C++/intersection-of-two-linked-lists.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param headA: the first list
|  16|  17|      * @param headB: the second list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-linked-lists.cpp
|    |++++| /app/C++/intersection-of-two-linked-lists.cpp
|  16|  16|      * @param headB: the second list
|  17|  17|      * @return: a ListNode
|  18|  18|      */
|  19|    |-    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
|    |  19|+    ListNode * getIntersectionNode (ListNode * headA, ListNode * headB)
|    |  20|+    {
|  20|  21|         auto currA = headA, currB = headB;
|  21|  22|         ListNode *begin = nullptr, *tailA = nullptr, *tailB = nullptr;
|  22|  23|         while (currA && currB) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/intersection-of-two-linked-lists.cpp
|    |++++| /app/C++/intersection-of-two-linked-lists.cpp
|  19|  19|     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
|  20|  20|         auto currA = headA, currB = headB;
|  21|  21|         ListNode *begin = nullptr, *tailA = nullptr, *tailB = nullptr;
|  22|    |-        while (currA && currB) {
|  23|    |-            if (currA == currB) {
|  24|    |-                begin = currA;
|  25|    |-                break;
|  26|    |-            }
|  27|    |-   
|  28|    |-            if (currA->next) {
|  29|    |-                currA = currA->next;
|  30|    |-            } else if (!tailA) {
|  31|    |-                tailA = currA;
|  32|    |-                currA = headB;
|  33|    |-            } else {
|  34|    |-                break;
|  35|    |-            }
|    |  22|+        while (currA && currB)
|    |  23|+          {
|    |  24|+              if (currA == currB)
|    |  25|+                {
|    |  26|+                    begin = currA;
|    |  27|+                    break;
|    |  28|+                }
|  36|  29| 
|  37|    |-            if (currB->next) {
|  38|    |-                currB = currB->next;
|  39|    |-            } else if (!tailB) {
|  40|    |-                tailB = currB;
|  41|    |-                currB = headA;
|  42|    |-            } else {
|  43|    |-                break;
|  44|    |-            }
|  45|    |-        }
|  46|    |-        
|    |  30|+              if (currA->next)
|    |  31|+                {
|    |  32|+                    currA = currA->next;
|    |  33|+                }
|    |  34|+              else if (!tailA)
|    |  35|+                {
|    |  36|+                    tailA = currA;
|    |  37|+                    currA = headB;
|    |  38|+                }
|    |  39|+              else
|    |  40|+                {
|    |  41|+                    break;
|    |  42|+                }
|    |  43|+
|    |  44|+              if (currB->next)
|    |  45|+                {
|    |  46|+                    currB = currB->next;
|    |  47|+                }
|    |  48|+              else if (!tailB)
|    |  49|+                {
|    |  50|+                    tailB = currB;
|    |  51|+                    currB = headA;
|    |  52|+                }
|    |  53|+              else
|    |  54|+                {
|    |  55|+                    break;
|    |  56|+                }
|    |  57|+          }
|    |  58|+
|  47|  59|         return begin;
|  48|  60|     }
|  49|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nth-to-last-node-in-list.cpp
|    |++++| /app/C++/nth-to-last-node-in-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @param n: An integer.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nth-to-last-node-in-list.cpp
|    |++++| /app/C++/nth-to-last-node-in-list.cpp
|  20|  20|      * @param n: An integer.
|  21|  21|      * @return: Nth to last node of a singly linked list.
|  22|  22|      */
|  23|    |-    ListNode *nthToLast(ListNode *head, int n) {
|    |  23|+    ListNode * nthToLast (ListNode * head, int n)
|    |  24|+    {
|  24|  25|         auto slow = head, fast = head;
|  25|  26| 
|  26|  27|         // fast is n-step ahead.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nth-to-last-node-in-list.cpp
|    |++++| /app/C++/nth-to-last-node-in-list.cpp
|  24|  24|         auto slow = head, fast = head;
|  25|  25| 
|  26|  26|         // fast is n-step ahead.
|  27|    |-        while (n > 0) {
|  28|    |-            fast = fast->next;
|  29|    |-            --n;
|  30|    |-        }
|    |  27|+        while (n > 0)
|    |  28|+          {
|    |  29|+              fast = fast->next;
|    |  30|+              --n;
|    |  31|+          }
|  31|  32| 
|  32|  33|         // When fast reaches the end, slow must be nth to last node.
|  33|  34|         while (fast != nullptr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/nth-to-last-node-in-list.cpp
|    |++++| /app/C++/nth-to-last-node-in-list.cpp
|  30|  30|         }
|  31|  31| 
|  32|  32|         // When fast reaches the end, slow must be nth to last node.
|  33|    |-        while (fast != nullptr) {
|  34|    |-            slow = slow->next;
|  35|    |-            fast = fast->next;
|  36|    |-        }
|    |  33|+        while (fast != nullptr)
|    |  34|+          {
|    |  35|+              slow = slow->next;
|    |  36|+              fast = fast->next;
|    |  37|+          }
|  37|  38| 
|  38|  39|         return slow;
|  39|  40|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line.cpp
|    |++++| /app/C++/coins-in-a-line.cpp
|   1|   1| // Time:  O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: an integer
|   8|   9|      * @return: a boolean which equals to true if the first player will win
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/coins-in-a-line.cpp
|    |++++| /app/C++/coins-in-a-line.cpp
|   7|   7|      * @param n: an integer
|   8|   8|      * @return: a boolean which equals to true if the first player will win
|   9|   9|      */
|  10|    |-     bool firstWillWin(int n) {
|    |  10|+    bool firstWillWin (int n)
|    |  11|+    {
|  11|  12|         return n % 3 != 0;
|  12|  13|     }
|  13|  14| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands.cpp
|    |++++| /app/C++/number-of-islands.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(m * n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param grid a boolean 2D matrix
|   8|   9|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands.cpp
|    |++++| /app/C++/number-of-islands.cpp
|   7|   7|      * @param grid a boolean 2D matrix
|   8|   8|      * @return an integer
|   9|   9|      */
|  10|    |-    int numIslands(vector<vector<bool>>& grid) {
|  11|    |-        if (grid.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int numIslands (vector < vector < bool >> &grid)
|    |  11|+    {
|    |  12|+        if (grid.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|    |-        vector<vector<bool>> used(grid.size(),
|  16|    |-                                  vector<bool>(grid[0].size(), false));
|    |  17|+        vector < vector < bool >> used (grid.size (),
|    |  18|+                                        vector < bool > (grid[0].size (),
|    |  19|+                                                         false));
|  17|  20| 
|  18|  21|         int count = 0;
|  19|  22|         for (int i = 0; i < grid.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands.cpp
|    |++++| /app/C++/number-of-islands.cpp
|  16|  16|                                   vector<bool>(grid[0].size(), false));
|  17|  17| 
|  18|  18|         int count = 0;
|  19|    |-        for (int i = 0; i < grid.size(); ++i) {
|  20|    |-            for (int j = 0; j < grid[0].size(); ++j) {
|  21|    |-                if (grid[i][j] && !used[i][j]) {
|  22|    |-                    findIsland(grid, i, j, &used);
|  23|    |-                    ++count;
|    |  19|+        for (int i = 0; i < grid.size (); ++i)
|    |  20|+          {
|    |  21|+              for (int j = 0; j < grid[0].size (); ++j)
|    |  22|+                {
|    |  23|+                    if (grid[i][j] && !used[i][j])
|    |  24|+                      {
|    |  25|+                          findIsland (grid, i, j, &used);
|    |  26|+                          ++count;
|    |  27|+                      }
|  24|  28|                 }
|  25|    |-            }
|  26|    |-        }
|    |  29|+          }
|  27|  30|         return count;
|  28|  31|     }
|  29|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/number-of-islands.cpp
|    |++++| /app/C++/number-of-islands.cpp
|  27|  27|         return count;
|  28|  28|     }
|  29|  29| 
|  30|    |-    void findIsland(const vector<vector<bool>>& grid,
|  31|    |-             const int x,
|  32|    |-             const int y,
|  33|    |-             vector<vector<bool>> *used) {
|  34|    |-        if (!grid[x][y] || (*used)[x][y]) {
|  35|    |-            return;
|  36|    |-        }
|  37|    |-        
|    |  30|+    void findIsland (const vector < vector < bool >> &grid,
|    |  31|+                     const int x, const int y, vector < vector < bool >> *used)
|    |  32|+    {
|    |  33|+        if (!grid[x][y] || (*used)[x][y])
|    |  34|+          {
|    |  35|+              return;
|    |  36|+          }
|    |  37|+
|  38|  38|         (*used)[x][y] = true;
|  39|    |-        if (x > 0) {
|  40|    |-            findIsland(grid, x - 1, y, used);
|  41|    |-        }
|  42|    |-        if (x < grid.size() - 1) {
|  43|    |-            findIsland(grid, x + 1, y, used);
|  44|    |-        }
|  45|    |-        if (y > 0) {
|  46|    |-            findIsland(grid, x, y - 1, used);
|  47|    |-        }
|  48|    |-        if (y < grid[0].size() - 1) {
|  49|    |-            findIsland(grid, x, y + 1, used);
|  50|    |-        }
|    |  39|+        if (x > 0)
|    |  40|+          {
|    |  41|+              findIsland (grid, x - 1, y, used);
|    |  42|+          }
|    |  43|+        if (x < grid.size () - 1)
|    |  44|+          {
|    |  45|+              findIsland (grid, x + 1, y, used);
|    |  46|+          }
|    |  47|+        if (y > 0)
|    |  48|+          {
|    |  49|+              findIsland (grid, x, y - 1, used);
|    |  50|+          }
|    |  51|+        if (y < grid[0].size () - 1)
|    |  52|+          {
|    |  53|+              findIsland (grid, x, y + 1, used);
|    |  54|+          }
|  51|  55|     }
|  52|  56| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num: a rotated sorted array
|   8|   9|      * @return: the minimum number in the array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|   7|   7|      * @param num: a rotated sorted array
|   8|   8|      * @return: the minimum number in the array
|   9|   9|      */
|  10|    |-    int findMin(vector<int> &num) {
|    |  10|+    int findMin (vector < int >&num)
|    |  11|+    {
|  11|  12|         int left = 0;
|  12|    |-        int right = num.size() - 1;
|    |  13|+        int right = num.size () - 1;
|  13|  14| 
|  14|  15|         // Find min left s.t. num[left] < num[left'].
|  15|  16|         while (left < right && num[left] >= num[right]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|  12|  12|         int right = num.size() - 1;
|  13|  13| 
|  14|  14|         // Find min left s.t. num[left] < num[left'].
|  15|    |-        while (left < right && num[left] >= num[right]) {
|  16|    |-            int mid = left + (right - left) / 2;
|  17|    |-            if (num[mid] < num[left]) {
|  18|    |-                right = mid;
|  19|    |-            } else if (num[mid] > num[left]) {
|  20|    |-                left = mid + 1;
|  21|    |-            } else {
|  22|    |-                ++left;
|  23|    |-            }
|  24|    |-        }
|    |  15|+        while (left < right && num[left] >= num[right])
|    |  16|+          {
|    |  17|+              int mid = left + (right - left) / 2;
|    |  18|+              if (num[mid] < num[left])
|    |  19|+                {
|    |  20|+                    right = mid;
|    |  21|+                }
|    |  22|+              else if (num[mid] > num[left])
|    |  23|+                {
|    |  24|+                    left = mid + 1;
|    |  25|+                }
|    |  26|+              else
|    |  27|+                {
|    |  28|+                    ++left;
|    |  29|+                }
|    |  30|+          }
|  25|  31| 
|  26|  32|         return num[left];
|  27|  33|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|    |++++| /app/C++/find-minimum-in-rotated-sorted-array-ii.cpp
|  26|  26|         return num[left];
|  27|  27|     }
|  28|  28| };
|  29|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: a list of integers
|   8|   9|      * @return : return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|   7|   7|      * @param A: a list of integers
|   8|   8|      * @return : return an integer
|   9|   9|      */
|  10|    |-    int removeDuplicates(vector<int> &nums) {
|  11|    |-        if (nums.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int removeDuplicates (vector < int >&nums)
|    |  11|+    {
|    |  12|+        if (nums.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|    |-        const int k = 2; // At most k duplicated.
|    |  17|+        const int k = 2;        // At most k duplicated.
|  16|  18| 
|  17|  19|         int left = 0;
|  18|  20|         int right = 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|    |++++| /app/C++/remove-duplicates-from-sorted-array-ii.cpp
|  17|  17|         int left = 0;
|  18|  18|         int right = 1;
|  19|  19| 
|  20|    |-        while (right < nums.size()) {
|  21|    |-            if (nums[left] != nums[right] ||
|  22|    |-                (left - k + 1 < 0 || nums[left] != nums[left - k + 1])) {
|  23|    |-                ++left;
|  24|    |-                nums[left] = nums[right];
|  25|    |-            }
|  26|    |-            ++right;
|  27|    |-        }
|    |  20|+        while (right < nums.size ())
|    |  21|+          {
|    |  22|+              if (nums[left] != nums[right] ||
|    |  23|+                  (left - k + 1 < 0 || nums[left] != nums[left - k + 1]))
|    |  24|+                {
|    |  25|+                    ++left;
|    |  26|+                    nums[left] = nums[right];
|    |  27|+                }
|    |  28|+              ++right;
|    |  29|+          }
|  28|  30| 
|  29|  31|         return left + 1;
|  30|  32|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flip-bits.cpp
|    |++++| /app/C++/flip-bits.cpp
|   1|   1| // Time:  O(logn) = O(32)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param a, b: Two integer
|   8|   9|      *return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flip-bits.cpp
|    |++++| /app/C++/flip-bits.cpp
|   7|   7|      *@param a, b: Two integer
|   8|   8|      *return: An integer
|   9|   9|      */
|  10|    |-    int bitSwapRequired(int a, int b) {
|    |  10|+    int bitSwapRequired (int a, int b)
|    |  11|+    {
|  11|  12|         int cnt = 0;
|  12|    |-        for (int c = a ^ b; c != 0; c &= c - 1) {
|  13|    |-            ++cnt;
|  14|    |-        }
|    |  13|+        for (int c = a ^ b; c != 0; c &= c - 1)
|    |  14|+          {
|    |  15|+              ++cnt;
|    |  16|+          }
|  15|  17|         return cnt;
|  16|  18|     }
|  17|  19| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/4-sum.cpp
|    |++++| /app/C++/4-sum.cpp
|   1|   1| // Time:  O(n^3)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|   6|    |-    vector<vector<int> > fourSum(vector<int> &nums, int target) {
|   7|    |-        int len = nums.size();
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|    |   7|+    vector < vector < int >>fourSum (vector < int >&nums, int target)
|    |   8|+    {
|    |   9|+        int len = nums.size ();
|   8|  10|         int left, right, sum;
|   9|    |-        sort(nums.begin(), nums.end());
|  10|    |-        vector<vector<int>> res;
|  11|    |-        for (int i = 0; i < len - 3; ++i) {
|  12|    |-            if (i && nums[i] == nums[i - 1]) {
|  13|    |-                continue;
|  14|    |-            }
|  15|    |-            for (int j = i + 1; j < len - 2; ++j) {
|  16|    |-                if (j != i + 1 && nums[j] == nums[j - 1]) {
|    |  11|+          sort (nums.begin (), nums.end ());
|    |  12|+          vector < vector < int >>res;
|    |  13|+        for (int i = 0; i < len - 3; ++i)
|    |  14|+          {
|    |  15|+              if (i && nums[i] == nums[i - 1])
|    |  16|+                {
|  17|  17|                     continue;
|  18|  18|                 }
|  19|  19|                 sum = target - nums[i] - nums[j];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/4-sum.cpp
|    |++++| /app/C++/4-sum.cpp
|  16|  16|                 if (j != i + 1 && nums[j] == nums[j - 1]) {
|  17|  17|                     continue;
|  18|  18|                 }
|  19|    |-                sum = target - nums[i] - nums[j];
|  20|    |-                left = j + 1, right = len - 1;
|  21|    |-                while (left < right) {
|  22|    |-                    if (nums[left] + nums[right] == sum) {
|  23|    |-                        res.emplace_back(move(vector<int>{nums[i], nums[j], nums[left], nums[right]}));
|  24|    |-                        ++left, --right;
|  25|    |-                        while (left < right && nums[left] == nums[left - 1]) {
|  26|    |-                            ++left;
|  27|    |-                        }
|  28|    |-                        while (left < right && nums[right] == nums[right + 1]) {
|  29|    |-                            --right;
|  30|    |-                        }
|  31|    |-                    } else {
|  32|    |-                        if (nums[left] + nums[right] > sum) {
|  33|    |-                            --right;
|  34|    |-                        } else {
|  35|    |-                            ++left;
|  36|    |-                        }
|  37|    |-                    }
|    |  19|+              for (int j = i + 1; j < len - 2; ++j)
|    |  20|+                {
|    |  21|+                    if (j != i + 1 && nums[j] == nums[j - 1])
|    |  22|+                      {
|    |  23|+                          continue;
|    |  24|+                      }
|    |  25|+                    sum = target - nums[i] - nums[j];
|    |  26|+                    left = j + 1, right = len - 1;
|    |  27|+                    while (left < right)
|    |  28|+                      {
|    |  29|+                          if (nums[left] + nums[right] == sum)
|    |  30|+                            {
|    |  31|+                                res.emplace_back (move (vector < int >
|    |  32|+                                                        {
|    |  33|+                                                        nums[i], nums[j],
|    |  34|+                                                        nums[left],
|    |  35|+                                                        nums[right]}));
|    |  36|+                                ++left, --right;
|    |  37|+                                while (left < right
|    |  38|+                                       && nums[left] == nums[left - 1])
|    |  39|+                                  {
|    |  40|+                                      ++left;
|    |  41|+                                  }
|    |  42|+                                while (left < right
|    |  43|+                                       && nums[right] == nums[right + 1])
|    |  44|+                                  {
|    |  45|+                                      --right;
|    |  46|+                                  }
|    |  47|+                            }
|    |  48|+                          else
|    |  49|+                            {
|    |  50|+                                if (nums[left] + nums[right] > sum)
|    |  51|+                                  {
|    |  52|+                                      --right;
|    |  53|+                                  }
|    |  54|+                                else
|    |  55|+                                  {
|    |  56|+                                      ++left;
|    |  57|+                                  }
|    |  58|+                            }
|    |  59|+                      }
|  38|  60|                 }
|  39|    |-            }
|  40|    |-        }
|    |  61|+          }
|  41|  62|         return res;
|  42|  63|     }
|  43|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/4-sum.cpp
|    |++++| /app/C++/4-sum.cpp
|  44|  44| 
|  45|  45| // Time:  O(n^2 * p), p is max number of the same two sum pairs.
|  46|  46| // Space: O(n^2 * p)
|  47|    |-class Solution2 {
|  48|    |-public:
|    |  47|+class Solution2
|    |  48|+{
|    |  49|+  public:
|  49|  50|     /**
|  50|  51|      * @param numbers: Give an array numbersbers of n integer
|  51|  52|      * @param target: you need to find four elements that's sum of target
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/4-sum.cpp
|    |++++| /app/C++/4-sum.cpp
|  52|  52|      * @return: Find all unique quadruplets in the array which gives the sum of
|  53|  53|      *          zero.
|  54|  54|      */
|  55|    |-    vector<vector<int>> fourSum(vector<int> nums, int target) {
|  56|    |-        sort(nums.begin(), nums.end()); // Make sure quadruplets are in non-descending orders.
|  57|    |-        unordered_map<int, vector<vector<size_t>>> two_sum; // two_sum saves "sum to (i, j) pairs, which i < j."
|  58|    |-        for (size_t i = 0; i < nums.size(); ++i) {
|  59|    |-            for (size_t j = i + 1; j < nums.size(); ++j) {
|  60|    |-                bool have_duplicate = false;
|  61|    |-                for (const auto& vec : two_sum[nums[i] + nums[j]]) {
|  62|    |-                    if (nums[vec.front()] == nums[i]) {  // Duplicated.
|  63|    |-                        have_duplicate = true;
|  64|    |-                        break;
|  65|    |-                    }
|    |  55|+    vector < vector < int >>fourSum (vector < int >nums, int target)
|    |  56|+    {
|    |  57|+        sort (nums.begin (), nums.end ());  // Make sure quadruplets are in non-descending orders.
|    |  58|+        unordered_map < int, vector < vector < size_t >>> two_sum;  // two_sum saves "sum to (i, j) pairs, which i < j."
|    |  59|+        for (size_t i = 0; i < nums.size (); ++i)
|    |  60|+          {
|    |  61|+              for (size_t j = i + 1; j < nums.size (); ++j)
|    |  62|+                {
|    |  63|+                    bool have_duplicate = false;
|    |  64|+                    for (const auto & vec:two_sum[nums[i] + nums[j]])
|    |  65|+                      {
|    |  66|+                          if (nums[vec.front ()] == nums[i])
|    |  67|+                            {   // Duplicated.
|    |  68|+                                have_duplicate = true;
|    |  69|+                                break;
|    |  70|+                            }
|    |  71|+                      }
|    |  72|+                    if (!have_duplicate)
|    |  73|+                      {         // Not duplicated
|    |  74|+                          vector < size_t > new_vec =
|    |  75|+                          {
|    |  76|+                          i, j};
|    |  77|+                          two_sum[nums[i] +
|    |  78|+                                  nums[j]].emplace_back (move (new_vec));
|    |  79|+                      }
|  66|  80|                 }
|  67|    |-                if (!have_duplicate) {  // Not duplicated
|  68|    |-                    vector<size_t> new_vec = {i, j};
|  69|    |-                    two_sum[nums[i] + nums[j]].emplace_back(move(new_vec));
|    |  81|+          }
|    |  82|+
|    |  83|+        unordered_set < string > answers;   // Use hash to filter duplicated.
|    |  84|+        vector < vector < int >>res;
|    |  85|+        for (size_t i = 2; i < nums.size (); ++i)
|    |  86|+          {
|    |  87|+              for (size_t j = i + 1; j < nums.size (); ++j)
|    |  88|+                {
|    |  89|+                    auto it = two_sum.find (target - nums[i] - nums[j]);
|    |  90|+                    if (it == two_sum.end ())
|    |  91|+                      {
|    |  92|+                          continue;
|    |  93|+                      }
|    |  94|+                  for (const auto & vec:it->second)
|    |  95|+                      {
|    |  96|+                          if (vec.back () >= i)
|    |  97|+                            {
|    |  98|+                                continue;
|    |  99|+                            }
|    | 100|+                          // {vec.front() < vec.back() < i < j}
|    | 101|+                          vector < int >candidate =
|    | 102|+                              { nums[vec.front ()], nums[vec.back ()], nums[i],
|    | 103|+            nums[j] };
|    | 104|+                          if (answers.emplace (join_vector (candidate)).second)
|    | 105|+                            {   // Not duplicated.
|    | 106|+                                res.emplace_back (move (candidate));    // Add to answers.
|    | 107|+                            }
|    | 108|+                      }
|  70| 109|                 }
|  71|    |-            }
|  72|    |-        }
|  73|    |-
|  74|    |-        unordered_set<string> answers; // Use hash to filter duplicated.
|  75|    |-        vector<vector<int>> res;
|  76|    |-        for (size_t i = 2; i < nums.size(); ++i) {
|  77|    |-            for (size_t j = i + 1; j < nums.size(); ++j) {
|  78|    |-                auto it = two_sum.find(target - nums[i] - nums[j]);
|  79|    |-                if (it == two_sum.end()) {
|  80|    |-                    continue;
|  81|    |-                }
|  82|    |-                for (const auto& vec : it->second) {
|  83|    |-                    if (vec.back() >= i) {
|  84|    |-                        continue;
|  85|    |-                    }
|  86|    |-                    // {vec.front() < vec.back() < i < j}
|  87|    |-                    vector<int> candidate = {nums[vec.front()], nums[vec.back()], nums[i], nums[j]};
|  88|    |-                    if (answers.emplace(join_vector(candidate)).second) {  // Not duplicated.
|  89|    |-                        res.emplace_back(move(candidate)); // Add to answers.
|  90|    |-                    }
|  91|    |-                }
|  92|    |-            }
|  93|    |-        }
|    | 110|+          }
|  94| 111|         return res;
|  95| 112|     }
|  96| 113| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/4-sum.cpp
|    |++++| /app/C++/4-sum.cpp
|  95|  95|     }
|  96|  96| 
|  97|  97|     // Hash vector to string.
|  98|    |-    string join_vector(const vector<int>& nums) {
|    |  98|+    string join_vector (const vector < int >&nums)
|    |  99|+    {
|  99| 100|         string ret;
| 100|    |-        for (const auto& n : nums) {
| 101|    |-            ret += to_string(n);
| 102|    |-            ret += ' ';
| 103|    |-        }
|    | 101|+      for (const auto & n:nums)
|    | 102|+          {
|    | 103|+              ret += to_string (n);
|    | 104|+              ret += ' ';
|    | 105|+          }
| 104| 106|         return ret;
| 105| 107|     }
| 106| 108| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  17|  17|  */
|  18|  18| 
|  19|  19| // Segment tree solution.
|  20|    |-class Solution {
|  21|    |-public:
|    |  20|+class Solution
|    |  21|+{
|    |  22|+  public:
|  22|  23|     /**
|  23|  24|      * @param A: An integer array
|  24|  25|      * @return: The number of element in the array that
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  24|  24|      * @return: The number of element in the array that
|  25|  25|      *          are smaller that the given integer
|  26|  26|      */
|  27|    |-    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {
|  28|    |-        vector<int> res;
|    |  27|+    vector < int >countOfSmallerNumber (vector < int >&A,
|    |  28|+                                        vector < int >&queries)
|    |  29|+    {
|    |  30|+        vector < int >res;
|  29|  31| 
|  30|  32|         // Sort array before building segment tree.
|  31|  33|         sort(A.begin(), A.end());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  28|  28|         vector<int> res;
|  29|  29| 
|  30|  30|         // Sort array before building segment tree.
|  31|    |-        sort(A.begin(), A.end());
|    |  31|+          sort (A.begin (), A.end ());
|  32|  32| 
|  33|  33|         // Build segment tree.
|  34|  34|         SegmentTreeNode *root = build(A, 0, A.size() - 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  31|  31|         sort(A.begin(), A.end());
|  32|  32| 
|  33|  33|         // Build segment tree.
|  34|    |-        SegmentTreeNode *root = build(A, 0, A.size() - 1);
|    |  34|+        SegmentTreeNode *root = build (A, 0, A.size () - 1);
|  35|  35| 
|  36|  36|         // Do each query.
|  37|  37|         for (const auto& q : queries) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  34|  34|         SegmentTreeNode *root = build(A, 0, A.size() - 1);
|  35|  35| 
|  36|  36|         // Do each query.
|  37|    |-        for (const auto& q : queries) {
|  38|    |-            res.emplace_back(query(root, 0, A.size() - 1, A, q));
|  39|    |-        }
|    |  37|+        for (const auto & q:queries)
|    |  38|+          {
|    |  39|+              res.emplace_back (query (root, 0, A.size () - 1, A, q));
|    |  40|+          }
|  40|  41| 
|  41|  42|         return res;
|  42|  43|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  42|  42|     }
|  43|  43| 
|  44|  44|     // Build segment tree.
|  45|    |-    SegmentTreeNode *build(vector<int> &A, int start, int end) {
|  46|    |-        if (start > end) {
|  47|    |-            return nullptr;
|  48|    |-        }
|    |  45|+    SegmentTreeNode *build (vector < int >&A, int start, int end)
|    |  46|+    {
|    |  47|+        if (start > end)
|    |  48|+          {
|    |  49|+              return nullptr;
|    |  50|+          }
|  49|  51| 
|  50|  52|         // The root's start and end is given by build method.
|  51|  53|         SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  48|  48|         }
|  49|  49| 
|  50|  50|         // The root's start and end is given by build method.
|  51|    |-        SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);
|    |  51|+        SegmentTreeNode *root = new SegmentTreeNode (start, end, 0);
|  52|  52| 
|  53|  53|         // If start equals to end, there will be no children for this node.
|  54|  54|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  51|  51|         SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);
|  52|  52| 
|  53|  53|         // If start equals to end, there will be no children for this node.
|  54|    |-        if (start == end) {
|  55|    |-            root->count = 1;
|  56|    |-            return root;
|  57|    |-        }
|    |  54|+        if (start == end)
|    |  55|+          {
|    |  56|+              root->count = 1;
|    |  57|+              return root;
|    |  58|+          }
|  58|  59| 
|  59|  60|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  60|  61|         root->left = build(A, start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  57|  57|         }
|  58|  58| 
|  59|  59|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  60|    |-        root->left = build(A, start, (start + end) / 2);
|    |  60|+        root->left = build (A, start, (start + end) / 2);
|  61|  61| 
|  62|  62|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  63|  63|         root->right = build(A, (start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  60|  60|         root->left = build(A, start, (start + end) / 2);
|  61|  61| 
|  62|  62|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  63|    |-        root->right = build(A, (start + end) / 2 + 1, end);
|    |  63|+        root->right = build (A, (start + end) / 2 + 1, end);
|  64|  64| 
|  65|    |-        int left_count = root->left != nullptr? root->left->count : 0;
|  66|    |-        int right_count = root->right != nullptr? root->right->count : 0;
|    |  65|+        int left_count = root->left != nullptr ? root->left->count : 0;
|    |  66|+        int right_count = root->right != nullptr ? root->right->count : 0;
|  67|  67| 
|  68|  68|         // Update count.
|  69|  69|         root->count = left_count + right_count;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  70|  70|         return root;
|  71|  71|     }
|  72|  72| 
|  73|    |-
|  74|  73|     // Query count in given range.
|  75|    |-    int query(SegmentTreeNode *root, int start, int end,
|  76|    |-                    vector<int> &A, int q) {
|    |  74|+    int query (SegmentTreeNode * root, int start, int end,
|    |  75|+               vector < int >&A, int q)
|    |  76|+    {
|  77|  77|         // Out of range.
|  78|    |-        if (root == nullptr || root->start > end || root->end <  start) {
|  79|    |-            return 0;
|  80|    |-        }
|    |  78|+        if (root == nullptr || root->start > end || root->end < start)
|    |  79|+          {
|    |  80|+              return 0;
|    |  81|+          }
|  81|  82| 
|  82|  83|         // Skip the segment where q is smaller than its start.
|  83|  84|         if (q <= A[root->start]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  80|  80|         }
|  81|  81| 
|  82|  82|         // Skip the segment where q is smaller than its start.
|  83|    |-        if (q <= A[root->start]) {
|  84|    |-            return 0;
|  85|    |-        }
|    |  83|+        if (q <= A[root->start])
|    |  84|+          {
|    |  85|+              return 0;
|    |  86|+          }
|  86|  87| 
|  87|  88|         // Current segment is totally smaller than q.
|  88|  89|         if (q > A[root->end]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  85|  85|         }
|  86|  86| 
|  87|  87|         // Current segment is totally smaller than q.
|  88|    |-        if (q > A[root->end]) {
|  89|    |-            return root->count;
|  90|    |-        }
|    |  88|+        if (q > A[root->end])
|    |  89|+          {
|    |  90|+              return root->count;
|    |  91|+          }
|  91|  92| 
|  92|    |-        int left = query(root->left, start, end, A, q);
|  93|    |-        int right = query(root->right, start, end, A, q);
|    |  93|+        int left = query (root->left, start, end, A, q);
|    |  94|+        int right = query (root->right, start, end, A, q);
|  94|  95| 
|  95|  96|         // Find count in the children.
|  96|  97|         return left + right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
|  97|  97|     }
|  98|  98| };
|  99|  99| 
| 100|    |-
| 101| 100| // Time:  O(logn)
| 102| 101| // Space: O(1)
| 103| 102| // Binary search solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
| 101| 101| // Time:  O(logn)
| 102| 102| // Space: O(1)
| 103| 103| // Binary search solution.
| 104|    |-class Solution2 {
| 105|    |-public:
|    | 104|+class Solution2
|    | 105|+{
|    | 106|+  public:
| 106| 107|     /**
| 107| 108|      * @param A: An integer array
| 108| 109|      * @return: The number of element in the array that
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
| 108| 108|      * @return: The number of element in the array that
| 109| 109|      *          are smaller that the given integer
| 110| 110|      */
| 111|    |-    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {
| 112|    |-        vector<int> result;
| 113|    |-        sort(A.begin(), A.end());
| 114|    |-        for (int i = 0; i < queries.size(); ++i) {
| 115|    |-            const auto it = lower_bound(A.cbegin(), A.cend(), queries[i]);
| 116|    |-            result.emplace_back(it - A.cbegin());
| 117|    |-        }
|    | 111|+    vector < int >countOfSmallerNumber (vector < int >&A,
|    | 112|+                                        vector < int >&queries)
|    | 113|+    {
|    | 114|+        vector < int >result;
|    | 115|+          sort (A.begin (), A.end ());
|    | 116|+        for (int i = 0; i < queries.size (); ++i)
|    | 117|+          {
|    | 118|+              const auto it = lower_bound (A.cbegin (), A.cend (), queries[i]);
|    | 119|+                result.emplace_back (it - A.cbegin ());
|    | 120|+          }
| 118| 121|         return result;
| 119| 122|     }
| 120| 123| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
| 122| 122| // Time:  O(n)
| 123| 123| // Space: O(1)
| 124| 124| // Loop solution.
| 125|    |-class Solution_TLE {
| 126|    |-public:
|    | 125|+class Solution_TLE
|    | 126|+{
|    | 127|+  public:
| 127| 128|     /**
| 128| 129|      * @param A: An integer array
| 129| 130|      * @return: The number of element in the array that
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number.cpp
|    |++++| /app/C++/count-of-smaller-number.cpp
| 129| 129|      * @return: The number of element in the array that
| 130| 130|      *          are smaller that the given integer
| 131| 131|      */
| 132|    |-    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {
| 133|    |-        vector<int> result(queries.size(), 0);
| 134|    |-        for (auto& x : A) {
| 135|    |-            for (int i = 0; i < queries.size(); ++i) {
| 136|    |-                if (queries[i] > x) {
| 137|    |-                    ++result[i];
|    | 132|+    vector < int >countOfSmallerNumber (vector < int >&A,
|    | 133|+                                        vector < int >&queries)
|    | 134|+    {
|    | 135|+        vector < int >result (queries.size (), 0);
|    | 136|+        for (auto & x:A)
|    | 137|+          {
|    | 138|+              for (int i = 0; i < queries.size (); ++i)
|    | 139|+                {
|    | 140|+                    if (queries[i] > x)
|    | 141|+                      {
|    | 142|+                          ++result[i];
|    | 143|+                      }
| 138| 144|                 }
| 139|    |-            }
| 140|    |-        }
|    | 145|+          }
| 141| 146|         return result;
| 142| 147|     }
| 143| 148| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: The integer array.
|   8|   9|      * @param target: Target number to find.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|   8|   8|      * @param target: Target number to find.
|   9|   9|      * @return: The first position of target. Position starts from 0.
|  10|  10|      */
|  11|    |-    int binarySearch(vector<int> &array, int target) {
|    |  11|+    int binarySearch (vector < int >&array, int target)
|    |  12|+    {
|  12|  13|         int left = 0;
|  13|    |-        int right = array.size() - 1;
|    |  14|+        int right = array.size () - 1;
|  14|  15| 
|  15|    |-        while (left <= right) {
|  16|    |-            int mid = left + (right - left) / 2;
|  17|    |-            if (array[mid] >= target) {
|  18|    |-                right = mid - 1;
|  19|    |-            } else {
|  20|    |-                left = mid + 1;
|  21|    |-            }
|  22|    |-        }
|    |  16|+        while (left <= right)
|    |  17|+          {
|    |  18|+              int mid = left + (right - left) / 2;
|    |  19|+              if (array[mid] >= target)
|    |  20|+                {
|    |  21|+                    right = mid - 1;
|    |  22|+                }
|    |  23|+              else
|    |  24|+                {
|    |  25|+                    left = mid + 1;
|    |  26|+                }
|    |  27|+          }
|  23|  28| 
|  24|    |-        if (left < array.size() && array[left] == target) {
|  25|    |-            return left;
|  26|    |-        }
|    |  29|+        if (left < array.size () && array[left] == target)
|    |  30|+          {
|    |  31|+              return left;
|    |  32|+          }
|  27|  33| 
|  28|  34|         return -1;
|  29|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|  29|  29|     }
|  30|  30| };
|  31|  31| 
|  32|    |-
|  33|    |-class Solution2 {
|  34|    |-public:
|    |  32|+class Solution2
|    |  33|+{
|    |  34|+  public:
|  35|  35|     /**
|  36|  36|      * @param nums: The integer array.
|  37|  37|      * @param target: Target number to find.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|  37|  37|      * @param target: Target number to find.
|  38|  38|      * @return: The first position of target. Position starts from 0.
|  39|  39|      */
|  40|    |-    int binarySearch(vector<int> &array, int target) {
|    |  40|+    int binarySearch (vector < int >&array, int target)
|    |  41|+    {
|  41|  42|         int left = 0;
|  42|    |-        int right = array.size();
|    |  43|+        int right = array.size ();
|  43|  44| 
|  44|    |-        while (left < right) {
|  45|    |-            int mid = left + (right - left) / 2;
|  46|    |-            if (array[mid] >= target) {
|  47|    |-                right = mid;
|  48|    |-            } else {
|  49|    |-                left = mid + 1;
|  50|    |-            }
|  51|    |-        }
|    |  45|+        while (left < right)
|    |  46|+          {
|    |  47|+              int mid = left + (right - left) / 2;
|    |  48|+              if (array[mid] >= target)
|    |  49|+                {
|    |  50|+                    right = mid;
|    |  51|+                }
|    |  52|+              else
|    |  53|+                {
|    |  54|+                    left = mid + 1;
|    |  55|+                }
|    |  56|+          }
|  52|  57| 
|  53|    |-        if (left < array.size() && array[left] == target) {
|  54|    |-            return left;
|  55|    |-        }
|    |  58|+        if (left < array.size () && array[left] == target)
|    |  59|+          {
|    |  60|+              return left;
|    |  61|+          }
|  56|  62| 
|  57|  63|         return -1;
|  58|  64|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|  58|  58|     }
|  59|  59| };
|  60|  60| 
|  61|    |-class Solution3 {
|  62|    |-public:
|    |  61|+class Solution3
|    |  62|+{
|    |  63|+  public:
|  63|  64|     /**
|  64|  65|      * @param nums: The integer array.
|  65|  66|      * @param target: Target number to find.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|  65|  65|      * @param target: Target number to find.
|  66|  66|      * @return: The first position of target. Position starts from 0.
|  67|  67|      */
|  68|    |-    int binarySearch(vector<int> &array, int target) {
|    |  68|+    int binarySearch (vector < int >&array, int target)
|    |  69|+    {
|  69|  70|         int left = -1;
|  70|    |-        int right = array.size();
|    |  71|+        int right = array.size ();
|  71|  72| 
|  72|    |-        while (right - left > 1) {
|  73|    |-            int mid = left + (right - left) / 2;
|  74|    |-            if (array[mid] >= target) {
|  75|    |-                right = mid;
|  76|    |-            } else {
|  77|    |-                left = mid;
|  78|    |-            }
|  79|    |-        }
|    |  73|+        while (right - left > 1)
|    |  74|+          {
|    |  75|+              int mid = left + (right - left) / 2;
|    |  76|+              if (array[mid] >= target)
|    |  77|+                {
|    |  78|+                    right = mid;
|    |  79|+                }
|    |  80|+              else
|    |  81|+                {
|    |  82|+                    left = mid;
|    |  83|+                }
|    |  84|+          }
|  80|  85| 
|  81|    |-        if (right < array.size() && array[right] == target) {
|  82|    |-            return right;
|  83|    |-        }
|    |  86|+        if (right < array.size () && array[right] == target)
|    |  87|+          {
|    |  88|+              return right;
|    |  89|+          }
|  84|  90| 
|  85|  91|         return -1;
|  86|  92|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-position-of-target.cpp
|    |++++| /app/C++/first-position-of-target.cpp
|  85|  85|         return -1;
|  86|  86|     }
|  87|  87| };
|  88|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|   3|   3| 
|   4|   4| // Wiki of KMP algorithm:
|   5|   5| // http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm
|   6|    |-class Solution {
|   7|    |-public:
|    |   6|+class Solution
|    |   7|+{
|    |   8|+  public:
|   8|   9|     /**
|   9|  10|      * Returns a index to the first occurrence of target in source,
|  10|  11|      * or -1  if target is not part of source.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  11|  11|      * @param source string to be scanned.
|  12|  12|      * @param target string containing the sequence of characters to match.
|  13|  13|      */
|  14|    |-    int strStr(const char *source, const char *target) {
|  15|    |-        if (source != nullptr && target != nullptr) {
|  16|    |-            const string src(source), tgt(target);
|  17|    |-            if (tgt.empty()) {
|  18|    |-                return 0;
|  19|    |-            }
|    |  14|+    int strStr (const char *source, const char *target)
|    |  15|+    {
|    |  16|+        if (source != nullptr && target != nullptr)
|    |  17|+          {
|    |  18|+              const string src (source), tgt (target);
|    |  19|+              if (tgt.empty ())
|    |  20|+                {
|    |  21|+                    return 0;
|    |  22|+                }
|  20|  23| 
|  21|    |-            return KMP(src, tgt);
|  22|    |-        }
|    |  24|+              return KMP (src, tgt);
|    |  25|+          }
|  23|  26|         return -1;
|  24|  27|     }
|  25|  28| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  23|  23|         return -1;
|  24|  24|     }
|  25|  25| 
|  26|    |-    int KMP(const string& text, const string& pattern) {
|  27|    |-        const vector<int> prefix = getPrefix(pattern);
|    |  26|+    int KMP (const string & text, const string & pattern)
|    |  27|+    {
|    |  28|+        const vector < int >prefix = getPrefix (pattern);
|  28|  29|         int j = -1;
|  29|    |-        for (int i = 0; i < text.length(); ++i) {
|  30|    |-            while (j > -1 && pattern[j + 1] != text[i]) {
|  31|    |-                j = prefix[j];
|  32|    |-            }
|  33|    |-            if (pattern[j + 1] == text[i]) {
|  34|    |-                ++j;
|  35|    |-            }
|  36|    |-            if (j == pattern.length() - 1) {
|  37|    |-                return i - j;
|  38|    |-            }
|  39|    |-        }
|    |  30|+        for (int i = 0; i < text.length (); ++i)
|    |  31|+          {
|    |  32|+              while (j > -1 && pattern[j + 1] != text[i])
|    |  33|+                {
|    |  34|+                    j = prefix[j];
|    |  35|+                }
|    |  36|+              if (pattern[j + 1] == text[i])
|    |  37|+                {
|    |  38|+                    ++j;
|    |  39|+                }
|    |  40|+              if (j == pattern.length () - 1)
|    |  41|+                {
|    |  42|+                    return i - j;
|    |  43|+                }
|    |  44|+          }
|  40|  45|         return -1;
|  41|  46|     }
|  42|  47| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  40|  40|         return -1;
|  41|  41|     }
|  42|  42| 
|  43|    |-    vector<int> getPrefix(const string& pattern) {
|  44|    |-        vector<int> prefix(pattern.length(), -1);
|    |  43|+    vector < int >getPrefix (const string & pattern)
|    |  44|+    {
|    |  45|+        vector < int >prefix (pattern.length (), -1);
|  45|  46|         int j = -1;
|  46|    |-        for (int i = 1; i < pattern.length(); ++i) {
|  47|    |-            while (j > -1 && pattern[j + 1] != pattern[i]) {
|  48|    |-                j = prefix[j];
|  49|    |-            }
|  50|    |-            if (pattern[j + 1] == pattern[i]) {
|  51|    |-                ++j;
|  52|    |-            }
|  53|    |-            prefix[i] = j;
|  54|    |-        }
|    |  47|+        for (int i = 1; i < pattern.length (); ++i)
|    |  48|+          {
|    |  49|+              while (j > -1 && pattern[j + 1] != pattern[i])
|    |  50|+                {
|    |  51|+                    j = prefix[j];
|    |  52|+                }
|    |  53|+              if (pattern[j + 1] == pattern[i])
|    |  54|+                {
|    |  55|+                    ++j;
|    |  56|+                }
|    |  57|+              prefix[i] = j;
|    |  58|+          }
|  55|  59|         return prefix;
|  56|  60|     }
|  57|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  56|  56|     }
|  57|  57| };
|  58|  58| 
|  59|    |-
|  60|  59| // Time:  O(n * k)
|  61|  60| // Space: O(k)
|  62|  61| class Solution2 {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  59|  59| 
|  60|  60| // Time:  O(n * k)
|  61|  61| // Space: O(k)
|  62|    |-class Solution2 {
|  63|    |-public:
|    |  62|+class Solution2
|    |  63|+{
|    |  64|+  public:
|  64|  65|     /**
|  65|  66|      * Returns a index to the first occurrence of target in source,
|  66|  67|      * or -1  if target is not part of source.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  67|  67|      * @param source string to be scanned.
|  68|  68|      * @param target string containing the sequence of characters to match.
|  69|  69|      */
|  70|    |-    int strStr(const char *source, const char *target) {
|  71|    |-        if (source != nullptr && target != nullptr) {
|  72|    |-            const string src(source), tgt(target);
|  73|    |-            for (int i = 0; i < src.length() - tgt.length() + 1; ++i) {
|  74|    |-                if (src.substr(i, tgt.length()) == tgt) {
|  75|    |-                    return i;
|    |  70|+    int strStr (const char *source, const char *target)
|    |  71|+    {
|    |  72|+        if (source != nullptr && target != nullptr)
|    |  73|+          {
|    |  74|+              const string src (source), tgt (target);
|    |  75|+              for (int i = 0; i < src.length () - tgt.length () + 1; ++i)
|    |  76|+                {
|    |  77|+                    if (src.substr (i, tgt.length ()) == tgt)
|    |  78|+                      {
|    |  79|+                          return i;
|    |  80|+                      }
|  76|  81|                 }
|  77|    |-            }
|  78|    |-        }
|    |  82|+          }
|  79|  83|         return -1;
|  80|  84|     }
|  81|  85| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/strstr.cpp
|    |++++| /app/C++/strstr.cpp
|  79|  79|         return -1;
|  80|  80|     }
|  81|  81| };
|  82|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/digit-counts.cpp
|    |++++| /app/C++/digit-counts.cpp
|   1|   1| // Time:  O(logn) = O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /*
|   7|   8|      * param k : As description.
|   8|   9|      * param n : As description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/digit-counts.cpp
|    |++++| /app/C++/digit-counts.cpp
|   8|   8|      * param n : As description.
|   9|   9|      * return: How many k's between 0 and n.
|  10|  10|      */
|  11|    |-    int digitCounts(int k, int n) {
|    |  11|+    int digitCounts (int k, int n)
|    |  12|+    {
|  12|  13|         int cnt = 0, multiplier = 1, left_part = n;
|  13|  14| 
|  14|  15|         while (left_part > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/digit-counts.cpp
|    |++++| /app/C++/digit-counts.cpp
|  11|  11|     int digitCounts(int k, int n) {
|  12|  12|         int cnt = 0, multiplier = 1, left_part = n;
|  13|  13| 
|  14|    |-        while (left_part > 0) {
|  15|    |-            // split number into: left_part, curr, right_part
|  16|    |-            int curr = left_part % 10;
|  17|    |-            int right_part = n % multiplier;
|    |  14|+        while (left_part > 0)
|    |  15|+          {
|    |  16|+              // split number into: left_part, curr, right_part
|    |  17|+              int curr = left_part % 10;
|    |  18|+              int right_part = n % multiplier;
|  18|  19| 
|  19|    |-            // count of (c000 ~ oooc000) = (ooo + (k < curr)? 1 : 0) * 1000
|  20|    |-            cnt += (left_part / 10 + (k < curr)) * multiplier;
|    |  20|+              // count of (c000 ~ oooc000) = (ooo + (k < curr)? 1 : 0) * 1000
|    |  21|+                cnt += (left_part / 10 + (k < curr)) * multiplier;
|  21|  22| 
|  22|    |-            // if k == 0, oooc000 = (ooo - 1) * 1000
|  23|    |-            if (k == 0 && multiplier > 1) {
|  24|    |-                cnt -= multiplier;
|  25|    |-            }
|    |  23|+              // if k == 0, oooc000 = (ooo - 1) * 1000
|    |  24|+              if (k == 0 && multiplier > 1)
|    |  25|+                {
|    |  26|+                    cnt -= multiplier;
|    |  27|+                }
|  26|  28| 
|  27|    |-            // count of (oook000 ~ oookxxx): count += xxx + 1
|  28|    |-            if (curr == k) {
|  29|    |-                cnt += right_part + 1;
|  30|    |-            }
|    |  29|+              // count of (oook000 ~ oookxxx): count += xxx + 1
|    |  30|+              if (curr == k)
|    |  31|+                {
|    |  32|+                    cnt += right_part + 1;
|    |  33|+                }
|  31|  34| 
|  32|    |-            left_part /= 10;
|  33|    |-            multiplier *= 10;
|  34|    |-        }
|    |  35|+              left_part /= 10;
|    |  36|+              multiplier *= 10;
|    |  37|+          }
|  35|  38| 
|  36|  39|         return cnt;
|  37|  40|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/digit-counts.cpp
|    |++++| /app/C++/digit-counts.cpp
|  39|  39| 
|  40|  40| // Time:  O(n)
|  41|  41| // Space: O(1)
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  42|+class Solution2
|    |  43|+{
|    |  44|+  public:
|  44|  45|     /*
|  45|  46|      * param k : As description.
|  46|  47|      * param n : As description.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/digit-counts.cpp
|    |++++| /app/C++/digit-counts.cpp
|  46|  46|      * param n : As description.
|  47|  47|      * return: How many k's between 0 and n.
|  48|  48|      */
|  49|    |-    int digitCounts(int k, int n) {
|    |  49|+    int digitCounts (int k, int n)
|    |  50|+    {
|  50|  51|         int cnt = 0;
|  51|    |-        for (int i = 0; i <= n; ++i) {
|  52|    |-            int num = i;
|  53|    |-            while (num > 0) {
|  54|    |-                if (num % 10 == k) {
|  55|    |-                    ++cnt;
|    |  52|+        for (int i = 0; i <= n; ++i)
|    |  53|+          {
|    |  54|+              int num = i;
|    |  55|+              while (num > 0)
|    |  56|+                {
|    |  57|+                    if (num % 10 == k)
|    |  58|+                      {
|    |  59|+                          ++cnt;
|    |  60|+                      }
|    |  61|+                    num /= 10;
|  56|  62|                 }
|  57|    |-                num /= 10;
|  58|    |-            }
|  59|    |-        }
|    |  63|+          }
|  60|  64|         return cnt;
|  61|  65|     }
|  62|  66| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/2-sum.cpp
|    |++++| /app/C++/2-sum.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /*
|   7|   8|      * @param numbers : An array of Integer
|   8|   9|      * @param target : target = numbers[index1] + numbers[index2]
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/2-sum.cpp
|    |++++| /app/C++/2-sum.cpp
|   8|   8|      * @param target : target = numbers[index1] + numbers[index2]
|   9|   9|      * @return : [index1+1, index2+1] (index1 < index2)
|  10|  10|      */
|  11|    |-    vector<int> twoSum(vector<int> &nums, int target) {
|  12|    |-        unordered_map<int, int> hash;
|    |  11|+    vector < int >twoSum (vector < int >&nums, int target)
|    |  12|+    {
|    |  13|+        unordered_map < int, int >hash;
|  13|  14| 
|  14|    |-        for (int i = 0; i < nums.size(); ++i) {
|  15|    |-            // Check if "target - nums[i]" exists or not
|  16|    |-            if (hash.find(target - nums[i]) != hash.end()) {
|  17|    |-                return {hash[target - nums[i]] + 1, i + 1};
|  18|    |-            }
|  19|    |-            hash[nums[i]] = i;
|  20|    |-        }
|    |  15|+        for (int i = 0; i < nums.size (); ++i)
|    |  16|+          {
|    |  17|+              // Check if "target - nums[i]" exists or not
|    |  18|+              if (hash.find (target - nums[i]) != hash.end ())
|    |  19|+                {
|    |  20|+                    return
|    |  21|+                    {
|    |  22|+                    hash[target - nums[i]] + 1, i + 1};
|    |  23|+                }
|    |  24|+              hash[nums[i]] = i;
|    |  25|+          }
|  21|  26| 
|  22|    |-        return {};
|    |  27|+        return
|    |  28|+        {
|    |  29|+        };
|  23|  30|     }
|  24|  31| };
|  25|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/2-sum.cpp
|    |++++| /app/C++/2-sum.cpp
|  22|  22|         return {};
|  23|  23|     }
|  24|  24| };
|  25|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an array of Integer
|   8|   9|      * @return  an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence.cpp
|   7|   7|      * @param A an array of Integer
|   8|   8|      * @return  an integer
|   9|   9|      */
|  10|    |-    int longestIncreasingContinuousSubsequence(vector<int>& A) {
|    |  10|+    int longestIncreasingContinuousSubsequence (vector < int >&A)
|    |  11|+    {
|  11|  12|         int max_inc_len = 0, cur_inc_len = 0;
|  12|  13|         int max_dec_len = 0, cur_dec_len = 0;
|  13|  14| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-continuous-subsequence.cpp
|    |++++| /app/C++/longest-increasing-continuous-subsequence.cpp
|  11|  11|         int max_inc_len = 0, cur_inc_len = 0;
|  12|  12|         int max_dec_len = 0, cur_dec_len = 0;
|  13|  13| 
|  14|    |-        for (int i = 0; i < A.size(); ++i) {
|  15|    |-            if (i == 0 || A[i] == A[i - 1]) {
|  16|    |-                max_inc_len = max(max_inc_len, ++cur_inc_len);
|  17|    |-                max_dec_len = max(max_dec_len, ++cur_dec_len);
|  18|    |-            } else if (A[i] > A[i - 1]) {
|  19|    |-                max_inc_len = max(max_inc_len, ++cur_inc_len);
|  20|    |-                cur_dec_len = 1;
|  21|    |-            } else if (A[i] < A[i - 1]) {
|  22|    |-                max_dec_len = max(max_dec_len, ++cur_dec_len);
|  23|    |-                cur_inc_len = 1;
|  24|    |-            }
|  25|    |-        }
|    |  14|+        for (int i = 0; i < A.size (); ++i)
|    |  15|+          {
|    |  16|+              if (i == 0 || A[i] == A[i - 1])
|    |  17|+                {
|    |  18|+                    max_inc_len = max (max_inc_len, ++cur_inc_len);
|    |  19|+                    max_dec_len = max (max_dec_len, ++cur_dec_len);
|    |  20|+                }
|    |  21|+              else if (A[i] > A[i - 1])
|    |  22|+                {
|    |  23|+                    max_inc_len = max (max_inc_len, ++cur_inc_len);
|    |  24|+                    cur_dec_len = 1;
|    |  25|+                }
|    |  26|+              else if (A[i] < A[i - 1])
|    |  27|+                {
|    |  28|+                    max_dec_len = max (max_dec_len, ++cur_dec_len);
|    |  29|+                    cur_inc_len = 1;
|    |  30|+                }
|    |  31|+          }
|  26|  32| 
|  27|    |-        return max(max_inc_len, max_dec_len);
|    |  33|+        return max (max_inc_len, max_dec_len);
|  28|  34|     }
|  29|  35| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number.cpp
|    |++++| /app/C++/ugly-number.cpp
|   1|   1| // Time:  O(logn) = O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param num an integer
|   8|   9|      * @return true if num is an ugly number or false
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/ugly-number.cpp
|    |++++| /app/C++/ugly-number.cpp
|   7|   7|      * @param num an integer
|   8|   8|      * @return true if num is an ugly number or false
|   9|   9|      */
|  10|    |-    bool isUgly(int num) {
|  11|    |-        if (num == 0) {
|  12|    |-            return false;
|  13|    |-        }
|  14|    |-        for (const auto& i : {2, 3, 5}) {
|  15|    |-            while (num % i == 0) {
|  16|    |-                num /= i;
|  17|    |-            }
|  18|    |-        }
|    |  10|+    bool isUgly (int num)
|    |  11|+    {
|    |  12|+        if (num == 0)
|    |  13|+          {
|    |  14|+              return false;
|    |  15|+          }
|    |  16|+        for (const auto & i:
|    |  17|+             {
|    |  18|+             2, 3, 5})
|    |  19|+          {
|    |  20|+              while (num % i == 0)
|    |  21|+                {
|    |  22|+                    num /= i;
|    |  23|+                }
|    |  24|+          }
|  19|  25|         return num == 1;
|  20|  26|     }
|  21|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|   1|   1| // Time:  O(m + n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution { 
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An integer matrix
|   8|   9|      * @return: The index of the peak
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|   7|   7|      * @param A: An integer matrix
|   8|   8|      * @return: The index of the peak
|   9|   9|      */
|  10|    |-    vector<int> findPeakII(vector<vector<int>> A) {
|  11|    |-        int upper = 0, down = A.size() - 1;
|  12|    |-        int left = 0, right = A[0].size() - 1;
|    |  10|+    vector < int >findPeakII (vector < vector < int >>A)
|    |  11|+    {
|    |  12|+        int upper = 0, down = A.size () - 1;
|    |  13|+        int left = 0, right = A[0].size () - 1;
|  13|  14| 
|  14|    |-        while (upper < down && left < right) {
|  15|    |-            int height = down - upper + 1;
|  16|    |-            int width = right - left + 1;
|    |  15|+        while (upper < down && left < right)
|    |  16|+          {
|    |  17|+              int height = down - upper + 1;
|    |  18|+              int width = right - left + 1;
|  17|  19| 
|  18|    |-            // T(m, n) = T(m, n / 2) + O(m) = T(m / 2, n / 2) + O(m) + O(n / 2) = ... = O(2m) + O(2n) = O(max(m, n))
|  19|    |-            if (width > height) {  // Vertical split.
|  20|    |-                int mid_j = left + (right - left) / 2;
|  21|    |-                int left_max = 0, central_max = 0, right_max = 0;
|  22|    |-                int max_i = -1, max_j = -1;
|  23|    |-                for (int i = upper + 1; i < down; ++i) {
|  24|    |-                    if (A[i][mid_j] > central_max) {
|  25|    |-                        max_i = i, max_j = mid_j;
|  26|    |-                        central_max = A[i][mid_j];
|  27|    |-                    }
|  28|    |-                    left_max = max(left_max, A[i][mid_j - 1]);
|  29|    |-                    right_max = max(right_max, A[i][mid_j +  1]);
|    |  20|+              // T(m, n) = T(m, n / 2) + O(m) = T(m / 2, n / 2) + O(m) + O(n / 2) = ... = O(2m) + O(2n) = O(max(m, n))
|    |  21|+              if (width > height)
|    |  22|+                {               // Vertical split.
|    |  23|+                    int mid_j = left + (right - left) / 2;
|    |  24|+                    int left_max = 0, central_max = 0, right_max = 0;
|    |  25|+                    int max_i = -1, max_j = -1;
|    |  26|+                    for (int i = upper + 1; i < down; ++i)
|    |  27|+                      {
|    |  28|+                          if (A[i][mid_j] > central_max)
|    |  29|+                            {
|    |  30|+                                max_i = i, max_j = mid_j;
|    |  31|+                                central_max = A[i][mid_j];
|    |  32|+                            }
|    |  33|+                          left_max = max (left_max, A[i][mid_j - 1]);
|    |  34|+                          right_max = max (right_max, A[i][mid_j + 1]);
|    |  35|+                      }
|    |  36|+                    if (left_max > central_max && left_max > right_max)
|    |  37|+                      {         // Find left.
|    |  38|+                          right = mid_j;
|    |  39|+                      }
|    |  40|+                    else if (right_max > central_max && right_max > left_max)
|    |  41|+                      {         // Find right.
|    |  42|+                          left = mid_j;
|    |  43|+                      }
|    |  44|+                    else
|    |  45|+                      {         // Find one peak.
|    |  46|+                          return
|    |  47|+                          {
|    |  48|+                          max_i, max_j};
|    |  49|+                      }
|  30|  50|                 }
|  31|    |-                if (left_max > central_max && left_max > right_max) {  // Find left.
|  32|    |-                    right = mid_j;
|  33|    |-                } else if (right_max > central_max && right_max > left_max) {  // Find right.
|  34|    |-                    left = mid_j;
|  35|    |-                } else {  // Find one peak.
|  36|    |-                    return {max_i, max_j};
|    |  51|+              else
|    |  52|+                {               // Horizontal split.
|    |  53|+                    int mid_i = upper + (down - upper) / 2;
|    |  54|+                    int upper_max = 0, central_max = 0, down_max = 0;
|    |  55|+                    int max_i = -1, max_j = -1;
|    |  56|+                    for (int j = left + 1; j < right; ++j)
|    |  57|+                      {
|    |  58|+                          if (A[mid_i][j] > central_max)
|    |  59|+                            {
|    |  60|+                                max_i = mid_i, max_j = j;
|    |  61|+                                central_max = A[mid_i][j];
|    |  62|+                            }
|    |  63|+                          upper_max = max (upper_max, A[mid_i - 1][j]);
|    |  64|+                          down_max = max (down_max, A[mid_i + 1][j]);
|    |  65|+                      }
|    |  66|+                    if (upper_max > central_max && upper_max > down_max)
|    |  67|+                      {         // Find upper.
|    |  68|+                          down = mid_i;
|    |  69|+                      }
|    |  70|+                    else if (down_max > central_max && down_max > upper_max)
|    |  71|+                      {         // Find down.
|    |  72|+                          upper = mid_i;
|    |  73|+                      }
|    |  74|+                    else
|    |  75|+                      {         // Find one peak.
|    |  76|+                          return
|    |  77|+                          {
|    |  78|+                          max_i, max_j};
|    |  79|+                      }
|  37|  80|                 }
|  38|    |-            } else {  // Horizontal split.
|  39|    |-                int mid_i = upper + (down - upper) / 2;
|  40|    |-                int upper_max = 0, central_max = 0, down_max = 0;
|  41|    |-                int max_i = -1, max_j = -1;
|  42|    |-                for (int j = left + 1; j < right; ++j) {
|  43|    |-                    if (A[mid_i][j] > central_max) {
|  44|    |-                        max_i = mid_i, max_j = j;
|  45|    |-                        central_max = A[mid_i][j];
|  46|    |-                    }
|  47|    |-                    upper_max = max(upper_max, A[mid_i - 1][j]);
|  48|    |-                    down_max = max(down_max, A[mid_i + 1][j]);
|  49|    |-                }
|  50|    |-                if (upper_max > central_max && upper_max > down_max) {  // Find upper.
|  51|    |-                    down = mid_i;
|  52|    |-                } else if (down_max > central_max && down_max > upper_max) {  // Find down.
|  53|    |-                    upper = mid_i;
|  54|    |-                } else {  // Find one peak.
|  55|    |-                    return {max_i, max_j};
|  56|    |-                }
|  57|    |-            } 
|  58|  81| 
|  59|    |-        }
|  60|    |-        return {-1, -1}; // Not found.
|    |  82|+          }
|    |  83|+        return
|    |  84|+        {
|    |  85|+        -1, -1};                // Not found.
|  61|  86|     }
|  62|  87| };
|  63|  88| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|  67|  67| //      { 6, 22, 23, 28,  7},
|  68|  68| //      { 8, 24, 25, 26,  9},
|  69|  69| //      {10, 11, 12, 13, 14}};
|  70|    |-class Solution_Wrong {
|  71|    |-public:
|    |  70|+class Solution_Wrong
|    |  71|+{
|    |  72|+  public:
|  72|  73|     /**
|  73|  74|      * @param A: An integer matrix
|  74|  75|      * @return: The index of the peak
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|  73|  73|      * @param A: An integer matrix
|  74|  74|      * @return: The index of the peak
|  75|  75|      */
|  76|    |-    bool isPeak(const vector<vector<int>> &A, const int i, const int j) {
|  77|    |-        if (i < 1 || i >= A.size() - 1 || j < 1 || j >= A[0].size() - 1) {
|  78|    |-            return false;
|  79|    |-        }
|    |  76|+    bool isPeak (const vector < vector < int >>&A, const int i, const int j)
|    |  77|+    {
|    |  78|+        if (i < 1 || i >= A.size () - 1 || j < 1 || j >= A[0].size () - 1)
|    |  79|+          {
|    |  80|+              return false;
|    |  81|+          }
|  80|  82| 
|  81|  83|         return A[i][j] > A[i][j - 1] && A[i][j] > A[i - 1][j] &&
|  82|  84|                A[i][j] > A[i][j + 1] && A[i][j] > A[i + 1][j];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|  79|  79|         }
|  80|  80| 
|  81|  81|         return A[i][j] > A[i][j - 1] && A[i][j] > A[i - 1][j] &&
|  82|    |-               A[i][j] > A[i][j + 1] && A[i][j] > A[i + 1][j];
|    |  82|+            A[i][j] > A[i][j + 1] && A[i][j] > A[i + 1][j];
|  83|  83|     }
|  84|  84| 
|  85|  85|     vector<int> findPeakII(vector<vector<int>> A) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|  82|  82|                A[i][j] > A[i][j + 1] && A[i][j] > A[i + 1][j];
|  83|  83|     }
|  84|  84| 
|  85|    |-    vector<int> findPeakII(vector<vector<int>> A) {
|    |  85|+    vector < int >findPeakII (vector < vector < int >>A)
|    |  86|+    {
|  86|  87|         int i = 1, j = 1;
|  87|    |-        while (i < A.size() - 1 && j < A[0].size() - 1) {
|  88|    |-            if (isPeak(A, i, j)) {
|  89|    |-                return {i, j};
|  90|    |-            } else {
|  91|    |-                if (A[i + 1][j] > A[i][j + 1]) {
|  92|    |-                    ++i;
|  93|    |-                } else {
|  94|    |-                    ++j;
|    |  88|+        while (i < A.size () - 1 && j < A[0].size () - 1)
|    |  89|+          {
|    |  90|+              if (isPeak (A, i, j))
|    |  91|+                {
|    |  92|+                    return
|    |  93|+                    {
|    |  94|+                    i, j};
|  95|  95|                 }
|  96|    |-            }
|  97|    |-        }
|  98|    |-        return {-1, -1};
|    |  96|+              else
|    |  97|+                {
|    |  98|+                    if (A[i + 1][j] > A[i][j + 1])
|    |  99|+                      {
|    | 100|+                          ++i;
|    | 101|+                      }
|    | 102|+                    else
|    | 103|+                      {
|    | 104|+                          ++j;
|    | 105|+                      }
|    | 106|+                }
|    | 107|+          }
|    | 108|+        return
|    | 109|+        {
|    | 110|+        -1, -1};
|  99| 111|     }
| 100| 112| };
| 101| 113| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-peak-element-ii.cpp
|    |++++| /app/C++/find-peak-element-ii.cpp
|  98|  98|         return {-1, -1};
|  99|  99|     }
| 100| 100| };
| 101|    |-
| 102|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/left-pad.cpp
|    |++++| /app/C++/left-pad.cpp
|   1|   1| // Time:  O(p + n), p is the number of padChars
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class StringUtils {
|   5|    |-public:
|    |   4|+class StringUtils
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param originalStr the string we want to append to
|   8|   9|      * @param size the target length of the string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/left-pad.cpp
|    |++++| /app/C++/left-pad.cpp
|   9|   9|      * @param padChar the character to pad to the left side of the string
|  10|  10|      * @return a string
|  11|  11|      */
|  12|    |-    static string leftPad(string& originalStr, int size, char padChar=' ') {
|    |  12|+    static string leftPad (string & originalStr, int size, char padChar = ' ')
|    |  13|+    {
|  13|  14| 
|  14|    |-        return string(max(0, size - static_cast<int>(originalStr.length())),
|  15|    |-                      padChar).append(originalStr);
|    |  15|+        return
|    |  16|+            string (max (0, size - static_cast < int >(originalStr.length ())),
|    |  17|+                    padChar).append (originalStr);
|  16|  18|     }
|  17|  19| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combinations.cpp
|    |++++| /app/C++/combinations.cpp
|   1|   1| // Time:  O(k * n^k)
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: Given the range of numbers
|   8|   9|      * @param k: Given the numbers of combinations
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combinations.cpp
|    |++++| /app/C++/combinations.cpp
|   8|   8|      * @param k: Given the numbers of combinations
|   9|   9|      * @return: All the combinations of k numbers out of 1..n
|  10|  10|      */
|  11|    |-    vector<vector<int>> combine(int n, int k) {
|  12|    |-        vector<vector<int>> result;
|  13|    |-        vector<int> ans;
|  14|    |-        CombinationsHelper(n, k, 1, &ans, &result);
|  15|    |-        return result;
|    |  11|+    vector < vector < int >>combine (int n, int k)
|    |  12|+    {
|    |  13|+        vector < vector < int >>result;
|    |  14|+          vector < int >ans;
|    |  15|+          CombinationsHelper (n, k, 1, &ans, &result);
|    |  16|+          return result;
|  16|  17|     }
|  17|  18| 
|  18|  19|     void CombinationsHelper(int n, int k,  int start, vector<int>* ans,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/combinations.cpp
|    |++++| /app/C++/combinations.cpp
|  15|  15|         return result;
|  16|  16|     }
|  17|  17| 
|  18|    |-    void CombinationsHelper(int n, int k,  int start, vector<int>* ans,
|  19|    |-                            vector<vector<int>>* result) {
|  20|    |-        if (ans->size() == k) {
|  21|    |-            result->emplace_back(*ans);
|  22|    |-            return;
|  23|    |-        }
|    |  18|+    void CombinationsHelper (int n, int k, int start, vector < int >*ans,
|    |  19|+                             vector < vector < int >>*result)
|    |  20|+    {
|    |  21|+        if (ans->size () == k)
|    |  22|+          {
|    |  23|+              result->emplace_back (*ans);
|    |  24|+              return;
|    |  25|+          }
|  24|  26| 
|  25|    |-        for (int i = start; i <= n && k - ans->size() <= n - i + 1; ++i) {
|  26|    |-            ans->emplace_back(i);
|  27|    |-            CombinationsHelper(n, k, i + 1, ans, result);
|  28|    |-            ans->pop_back();
|  29|    |-        }
|    |  27|+        for (int i = start; i <= n && k - ans->size () <= n - i + 1; ++i)
|    |  28|+          {
|    |  29|+              ans->emplace_back (i);
|    |  30|+              CombinationsHelper (n, k, i + 1, ans, result);
|    |  31|+              ans->pop_back ();
|    |  32|+          }
|  30|  33|     }
|  31|  34| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/hash-function.cpp
|    |++++| /app/C++/hash-function.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param key: A String you should hash
|   8|   9|      * @param HASH_SIZE: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/hash-function.cpp
|    |++++| /app/C++/hash-function.cpp
|   8|   8|      * @param HASH_SIZE: An integer
|   9|   9|      * @return an integer
|  10|  10|      */
|  11|    |-    int hashCode(string key,int HASH_SIZE) {
|    |  11|+    int hashCode (string key, int HASH_SIZE)
|    |  12|+    {
|  12|  13|         long long value = 0L;
|  13|    |-        for (const auto& c : key) {
|  14|    |-            value = value * 33L % HASH_SIZE;
|  15|    |-            value = (value + static_cast<const long long>(c) % HASH_SIZE) % HASH_SIZE;
|  16|    |-        }
|  17|    |-        return static_cast<int>(value);
|    |  14|+        for (const auto & c:key)
|    |  15|+          {
|    |  16|+              value = value * 33L % HASH_SIZE;
|    |  17|+              value =
|    |  18|+                  (value + static_cast <
|    |  19|+                   const long long >(c) % HASH_SIZE) %HASH_SIZE;
|    |  20|+          }
|    |  21|+        return static_cast < int >(value);
|  18|  22|     }
|  19|  23| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n: An integers.
|   8|   9|      * @return: An integer which is the first bad version.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|   7|   7|      * @param n: An integers.
|   8|   8|      * @return: An integer which is the first bad version.
|   9|   9|      */
|  10|    |-    int findFirstBadVersion(int n) {
|    |  10|+    int findFirstBadVersion (int n)
|    |  11|+    {
|  11|  12|         int left = 1 - 1, right = n + 1;
|  12|  13| 
|  13|  14|         // At the last, left is not target, right is target.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  11|  11|         int left = 1 - 1, right = n + 1;
|  12|  12| 
|  13|  13|         // At the last, left is not target, right is target.
|  14|    |-        while (right - left > 1) {
|  15|    |-            int mid = left + (right - left) / 2;
|  16|    |-            // Is target
|  17|    |-            if (VersionControl::isBadVersion(mid)) {
|  18|    |-                right = mid;
|  19|    |-            } else {
|  20|    |-                left = mid;
|  21|    |-            }
|  22|    |-        }
|    |  14|+        while (right - left > 1)
|    |  15|+          {
|    |  16|+              int mid = left + (right - left) / 2;
|    |  17|+              // Is target
|    |  18|+              if (VersionControl::isBadVersion (mid))
|    |  19|+                {
|    |  20|+                    right = mid;
|    |  21|+                }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    left = mid;
|    |  25|+                }
|    |  26|+          }
|  23|  27|         return right;
|  24|  28|     }
|  25|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  24|  24|     }
|  25|  25| };
|  26|  26| 
|  27|    |-class Solution2 {
|  28|    |-public:
|    |  27|+class Solution2
|    |  28|+{
|    |  29|+  public:
|  29|  30|     /**
|  30|  31|      * @param n: An integers.
|  31|  32|      * @return: An integer which is the first bad version.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  30|  30|      * @param n: An integers.
|  31|  31|      * @return: An integer which is the first bad version.
|  32|  32|      */
|  33|    |-    int findFirstBadVersion(int n) {
|    |  33|+    int findFirstBadVersion (int n)
|    |  34|+    {
|  34|  35|         int left = 1, right = n + 1;
|  35|  36| 
|  36|  37|         // At the last, left is not sure for target, right is target.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  34|  34|         int left = 1, right = n + 1;
|  35|  35| 
|  36|  36|         // At the last, left is not sure for target, right is target.
|  37|    |-        while (left < right) {
|  38|    |-            int mid = left + (right - left) / 2;
|  39|    |-            // Is target
|  40|    |-            if (VersionControl::isBadVersion(mid)) {
|  41|    |-                right = mid;
|  42|    |-            } else {
|  43|    |-                left = mid + 1;
|  44|    |-            }
|  45|    |-        }
|    |  37|+        while (left < right)
|    |  38|+          {
|    |  39|+              int mid = left + (right - left) / 2;
|    |  40|+              // Is target
|    |  41|+              if (VersionControl::isBadVersion (mid))
|    |  42|+                {
|    |  43|+                    right = mid;
|    |  44|+                }
|    |  45|+              else
|    |  46|+                {
|    |  47|+                    left = mid + 1;
|    |  48|+                }
|    |  49|+          }
|  46|  50|         return left;
|  47|  51|     }
|  48|  52| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  47|  47|     }
|  48|  48| };
|  49|  49| 
|  50|    |-class Solution3 {
|  51|    |-public:
|    |  50|+class Solution3
|    |  51|+{
|    |  52|+  public:
|  52|  53|     /**
|  53|  54|      * @param n: An integers.
|  54|  55|      * @return: An integer which is the first bad version.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  53|  53|      * @param n: An integers.
|  54|  54|      * @return: An integer which is the first bad version.
|  55|  55|      */
|  56|    |-    int findFirstBadVersion(int n) {
|    |  56|+    int findFirstBadVersion (int n)
|    |  57|+    {
|  57|  58|         int left = 1, right = n;
|  58|  59| 
|  59|  60|         // At the last, left is not sure for target, right is not sure for target.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/first-bad-version.cpp
|    |++++| /app/C++/first-bad-version.cpp
|  57|  57|         int left = 1, right = n;
|  58|  58| 
|  59|  59|         // At the last, left is not sure for target, right is not sure for target.
|  60|    |-        while (left <= right) {
|  61|    |-            int mid = left + (right - left) / 2;
|  62|    |-            // Is target
|  63|    |-            if (VersionControl::isBadVersion(mid)) {
|  64|    |-                right = mid - 1;
|  65|    |-            } else {
|  66|    |-                left = mid + 1;
|  67|    |-            }
|  68|    |-        }
|    |  60|+        while (left <= right)
|    |  61|+          {
|    |  62|+              int mid = left + (right - left) / 2;
|    |  63|+              // Is target
|    |  64|+              if (VersionControl::isBadVersion (mid))
|    |  65|+                {
|    |  66|+                    right = mid - 1;
|    |  67|+                }
|    |  68|+              else
|    |  69|+                {
|    |  70|+                    left = mid + 1;
|    |  71|+                }
|    |  72|+          }
|  69|  73|         return left;
|  70|  74|     }
|  71|  75| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/decode-ways.cpp
|    |++++| /app/C++/decode-ways.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s a string,  encoded message
|   8|   9|      * @return an integer, the number of ways decoding
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/decode-ways.cpp
|    |++++| /app/C++/decode-ways.cpp
|   7|   7|      * @param s a string,  encoded message
|   8|   8|      * @return an integer, the number of ways decoding
|   9|   9|      */
|  10|    |-    int numDecodings(string& s) {
|  11|    |-        if (s.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int numDecodings (string & s)
|    |  11|+    {
|    |  12|+        if (s.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|    |-        int prev = 0; // f[n - 2]
|  16|    |-        int cur = 1;  // f[n - 1]
|    |  17|+        int prev = 0;           // f[n - 2]
|    |  18|+        int cur = 1;            // f[n - 1]
|  17|  19| 
|  18|    |-        for (int i = 0; i < s.length(); ++i) {
|  19|    |-            if (s[i] == '0') {
|  20|    |-                cur = 0; // f[n - 1] = 0
|  21|    |-            }
|  22|    |-            if (i == 0 ||
|  23|    |-                !(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))) {
|  24|    |-                prev = 0; // f[n - 2] = 0
|  25|    |-            }
|    |  20|+        for (int i = 0; i < s.length (); ++i)
|    |  21|+          {
|    |  22|+              if (s[i] == '0')
|    |  23|+                {
|    |  24|+                    cur = 0;    // f[n - 1] = 0
|    |  25|+                }
|    |  26|+              if (i == 0 ||
|    |  27|+                  !(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')))
|    |  28|+                {
|    |  29|+                    prev = 0;   // f[n - 2] = 0
|    |  30|+                }
|  26|  31| 
|  27|    |-            int tmp = cur;
|  28|    |-            cur += prev; // f[n] = f[n - 1] + f[n - 2]
|  29|    |-            prev = tmp;
|  30|    |-        }
|    |  32|+              int tmp = cur;
|    |  33|+              cur += prev;      // f[n] = f[n - 1] + f[n - 2]
|    |  34|+              prev = tmp;
|    |  35|+          }
|  31|  36| 
|  32|  37|         return cur;
|  33|  38|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  10|  10|  * };
|  11|  11|  */
|  12|  12| // BFS
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param graph: A list of Directed graph node
|  17|  18|      * @return: Any topological order for the given graph.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  16|  16|      * @param graph: A list of Directed graph node
|  17|  17|      * @return: Any topological order for the given graph.
|  18|  18|      */
|  19|    |-    vector<DirectedGraphNode *> topSort(vector<DirectedGraphNode*> graph) {
|  20|    |-        vector<DirectedGraphNode *> output;
|    |  19|+    vector < DirectedGraphNode * >topSort (vector < DirectedGraphNode * >graph)
|    |  20|+    {
|    |  21|+        vector < DirectedGraphNode * >output;
|  21|  22| 
|  22|  23|         // Find ancestors of each node by DFS
|  23|  24|         unordered_set<DirectedGraphNode *> nodes;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  20|  20|         vector<DirectedGraphNode *> output;
|  21|  21| 
|  22|  22|         // Find ancestors of each node by DFS
|  23|    |-        unordered_set<DirectedGraphNode *> nodes;
|  24|    |-        unordered_map<DirectedGraphNode *, int> ancestors;
|  25|    |-        for (const auto& node :graph) {
|  26|    |-            findDependencyBFS(node, nodes, ancestors);
|  27|    |-        }
|    |  23|+        unordered_set < DirectedGraphNode * >nodes;
|    |  24|+        unordered_map < DirectedGraphNode *, int >ancestors;
|    |  25|+        for (const auto & node:graph)
|    |  26|+          {
|    |  27|+              findDependencyBFS (node, nodes, ancestors);
|    |  28|+          }
|  28|  29| 
|  29|  30|         // Output topological order by BFS
|  30|  31|         topSortBFS(graph, ancestors, output);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  27|  27|         }
|  28|  28| 
|  29|  29|         // Output topological order by BFS
|  30|    |-        topSortBFS(graph, ancestors, output);
|    |  30|+        topSortBFS (graph, ancestors, output);
|  31|  31| 
|  32|  32|         return output;
|  33|  33|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  32|  32|         return output;
|  33|  33|     }
|  34|  34| 
|  35|    |-private:
|  36|    |-    void findDependencyBFS(DirectedGraphNode* node,
|  37|    |-                           unordered_set<DirectedGraphNode *> &nodes,
|  38|    |-                           unordered_map<DirectedGraphNode *, int> &ancestors) {
|  39|    |-        if (nodes.emplace(node).second) {
|  40|    |-            queue<DirectedGraphNode *> scheduled;
|  41|    |-            scheduled.emplace(node);
|  42|    |-            while (!scheduled.empty()) {
|  43|    |-                DirectedGraphNode *node = scheduled.front();
|  44|    |-                scheduled.pop();
|    |  35|+  private:
|    |  36|+    void findDependencyBFS (DirectedGraphNode * node,
|    |  37|+                            unordered_set < DirectedGraphNode * >&nodes,
|    |  38|+                            unordered_map < DirectedGraphNode *,
|    |  39|+                            int >&ancestors)
|    |  40|+    {
|    |  41|+        if (nodes.emplace (node).second)
|    |  42|+          {
|    |  43|+              queue < DirectedGraphNode * >scheduled;
|    |  44|+              scheduled.emplace (node);
|    |  45|+              while (!scheduled.empty ())
|    |  46|+                {
|    |  47|+                    DirectedGraphNode *node = scheduled.front ();
|    |  48|+                    scheduled.pop ();
|  45|  49| 
|  46|    |-                // Update in degree of neighbors.
|  47|    |-                for (const auto& neighbor : node->neighbors) {
|  48|    |-                    ++ancestors[neighbor];
|  49|    |-                    if (nodes.emplace(neighbor).second) {
|  50|    |-                        scheduled.emplace(neighbor);
|  51|    |-                    }
|    |  50|+                    // Update in degree of neighbors.
|    |  51|+                  for (const auto & neighbor:node->
|    |  52|+                         neighbors)
|    |  53|+                      {
|    |  54|+                          ++ancestors[neighbor];
|    |  55|+                          if (nodes.emplace (neighbor).second)
|    |  56|+                            {
|    |  57|+                                scheduled.emplace (neighbor);
|    |  58|+                            }
|    |  59|+                      }
|  52|  60|                 }
|  53|    |-            }
|  54|    |-        }
|    |  61|+          }
|  55|  62|     }
|  56|  63| 
|  57|  64|     void topSortBFS(vector<DirectedGraphNode*>& graph,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  54|  54|         }
|  55|  55|     }
|  56|  56| 
|  57|    |-    void topSortBFS(vector<DirectedGraphNode*>& graph,
|  58|    |-                    unordered_map<DirectedGraphNode *, int> &ancestors,
|  59|    |-                    vector<DirectedGraphNode *> &output) {
|    |  57|+    void topSortBFS (vector < DirectedGraphNode * >&graph,
|    |  58|+                     unordered_map < DirectedGraphNode *, int >&ancestors,
|    |  59|+                     vector < DirectedGraphNode * >&output)
|    |  60|+    {
|  60|  61|         // Find the nodes with 0 in degree.
|  61|    |-        queue<DirectedGraphNode *> scheduled;
|  62|    |-        for (const auto& node : graph) {
|  63|    |-            if (ancestors[node] == 0) {
|  64|    |-                scheduled.emplace(node);
|  65|    |-            }
|  66|    |-        }
|    |  62|+        queue < DirectedGraphNode * >scheduled;
|    |  63|+      for (const auto & node:graph)
|    |  64|+          {
|    |  65|+              if (ancestors[node] == 0)
|    |  66|+                {
|    |  67|+                    scheduled.emplace (node);
|    |  68|+                }
|    |  69|+          }
|  67|  70| 
|  68|    |-        while (!scheduled.empty()) {
|  69|    |-            DirectedGraphNode *node = scheduled.front();
|  70|    |-            output.emplace_back(node);
|  71|    |-            scheduled.pop();
|    |  71|+        while (!scheduled.empty ())
|    |  72|+          {
|    |  73|+              DirectedGraphNode *node = scheduled.front ();
|    |  74|+              output.emplace_back (node);
|    |  75|+              scheduled.pop ();
|  72|  76| 
|  73|    |-            // Update in degree of neighbors.
|  74|    |-            for (const auto& neighbor : node->neighbors) {
|  75|    |-                --ancestors[neighbor];
|  76|    |-                if (ancestors[neighbor] == 0) {
|  77|    |-                    scheduled.emplace(neighbor);
|    |  77|+              // Update in degree of neighbors.
|    |  78|+            for (const auto & neighbor:node->neighbors)
|    |  79|+                {
|    |  80|+                    --ancestors[neighbor];
|    |  81|+                    if (ancestors[neighbor] == 0)
|    |  82|+                      {
|    |  83|+                          scheduled.emplace (neighbor);
|    |  84|+                      }
|  78|  85|                 }
|  79|    |-            }
|  80|    |-        }
|    |  86|+          }
|  81|  87|     }
|  82|  88| };
|  83|  89| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  82|  82| };
|  83|  83| 
|  84|  84| // DFS
|  85|    |-class Solution2 {
|  86|    |-public:
|    |  85|+class Solution2
|    |  86|+{
|    |  87|+  public:
|  87|  88|     /**
|  88|  89|      * @param graph: A list of Directed graph node
|  89|  90|      * @return: Any topological order for the given graph.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  88|  88|      * @param graph: A list of Directed graph node
|  89|  89|      * @return: Any topological order for the given graph.
|  90|  90|      */
|  91|    |-    vector<DirectedGraphNode *> topSort(vector<DirectedGraphNode*> graph) {
|  92|    |-        vector<DirectedGraphNode *> output;
|    |  91|+    vector < DirectedGraphNode * >topSort (vector < DirectedGraphNode * >graph)
|    |  92|+    {
|    |  93|+        vector < DirectedGraphNode * >output;
|  93|  94| 
|  94|  95|         // Find ancestors of each node by DFS
|  95|  96|         unordered_set<DirectedGraphNode *> nodes;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  92|  92|         vector<DirectedGraphNode *> output;
|  93|  93| 
|  94|  94|         // Find ancestors of each node by DFS
|  95|    |-        unordered_set<DirectedGraphNode *> nodes;
|  96|    |-        unordered_map<DirectedGraphNode *, vector<DirectedGraphNode *>> ancestors;
|  97|    |-        for (const auto& node :graph) {
|  98|    |-            findDependencyDFS(node, nodes, ancestors);
|  99|    |-        }
|    |  95|+        unordered_set < DirectedGraphNode * >nodes;
|    |  96|+        unordered_map < DirectedGraphNode *,
|    |  97|+            vector < DirectedGraphNode * >>ancestors;
|    |  98|+        for (const auto & node:graph)
|    |  99|+          {
|    | 100|+              findDependencyDFS (node, nodes, ancestors);
|    | 101|+          }
| 100| 102| 
| 101| 103|         // Output topological order by DFS
| 102| 104|         unordered_set<DirectedGraphNode *> scheduled;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
|  99|  99|         }
| 100| 100| 
| 101| 101|         // Output topological order by DFS
| 102|    |-        unordered_set<DirectedGraphNode *> scheduled;
| 103|    |-        for (const auto& node : graph) {
| 104|    |-            topSortDFS(node, ancestors, scheduled, output);
| 105|    |-        }
|    | 102|+        unordered_set < DirectedGraphNode * >scheduled;
|    | 103|+      for (const auto & node:graph)
|    | 104|+          {
|    | 105|+              topSortDFS (node, ancestors, scheduled, output);
|    | 106|+          }
| 106| 107| 
| 107| 108|         return output;
| 108| 109|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
| 107| 107|         return output;
| 108| 108|     }
| 109| 109| 
| 110|    |-private:
| 111|    |-    void findDependencyDFS(DirectedGraphNode* node,
| 112|    |-                           unordered_set<DirectedGraphNode *> &nodes,
| 113|    |-                           unordered_map<DirectedGraphNode *, vector<DirectedGraphNode *>> &ancestors) {
| 114|    |-        if (nodes.emplace(node).second) {
| 115|    |-            for (const auto& neighbor : node->neighbors) {
| 116|    |-                ancestors[neighbor].emplace_back(node);
| 117|    |-                findDependencyDFS(neighbor, nodes, ancestors);
| 118|    |-            }
| 119|    |-        }
|    | 110|+  private:
|    | 111|+    void findDependencyDFS (DirectedGraphNode * node,
|    | 112|+                            unordered_set < DirectedGraphNode * >&nodes,
|    | 113|+                            unordered_map < DirectedGraphNode *,
|    | 114|+                            vector < DirectedGraphNode * >>&ancestors)
|    | 115|+    {
|    | 116|+        if (nodes.emplace (node).second)
|    | 117|+          {
|    | 118|+            for (const auto & neighbor:node->neighbors)
|    | 119|+                {
|    | 120|+                    ancestors[neighbor].emplace_back (node);
|    | 121|+                    findDependencyDFS (neighbor, nodes, ancestors);
|    | 122|+                }
|    | 123|+          }
| 120| 124|     }
| 121| 125| 
| 122| 126|     void topSortDFS(DirectedGraphNode *node,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/topological-sorting.cpp
|    |++++| /app/C++/topological-sorting.cpp
| 119| 119|         }
| 120| 120|     }
| 121| 121| 
| 122|    |-    void topSortDFS(DirectedGraphNode *node,
| 123|    |-                    unordered_map<DirectedGraphNode *, vector<DirectedGraphNode *>> &ancestors,
| 124|    |-                    unordered_set<DirectedGraphNode *> &scheduled,
| 125|    |-                    vector<DirectedGraphNode *> &output) {
| 126|    |-        if (scheduled.emplace(node).second) {
| 127|    |-            for (const auto& ancestor: ancestors[node]) {
| 128|    |-                topSortDFS(ancestor, ancestors, scheduled, output);
| 129|    |-            }
| 130|    |-            output.emplace_back(node);
| 131|    |-        }
|    | 122|+    void topSortDFS (DirectedGraphNode * node,
|    | 123|+                     unordered_map < DirectedGraphNode *,
|    | 124|+                     vector < DirectedGraphNode * >>&ancestors,
|    | 125|+                     unordered_set < DirectedGraphNode * >&scheduled,
|    | 126|+                     vector < DirectedGraphNode * >&output)
|    | 127|+    {
|    | 128|+        if (scheduled.emplace (node).second)
|    | 129|+          {
|    | 130|+            for (const auto & ancestor:ancestors[node])
|    | 131|+                {
|    | 132|+                    topSortDFS (ancestor, ancestors, scheduled, output);
|    | 133|+                }
|    | 134|+              output.emplace_back (node);
|    | 135|+          }
| 132| 136|     }
| 133| 137| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/max-points-on-a-line.cpp
|    |++++| /app/C++/max-points-on-a-line.cpp
|  10|  10|  *     Point(int a, int b) : x(a), y(b) {}
|  11|  11|  * };
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param points an array of point
|  17|  18|      * @return an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/max-points-on-a-line.cpp
|    |++++| /app/C++/max-points-on-a-line.cpp
|  16|  16|      * @param points an array of point
|  17|  17|      * @return an integer
|  18|  18|      */
|  19|    |-    int maxPoints(vector<Point>& points) {
|    |  19|+    int maxPoints (vector < Point > &points)
|    |  20|+    {
|  20|  21|         int max_points = 0;
|  21|    |-        for (int i = 0; i < points.size(); ++i) {
|  22|    |-            unordered_map<double, int> slope_count;
|  23|    |-            const auto& start = points[i];
|  24|    |-            int same = 1;
|    |  22|+        for (int i = 0; i < points.size (); ++i)
|    |  23|+          {
|    |  24|+              unordered_map < double, int >slope_count;
|    |  25|+              const auto & start = points[i];
|    |  26|+              int same = 1;
|  25|  27| 
|  26|    |-            for (int j = i + 1; j < points.size(); ++j) {
|  27|    |-                const auto& end = points[j];
|  28|    |-                if (start.x == end.x && start.y == end.y) {
|  29|    |-                    ++same;
|  30|    |-                } else {
|  31|    |-                    auto slope = numeric_limits<double>::max();
|  32|    |-                    if (start.x - end.x != 0) {
|  33|    |-                        slope = (start.y - end.y) * 1.0 / (start.x - end.x);
|  34|    |-                    }
|  35|    |-                    ++slope_count[slope];
|    |  28|+              for (int j = i + 1; j < points.size (); ++j)
|    |  29|+                {
|    |  30|+                    const auto & end = points[j];
|    |  31|+                    if (start.x == end.x && start.y == end.y)
|    |  32|+                      {
|    |  33|+                          ++same;
|    |  34|+                      }
|    |  35|+                    else
|    |  36|+                      {
|    |  37|+                          auto slope = numeric_limits < double >::max ();
|    |  38|+                          if (start.x - end.x != 0)
|    |  39|+                            {
|    |  40|+                                slope =
|    |  41|+                                    (start.y - end.y) * 1.0 / (start.x -
|    |  42|+                                                               end.x);
|    |  43|+                            }
|    |  44|+                          ++slope_count[slope];
|    |  45|+                      }
|  36|  46|                 }
|  37|    |-            }
|  38|  47| 
|  39|    |-            int current_max = same;
|  40|    |-            for (const auto& kvp : slope_count) {
|  41|    |-                current_max = max(current_max, kvp.second + same);
|  42|    |-            }
|  43|    |-            max_points = max(max_points, current_max);
|  44|    |-        }
|    |  48|+              int current_max = same;
|    |  49|+            for (const auto & kvp:slope_count)
|    |  50|+                {
|    |  51|+                    current_max = max (current_max, kvp.second + same);
|    |  52|+                }
|    |  53|+              max_points = max (max_points, current_max);
|    |  54|+          }
|  45|  55| 
|  46|  56|         return max_points;
|  47|  57|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/swap-two-nodes-in-linked-list.cpp
|    |++++| /app/C++/swap-two-nodes-in-linked-list.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param head a ListNode
|  16|  17|      * @oaram v1 an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/swap-two-nodes-in-linked-list.cpp
|    |++++| /app/C++/swap-two-nodes-in-linked-list.cpp
|  17|  17|      * @param v2 an integer
|  18|  18|      * @return a new head of singly-linked list
|  19|  19|      */
|  20|    |-    ListNode* swapNodes(ListNode* head, int v1, int v2) {
|  21|    |-        ListNode dummy{0};
|  22|    |-        dummy.next = head;
|    |  20|+    ListNode * swapNodes (ListNode * head, int v1, int v2)
|    |  21|+    {
|    |  22|+        ListNode dummy
|    |  23|+        {
|    |  24|+        0};
|    |  25|+          dummy.next = head;
|  23|  26|         auto curr = &dummy;
|  24|    |-        ListNode *prev_node1{nullptr}, *prev_node2{nullptr};
|  25|    |-        while (curr && curr->next) {
|  26|    |-            if (curr->next->val == v1) {
|  27|    |-                prev_node1 = curr;
|  28|    |-            }
|  29|    |-            if (curr->next->val == v2) {
|  30|    |-                prev_node2 = curr;
|  31|    |-            }
|  32|    |-            if (prev_node1 && prev_node2) {
|  33|    |-                auto node1 = prev_node1->next;
|  34|    |-                auto node2 = prev_node2->next;
|  35|    |-                auto node1_next = node1->next;
|  36|    |-                auto node2_next = node2->next;
|  37|    |-                if (node1->next == node2) {
|  38|    |-                    prev_node1->next = node2;
|  39|    |-                    node2->next = node1;
|  40|    |-                    node1->next = node2_next;
|  41|    |-                } else if (node2->next == node1) {
|  42|    |-                    prev_node2->next = node1;
|  43|    |-                    node1->next = node2;
|  44|    |-                    node2->next = node1_next;
|  45|    |-                } else {
|  46|    |-                    prev_node1->next = node2;
|  47|    |-                    node2->next = node1_next;
|  48|    |-                    prev_node2->next = node1;
|  49|    |-                    node1->next = node2_next;
|    |  27|+        ListNode *prev_node1
|    |  28|+        {
|    |  29|+        nullptr}, *prev_node2
|    |  30|+        {
|    |  31|+        nullptr};
|    |  32|+        while (curr && curr->next)
|    |  33|+          {
|    |  34|+              if (curr->next->val == v1)
|    |  35|+                {
|    |  36|+                    prev_node1 = curr;
|  50|  37|                 }
|  51|    |-                break;
|  52|    |-            }
|  53|    |-            curr = curr->next;
|  54|    |-        }
|    |  38|+              if (curr->next->val == v2)
|    |  39|+                {
|    |  40|+                    prev_node2 = curr;
|    |  41|+                }
|    |  42|+              if (prev_node1 && prev_node2)
|    |  43|+                {
|    |  44|+                    auto node1 = prev_node1->next;
|    |  45|+                    auto node2 = prev_node2->next;
|    |  46|+                    auto node1_next = node1->next;
|    |  47|+                    auto node2_next = node2->next;
|    |  48|+                    if (node1->next == node2)
|    |  49|+                      {
|    |  50|+                          prev_node1->next = node2;
|    |  51|+                          node2->next = node1;
|    |  52|+                          node1->next = node2_next;
|    |  53|+                      }
|    |  54|+                    else if (node2->next == node1)
|    |  55|+                      {
|    |  56|+                          prev_node2->next = node1;
|    |  57|+                          node1->next = node2;
|    |  58|+                          node2->next = node1_next;
|    |  59|+                      }
|    |  60|+                    else
|    |  61|+                      {
|    |  62|+                          prev_node1->next = node2;
|    |  63|+                          node2->next = node1_next;
|    |  64|+                          prev_node2->next = node1;
|    |  65|+                          node1->next = node2_next;
|    |  66|+                      }
|    |  67|+                    break;
|    |  68|+                }
|    |  69|+              curr = curr->next;
|    |  70|+          }
|  55|  71|         return dummy.next;
|  56|  72|     }
|  57|  73| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query.cpp
|    |++++| /app/C++/segment-tree-query.cpp
|  15|  15|  *     }
|  16|  16|  * }
|  17|  17|  */
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      *@param root, start, end: The root of segment tree and
|  22|  23|      *                         an segment / interval
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query.cpp
|    |++++| /app/C++/segment-tree-query.cpp
|  22|  22|      *                         an segment / interval
|  23|  23|      *@return: The maximum number in the interval [start, end]
|  24|  24|      */
|  25|    |-    int query(SegmentTreeNode *root, int start, int end) {
|    |  25|+    int query (SegmentTreeNode * root, int start, int end)
|    |  26|+    {
|  26|  27|         // Out of range.
|  27|    |-        if (root == nullptr || root->start > end || root->end <  start) {
|  28|    |-            return INT_MIN;
|  29|    |-        }
|    |  28|+        if (root == nullptr || root->start > end || root->end < start)
|    |  29|+          {
|    |  30|+              return INT_MIN;
|    |  31|+          }
|  30|  32| 
|  31|  33|         // Current segment is totally within range [start, end]
|  32|  34|         if (root->start >= start && root->end <= end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query.cpp
|    |++++| /app/C++/segment-tree-query.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Current segment is totally within range [start, end]
|  32|    |-        if (root->start >= start && root->end <= end) {
|  33|    |-            return root->max;
|  34|    |-        }
|    |  32|+        if (root->start >= start && root->end <= end)
|    |  33|+          {
|    |  34|+              return root->max;
|    |  35|+          }
|  35|  36| 
|  36|    |-        int left = query(root->left, start, end);
|  37|    |-        int right = query(root->right, start, end);
|    |  37|+        int left = query (root->left, start, end);
|    |  38|+        int right = query (root->right, start, end);
|  38|  39| 
|  39|  40|         // Find max in the children.
|  40|  41|         return max(left, right);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query.cpp
|    |++++| /app/C++/segment-tree-query.cpp
|  37|  37|         int right = query(root->right, start, end);
|  38|  38| 
|  39|  39|         // Find max in the children.
|  40|    |-        return max(left, right);
|    |  40|+        return max (left, right);
|  41|  41|     }
|  42|  42| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: An array of integers
|   8|   9|      * @return: An array of integers that's previous permuation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|   7|   7|      * @param nums: An array of integers
|   8|   8|      * @return: An array of integers that's previous permuation
|   9|   9|      */
|  10|    |-    vector<int> previousPermuation(vector<int> &nums) {
|    |  10|+    vector < int >previousPermuation (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int k = -1, l = 0;
|  12|  13| 
|  13|  14|         // Find the last index k before the increasing sequence.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|  11|  11|         int k = -1, l = 0;
|  12|  12| 
|  13|  13|         // Find the last index k before the increasing sequence.
|  14|    |-        for (int i = 0; i < nums.size() - 1; ++i) {
|  15|    |-            if (nums[i] > nums[i + 1]) {
|  16|    |-                k = i;
|  17|    |-            }
|  18|    |-        }
|    |  14|+        for (int i = 0; i < nums.size () - 1; ++i)
|    |  15|+          {
|    |  16|+              if (nums[i] > nums[i + 1])
|    |  17|+                {
|    |  18|+                    k = i;
|    |  19|+                }
|    |  20|+          }
|  19|  21| 
|  20|    |-        if (k >= 0) {
|  21|    |-            // Find the largest number which is smaller than the value of the index k,
|  22|    |-            // and swap the values.
|  23|    |-            for (int i = 0; i < nums.size(); ++i) {
|  24|    |-                if (nums[i] < nums[k]) {
|  25|    |-                    l = i;
|    |  22|+        if (k >= 0)
|    |  23|+          {
|    |  24|+              // Find the largest number which is smaller than the value of the index k,
|    |  25|+              // and swap the values.
|    |  26|+              for (int i = 0; i < nums.size (); ++i)
|    |  27|+                {
|    |  28|+                    if (nums[i] < nums[k])
|    |  29|+                      {
|    |  30|+                          l = i;
|    |  31|+                      }
|  26|  32|                 }
|  27|    |-            }
|  28|    |-            swap(nums[k], nums[l]);
|  29|    |-        }
|    |  33|+              swap (nums[k], nums[l]);
|    |  34|+          }
|  30|  35| 
|  31|  36|         // Reverse the sequence after the index k.
|  32|  37|         reverse(nums.begin() + k + 1, nums.end());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Reverse the sequence after the index k.
|  32|    |-        reverse(nums.begin() + k + 1, nums.end());
|    |  32|+        reverse (nums.begin () + k + 1, nums.end ());
|  33|  33| 
|  34|  34|         return nums;
|  35|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|  35|  35|     }
|  36|  36| };
|  37|  37| 
|  38|    |-class Solution2 {
|  39|    |-public:
|    |  38|+class Solution2
|    |  39|+{
|    |  40|+  public:
|  40|  41|     /**
|  41|  42|      * @param nums: An array of integers
|  42|  43|      * @return: An array of integers that's previous permuation
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/previous-permutation.cpp
|    |++++| /app/C++/previous-permutation.cpp
|  41|  41|      * @param nums: An array of integers
|  42|  42|      * @return: An array of integers that's previous permuation
|  43|  43|      */
|  44|    |-    vector<int> previousPermuation(vector<int> &nums) {
|  45|    |-        prev_permutation(nums.begin(), nums.end());
|    |  44|+    vector < int >previousPermuation (vector < int >&nums)
|    |  45|+    {
|    |  46|+        prev_permutation (nums.begin (), nums.end ());
|  46|  47|         return nums;
|  47|  48|     }
|  48|  49| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum-ii.cpp
|    |++++| /app/C++/k-sum-ii.cpp
|   1|   1| // Time:  O(k * C(n, k))
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: an integer array.
|   8|   9|      * @param k: a positive integer (k <= length(A))
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum-ii.cpp
|    |++++| /app/C++/k-sum-ii.cpp
|   9|   9|      * @param target: a integer
|  10|  10|      * @return a list of lists of integer
|  11|  11|      */
|  12|    |-    vector<vector<int>> kSumII(vector<int> A, int k, int target) {
|  13|    |-        vector<vector<int>> ans;
|  14|    |-        vector<int> curr;
|  15|    |-        helper(A, k, 0, target, curr, ans);
|  16|    |-        return ans;
|    |  12|+    vector < vector < int >>kSumII (vector < int >A, int k, int target)
|    |  13|+    {
|    |  14|+        vector < vector < int >>ans;
|    |  15|+          vector < int >curr;
|    |  16|+          helper (A, k, 0, target, curr, ans);
|    |  17|+          return ans;
|  17|  18|     }
|  18|  19| 
|  19|  20|     void helper(vector<int> A, int k, int start, int target, vector<int>& curr, vector<vector<int>> & ans) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum-ii.cpp
|    |++++| /app/C++/k-sum-ii.cpp
|  16|  16|         return ans;
|  17|  17|     }
|  18|  18| 
|  19|    |-    void helper(vector<int> A, int k, int start, int target, vector<int>& curr, vector<vector<int>> & ans) {
|  20|    |-        if (k < 0 || target < 0) {
|  21|    |-            return;
|  22|    |-        }
|    |  19|+    void helper (vector < int >A, int k, int start, int target,
|    |  20|+                 vector < int >&curr, vector < vector < int >>&ans)
|    |  21|+    {
|    |  22|+        if (k < 0 || target < 0)
|    |  23|+          {
|    |  24|+              return;
|    |  25|+          }
|  23|  26| 
|  24|    |-        if (k == 0 && target == 0) {
|  25|    |-            ans.emplace_back(curr);
|  26|    |-            return;
|  27|    |-        }
|    |  27|+        if (k == 0 && target == 0)
|    |  28|+          {
|    |  29|+              ans.emplace_back (curr);
|    |  30|+              return;
|    |  31|+          }
|  28|  32| 
|  29|    |-        for (int i = start; i <= A.size() - k; i++) {
|  30|    |-            curr.emplace_back(A[i]);
|  31|    |-            helper(A, k - 1, i + 1, target - A[i], curr, ans);
|  32|    |-            curr.pop_back();
|  33|    |-        }
|    |  33|+        for (int i = start; i <= A.size () - k; i++)
|    |  34|+          {
|    |  35|+              curr.emplace_back (A[i]);
|    |  36|+              helper (A, k - 1, i + 1, target - A[i], curr, ans);
|    |  37|+              curr.pop_back ();
|    |  38|+          }
|  34|  39|     }
|  35|  40| };
|  36|  41| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/k-sum-ii.cpp
|    |++++| /app/C++/k-sum-ii.cpp
|  33|  33|         }
|  34|  34|     }
|  35|  35| };
|  36|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-representation.cpp
|    |++++| /app/C++/binary-representation.cpp
|   1|   1| // Time:  O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param n: Given a decimal number that is passed in as a string
|   8|   9|      *@return: A string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-representation.cpp
|    |++++| /app/C++/binary-representation.cpp
|   7|   7|      *@param n: Given a decimal number that is passed in as a string
|   8|   8|      *@return: A string
|   9|   9|      */
|  10|    |-    string binaryRepresentation(string n) {
|  11|    |-        int int_part = stoi(n.substr(0, n.find('.'));
|  12|    |-        double dec_part = stod(n.substr(n.find('.')));
|  13|    |-        string int_str = "";
|  14|    |-        string dec_str = "";
|    |  10|+    string binaryRepresentation (string n)
|    |  11|+    {
|    |  12|+        int int_part = stoi (n.substr (0, n.find ('.'));
|    |  13|+                             double dec_part = stod (n.substr (n.find ('.')));
|    |  14|+                             string int_str = "";
|    |  15|+                             string dec_str = ""; if (int_part == 0)
|    |  16|+                             {
|    |  17|+                             int_str.push_back ('0');}
|  15|  18| 
|  16|    |-        if (int_part == 0) {
|  17|    |-            int_str.push_back('0');
|  18|    |-        }
|  19|    |-
|  20|    |-        while (int_part > 0) {
|  21|    |-            int c = int_part % 2;
|  22|    |-            int_str.push_back('0' + c);
|  23|    |-            int_part = int_part >> 1;
|  24|    |-        }
|  25|    |-        reverse(int_str.begin(), int_str.end());
|  26|    |-
|  27|    |-        while (dec_part > 0.0) {
|  28|    |-            if (dec_str.length() > 32) {
|  29|    |-                return "ERROR";
|  30|    |-            }
|  31|    |-            double remain = dec_part * 2;
|  32|    |-            if (remain >= 1.0) {
|  33|    |-                dec_str.push_back('1');
|  34|    |-                dec_part = remain - 1.0;
|  35|    |-            }
|  36|    |-            else {
|  37|    |-                dec_str.push_back('0');
|  38|    |-                dec_part = remain;
|  39|    |-            }
|  40|    |-        }
|  41|    |-        return dec_str.length() > 0? int_str + "." + dec_str : int_str;
|  42|    |-    }
|  43|    |-};
|  44|    |-
|    |  19|+                             while (int_part > 0)
|    |  20|+                             {
|    |  21|+                             int c = int_part % 2;
|    |  22|+                             int_str.push_back ('0' + c);
|    |  23|+                             int_part = int_part >> 1;}
|    |  24|+                             reverse (int_str.begin (), int_str.end ());
|    |  25|+                             while (dec_part > 0.0)
|    |  26|+                             {
|    |  27|+                             if (dec_str.length () > 32)
|    |  28|+                             {
|    |  29|+                             return "ERROR";}
|    |  30|+                             double remain = dec_part * 2; if (remain >= 1.0)
|    |  31|+                             {
|    |  32|+                             dec_str.push_back ('1'); dec_part = remain - 1.0;}
|    |  33|+                             else
|    |  34|+                             {
|    |  35|+                             dec_str.push_back ('0'); dec_part = remain;}
|    |  36|+                             }
|    |  37|+                             return dec_str.length () >
|    |  38|+                             0 ? int_str + "." + dec_str : int_str;}
|    |  39|+                             };

C++/binary-representation.cpp
|  11| ••••••••int•int_part•=•stoi(n.substr(0,•n.find('.'));
|    | [MAJOR] CPPCheckBear (syntaxError):
|    | Invalid number of character '(' when these macros are defined: ''.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets-ii.cpp
|    |++++| /app/C++/subsets-ii.cpp
|   1|   1| // Time:  O(n * 2^n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param S: A set of numbers.
|   8|   9|      * @return: A list of lists. All valid subsets.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets-ii.cpp
|    |++++| /app/C++/subsets-ii.cpp
|   7|   7|      * @param S: A set of numbers.
|   8|   8|      * @return: A list of lists. All valid subsets.
|   9|   9|      */
|  10|    |-    vector<vector<int>> subsetsWithDup(const vector<int> &S) {
|  11|    |-        vector<int> sorted_S(S);
|  12|    |-        sort(sorted_S.begin(), sorted_S.end());
|  13|    |-        vector<vector<int>> result(1);
|    |  10|+    vector < vector < int >>subsetsWithDup (const vector < int >&S)
|    |  11|+    {
|    |  12|+        vector < int >sorted_S (S);
|    |  13|+          sort (sorted_S.begin (), sorted_S.end ());
|    |  14|+          vector < vector < int >>result (1);
|  14|  15|         size_t previous_size = 0;
|  15|    |-        for (size_t i = 0; i < sorted_S.size(); ++i) {
|  16|    |-            const size_t size = result.size();
|  17|    |-            for (size_t j = 0; j < size; ++j) {
|  18|    |-                // only union non-duplicate element or new union set
|  19|    |-                if (i == 0 || sorted_S[i] != sorted_S[i - 1] || j >= previous_size) {
|  20|    |-                    result.emplace_back(result[j]);
|  21|    |-                    result.back().emplace_back(sorted_S[i]);
|    |  16|+        for (size_t i = 0; i < sorted_S.size (); ++i)
|    |  17|+          {
|    |  18|+              const size_t size = result.size ();
|    |  19|+              for (size_t j = 0; j < size; ++j)
|    |  20|+                {
|    |  21|+                    // only union non-duplicate element or new union set
|    |  22|+                    if (i == 0 || sorted_S[i] != sorted_S[i - 1]
|    |  23|+                        || j >= previous_size)
|    |  24|+                      {
|    |  25|+                          result.emplace_back (result[j]);
|    |  26|+                          result.back ().emplace_back (sorted_S[i]);
|    |  27|+                      }
|  22|  28|                 }
|  23|    |-            }
|  24|    |-            previous_size = size;
|  25|    |-        }
|    |  29|+              previous_size = size;
|    |  30|+          }
|  26|  31|         return result;
|  27|  32|     }
|  28|  33| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-level-order-traversal-ii.cpp
|    |++++| /app/C++/binary-tree-level-order-traversal-ii.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |- 
|  17|    |- 
|  18|    |-class Solution {
|    |  16|+
|    |  17|+class Solution
|    |  18|+{
|  19|  19|     /**
|  20|  20|      * @param root : The root of binary tree.
|  21|  21|      * @return : buttom-up level order a list of lists of integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-level-order-traversal-ii.cpp
|    |++++| /app/C++/binary-tree-level-order-traversal-ii.cpp
|  20|  20|      * @param root : The root of binary tree.
|  21|  21|      * @return : buttom-up level order a list of lists of integer
|  22|  22|      */
|  23|    |-public:
|  24|    |-    vector<vector<int>> levelOrderBottom(TreeNode *root) {
|  25|    |-        vector<vector<int>> result;
|  26|    |-        queue<TreeNode *> que;
|    |  23|+  public:
|    |  24|+    vector < vector < int >>levelOrderBottom (TreeNode * root)
|    |  25|+    {
|    |  26|+        vector < vector < int >>result;
|    |  27|+          queue < TreeNode * >que;
|  27|  28| 
|  28|    |-        if (root != nullptr) {
|  29|    |-            que.emplace(root);
|  30|    |-        }
|    |  29|+        if (root != nullptr)
|    |  30|+          {
|    |  31|+              que.emplace (root);
|    |  32|+          }
|  31|  33| 
|  32|    |-        while (!que.empty()) {
|  33|    |-            vector<int> level;
|  34|    |-            int size = que.size();
|  35|    |-            for (int i = 0; i < size; i++) {
|  36|    |-                auto *front = que.front();
|  37|    |-                que.pop();
|  38|    |-                level.emplace_back(front->val);
|  39|    |-                if (front->left != nullptr) {
|  40|    |-                    que.emplace(front->left);
|    |  34|+        while (!que.empty ())
|    |  35|+          {
|    |  36|+              vector < int >level;
|    |  37|+              int size = que.size ();
|    |  38|+              for (int i = 0; i < size; i++)
|    |  39|+                {
|    |  40|+                    auto *front = que.front ();
|    |  41|+                    que.pop ();
|    |  42|+                    level.emplace_back (front->val);
|    |  43|+                    if (front->left != nullptr)
|    |  44|+                      {
|    |  45|+                          que.emplace (front->left);
|    |  46|+                      }
|    |  47|+                    if (front->right != nullptr)
|    |  48|+                      {
|    |  49|+                          que.emplace (front->right);
|    |  50|+                      }
|  41|  51|                 }
|  42|    |-                if (front->right != nullptr) {
|  43|    |-                    que.emplace(front->right);
|  44|    |-                }
|  45|    |-            }
|  46|    |-            result.emplace_back(move(level));
|  47|    |-        }
|    |  52|+              result.emplace_back (move (level));
|    |  53|+          }
|  48|  54| 
|  49|    |-        reverse(result.begin(), result.end());
|    |  55|+        reverse (result.begin (), result.end ());
|  50|  56|         return result;
|  51|  57|     }
|  52|  58| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-break.cpp
|    |++++| /app/C++/word-break.cpp
|   1|   1| // Time:  O(n * l^2), l is the max length of the words.
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s: A string s
|   8|   9|      * @param dict: A dictionary of words dict
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-break.cpp
|    |++++| /app/C++/word-break.cpp
|   7|   7|      * @param s: A string s
|   8|   8|      * @param dict: A dictionary of words dict
|   9|   9|      */
|  10|    |-    bool wordBreak(string s, unordered_set<string> &dict) {
|  11|    |-        const int n = s.length();
|    |  10|+    bool wordBreak (string s, unordered_set < string > &dict)
|    |  11|+    {
|    |  12|+        const int n = s.length ();
|  12|  13| 
|  13|  14|         size_t max_len = 0;
|  14|  15|         for (const auto& str: dict) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-break.cpp
|    |++++| /app/C++/word-break.cpp
|  11|  11|         const int n = s.length();
|  12|  12| 
|  13|  13|         size_t max_len = 0;
|  14|    |-        for (const auto& str: dict) {
|  15|    |-            max_len = max(max_len, str.length());
|  16|    |-        }
|    |  14|+        for (const auto & str:dict)
|    |  15|+          {
|    |  16|+              max_len = max (max_len, str.length ());
|    |  17|+          }
|  17|  18| 
|  18|    |-        vector<bool> canBreak(n + 1, false);
|    |  19|+        vector < bool > canBreak (n + 1, false);
|  19|  20|         canBreak[0] = true;
|  20|    |-        for (int i = 1; i <= n; ++i) {
|  21|    |-            for (int l = 1; l <= max_len && i - l >= 0; ++l) {
|  22|    |-                if (canBreak[i - l] && dict.count(s.substr(i - l, l))) {
|  23|    |-                    canBreak[i] = true;
|  24|    |-                    break;
|    |  21|+        for (int i = 1; i <= n; ++i)
|    |  22|+          {
|    |  23|+              for (int l = 1; l <= max_len && i - l >= 0; ++l)
|    |  24|+                {
|    |  25|+                    if (canBreak[i - l] && dict.count (s.substr (i - l, l)))
|    |  26|+                      {
|    |  27|+                          canBreak[i] = true;
|    |  28|+                          break;
|    |  29|+                      }
|  25|  30|                 }
|  26|    |-            }
|  27|    |-        }
|    |  31|+          }
|  28|  32| 
|  29|  33|         return canBreak[n];
|  30|  34|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/container-with-most-water.cpp
|    |++++| /app/C++/container-with-most-water.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param heights: a vector of integers
|   8|   9|      * @return: an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/container-with-most-water.cpp
|    |++++| /app/C++/container-with-most-water.cpp
|   7|   7|      * @param heights: a vector of integers
|   8|   8|      * @return: an integer
|   9|   9|      */
|  10|    |-    int maxArea(vector<int> &heights) {
|  11|    |-        int i = 0, j = heights.size() - 1, max_area = 0;
|  12|    |-        while (i < j) {
|  13|    |-            max_area = max(max_area, min(heights[i], heights[j]) * (j - i));
|  14|    |-            if (heights[i] > heights[j]) {
|  15|    |-                --j;
|  16|    |-            } else if (heights[i] < heights[j]) {
|  17|    |-                ++i;
|  18|    |-            } else {  // heights[i] == heights[j].
|  19|    |-                ++i, --j;
|  20|    |-            }
|  21|    |-        }
|    |  10|+    int maxArea (vector < int >&heights)
|    |  11|+    {
|    |  12|+        int i = 0, j = heights.size () - 1, max_area = 0;
|    |  13|+        while (i < j)
|    |  14|+          {
|    |  15|+              max_area =
|    |  16|+                  max (max_area, min (heights[i], heights[j]) * (j - i));
|    |  17|+              if (heights[i] > heights[j])
|    |  18|+                {
|    |  19|+                    --j;
|    |  20|+                }
|    |  21|+              else if (heights[i] < heights[j])
|    |  22|+                {
|    |  23|+                    ++i;
|    |  24|+                }
|    |  25|+              else
|    |  26|+                {               // heights[i] == heights[j].
|    |  27|+                    ++i, --j;
|    |  28|+                }
|    |  29|+          }
|  22|  30|         return max_area;
|  23|  31|     }
|  24|  32| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/container-with-most-water.cpp
|    |++++| /app/C++/container-with-most-water.cpp
|  22|  22|         return max_area;
|  23|  23|     }
|  24|  24| };
|  25|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-rectangle-in-histogram.cpp
|    |++++| /app/C++/largest-rectangle-in-histogram.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param height: A list of integer
|   8|   9|      * @return: The area of largest rectangle in the histogram
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-rectangle-in-histogram.cpp
|    |++++| /app/C++/largest-rectangle-in-histogram.cpp
|   7|   7|      * @param height: A list of integer
|   8|   8|      * @return: The area of largest rectangle in the histogram
|   9|   9|      */
|  10|    |-    int largestRectangleArea(vector<int> &height) {
|  11|    |-        stack<int> increasing_height;
|    |  10|+    int largestRectangleArea (vector < int >&height)
|    |  11|+    {
|    |  12|+        stack < int >increasing_height;
|  12|  13|         int max_area = 0;
|  13|  14| 
|  14|  15|         for (int i = 0; i <= height.size();) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/largest-rectangle-in-histogram.cpp
|    |++++| /app/C++/largest-rectangle-in-histogram.cpp
|  11|  11|         stack<int> increasing_height;
|  12|  12|         int max_area = 0;
|  13|  13| 
|  14|    |-        for (int i = 0; i <= height.size();) {
|  15|    |-            if (increasing_height.empty() ||
|  16|    |-                (i < height.size() && height[i] > height[increasing_height.top()])) {
|  17|    |-                increasing_height.emplace(i);
|  18|    |-                ++i;
|  19|    |-            } else {
|  20|    |-                auto h = height[increasing_height.top()];
|  21|    |-                increasing_height.pop();
|  22|    |-                auto left = increasing_height.empty() ? -1 : increasing_height.top();
|  23|    |-                max_area = max(max_area, h * (i - left - 1));
|  24|    |-            }
|  25|    |-        }
|    |  14|+        for (int i = 0; i <= height.size ();)
|    |  15|+          {
|    |  16|+              if (increasing_height.empty () ||
|    |  17|+                  (i < height.size ()
|    |  18|+                   && height[i] > height[increasing_height.top ()]))
|    |  19|+                {
|    |  20|+                    increasing_height.emplace (i);
|    |  21|+                    ++i;
|    |  22|+                }
|    |  23|+              else
|    |  24|+                {
|    |  25|+                    auto h = height[increasing_height.top ()];
|    |  26|+                    increasing_height.pop ();
|    |  27|+                    auto left =
|    |  28|+                        increasing_height.empty ()? -1 : increasing_height.
|    |  29|+                        top ();
|    |  30|+                    max_area = max (max_area, h * (i - left - 1));
|    |  31|+                }
|    |  32|+          }
|  26|  33| 
|  27|  34|         return max_area;
|  28|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|   1|   1| // Time:  O(m * n * l), l is length of the word
|   2|   2| // Space: O(l)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param board: A list of lists of character
|   8|   9|      * @param word: A string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|   8|   8|      * @param word: A string
|   9|   9|      * @return: A boolean
|  10|  10|      */
|  11|    |-    bool exist(vector<vector<char>> &board, string word) {
|  12|    |-        unordered_set<string> ret;
|  13|    |-        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
|    |  11|+    bool exist (vector < vector < char >>&board, string word)
|    |  12|+    {
|    |  13|+        unordered_set < string > ret;
|    |  14|+        vector < vector < bool >> visited (board.size (),
|    |  15|+                                           vector < bool > (board[0].size (),
|    |  16|+                                                            false));
|  14|  17|         int cur = 0;
|  15|  18| 
|  16|  19|         for (int i = 0; i < board.size(); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|  13|  13|         vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));
|  14|  14|         int cur = 0;
|  15|  15| 
|  16|    |-        for (int i = 0; i < board.size(); ++i) {
|  17|    |-            for (int j = 0; j < board[0].size(); ++j) {
|  18|    |-                if (wordSearchDFS(board, visited, word, i, j, cur)) {
|  19|    |-                    return true;
|    |  16|+        for (int i = 0; i < board.size (); ++i)
|    |  17|+          {
|    |  18|+              for (int j = 0; j < board[0].size (); ++j)
|    |  19|+                {
|    |  20|+                    if (wordSearchDFS (board, visited, word, i, j, cur))
|    |  21|+                      {
|    |  22|+                          return true;
|    |  23|+                      }
|  20|  24|                 }
|  21|    |-            }
|  22|    |-        }
|    |  25|+          }
|  23|  26| 
|  24|  27|         return false;
|  25|  28|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|  24|  24|         return false;
|  25|  25|     }
|  26|  26| 
|  27|    |-    bool wordSearchDFS(vector<vector<char>> &grid,
|  28|    |-                       vector<vector<bool>> &visited,
|  29|    |-                       string word,
|  30|    |-                       int i,
|  31|    |-                       int j,
|  32|    |-                       int cur) {
|    |  27|+    bool wordSearchDFS (vector < vector < char >>&grid,
|    |  28|+                        vector < vector < bool >> &visited,
|    |  29|+                        string word, int i, int j, int cur)
|    |  30|+    {
|  33|  31|         // Invalid state.
|  34|    |-        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {
|  35|    |-            return false;
|  36|    |-        }
|    |  32|+        if (i < 0 || i >= grid.size () || j < 0 || j >= grid[0].size ())
|    |  33|+          {
|    |  34|+              return false;
|    |  35|+          }
|  37|  36| 
|  38|  37|         // Not mathced or visited.
|  39|  38|         if (grid[i][j] != word[cur] || visited[i][j]) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|  36|  36|         }
|  37|  37| 
|  38|  38|         // Not mathced or visited.
|  39|    |-        if (grid[i][j] != word[cur] || visited[i][j]) {
|  40|    |-            return false;
|  41|    |-        }
|    |  39|+        if (grid[i][j] != word[cur] || visited[i][j])
|    |  40|+          {
|    |  41|+              return false;
|    |  42|+          }
|  42|  43| 
|  43|  44|         // Update current string.
|  44|  45|         ++cur;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|  44|  44|         ++cur;
|  45|  45| 
|  46|  46|         // Find the string, add to the answers.
|  47|    |-        if (cur == word.length()) {
|  48|    |-            return true;
|  49|    |-        }
|    |  47|+        if (cur == word.length ())
|    |  48|+          {
|    |  49|+              return true;
|    |  50|+          }
|  50|  51| 
|  51|  52|         // Marked as visited.
|  52|  53|         visited[i][j] = true;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-search.cpp
|    |++++| /app/C++/word-search.cpp
|  52|  52|         visited[i][j] = true;
|  53|  53| 
|  54|  54|         // Try each direction.
|  55|    |-        const vector<pair<int, int>> directions{{0, -1}, {0, 1},
|  56|    |-                                                {-1, 0}, {1, 0}};
|  57|    |-        for (const auto& d : directions) {
|  58|    |-            if (wordSearchDFS(grid, visited, word,
|  59|    |-                              i + d.first, j + d.second, cur)) {
|  60|    |-                return true;
|  61|    |-            }
|  62|    |-        }
|    |  55|+        const vector < pair < int, int >>directions
|    |  56|+        {
|    |  57|+            {
|    |  58|+            0, -1},
|    |  59|+            {
|    |  60|+            0, 1},
|    |  61|+            {
|    |  62|+            -1, 0},
|    |  63|+            {
|    |  64|+        1, 0}};
|    |  65|+      for (const auto & d:directions)
|    |  66|+          {
|    |  67|+              if (wordSearchDFS (grid, visited, word,
|    |  68|+                                 i + d.first, j + d.second, cur))
|    |  69|+                {
|    |  70|+                    return true;
|    |  71|+                }
|    |  72|+          }
|  63|  73| 
|  64|  74|         visited[i][j] = false;
|  65|  75| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/o1-check-power-of-2.cpp
|    |++++| /app/C++/o1-check-power-of-2.cpp
|   1|   1| // Time:  O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /*
|   7|   8|      * @param n: An integer
|   8|   9|      * @return: True or false
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/o1-check-power-of-2.cpp
|    |++++| /app/C++/o1-check-power-of-2.cpp
|   7|   7|      * @param n: An integer
|   8|   8|      * @return: True or false
|   9|   9|      */
|  10|    |-    bool checkPowerOf2(int n) {
|    |  10|+    bool checkPowerOf2 (int n)
|    |  11|+    {
|  11|  12|         return n > 0 && (n & (n - 1)) == 0;
|  12|  13|     }
|  13|  14| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer array
|   8|   9|      * @return a long integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|   7|   7|      * @param A an integer array
|   8|   8|      * @return a long integer
|   9|   9|      */
|  10|    |-    long long permutationIndexII(vector<int>& A) {
|    |  10|+    long long permutationIndexII (vector < int >&A)
|    |  11|+    {
|  11|  12|         long long index = 1;
|  12|  13|         // Position 1 is paired with factor 0 and so is skipped.
|  13|  14|         int position = 2;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  12|  12|         // Position 1 is paired with factor 0 and so is skipped.
|  13|  13|         int position = 2;
|  14|  14|         long long factor = 1;
|  15|    |-        map<int, int> number_to_count;
|  16|    |-        ++number_to_count[A.back()];
|  17|    |-        for (int i = static_cast<int>(A.size()) - 2; i >= 0; --i) {
|  18|    |-            ++number_to_count[A[i]];
|  19|    |-            for (const auto& kvp : number_to_count) {
|  20|    |-                if (kvp.first >= A[i]) {
|  21|    |-                    break;
|  22|    |-                } 
|  23|    |-                index += factor * kvp.second / number_to_count[A[i]];
|  24|    |-            }
|  25|    |-            factor = factor * position / number_to_count[A[i]];
|  26|    |-            ++position;
|  27|    |-        }
|    |  15|+          map < int, int >number_to_count;
|    |  16|+        ++number_to_count[A.back ()];
|    |  17|+        for (int i = static_cast < int >(A.size ()) - 2; i >= 0; --i)
|    |  18|+          {
|    |  19|+              ++number_to_count[A[i]];
|    |  20|+              for (const auto & kvp:number_to_count)
|    |  21|+                {
|    |  22|+                    if (kvp.first >= A[i])
|    |  23|+                      {
|    |  24|+                          break;
|    |  25|+                      }
|    |  26|+                    index += factor * kvp.second / number_to_count[A[i]];
|    |  27|+                }
|    |  28|+              factor = factor * position / number_to_count[A[i]];
|    |  29|+              ++position;
|    |  30|+          }
|  28|  31|         return index;
|  29|  32|     }
|  30|  33| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  31|  31| 
|  32|  32| // Time:  O(n^2)
|  33|  33| // Space: O(n)
|  34|    |-class Solution2 {
|  35|    |-public:
|    |  34|+class Solution2
|    |  35|+{
|    |  36|+  public:
|  36|  37|     /**
|  37|  38|      * @param A an integer array
|  38|  39|      * @return a long integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  37|  37|      * @param A an integer array
|  38|  38|      * @return a long integer
|  39|  39|      */
|  40|    |-    long long permutationIndexII(vector<int>& A) {
|    |  40|+    long long permutationIndexII (vector < int >&A)
|    |  41|+    {
|  41|  42|         long long index = 1;
|  42|  43|         // Position 1 is paired with factor 0 and so is skipped.
|  43|  44|         int position = 2;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  42|  42|         // Position 1 is paired with factor 0 and so is skipped.
|  43|  43|         int position = 2;
|  44|  44|         long long factor = 1;
|  45|    |-        unordered_map<int, int> number_to_count;
|  46|    |-        ++number_to_count[A.back()];
|  47|    |-        for (int i = static_cast<int>(A.size()) - 2; i >= 0; --i) {
|  48|    |-            unordered_map<int, int> successor_to_count;
|  49|    |-            ++number_to_count[A[i]];
|  50|    |-            for (int j = i + 1; j < A.size(); ++j) {
|  51|    |-                if (A[i] > A[j]) {
|  52|    |-                    ++successor_to_count[A[j]];
|    |  45|+          unordered_map < int, int >number_to_count;
|    |  46|+        ++number_to_count[A.back ()];
|    |  47|+        for (int i = static_cast < int >(A.size ()) - 2; i >= 0; --i)
|    |  48|+          {
|    |  49|+              unordered_map < int, int >successor_to_count;
|    |  50|+              ++number_to_count[A[i]];
|    |  51|+              for (int j = i + 1; j < A.size (); ++j)
|    |  52|+                {
|    |  53|+                    if (A[i] > A[j])
|    |  54|+                      {
|    |  55|+                          ++successor_to_count[A[j]];
|    |  56|+                      }
|  53|  57|                 }
|  54|    |-            }
|  55|    |-            for (const auto& kvp : successor_to_count) {
|  56|    |-                index += factor * kvp.second / number_to_count[A[i]];
|  57|    |-            }
|  58|    |-            factor = factor * position / number_to_count[A[i]];
|  59|    |-            ++position;
|  60|    |-        }
|    |  58|+              for (const auto & kvp:successor_to_count)
|    |  59|+                {
|    |  60|+                    index += factor * kvp.second / number_to_count[A[i]];
|    |  61|+                }
|    |  62|+              factor = factor * position / number_to_count[A[i]];
|    |  63|+              ++position;
|    |  64|+          }
|  61|  65|         return index;
|  62|  66|     }
|  63|  67| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  64|  64| 
|  65|  65| // Time:  O(n^3)
|  66|  66| // Space: O(n)
|  67|    |-class Solution3 {
|  68|    |-public:
|    |  67|+class Solution3
|    |  68|+{
|    |  69|+  public:
|  69|  70|     /**
|  70|  71|      * @param A an integer array
|  71|  72|      * @return a long integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  70|  70|      * @param A an integer array
|  71|  71|      * @return a long integer
|  72|  72|      */
|  73|    |-    long long permutationIndexII(vector<int>& A) {
|    |  73|+    long long permutationIndexII (vector < int >&A)
|    |  74|+    {
|  74|  75|         long long index = 1;
|  75|    |-        unordered_map<int, int> number_to_count;
|  76|    |-        ++number_to_count[A.back()];
|  77|    |-        for (int i = static_cast<int>(A.size()) - 2; i >= 0; --i) {
|  78|    |-            unordered_map<int, int> successor_to_count;
|  79|    |-            ++number_to_count[A[i]];
|  80|    |-            for (int j = i + 1; j < A.size(); ++j) {
|  81|    |-                if (A[i] > A[j]) {
|  82|    |-                    ++successor_to_count[A[j]];
|    |  76|+          unordered_map < int, int >number_to_count;
|    |  77|+        ++number_to_count[A.back ()];
|    |  78|+        for (int i = static_cast < int >(A.size ()) - 2; i >= 0; --i)
|    |  79|+          {
|    |  80|+              unordered_map < int, int >successor_to_count;
|    |  81|+              ++number_to_count[A[i]];
|    |  82|+              for (int j = i + 1; j < A.size (); ++j)
|    |  83|+                {
|    |  84|+                    if (A[i] > A[j])
|    |  85|+                      {
|    |  86|+                          ++successor_to_count[A[j]];
|    |  87|+                      }
|  83|  88|                 }
|  84|    |-            }
|  85|    |-            for (const auto& kvp : successor_to_count) {
|  86|    |-                --number_to_count[kvp.first];
|  87|    |-                index += combination(number_to_count);
|  88|    |-                ++number_to_count[kvp.first];
|  89|    |-            }
|  90|    |-        }
|    |  89|+              for (const auto & kvp:successor_to_count)
|    |  90|+                {
|    |  91|+                    --number_to_count[kvp.first];
|    |  92|+                    index += combination (number_to_count);
|    |  93|+                    ++number_to_count[kvp.first];
|    |  94|+                }
|    |  95|+          }
|  91|  96|         return index;
|  92|  97|     }
|  93|  98| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/permutation-index-ii.cpp
|    |++++| /app/C++/permutation-index-ii.cpp
|  91|  91|         return index;
|  92|  92|     }
|  93|  93| 
|  94|    |-    long long combination(const unordered_map<int, int>& number_to_count) {
|    |  94|+    long long combination (const unordered_map < int, int >&number_to_count)
|    |  95|+    {
|  95|  96|         int n = 0;
|  96|    |-        for (const auto& kvp : number_to_count) {
|  97|    |-            n += kvp.second;
|  98|    |-        }
|    |  97|+      for (const auto & kvp:number_to_count)
|    |  98|+          {
|    |  99|+              n += kvp.second;
|    | 100|+          }
|  99| 101|         long long count = 1;
| 100|    |-        for (const auto& kvp : number_to_count) {
| 101|    |-            // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
| 102|    |-            for (int i = 1; i <= kvp.second; ++i, --n) {
| 103|    |-                 count = count * n / i;
| 104|    |-            }
| 105|    |-        }
|    | 102|+      for (const auto & kvp:number_to_count)
|    | 103|+          {
|    | 104|+              // C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k
|    | 105|+              for (int i = 1; i <= kvp.second; ++i, --n)
|    | 106|+                {
|    | 107|+                    count = count * n / i;
|    | 108|+                }
|    | 109|+          }
| 106| 110|         return count;
| 107| 111|     }
| 108| 112| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-to-integeratoi.cpp
|    |++++| /app/C++/string-to-integeratoi.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param str: A string
|   8|   9|      * @return An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-to-integeratoi.cpp
|    |++++| /app/C++/string-to-integeratoi.cpp
|   7|   7|      * @param str: A string
|   8|   8|      * @return An integer
|   9|   9|      */
|  10|    |-    int atoi(string str) {
|  11|    |-        if (str.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|    |  10|+    int atoi (string str)
|    |  11|+    {
|    |  12|+        if (str.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|  14|  16| 
|  15|  17|         int ans = 0;
|  16|  18|         int sign = 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-to-integeratoi.cpp
|    |++++| /app/C++/string-to-integeratoi.cpp
|  17|  17|         int i = 0;
|  18|  18| 
|  19|  19|         // Skip ' '.
|  20|    |-        while (str[i] == ' ') {
|  21|    |-            ++i;
|  22|    |-        }
|    |  20|+        while (str[i] == ' ')
|    |  21|+          {
|    |  22|+              ++i;
|    |  23|+          }
|  23|  24| 
|  24|  25|         // Parse sign.
|  25|  26|         if (str[i] == '+') {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-to-integeratoi.cpp
|    |++++| /app/C++/string-to-integeratoi.cpp
|  22|  22|         }
|  23|  23| 
|  24|  24|         // Parse sign.
|  25|    |-        if (str[i] == '+') {
|  26|    |-            ++i;
|  27|    |-        } else if (str[i] == '-') {
|  28|    |-            sign = -1;
|  29|    |-            ++i;
|  30|    |-        }
|    |  25|+        if (str[i] == '+')
|    |  26|+          {
|    |  27|+              ++i;
|    |  28|+          }
|    |  29|+        else if (str[i] == '-')
|    |  30|+          {
|    |  31|+              sign = -1;
|    |  32|+              ++i;
|    |  33|+          }
|  31|  34| 
|  32|  35|         // Compute integer.
|  33|  36|         for (; i < str.length() && isdigit(str[i]); ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/string-to-integeratoi.cpp
|    |++++| /app/C++/string-to-integeratoi.cpp
|  30|  30|         }
|  31|  31| 
|  32|  32|         // Compute integer.
|  33|    |-        for (; i < str.length() && isdigit(str[i]); ++i) {
|  34|    |-            if (ans > (numeric_limits<int>::max() - (str[i] - '0')) / 10) { 
|  35|    |-                return sign > 0 ? numeric_limits<int>::max() : numeric_limits<int>::min();
|  36|    |-            }
|  37|    |-            ans *= 10;
|  38|    |-            ans += str[i] - '0';
|  39|    |-        }
|    |  33|+        for (; i < str.length () && isdigit (str[i]); ++i)
|    |  34|+          {
|    |  35|+              if (ans > (numeric_limits < int >::max () - (str[i] - '0')) /10)
|    |  36|+                {
|    |  37|+                    return sign > 0 ? numeric_limits <
|    |  38|+                        int >::max () : numeric_limits < int >::min ();
|    |  39|+                }
|    |  40|+              ans *= 10;
|    |  41|+              ans += str[i] - '0';
|    |  42|+          }
|  40|  43| 
|  41|  44|         ans *= sign;
|  42|  45|         return ans;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets.cpp
|    |++++| /app/C++/subsets.cpp
|   1|   1| // Time:  O(n * 2^n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param S: A set of numbers.
|   8|   9|      * @return: A list of lists. All valid subsets.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets.cpp
|    |++++| /app/C++/subsets.cpp
|   7|   7|      * @param S: A set of numbers.
|   8|   8|      * @return: A list of lists. All valid subsets.
|   9|   9|      */
|  10|    |-    vector<vector<int>> subsets(vector<int> &nums) {
|  11|    |-        const int size = nums.size();
|    |  10|+    vector < vector < int >>subsets (vector < int >&nums)
|    |  11|+    {
|    |  12|+        const int size = nums.size ();
|  12|  13|         const int set_size = 1 << size;
|  13|    |-        vector<vector<int>> ans;
|  14|    |-        vector<int> v;
|    |  14|+          vector < vector < int >>ans;
|    |  15|+          vector < int >v;
|  15|  16| 
|  16|    |-        sort(nums.begin(), nums.end());
|    |  17|+          sort (nums.begin (), nums.end ());
|  17|  18| 
|  18|    |-        for (int i = 0; i < set_size; ++i) {
|  19|    |-            for (int j = 0; j < size; ++j) {
|  20|    |-                if (i & (1 << j)) {
|  21|    |-                    v.emplace_back(nums[j]);
|    |  19|+        for (int i = 0; i < set_size; ++i)
|    |  20|+          {
|    |  21|+              for (int j = 0; j < size; ++j)
|    |  22|+                {
|    |  23|+                    if (i & (1 << j))
|    |  24|+                      {
|    |  25|+                          v.emplace_back (nums[j]);
|    |  26|+                      }
|  22|  27|                 }
|  23|    |-            }
|  24|    |-            ans.emplace_back(v);
|  25|    |-            v.clear();
|  26|    |-        }
|    |  28|+              ans.emplace_back (v);
|    |  29|+              v.clear ();
|    |  30|+          }
|  27|  31| 
|  28|  32|         return ans;
|  29|  33|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets.cpp
|    |++++| /app/C++/subsets.cpp
|  31|  31| 
|  32|  32| // Time:  O(n * 2^n)
|  33|  33| // Space: O(1)
|  34|    |-class Solution2 {
|  35|    |-public:
|    |  34|+class Solution2
|    |  35|+{
|    |  36|+  public:
|  36|  37|     /**
|  37|  38|      * @param S: A set of numbers.
|  38|  39|      * @return: A list of lists. All valid subsets.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subsets.cpp
|    |++++| /app/C++/subsets.cpp
|  37|  37|      * @param S: A set of numbers.
|  38|  38|      * @return: A list of lists. All valid subsets.
|  39|  39|      */
|  40|    |-    vector<vector<int> > subsets(vector<int> &nums) {
|  41|    |-        vector<vector<int>> result(1);
|  42|    |-        for (size_t i = 0; i < nums.size(); ++i) {
|  43|    |-            const size_t size = result.size();
|  44|    |-            for (size_t j = 0; j < size; ++j) {
|  45|    |-                result.emplace_back(result[j]);
|  46|    |-                result.back().emplace_back(nums[i]);
|  47|    |-            }
|  48|    |-        }
|    |  40|+    vector < vector < int >>subsets (vector < int >&nums)
|    |  41|+    {
|    |  42|+        vector < vector < int >>result (1);
|    |  43|+        for (size_t i = 0; i < nums.size (); ++i)
|    |  44|+          {
|    |  45|+              const size_t size = result.size ();
|    |  46|+              for (size_t j = 0; j < size; ++j)
|    |  47|+                {
|    |  48|+                    result.emplace_back (result[j]);
|    |  49|+                    result.back ().emplace_back (nums[i]);
|    |  50|+                }
|    |  51|+          }
|  49|  52|         return result;
|  50|  53|     }
|  51|  54| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param n an integer
|   8|   9|      * @return a square matrix
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|   7|   7|      * @param n an integer
|   8|   8|      * @return a square matrix
|   9|   9|      */
|  10|    |-    vector<vector<int>> generateMatrix(int n) {
|  11|    |-       vector<vector<int>> matrix(n, vector<int>(n));
|    |  10|+    vector < vector < int >>generateMatrix (int n)
|    |  11|+    {
|    |  12|+        vector < vector < int >>matrix (n, vector < int >(n));
|  12|  13| 
|  13|    |-       for (int num = 0, left = 0, right = n - 1, top = 0, bottom = n - 1;
|  14|    |-            left <= right && top <= bottom;
|  15|    |-            ++left, --right, ++top, --bottom) {
|    |  14|+        for (int num = 0, left = 0, right = n - 1, top = 0, bottom = n - 1;
|    |  15|+             left <= right && top <= bottom; ++left, --right, ++top, --bottom)
|    |  16|+          {
|  16|  17| 
|  17|    |-            for (int j = left; j <= right; ++j) {
|  18|    |-                matrix[top][j] = ++num;
|  19|    |-            }
|  20|    |-            for (int i = top + 1; i < bottom; ++i) {
|  21|    |-                matrix[i][right] = ++num;
|  22|    |-            }
|  23|    |-            for (int j = right; top < bottom && j >= left; --j) {
|  24|    |-                matrix[bottom][j] = ++num;
|  25|    |-            }
|  26|    |-            for (int i = bottom - 1; left < right && i >= top + 1; --i) {
|  27|    |-                matrix[i][left] = ++num;
|  28|    |-            }
|  29|    |-        }
|    |  18|+              for (int j = left; j <= right; ++j)
|    |  19|+                {
|    |  20|+                    matrix[top][j] = ++num;
|    |  21|+                }
|    |  22|+              for (int i = top + 1; i < bottom; ++i)
|    |  23|+                {
|    |  24|+                    matrix[i][right] = ++num;
|    |  25|+                }
|    |  26|+              for (int j = right; top < bottom && j >= left; --j)
|    |  27|+                {
|    |  28|+                    matrix[bottom][j] = ++num;
|    |  29|+                }
|    |  30|+              for (int i = bottom - 1; left < right && i >= top + 1; --i)
|    |  31|+                {
|    |  32|+                    matrix[i][left] = ++num;
|    |  33|+                }
|    |  34|+          }
|  30|  35| 
|  31|  36|         return matrix;
|  32|  37|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|  34|  34| 
|  35|  35| // Time:  O(n^2)
|  36|  36| // Space: O(1)
|  37|    |-class Solution2 {
|  38|    |-public:
|  39|    |-    vector<vector<int> > generateMatrix(int n) {
|  40|    |-        vector<vector<int> > matrix(n, vector<int>(n));
|  41|    |-        enum Action {RIGHT, DOWN, LEFT, UP};
|    |  37|+class Solution2
|    |  38|+{
|    |  39|+  public:
|    |  40|+    vector < vector < int >>generateMatrix (int n)
|    |  41|+    {
|    |  42|+        vector < vector < int >>matrix (n, vector < int >(n));
|    |  43|+        enum Action
|    |  44|+        { RIGHT, DOWN, LEFT, UP };
|  42|  45|         Action action = RIGHT;
|  43|    |-        for (int i = 0, j = 0, cnt = 0, total = n * n; cnt < total;) {
|  44|    |-            matrix[i][j] = ++cnt;
|    |  46|+        for (int i = 0, j = 0, cnt = 0, total = n * n; cnt < total;)
|    |  47|+          {
|    |  48|+              matrix[i][j] = ++cnt;
|  45|  49| 
|  46|    |-            switch (action) {
|    |  50|+              switch (action)
|    |  51|+                {
|  47|  52|                 case RIGHT:
|  48|    |-                    if (j + 1 < n && matrix[i][j + 1] == 0) {
|  49|    |-                        ++j;
|  50|    |-                    } else {
|  51|    |-                        action = DOWN, ++i;
|  52|    |-                    }
|    |  53|+                    if (j + 1 < n && matrix[i][j + 1] == 0)
|    |  54|+                      {
|    |  55|+                          ++j;
|    |  56|+                      }
|    |  57|+                    else
|    |  58|+                      {
|    |  59|+                          action = DOWN, ++i;
|    |  60|+                      }
|  53|  61|                     break;
|  54|  62|                 case DOWN:
|  55|  63|                     if (i + 1 < n && matrix[i + 1][j] == 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|  52|  52|                     }
|  53|  53|                     break;
|  54|  54|                 case DOWN:
|  55|    |-                    if (i + 1 < n && matrix[i + 1][j] == 0) {
|  56|    |-                        ++i;
|  57|    |-                    } else {
|  58|    |-                        action = LEFT, --j;
|  59|    |-                    }
|    |  55|+                    if (i + 1 < n && matrix[i + 1][j] == 0)
|    |  56|+                      {
|    |  57|+                          ++i;
|    |  58|+                      }
|    |  59|+                    else
|    |  60|+                      {
|    |  61|+                          action = LEFT, --j;
|    |  62|+                      }
|  60|  63|                     break;
|  61|  64|                 case LEFT:
|  62|  65|                     if (j - 1 >= 0 && matrix[i][j - 1] == 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|  59|  59|                     }
|  60|  60|                     break;
|  61|  61|                 case LEFT:
|  62|    |-                    if (j - 1 >= 0 && matrix[i][j - 1] == 0) {
|  63|    |-                        --j;
|  64|    |-                    } else {
|  65|    |-                        action = UP, --i;
|  66|    |-                    }
|    |  62|+                    if (j - 1 >= 0 && matrix[i][j - 1] == 0)
|    |  63|+                      {
|    |  64|+                          --j;
|    |  65|+                      }
|    |  66|+                    else
|    |  67|+                      {
|    |  68|+                          action = UP, --i;
|    |  69|+                      }
|  67|  70|                     break;
|  68|  71|                 case UP:
|  69|  72|                     if (i - 1 >= 0 && matrix[i - 1][j] == 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|  66|  66|                     }
|  67|  67|                     break;
|  68|  68|                 case UP:
|  69|    |-                    if (i - 1 >= 0 && matrix[i - 1][j] == 0) {
|  70|    |-                        --i;
|  71|    |-                    } else {
|  72|    |-                        action = RIGHT, ++j;
|  73|    |-                    }
|    |  69|+                    if (i - 1 >= 0 && matrix[i - 1][j] == 0)
|    |  70|+                      {
|    |  71|+                          --i;
|    |  72|+                      }
|    |  73|+                    else
|    |  74|+                      {
|    |  75|+                          action = RIGHT, ++j;
|    |  76|+                      }
|  74|  77|                     break;
|  75|  78|                 default:
|  76|  79|                     break;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/spiral-matrix-ii.cpp
|    |++++| /app/C++/spiral-matrix-ii.cpp
|  74|  74|                     break;
|  75|  75|                 default:
|  76|  76|                     break;
|  77|    |-            }
|  78|    |-        }
|    |  77|+                }
|    |  78|+          }
|  79|  79|         return matrix;
|  80|  80|     }
|  81|  81| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|    |++++| /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s : A string
|   8|   9|      * @return : The length of the longest substring
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|    |++++| /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|   8|   8|      * @return : The length of the longest substring
|   9|   9|      *           that contains at most k distinct characters.
|  10|  10|      */
|  11|    |-    int lengthOfLongestSubstringKDistinct(string s, int k) {
|  12|    |-        unordered_map<char, int> distinct;
|    |  11|+    int lengthOfLongestSubstringKDistinct (string s, int k)
|    |  12|+    {
|    |  13|+        unordered_map < char, int >distinct;
|  13|  14| 
|  14|  15|         int start = 0;
|  15|  16|         int max_len = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|    |++++| /app/C++/longest-substring-with-at-most-k-distinct-characters.cpp
|  13|  13| 
|  14|  14|         int start = 0;
|  15|  15|         int max_len = 0;
|  16|    |-        for (int i = 0; i < s.length(); ++i) {
|  17|    |-            ++distinct[s[i]];
|  18|    |-            while (distinct.size() > k) {
|  19|    |-                --distinct[s[start]];
|  20|    |-                if (distinct[s[start]] == 0) {
|  21|    |-                    distinct.erase(s[start]);
|    |  16|+        for (int i = 0; i < s.length (); ++i)
|    |  17|+          {
|    |  18|+              ++distinct[s[i]];
|    |  19|+              while (distinct.size () > k)
|    |  20|+                {
|    |  21|+                    --distinct[s[start]];
|    |  22|+                    if (distinct[s[start]] == 0)
|    |  23|+                      {
|    |  24|+                          distinct.erase (s[start]);
|    |  25|+                      }
|    |  26|+                    ++start;
|  22|  27|                 }
|  23|    |-                ++start;
|  24|    |-            }
|  25|    |-            max_len = max(max_len, i - start + 1);
|  26|    |-        }
|    |  28|+              max_len = max (max_len, i - start + 1);
|    |  29|+          }
|  27|  30| 
|  28|  31|         return max_len;
|  29|  32|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/lru-cache.cpp
|    |++++| /app/C++/lru-cache.cpp
|   3|   3| 
|   4|   4| #include <list>
|   5|   5| 
|   6|    |-class LRUCache {
|   7|    |-public:
|   8|    |-    LRUCache(int capacity) : capa_(capacity) {
|    |   6|+class LRUCache
|    |   7|+{
|    |   8|+  public:
|    |   9|+    LRUCache (int capacity):capa_ (capacity)
|    |  10|+    {
|   9|  11|     }
|  10|    |-    
|  11|    |-    int get(int key) {
|  12|    |-        if (map_.find(key) != map_.end()) {
|  13|    |-            // It key exists, update it.
|  14|    |-            const auto value = map_[key]->second;
|  15|    |-            update(key, value);
|  16|    |-            return value;
|  17|    |-        } else {
|  18|    |-            return -1;
|  19|    |-        }
|    |  12|+
|    |  13|+    int get (int key)
|    |  14|+    {
|    |  15|+        if (map_.find (key) != map_.end ())
|    |  16|+          {
|    |  17|+              // It key exists, update it.
|    |  18|+              const auto value = map_[key]->second;
|    |  19|+              update (key, value);
|    |  20|+              return value;
|    |  21|+          }
|    |  22|+        else
|    |  23|+          {
|    |  24|+              return -1;
|    |  25|+          }
|  20|  26|     }
|  21|    |-    
|  22|    |-    void set(int key, int value) {
|    |  27|+
|    |  28|+    void set (int key, int value)
|    |  29|+    {
|  23|  30|         // If cache is full while inserting, remove the last one.
|  24|    |-        if (map_.find(key) == map_.end() && list_.size() == capa_) {
|  25|    |-            auto del = list_.back(); list_.pop_back();
|  26|    |-            map_.erase(del.first);
|  27|    |-        }
|  28|    |-         update(key, value);
|    |  31|+        if (map_.find (key) == map_.end () && list_.size () == capa_)
|    |  32|+          {
|    |  33|+              auto del = list_.back ();
|    |  34|+              list_.pop_back ();
|    |  35|+              map_.erase (del.first);
|    |  36|+          }
|    |  37|+        update (key, value);
|  29|  38|     }
|  30|    |-    
|  31|    |-private:
|  32|    |-    list<pair<int, int>> list_; // key, value
|  33|    |-    unordered_map<int, list<pair<int, int>>::iterator> map_; // key, list iterator
|    |  39|+
|    |  40|+  private:
|    |  41|+    list < pair < int, int >>list_; // key, value
|    |  42|+    unordered_map < int, list < pair < int, int >>::iterator > map_;    // key, list iterator
|  34|  43|     int capa_;
|  35|    |-    
|    |  44|+
|  36|  45|     // Update (key, iterator of (key, value)) pair
|  37|    |-    void update(int key, int value) {
|  38|    |-        auto it = map_.find(key);
|  39|    |-        if (it != map_.end()) {
|  40|    |-            list_.erase(it->second);
|  41|    |-        }
|  42|    |-        list_.emplace_front(key, value);
|  43|    |-        map_[key] = list_.begin();
|    |  46|+    void update (int key, int value)
|    |  47|+    {
|    |  48|+        auto it = map_.find (key);
|    |  49|+        if (it != map_.end ())
|    |  50|+          {
|    |  51|+              list_.erase (it->second);
|    |  52|+          }
|    |  53|+        list_.emplace_front (key, value);
|    |  54|+        map_[key] = list_.begin ();
|  44|  55|     }
|  45|  56| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|    |   4|+class Solution
|    |   5|+{
|   5|   6|     /**
|   6|   7|      * param A : an integer sorted array
|   7|   8|      * param target :  an integer to be inserted
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|   7|   7|      * param target :  an integer to be inserted
|   8|   8|      * return : an integer
|   9|   9|      */
|  10|    |-public:
|  11|    |-    int searchInsert(vector<int> &A, int target) {
|    |  10|+  public:
|    |  11|+    int searchInsert (vector < int >&A, int target)
|    |  12|+    {
|  12|  13|         int left = 0;
|  13|    |-        int right = A.size() - 1;
|    |  14|+        int right = A.size () - 1;
|  14|  15| 
|  15|  16|         // First min of left s.t. A[left] >= target
|  16|  17|         while (left <= right) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  13|  13|         int right = A.size() - 1;
|  14|  14| 
|  15|  15|         // First min of left s.t. A[left] >= target
|  16|    |-        while (left <= right) {
|  17|    |-            int mid = left + (right -left) / 2;
|  18|    |-            if (A[mid] >= target) {
|  19|    |-                right = mid - 1;
|  20|    |-            } else {
|  21|    |-                left = mid + 1;
|  22|    |-            }
|  23|    |-        }
|    |  16|+        while (left <= right)
|    |  17|+          {
|    |  18|+              int mid = left + (right - left) / 2;
|    |  19|+              if (A[mid] >= target)
|    |  20|+                {
|    |  21|+                    right = mid - 1;
|    |  22|+                }
|    |  23|+              else
|    |  24|+                {
|    |  25|+                    left = mid + 1;
|    |  26|+                }
|    |  27|+          }
|  24|  28| 
|  25|  29|         return left;
|  26|  30|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  26|  26|     }
|  27|  27| };
|  28|  28| 
|  29|    |-class Solution2 {
|    |  29|+class Solution2
|    |  30|+{
|  30|  31|     /**
|  31|  32|      * param A : an integer sorted array
|  32|  33|      * param target :  an integer to be inserted
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  32|  32|      * param target :  an integer to be inserted
|  33|  33|      * return : an integer
|  34|  34|      */
|  35|    |-public:
|  36|    |-    int searchInsert(vector<int> &A, int target) {
|    |  35|+  public:
|    |  36|+    int searchInsert (vector < int >&A, int target)
|    |  37|+    {
|  37|  38|         int left = 0;
|  38|    |-        int right = A.size();
|    |  39|+        int right = A.size ();
|  39|  40| 
|  40|  41|         // First min of left s.t. A[left] >= target
|  41|  42|         while (left < right) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  38|  38|         int right = A.size();
|  39|  39| 
|  40|  40|         // First min of left s.t. A[left] >= target
|  41|    |-        while (left < right) {
|  42|    |-            int mid = left + (right -left) / 2;
|  43|    |-            if (A[mid] >= target) {
|  44|    |-                right = mid;
|  45|    |-            } else {
|  46|    |-                left = mid + 1;
|  47|    |-            }
|  48|    |-        }
|    |  41|+        while (left < right)
|    |  42|+          {
|    |  43|+              int mid = left + (right - left) / 2;
|    |  44|+              if (A[mid] >= target)
|    |  45|+                {
|    |  46|+                    right = mid;
|    |  47|+                }
|    |  48|+              else
|    |  49|+                {
|    |  50|+                    left = mid + 1;
|    |  51|+                }
|    |  52|+          }
|  49|  53| 
|  50|  54|         return left;
|  51|  55|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  51|  51|     }
|  52|  52| };
|  53|  53| 
|  54|    |-class Solution3 {
|    |  54|+class Solution3
|    |  55|+{
|  55|  56|     /**
|  56|  57|      * param A : an integer sorted array
|  57|  58|      * param target :  an integer to be inserted
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  57|  57|      * param target :  an integer to be inserted
|  58|  58|      * return : an integer
|  59|  59|      */
|  60|    |-public:
|  61|    |-    int searchInsert(vector<int> &A, int target) {
|    |  60|+  public:
|    |  61|+    int searchInsert (vector < int >&A, int target)
|    |  62|+    {
|  62|  63|         int left = -1;
|  63|    |-        int right = A.size();
|    |  64|+        int right = A.size ();
|  64|  65| 
|  65|  66|         // First min of right s.t. A[right] >= target
|  66|  67|         while (right - left > 1) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  63|  63|         int right = A.size();
|  64|  64| 
|  65|  65|         // First min of right s.t. A[right] >= target
|  66|    |-        while (right - left > 1) {
|  67|    |-            int mid = left + (right -left) / 2;
|  68|    |-            if (A[mid] >= target) {
|  69|    |-                right = mid;
|  70|    |-            } else {
|  71|    |-                left = mid;
|  72|    |-            }
|  73|    |-        }
|    |  66|+        while (right - left > 1)
|    |  67|+          {
|    |  68|+              int mid = left + (right - left) / 2;
|    |  69|+              if (A[mid] >= target)
|    |  70|+                {
|    |  71|+                    right = mid;
|    |  72|+                }
|    |  73|+              else
|    |  74|+                {
|    |  75|+                    left = mid;
|    |  76|+                }
|    |  77|+          }
|  74|  78| 
|  75|  79|         return right;
|  76|  80|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-insert-position.cpp
|    |++++| /app/C++/search-insert-position.cpp
|  75|  75|         return right;
|  76|  76|     }
|  77|  77| };
|  78|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|   1|   1| // Time:  O(log(min(m, n)))
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An integer array.
|   8|   9|      * @param B: An integer array.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|   8|   8|      * @param B: An integer array.
|   9|   9|      * @return: a double whose format is *.5 or *.0
|  10|  10|      */
|  11|    |-    double findMedianSortedArrays(vector<int> A, vector<int> B) {
|  12|    |-        if ((A.size() + B.size()) % 2 == 1) {
|  13|    |-            return findKthInTwoSortedArrays(A, B, (A.size() + B.size()) / 2 + 1);
|  14|    |-        } else {
|  15|    |-            return (findKthInTwoSortedArrays(A, B, (A.size() + B.size()) / 2) +
|  16|    |-                    findKthInTwoSortedArrays(A, B, (A.size() + B.size()) / 2 + 1)) / 2.0;
|  17|    |-        }
|    |  11|+    double findMedianSortedArrays (vector < int >A, vector < int >B)
|    |  12|+    {
|    |  13|+        if ((A.size () + B.size ()) % 2 == 1)
|    |  14|+          {
|    |  15|+              return findKthInTwoSortedArrays (A, B,
|    |  16|+                                               (A.size () + B.size ()) / 2 +
|    |  17|+                                               1);
|    |  18|+          }
|    |  19|+        else
|    |  20|+          {
|    |  21|+              return (findKthInTwoSortedArrays
|    |  22|+                      (A, B,
|    |  23|+                       (A.size () + B.size ()) / 2) +
|    |  24|+                      findKthInTwoSortedArrays (A, B,
|    |  25|+                                                (A.size () + B.size ()) / 2 +
|    |  26|+                                                1)) / 2.0;
|    |  27|+          }
|  18|  28|     }
|  19|  29| 
|  20|  30|     int findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|  17|  17|         }
|  18|  18|     }
|  19|  19| 
|  20|    |-    int findKthInTwoSortedArrays(const vector<int>& A, const vector<int>& B,
|  21|    |-                                 int k) {
|  22|    |-        const int m = A.size();
|  23|    |-        const int n = B.size();
|    |  20|+    int findKthInTwoSortedArrays (const vector < int >&A,
|    |  21|+                                  const vector < int >&B, int k)
|    |  22|+    {
|    |  23|+        const int m = A.size ();
|    |  24|+        const int n = B.size ();
|  24|  25| 
|  25|  26|         // Make sure m is the smaller one.
|  26|  27|         if (m > n) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|  23|  23|         const int n = B.size();
|  24|  24| 
|  25|  25|         // Make sure m is the smaller one.
|  26|    |-        if (m > n) {
|  27|    |-            return findKthInTwoSortedArrays(B, A, k);
|  28|    |-        }
|    |  26|+        if (m > n)
|    |  27|+          {
|    |  28|+              return findKthInTwoSortedArrays (B, A, k);
|    |  29|+          }
|  29|  30| 
|  30|  31|         int left = 0;
|  31|  32|         int right = m;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|  31|  31|         int right = m;
|  32|  32|         // Find a partition of A and B
|  33|  33|         // where min left s.t. A[left] >= B[k - 1 - left]. Thus left is the (k + 1)-th element.
|  34|    |-        while (left < right) {
|  35|    |-            int mid = left + (right - left) / 2;
|  36|    |-            if (0 <= k - 1 - mid && k - 1 - mid < n && A[mid] >= B[k - 1 - mid]) {
|  37|    |-                right = mid;
|  38|    |-            } else {
|  39|    |-                left = mid + 1;
|  40|    |-            }
|  41|    |-        }
|    |  34|+        while (left < right)
|    |  35|+          {
|    |  36|+              int mid = left + (right - left) / 2;
|    |  37|+              if (0 <= k - 1 - mid && k - 1 - mid < n
|    |  38|+                  && A[mid] >= B[k - 1 - mid])
|    |  39|+                {
|    |  40|+                    right = mid;
|    |  41|+                }
|    |  42|+              else
|    |  43|+                {
|    |  44|+                    left = mid + 1;
|    |  45|+                }
|    |  46|+          }
|  42|  47| 
|  43|    |-        int Ai_minus_1 = left - 1 >= 0 ? A[left - 1] : numeric_limits<int>::min();
|  44|    |-        int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();
|    |  48|+        int Ai_minus_1 =
|    |  49|+            left - 1 >= 0 ? A[left - 1] : numeric_limits < int >::min ();
|    |  50|+        int Bj =
|    |  51|+            k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits <
|    |  52|+            int >::min ();
|  45|  53| 
|  46|  54|         // kth element would be A[left - 1] or B[k - 1 - left].
|  47|  55|         return max(Ai_minus_1, Bj);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|  44|  44|         int Bj = k - 1 - left >= 0 ? B[k - 1 - left] : numeric_limits<int>::min();
|  45|  45| 
|  46|  46|         // kth element would be A[left - 1] or B[k - 1 - left].
|  47|    |-        return max(Ai_minus_1, Bj);
|    |  47|+        return max (Ai_minus_1, Bj);
|  48|  48|     }
|  49|  49| };
|  50|  50| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median-of-two-sorted-arrays.cpp
|    |++++| /app/C++/median-of-two-sorted-arrays.cpp
|  47|  47|         return max(Ai_minus_1, Bj);
|  48|  48|     }
|  49|  49| };
|  50|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/space-replacement.cpp
|    |++++| /app/C++/space-replacement.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param string: An array of Char
|   8|   9|      * @param length: The true length of the string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/space-replacement.cpp
|    |++++| /app/C++/space-replacement.cpp
|   8|   8|      * @param length: The true length of the string
|   9|   9|      * @return: The true length of new string
|  10|  10|      */
|  11|    |-    int replaceBlank(char string[], int length) {
|  12|    |-        const array<char, 3> to{'%', '2', '0'};
|    |  11|+    int replaceBlank (char string[], int length)
|    |  12|+    {
|    |  13|+        const array < char, 3 > to
|    |  14|+        {
|    |  15|+        '%', '2', '0'};
|  13|  16| 
|  14|  17|         int space_count = 0;
|  15|  18|         for (int i = 0; i < length; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/space-replacement.cpp
|    |++++| /app/C++/space-replacement.cpp
|  12|  12|         const array<char, 3> to{'%', '2', '0'};
|  13|  13| 
|  14|  14|         int space_count = 0;
|  15|    |-        for (int i = 0; i < length; ++i) {
|  16|    |-            if (string[i] == ' ') {
|  17|    |-                ++space_count;
|  18|    |-            }
|  19|    |-        }
|    |  15|+        for (int i = 0; i < length; ++i)
|    |  16|+          {
|    |  17|+              if (string[i] == ' ')
|    |  18|+                {
|    |  19|+                    ++space_count;
|    |  20|+                }
|    |  21|+          }
|  20|  22| 
|  21|  23|         const int new_length = length +
|  22|  24|                                (static_cast<int>(to.size()) - 1) * space_count;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/space-replacement.cpp
|    |++++| /app/C++/space-replacement.cpp
|  19|  19|         }
|  20|  20| 
|  21|  21|         const int new_length = length +
|  22|    |-                               (static_cast<int>(to.size()) - 1) * space_count;
|  23|    |-        for (int i = length - 1, j = new_length - 1; i >= 0; --i) {
|  24|    |-            if (string[i] == ' ') {
|  25|    |-                j -= to.size();
|  26|    |-                copy(to.cbegin(), to.cend(), string + j + 1);
|  27|    |-            } else {
|  28|    |-                string[j--] = string[i];
|  29|    |-            }
|  30|    |-        }
|    |  22|+            (static_cast < int >(to.size ()) - 1) *space_count;
|    |  23|+        for (int i = length - 1, j = new_length - 1; i >= 0; --i)
|    |  24|+          {
|    |  25|+              if (string[i] == ' ')
|    |  26|+                {
|    |  27|+                    j -= to.size ();
|    |  28|+                    copy (to.cbegin (), to.cend (), string + j + 1);
|    |  29|+                }
|    |  30|+              else
|    |  31|+                {
|    |  32|+                    string[j--] = string[i];
|    |  33|+                }
|    |  34|+          }
|  31|  35| 
|  32|  36|         return new_length;
|  33|  37|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/data-stream-median.cpp
|    |++++| /app/C++/data-stream-median.cpp
|   1|   1| // Time:  O(nlogn)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers.
|   8|   9|      * @return: The median of numbers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/data-stream-median.cpp
|    |++++| /app/C++/data-stream-median.cpp
|   7|   7|      * @param nums: A list of integers.
|   8|   8|      * @return: The median of numbers
|   9|   9|      */
|  10|    |-    vector<int> medianII(vector<int> &nums) {
|    |  10|+    vector < int >medianII (vector < int >&nums)
|    |  11|+    {
|  11|  12|         // min_bst stores the larger half seen so far.
|  12|    |-        multiset<int, less<int>> min_bst;
|    |  13|+        multiset < int, less < int >>min_bst;
|  13|  14|         // max_bst stores the smaller half seen so far.
|  14|    |-        multiset<int, greater<int>> max_bst;
|    |  15|+          multiset < int, greater < int >>max_bst;
|  15|  16| 
|  16|    |-        vector<int> ans;
|  17|    |-        for (const auto& num : nums) {
|  18|    |-            // Balance smaller half and larger half.
|  19|    |-            if (max_bst.empty() || num > *max_bst.cbegin()) {
|  20|    |-                min_bst.emplace(num);
|  21|    |-                if (min_bst.size() > max_bst.size() + 1) {
|  22|    |-                    max_bst.emplace(*min_bst.cbegin());
|  23|    |-                    min_bst.erase(min_bst.cbegin());
|    |  17|+          vector < int >ans;
|    |  18|+        for (const auto & num:nums)
|    |  19|+          {
|    |  20|+              // Balance smaller half and larger half.
|    |  21|+              if (max_bst.empty () || num > *max_bst.cbegin ())
|    |  22|+                {
|    |  23|+                    min_bst.emplace (num);
|    |  24|+                    if (min_bst.size () > max_bst.size () + 1)
|    |  25|+                      {
|    |  26|+                          max_bst.emplace (*min_bst.cbegin ());
|    |  27|+                          min_bst.erase (min_bst.cbegin ());
|    |  28|+                      }
|  24|  29|                 }
|  25|    |-            } else {
|  26|    |-                max_bst.emplace(num);
|  27|    |-                if (max_bst.size() > min_bst.size()) {
|  28|    |-                    min_bst.emplace(*max_bst.cbegin());
|  29|    |-                    max_bst.erase(max_bst.cbegin());
|    |  30|+              else
|    |  31|+                {
|    |  32|+                    max_bst.emplace (num);
|    |  33|+                    if (max_bst.size () > min_bst.size ())
|    |  34|+                      {
|    |  35|+                          min_bst.emplace (*max_bst.cbegin ());
|    |  36|+                          max_bst.erase (max_bst.cbegin ());
|    |  37|+                      }
|  30|  38|                 }
|  31|    |-            }
|  32|  39| 
|  33|    |-            ans.emplace_back(min_bst.size() == max_bst.size() ?
|  34|    |-                             *max_bst.cbegin() : *min_bst.cbegin());
|  35|    |-        }
|    |  40|+              ans.emplace_back (min_bst.size () == max_bst.size ()?
|    |  41|+                                *max_bst.cbegin () : *min_bst.cbegin ());
|    |  42|+          }
|  36|  43| 
|  37|  44|         return ans;
|  38|  45|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/data-stream-median.cpp
|    |++++| /app/C++/data-stream-median.cpp
|  38|  38|     }
|  39|  39| };
|  40|  40| 
|  41|    |-
|  42|    |-class Solution2 {
|  43|    |-public:
|    |  41|+class Solution2
|    |  42|+{
|    |  43|+  public:
|  44|  44|     /**
|  45|  45|      * @param nums: A list of integers.
|  46|  46|      * @return: The median of numbers
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/data-stream-median.cpp
|    |++++| /app/C++/data-stream-median.cpp
|  45|  45|      * @param nums: A list of integers.
|  46|  46|      * @return: The median of numbers
|  47|  47|      */
|  48|    |-    vector<int> medianII(vector<int> &nums) {
|    |  48|+    vector < int >medianII (vector < int >&nums)
|    |  49|+    {
|  49|  50|         // min_heap stores the larger half seen so far.
|  50|    |-        priority_queue<int, vector<int>, greater<int>> min_heap;
|    |  51|+        priority_queue < int, vector < int >, greater < int >>min_heap;
|  51|  52|         // max_heap stores the smaller half seen so far.
|  52|    |-        priority_queue<int, vector<int>, less<int>> max_heap;
|    |  53|+          priority_queue < int, vector < int >, less < int >>max_heap;
|  53|  54| 
|  54|    |-        vector<int> ans;
|  55|    |-        for (const auto& num : nums) {
|  56|    |-            if (max_heap.empty() || num > max_heap.top()) {
|  57|    |-                min_heap.emplace(num);
|  58|    |-                if (min_heap.size() > max_heap.size() + 1) {
|  59|    |-                    max_heap.emplace(min_heap.top());
|  60|    |-                    min_heap.pop();
|    |  55|+          vector < int >ans;
|    |  56|+        for (const auto & num:nums)
|    |  57|+          {
|    |  58|+              if (max_heap.empty () || num > max_heap.top ())
|    |  59|+                {
|    |  60|+                    min_heap.emplace (num);
|    |  61|+                    if (min_heap.size () > max_heap.size () + 1)
|    |  62|+                      {
|    |  63|+                          max_heap.emplace (min_heap.top ());
|    |  64|+                          min_heap.pop ();
|    |  65|+                      }
|  61|  66|                 }
|  62|    |-            } else {
|  63|    |-                max_heap.emplace(num);
|  64|    |-                if (max_heap.size() > min_heap.size()) {
|  65|    |-                    min_heap.emplace(max_heap.top());
|  66|    |-                    max_heap.pop();
|    |  67|+              else
|    |  68|+                {
|    |  69|+                    max_heap.emplace (num);
|    |  70|+                    if (max_heap.size () > min_heap.size ())
|    |  71|+                      {
|    |  72|+                          min_heap.emplace (max_heap.top ());
|    |  73|+                          max_heap.pop ();
|    |  74|+                      }
|  67|  75|                 }
|  68|    |-            }
|  69|  76| 
|  70|    |-            ans.emplace_back(min_heap.size() == max_heap.size() ?
|  71|    |-                             max_heap.top() : min_heap.top());
|  72|    |-        }
|    |  77|+              ans.emplace_back (min_heap.size () == max_heap.size ()?
|    |  78|+                                max_heap.top () : min_heap.top ());
|    |  79|+          }
|  73|  80| 
|  74|  81|         return ans;
|  75|  82|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/data-stream-median.cpp
|    |++++| /app/C++/data-stream-median.cpp
|  74|  74|         return ans;
|  75|  75|     }
|  76|  76| };
|  77|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // automata: http://images.cnitblog.com/i/627993/201405/012016243309923.png
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param s the string that represents a number
|   9|  10|      * @return whether the string is a valid number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|   8|   8|      * @param s the string that represents a number
|   9|   9|      * @return whether the string is a valid number
|  10|  10|      */
|  11|    |-    bool isNumber(string& s) {
|  12|    |-        enum InputType {
|  13|    |-            INVALID,    // 0
|  14|    |-            SPACE,      // 1
|  15|    |-            SIGN,       // 2
|  16|    |-            DIGIT,      // 3
|  17|    |-            DOT,        // 4
|  18|    |-            EXPONENT,   // 5
|  19|    |-            NUM_INPUTS  // 6
|    |  11|+    bool isNumber (string & s)
|    |  12|+    {
|    |  13|+        enum InputType
|    |  14|+        {
|    |  15|+            INVALID,            // 0
|    |  16|+            SPACE,              // 1
|    |  17|+            SIGN,               // 2
|    |  18|+            DIGIT,              // 3
|    |  19|+            DOT,                // 4
|    |  20|+            EXPONENT,           // 5
|    |  21|+            NUM_INPUTS          // 6
|  20|  22|         };
|  21|  23|         int transitionTable[][NUM_INPUTS] = {
|  22|  24|             -1,  0,  3,  1,  2, -1,     // next states for state 0
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|  19|  19|             NUM_INPUTS  // 6
|  20|  20|         };
|  21|  21|         int transitionTable[][NUM_INPUTS] = {
|  22|    |-            -1,  0,  3,  1,  2, -1,     // next states for state 0
|  23|    |-            -1,  8, -1,  1,  4,  5,     // next states for state 1
|  24|    |-            -1, -1, -1,  4, -1, -1,     // next states for state 2
|  25|    |-            -1, -1, -1,  1,  2, -1,     // next states for state 3
|  26|    |-            -1,  8, -1,  4, -1,  5,     // next states for state 4
|  27|    |-            -1, -1,  6,  7, -1, -1,     // next states for state 5
|  28|    |-            -1, -1, -1,  7, -1, -1,     // next states for state 6
|  29|    |-            -1,  8, -1,  7, -1, -1,     // next states for state 7
|  30|    |-            -1,  8, -1, -1, -1, -1,     // next states for state 8
|    |  22|+            -1, 0, 3, 1, 2, -1, // next states for state 0
|    |  23|+            -1, 8, -1, 1, 4, 5, // next states for state 1
|    |  24|+            -1, -1, -1, 4, -1, -1,  // next states for state 2
|    |  25|+            -1, -1, -1, 1, 2, -1,   // next states for state 3
|    |  26|+            -1, 8, -1, 4, -1, 5,    // next states for state 4
|    |  27|+            -1, -1, 6, 7, -1, -1,   // next states for state 5
|    |  28|+            -1, -1, -1, 7, -1, -1,  // next states for state 6
|    |  29|+            -1, 8, -1, 7, -1, -1,   // next states for state 7
|    |  30|+            -1, 8, -1, -1, -1, -1,  // next states for state 8
|  31|  31|         };
|  32|  32| 
|  33|  33|         int state = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|  31|  31|         };
|  32|  32| 
|  33|  33|         int state = 0;
|  34|    |-        for (const auto& c: s) {
|  35|    |-            InputType inputType = INVALID;
|  36|    |-            if (isspace(c)) {
|  37|    |-                inputType = SPACE;
|  38|    |-            } else if (c == '+' || c == '-') {
|  39|    |-                inputType = SIGN;
|  40|    |-            } else if (isdigit(c)) {
|  41|    |-                inputType = DIGIT;
|  42|    |-            } else if (c == '.') {
|  43|    |-                inputType = DOT;
|  44|    |-            } else if (c == 'e' || c == 'E') {
|  45|    |-                inputType = EXPONENT;
|  46|    |-            }
|  47|    |-            // Get next state from current state and input symbol
|  48|    |-            state = transitionTable[state][inputType];
|    |  34|+      for (const auto & c:s)
|    |  35|+          {
|    |  36|+              InputType inputType = INVALID;
|    |  37|+              if (isspace (c))
|    |  38|+                {
|    |  39|+                    inputType = SPACE;
|    |  40|+                }
|    |  41|+              else if (c == '+' || c == '-')
|    |  42|+                {
|    |  43|+                    inputType = SIGN;
|    |  44|+                }
|    |  45|+              else if (isdigit (c))
|    |  46|+                {
|    |  47|+                    inputType = DIGIT;
|    |  48|+                }
|    |  49|+              else if (c == '.')
|    |  50|+                {
|    |  51|+                    inputType = DOT;
|    |  52|+                }
|    |  53|+              else if (c == 'e' || c == 'E')
|    |  54|+                {
|    |  55|+                    inputType = EXPONENT;
|    |  56|+                }
|    |  57|+              // Get next state from current state and input symbol
|    |  58|+              state = transitionTable[state][inputType];
|  49|  59| 
|  50|    |-            // Invalid input
|  51|    |-            if (state == -1) {
|  52|    |-                return false;
|  53|    |-            }
|  54|    |-        }
|    |  60|+              // Invalid input
|    |  61|+              if (state == -1)
|    |  62|+                {
|    |  63|+                    return false;
|    |  64|+                }
|    |  65|+          }
|  55|  66|         // If the current state belongs to one of the accepting (final) states,
|  56|  67|         // then the number is valid
|  57|  68|         return state == 1 || state == 4 || state == 7 || state == 8;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|  60|  60| 
|  61|  61| #include <regex>
|  62|  62| // It shows runtime error on LintCode Online Judge, but it works with the latest C++14 compiler.
|  63|    |-class Solution2 {
|  64|    |-public:
|    |  63|+class Solution2
|    |  64|+{
|    |  65|+  public:
|  65|  66|     /**
|  66|  67|      * @param s the string that represents a number
|  67|  68|      * @return whether the string is a valid number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-number.cpp
|    |++++| /app/C++/valid-number.cpp
|  66|  66|      * @param s the string that represents a number
|  67|  67|      * @return whether the string is a valid number
|  68|  68|      */
|  69|    |-    bool isNumber(string& s) {
|  70|    |-        regex e("^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$");
|  71|    |-        return regex_match(s, e);
|    |  69|+    bool isNumber (string & s)
|    |  70|+    {
|    |  71|+        regex
|    |  72|+            e
|    |  73|+            ("^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$");
|    |  74|+          return regex_match (s, e);
|  72|  75|     }
|  73|  76| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-polish-notation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param expression: A string array
|   8|   9|      * @return: The Polish notation of this expression
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-polish-notation.cpp
|   7|   7|      * @param expression: A string array
|   8|   8|      * @return: The Polish notation of this expression
|   9|   9|      */
|  10|    |-    vector<string> convertToPN(vector<string> &expression) {
|  11|    |-        vector<string> output;
|  12|    |-        infixToPrefix(expression, output);
|    |  10|+    vector < string > convertToPN (vector < string > &expression)
|    |  11|+    {
|    |  12|+        vector < string > output;
|    |  13|+        infixToPrefix (expression, output);
|  13|  14|         return output;
|  14|  15|     }
|  15|  16| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-polish-notation.cpp
|  14|  14|     }
|  15|  15| 
|  16|  16|     // Convert Infix to Prefix Expression.
|  17|    |-    void infixToPrefix(vector<string>& infix, vector<string>& prefix) {
|  18|    |-        reverse(infix.begin(), infix.end());
|  19|    |-        stack<string> s;
|  20|    |-        for (auto& tok : infix) {
|  21|    |-            if (atoi(tok.c_str())) {
|  22|    |-                prefix.emplace_back(tok);
|  23|    |-            } else if (tok == ")") {
|  24|    |-                s.emplace(tok);
|  25|    |-            } else if (tok == "(") {
|  26|    |-                while (!s.empty()) {
|  27|    |-                    tok = s.top();
|  28|    |-                    s.pop();
|  29|    |-                    if (tok == ")") {
|  30|    |-                        break;
|  31|    |-                    }
|  32|    |-                    prefix.emplace_back(tok);
|    |  17|+    void infixToPrefix (vector < string > &infix, vector < string > &prefix)
|    |  18|+    {
|    |  19|+        reverse (infix.begin (), infix.end ());
|    |  20|+        stack < string > s;
|    |  21|+      for (auto & tok:infix)
|    |  22|+          {
|    |  23|+              if (atoi (tok.c_str ()))
|    |  24|+                {
|    |  25|+                    prefix.emplace_back (tok);
|  33|  26|                 }
|  34|    |-            } else {
|  35|    |-                while (!s.empty() && precedence(tok) < precedence(s.top())) {
|  36|    |-                    prefix.emplace_back(s.top());
|  37|    |-                    s.pop();
|    |  27|+              else if (tok == ")")
|    |  28|+                {
|    |  29|+                    s.emplace (tok);
|  38|  30|                 }
|  39|    |-                s.emplace(tok);
|  40|    |-            }
|  41|    |-        }
|  42|    |-        while (!s.empty()) {
|  43|    |-            prefix.emplace_back(s.top());
|  44|    |-            s.pop();
|  45|    |-        }
|  46|    |-        reverse(prefix.begin(), prefix.end());
|    |  31|+              else if (tok == "(")
|    |  32|+                {
|    |  33|+                    while (!s.empty ())
|    |  34|+                      {
|    |  35|+                          tok = s.top ();
|    |  36|+                          s.pop ();
|    |  37|+                          if (tok == ")")
|    |  38|+                            {
|    |  39|+                                break;
|    |  40|+                            }
|    |  41|+                          prefix.emplace_back (tok);
|    |  42|+                      }
|    |  43|+                }
|    |  44|+              else
|    |  45|+                {
|    |  46|+                    while (!s.empty ()
|    |  47|+                           && precedence (tok) < precedence (s.top ()))
|    |  48|+                      {
|    |  49|+                          prefix.emplace_back (s.top ());
|    |  50|+                          s.pop ();
|    |  51|+                      }
|    |  52|+                    s.emplace (tok);
|    |  53|+                }
|    |  54|+          }
|    |  55|+        while (!s.empty ())
|    |  56|+          {
|    |  57|+              prefix.emplace_back (s.top ());
|    |  58|+              s.pop ();
|    |  59|+          }
|    |  60|+        reverse (prefix.begin (), prefix.end ());
|  47|  61|     }
|  48|  62| 
|  49|  63|     int precedence(string x) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-expression-to-polish-notation.cpp
|    |++++| /app/C++/convert-expression-to-polish-notation.cpp
|  46|  46|         reverse(prefix.begin(), prefix.end());
|  47|  47|     }
|  48|  48| 
|  49|    |-    int precedence(string x) {
|  50|    |-        if (x == ")") {
|  51|    |-            return 0;
|  52|    |-        } else if (x == "+" || x == "-") {
|  53|    |-            return 1;
|  54|    |-        } else if (x == "*" || x == "/") {
|  55|    |-            return 2;
|  56|    |-        }
|    |  49|+    int precedence (string x)
|    |  50|+    {
|    |  51|+        if (x == ")")
|    |  52|+          {
|    |  53|+              return 0;
|    |  54|+          }
|    |  55|+        else if (x == "+" || x == "-")
|    |  56|+          {
|    |  57|+              return 1;
|    |  58|+          }
|    |  59|+        else if (x == "*" || x == "/")
|    |  60|+          {
|    |  61|+              return 2;
|    |  62|+          }
|  57|  63|         return 3;
|  58|  64|     }
|  59|  65| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Bottom-Up.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param A: Given an integer array
|   9|  10|      * @return: void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|   8|   8|      * @param A: Given an integer array
|   9|   9|      * @return: void
|  10|  10|      */
|  11|    |-    void heapify(vector<int> &A) {
|  12|    |-        for (int i = A.size() / 2; i >= 0; --i) {
|  13|    |-            sift_down(A, i);
|  14|    |-        }
|    |  11|+    void heapify (vector < int >&A)
|    |  12|+    {
|    |  13|+        for (int i = A.size () / 2; i >= 0; --i)
|    |  14|+          {
|    |  15|+              sift_down (A, i);
|    |  16|+          }
|  15|  17|     }
|  16|  18| 
|  17|  19|     void sift_down(vector<int>& A, int index) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  14|  14|         }
|  15|  15|     }
|  16|  16| 
|  17|    |-    void sift_down(vector<int>& A, int index) {
|  18|    |-        while (index < A.size()) {
|  19|    |-            int smallest = index;
|  20|    |-            if (index * 2 + 1 < A.size() && A[index * 2 + 1] < A[smallest]) {
|  21|    |-                smallest = index * 2 + 1;
|  22|    |-            }
|  23|    |-            if (index * 2 + 2 < A.size() && A[index * 2 + 2] < A[smallest]) {
|  24|    |-                smallest = index * 2 + 2;
|  25|    |-            }
|  26|    |-            if (smallest == index) {
|  27|    |-                break;
|  28|    |-            }
|  29|    |-            swap(A[smallest], A[index]);
|  30|    |-            index = smallest;
|  31|    |-        }
|    |  17|+    void sift_down (vector < int >&A, int index)
|    |  18|+    {
|    |  19|+        while (index < A.size ())
|    |  20|+          {
|    |  21|+              int smallest = index;
|    |  22|+              if (index * 2 + 1 < A.size () && A[index * 2 + 1] < A[smallest])
|    |  23|+                {
|    |  24|+                    smallest = index * 2 + 1;
|    |  25|+                }
|    |  26|+              if (index * 2 + 2 < A.size () && A[index * 2 + 2] < A[smallest])
|    |  27|+                {
|    |  28|+                    smallest = index * 2 + 2;
|    |  29|+                }
|    |  30|+              if (smallest == index)
|    |  31|+                {
|    |  32|+                    break;
|    |  33|+                }
|    |  34|+              swap (A[smallest], A[index]);
|    |  35|+              index = smallest;
|    |  36|+          }
|  32|  37|     }
|  33|  38| };
|  34|  39| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  32|  32|     }
|  33|  33| };
|  34|  34| 
|  35|    |-
|  36|  35| // Time:  O(nlogn)
|  37|  36| // Space: O(1)
|  38|  37| // Top-Down.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  36|  36| // Time:  O(nlogn)
|  37|  37| // Space: O(1)
|  38|  38| // Top-Down.
|  39|    |-class Solution2 {
|  40|    |-public:
|    |  39|+class Solution2
|    |  40|+{
|    |  41|+  public:
|  41|  42|     /**
|  42|  43|      * @param A: Given an integer array
|  43|  44|      * @return: void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  42|  42|      * @param A: Given an integer array
|  43|  43|      * @return: void
|  44|  44|      */
|  45|    |-    void heapify(vector<int> &A) {
|  46|    |-        for (int i = 0; i < A.size(); ++i) {
|  47|    |-            sift_up(A, i);
|  48|    |-        }
|    |  45|+    void heapify (vector < int >&A)
|    |  46|+    {
|    |  47|+        for (int i = 0; i < A.size (); ++i)
|    |  48|+          {
|    |  49|+              sift_up (A, i);
|    |  50|+          }
|  49|  51|     }
|  50|  52| 
|  51|  53|     void sift_up(vector<int>& A, int index) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  48|  48|         }
|  49|  49|     }
|  50|  50| 
|  51|    |-    void sift_up(vector<int>& A, int index) {
|  52|    |-        while ((index - 1) / 2 >= 0) {
|  53|    |-            int parent = (index - 1) / 2;
|  54|    |-            if (A[index] < A[parent]) {
|  55|    |-                swap(A[parent], A[index]);
|  56|    |-                index = parent;
|  57|    |-            } else {
|  58|    |-                break;
|  59|    |-            }
|  60|    |-        }
|    |  51|+    void sift_up (vector < int >&A, int index)
|    |  52|+    {
|    |  53|+        while ((index - 1) / 2 >= 0)
|    |  54|+          {
|    |  55|+              int parent = (index - 1) / 2;
|    |  56|+              if (A[index] < A[parent])
|    |  57|+                {
|    |  58|+                    swap (A[parent], A[index]);
|    |  59|+                    index = parent;
|    |  60|+                }
|    |  61|+              else
|    |  62|+                {
|    |  63|+                    break;
|    |  64|+                }
|    |  65|+          }
|  61|  66|     }
|  62|  67| };
|  63|  68| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/heapify.cpp
|    |++++| /app/C++/heapify.cpp
|  60|  60|         }
|  61|  61|     }
|  62|  62| };
|  63|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-nth-node-from-end-of-list.cpp
|    |++++| /app/C++/remove-nth-node-from-end-of-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @param n: An integer.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-nth-node-from-end-of-list.cpp
|    |++++| /app/C++/remove-nth-node-from-end-of-list.cpp
|  20|  20|      * @param n: An integer.
|  21|  21|      * @return: The head of linked list.
|  22|  22|      */
|  23|    |-    ListNode *removeNthFromEnd(ListNode *head, int n) {
|  24|    |-        ListNode dummy{0};
|  25|    |-        dummy.next = head;
|    |  23|+    ListNode * removeNthFromEnd (ListNode * head, int n)
|    |  24|+    {
|    |  25|+        ListNode dummy
|    |  26|+        {
|    |  27|+        0};
|    |  28|+          dummy.next = head;
|  26|  29|         auto slow = &dummy;
|  27|  30|         auto fast = &dummy;
|  28|  31| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-nth-node-from-end-of-list.cpp
|    |++++| /app/C++/remove-nth-node-from-end-of-list.cpp
|  27|  27|         auto fast = &dummy;
|  28|  28| 
|  29|  29|         // fast is n-step ahead.
|  30|    |-        while (n > 0) {
|  31|    |-            fast = fast->next;
|  32|    |-            --n;
|  33|    |-        }
|    |  30|+        while (n > 0)
|    |  31|+          {
|    |  32|+              fast = fast->next;
|    |  33|+              --n;
|    |  34|+          }
|  34|  35| 
|  35|  36|         // When fast reaches the end, slow must be nth to last node.
|  36|  37|         while (fast->next != nullptr) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-nth-node-from-end-of-list.cpp
|    |++++| /app/C++/remove-nth-node-from-end-of-list.cpp
|  33|  33|         }
|  34|  34| 
|  35|  35|         // When fast reaches the end, slow must be nth to last node.
|  36|    |-        while (fast->next != nullptr) {
|  37|    |-            slow = slow->next;
|  38|    |-            fast = fast->next;
|  39|    |-        }
|    |  36|+        while (fast->next != nullptr)
|    |  37|+          {
|    |  38|+              slow = slow->next;
|    |  39|+              fast = fast->next;
|    |  40|+          }
|  40|  41| 
|  41|  42|         auto node_to_delete = slow->next;
|  42|  43|         slow->next = slow->next->next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param A: A sorted (increasing order) array
|  20|  21|      * @return: A tree node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  19|  19|      * @param A: A sorted (increasing order) array
|  20|  20|      * @return: A tree node
|  21|  21|      */
|  22|    |-    TreeNode *sortedArrayToBST(vector<int> &A) {
|  23|    |-        return sortedArrayToBSTHelper(A, 0, A.size() - 1);
|    |  22|+    TreeNode * sortedArrayToBST (vector < int >&A)
|    |  23|+    {
|    |  24|+        return sortedArrayToBSTHelper (A, 0, A.size () - 1);
|  24|  25|     }
|  25|  26| 
|  26|  27|     TreeNode *sortedArrayToBSTHelper(vector<int> &A, int start, int end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  23|  23|         return sortedArrayToBSTHelper(A, 0, A.size() - 1);
|  24|  24|     }
|  25|  25| 
|  26|    |-    TreeNode *sortedArrayToBSTHelper(vector<int> &A, int start, int end) {
|  27|    |-        if (start <= end) {
|  28|    |-            TreeNode *node = new TreeNode(A[start + (end - start) / 2]);
|  29|    |-            node->left = sortedArrayToBSTHelper(A, start, start + (end - start) / 2 - 1);
|  30|    |-            node->right = sortedArrayToBSTHelper(A, start + (end - start) / 2 + 1, end);
|  31|    |-            return node;
|  32|    |-        }
|    |  26|+    TreeNode *sortedArrayToBSTHelper (vector < int >&A, int start, int end)
|    |  27|+    {
|    |  28|+        if (start <= end)
|    |  29|+          {
|    |  30|+              TreeNode *node = new TreeNode (A[start + (end - start) / 2]);
|    |  31|+              node->left =
|    |  32|+                  sortedArrayToBSTHelper (A, start,
|    |  33|+                                          start + (end - start) / 2 - 1);
|    |  34|+              node->right =
|    |  35|+                  sortedArrayToBSTHelper (A, start + (end - start) / 2 + 1,
|    |  36|+                                          end);
|    |  37|+              return node;
|    |  38|+          }
|  33|  39|         return nullptr;
|  34|  40|     }
|  35|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  34|  34|     }
|  35|  35| };
|  36|  36| 
|  37|    |-class Solution2 {
|  38|    |-public:
|    |  37|+class Solution2
|    |  38|+{
|    |  39|+  public:
|  39|  40|     /**
|  40|  41|      * @param A: A sorted (increasing order) array
|  41|  42|      * @return: A tree node
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  40|  40|      * @param A: A sorted (increasing order) array
|  41|  41|      * @return: A tree node
|  42|  42|      */
|  43|    |-    TreeNode *sortedArrayToBST(vector<int> &A) {
|  44|    |-        return sortedArrayToBSTHelper(A, 0, A.size());
|    |  43|+    TreeNode * sortedArrayToBST (vector < int >&A)
|    |  44|+    {
|    |  45|+        return sortedArrayToBSTHelper (A, 0, A.size ());
|  45|  46|     }
|  46|  47| 
|  47|  48|     TreeNode *sortedArrayToBSTHelper(vector<int> &A, int start, int end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  44|  44|         return sortedArrayToBSTHelper(A, 0, A.size());
|  45|  45|     }
|  46|  46| 
|  47|    |-    TreeNode *sortedArrayToBSTHelper(vector<int> &A, int start, int end) {
|  48|    |-        if (start < end) {
|  49|    |-            TreeNode *node = new TreeNode(A[start + (end - start) / 2]);
|  50|    |-            node->left = sortedArrayToBSTHelper(A, start, start + (end - start) / 2);
|  51|    |-            node->right = sortedArrayToBSTHelper(A, start + (end - start) / 2 + 1, end);
|  52|    |-            return node;
|  53|    |-        }
|    |  47|+    TreeNode *sortedArrayToBSTHelper (vector < int >&A, int start, int end)
|    |  48|+    {
|    |  49|+        if (start < end)
|    |  50|+          {
|    |  51|+              TreeNode *node = new TreeNode (A[start + (end - start) / 2]);
|    |  52|+              node->left =
|    |  53|+                  sortedArrayToBSTHelper (A, start, start + (end - start) / 2);
|    |  54|+              node->right =
|    |  55|+                  sortedArrayToBSTHelper (A, start + (end - start) / 2 + 1,
|    |  56|+                                          end);
|    |  57|+              return node;
|    |  58|+          }
|  54|  59|         return nullptr;
|  55|  60|     }
|  56|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|    |++++| /app/C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp
|  54|  54|         return nullptr;
|  55|  55|     }
|  56|  56| };
|  57|    |-
|  58|    |-
|  59|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-parentheses.cpp
|    |++++| /app/C++/valid-parentheses.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s A string
|   8|   9|      * @return whether the string is a valid parentheses
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-parentheses.cpp
|    |++++| /app/C++/valid-parentheses.cpp
|   7|   7|      * @param s A string
|   8|   8|      * @return whether the string is a valid parentheses
|   9|   9|      */
|  10|    |-    bool isValidParentheses(string& s) {
|  11|    |-        const  unordered_map<char, char> symbol_pair = {{')', '('},
|  12|    |-                                                        {']', '['},
|  13|    |-                                                        {'}', '{'}};
|  14|    |-        stack<char> parentheses;
|  15|    |-        for (const auto& c: s) {
|  16|    |-            const auto& it = symbol_pair.find(c);
|  17|    |-            if (it != symbol_pair.cend()) {
|  18|    |-                if (parentheses.empty() ||
|  19|    |-                    parentheses.top() != it->second) {
|  20|    |-                    return false;
|    |  10|+    bool isValidParentheses (string & s)
|    |  11|+    {
|    |  12|+        const unordered_map < char, char >symbol_pair = { {')', '('},
|    |  13|+        {']', '['},
|    |  14|+        {'}', '{'}
|    |  15|+        };
|    |  16|+        stack < char >parentheses;
|    |  17|+      for (const auto & c:s)
|    |  18|+          {
|    |  19|+              const auto & it = symbol_pair.find (c);
|    |  20|+              if (it != symbol_pair.cend ())
|    |  21|+                {
|    |  22|+                    if (parentheses.empty () ||
|    |  23|+                        parentheses.top () != it->second)
|    |  24|+                      {
|    |  25|+                          return false;
|    |  26|+                      }
|    |  27|+                    parentheses.pop ();
|  21|  28|                 }
|  22|    |-                parentheses.pop();
|  23|    |-            } else {
|  24|    |-                parentheses.emplace(c);
|  25|    |-            }
|  26|    |-        }
|  27|    |-        return parentheses.empty();
|    |  29|+              else
|    |  30|+                {
|    |  31|+                    parentheses.emplace (c);
|    |  32|+                }
|    |  33|+          }
|    |  34|+        return parentheses.empty ();
|  28|  35|     }
|  29|  36| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-ii.cpp
|    |++++| /app/C++/single-number-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A : An integer array
|   8|   9|      * @return : An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-ii.cpp
|    |++++| /app/C++/single-number-ii.cpp
|   7|   7|      * @param A : An integer array
|   8|   8|      * @return : An integer
|   9|   9|      */
|  10|    |-    int singleNumberII(vector<int> &A) {
|    |  10|+    int singleNumberII (vector < int >&A)
|    |  11|+    {
|  11|  12|         int one = 0, two = 0;
|  12|  13| 
|  13|  14|         for (const auto& i : A) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/single-number-ii.cpp
|    |++++| /app/C++/single-number-ii.cpp
|  10|  10|     int singleNumberII(vector<int> &A) {
|  11|  11|         int one = 0, two = 0;
|  12|  12| 
|  13|    |-        for (const auto& i : A) {
|  14|    |-            int new_one = (~i & one) | (i & ~one & ~two);
|  15|    |-            int new_two = (~i & two) | (i & one);
|  16|    |-            one = new_one, two = new_two;
|  17|    |-        }
|    |  13|+        for (const auto & i:A)
|    |  14|+          {
|    |  15|+              int new_one = (~i & one) | (i & ~one & ~two);
|    |  16|+              int new_two = (~i & two) | (i & one);
|    |  17|+                one = new_one, two = new_two;
|    |  18|+          }
|  18|  19| 
|  19|  20|         return one;
|  20|  21|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-fence.cpp
|    |++++| /app/C++/paint-fence.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // DP with rolling window.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param n non-negative integer, n posts
|   9|  10|      * @param k non-negative integer, k colors
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-fence.cpp
|    |++++| /app/C++/paint-fence.cpp
|   9|   9|      * @param k non-negative integer, k colors
|  10|  10|      * @return an integer, the total number of ways
|  11|  11|      */
|  12|    |-    int numWays(int n, int k) {
|  13|    |-        if (n == 0) {
|  14|    |-            return 0;
|  15|    |-        } else if (n == 1) {
|  16|    |-            return k;
|  17|    |-        }
|  18|    |-        vector<int> ways(3);
|    |  12|+    int numWays (int n, int k)
|    |  13|+    {
|    |  14|+        if (n == 0)
|    |  15|+          {
|    |  16|+              return 0;
|    |  17|+          }
|    |  18|+        else if (n == 1)
|    |  19|+          {
|    |  20|+              return k;
|    |  21|+          }
|    |  22|+        vector < int >ways (3);
|  19|  23|         ways[0] = k;
|  20|  24|         ways[1] = (k - 1) * ways[0] + k;
|  21|  25|         for (int i = 2; i < n; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/paint-fence.cpp
|    |++++| /app/C++/paint-fence.cpp
|  18|  18|         vector<int> ways(3);
|  19|  19|         ways[0] = k;
|  20|  20|         ways[1] = (k - 1) * ways[0] + k;
|  21|    |-        for (int i = 2; i < n; ++i) {
|  22|    |-            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3]);
|  23|    |-        }
|    |  21|+        for (int i = 2; i < n; ++i)
|    |  22|+          {
|    |  23|+              ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3]);
|    |  24|+          }
|  24|  25|         return ways[(n - 1) % 3];
|  25|  26|     }
|  26|  27| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|   4|   4| #include <memory>
|   5|   5| 
|   6|   6| // enum type for Vehicle
|   7|    |-enum class VehicleSize {
|    |   7|+enum class VehicleSize
|    |   8|+{
|   8|   9|     Motorcycle,
|   9|  10|     Compact,
|  10|  11|     Large
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  15|  15| class Level;
|  16|  16| 
|  17|  17| // Use pImpl idiom to make copy assignment work.
|  18|    |-class VehicleImpl {
|  19|    |-public:
|  20|    |-    vector<weak_ptr<ParkingSpot>> parking_spots() const noexcept {
|    |  18|+class VehicleImpl
|    |  19|+{
|    |  20|+  public:
|    |  21|+    vector < weak_ptr < ParkingSpot >> parking_spots () const noexcept
|    |  22|+    {
|  21|  23|         return parking_spots_;
|  22|  24|     }
|  23|  25| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  21|  21|         return parking_spots_;
|  22|  22|     }
|  23|  23| 
|  24|    |-    int spots_needed() const noexcept {
|    |  24|+    int spots_needed () const noexcept
|    |  25|+    {
|  25|  26|         return spots_needed_;
|  26|  27|     }
|  27|  28| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  25|  25|         return spots_needed_;
|  26|  26|     }
|  27|  27| 
|  28|    |-    VehicleSize size() const noexcept {
|    |  28|+    VehicleSize size () const noexcept
|    |  29|+    {
|  29|  30|         return size_;
|  30|  31|     }
|  31|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  29|  29|         return size_;
|  30|  30|     }
|  31|  31| 
|  32|    |-    void park_in_spot(const shared_ptr<ParkingSpot>& spot) {
|  33|    |-        parking_spots_.emplace_back(spot);
|  34|    |-    }
|  35|    |-
|  36|    |-    void clear_spots();
|  37|    |-
|  38|    |-    virtual bool can_fit_in_spot(const shared_ptr<ParkingSpot>& spot)
|  39|    |-        const noexcept {
|    |  32|+    void park_in_spot (const shared_ptr < ParkingSpot > &spot)
|    |  33|+    {
|    |  34|+        parking_spots_.emplace_back (spot);
|    |  35|+    }
|    |  36|+
|    |  37|+    void clear_spots ();
|    |  38|+
|    |  39|+    virtual bool can_fit_in_spot (const shared_ptr < ParkingSpot > &spot)
|    |  40|+        const noexcept
|    |  41|+    {
|  40|  42|         return true;
|  41|  43|     }
|  42|  44| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  40|  40|         return true;
|  41|  41|     }
|  42|  42| 
|  43|    |-protected:
|  44|    |-    vector<weak_ptr<ParkingSpot>> parking_spots_;
|    |  43|+  protected:
|    |  44|+      vector < weak_ptr < ParkingSpot >> parking_spots_;
|  45|  45|     int spots_needed_;
|  46|  46|     VehicleSize size_;
|  47|  47| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
|  46|  46|     VehicleSize size_;
|  47|  47| };
|  48|  48| 
|  49|    |-class Vehicle {
|  50|    |-public:
|  51|    |-    Vehicle() : pImpl_(make_shared<VehicleImpl>()) {}
|  52|    |-
|  53|    |-    vector<weak_ptr<ParkingSpot>> parking_spots() const noexcept {
|  54|    |-        return pImpl_->parking_spots();
|  55|    |-    }
|  56|    |-
|  57|    |-    int spots_needed() const noexcept {
|  58|    |-        return pImpl_->spots_needed();
|  59|    |-    }
|  60|    |-
|  61|    |-    VehicleSize size() const noexcept {
|  62|    |-        return pImpl_->size();
|  63|    |-    }
|  64|    |-
|  65|    |-    void park_in_spot(const shared_ptr<ParkingSpot>& spot) {
|  66|    |-        pImpl_->park_in_spot(spot);
|  67|    |-    }
|  68|    |-
|  69|    |-    void clear_spots() {
|  70|    |-        pImpl_->clear_spots();
|  71|    |-    }
|  72|    |-
|  73|    |-    virtual bool can_fit_in_spot(const shared_ptr<ParkingSpot>& spot)
|  74|    |-        const noexcept {
|  75|    |-        return pImpl_->can_fit_in_spot(spot);
|  76|    |-    }
|  77|    |-
|  78|    |-protected:
|  79|    |-    shared_ptr<VehicleImpl> pImpl_;
|  80|    |-};
|  81|    |-
|  82|    |-class ParkingSpot : public std::enable_shared_from_this<ParkingSpot> {
|  83|    |-public:
|  84|    |-    ParkingSpot(const shared_ptr<Level>& level, int row,
|  85|    |-                int spot_number, VehicleSize spot_size) :
|  86|    |-        level_(level), row_(row),
|  87|    |-        spot_number_(spot_number), spot_size_(spot_size),
|  88|    |-        vehicle_(nullptr) {}
|  89|    |-
|  90|    |-    bool is_available() const noexcept {
|  91|    |-        return vehicle_ == nullptr;
|  92|    |-    }
|  93|    |-
|  94|    |-    bool can_fit_vehicle(Vehicle *vehicle) {
|  95|    |-        return is_available() && vehicle->can_fit_in_spot(shared_from_this());
|  96|    |-    }
|  97|    |-
|  98|    |-    void park(Vehicle *vehicle) {
|    |  49|+class Vehicle
|    |  50|+{
|    |  51|+  public:
|    |  52|+    Vehicle ():pImpl_ (make_shared < VehicleImpl > ())
|    |  53|+    {
|    |  54|+    }
|    |  55|+
|    |  56|+    vector < weak_ptr < ParkingSpot >> parking_spots () const noexcept
|    |  57|+    {
|    |  58|+        return pImpl_->parking_spots ();
|    |  59|+    }
|    |  60|+
|    |  61|+    int spots_needed () const noexcept
|    |  62|+    {
|    |  63|+        return pImpl_->spots_needed ();
|    |  64|+    }
|    |  65|+
|    |  66|+    VehicleSize size () const noexcept
|    |  67|+    {
|    |  68|+        return pImpl_->size ();
|    |  69|+    }
|    |  70|+
|    |  71|+    void park_in_spot (const shared_ptr < ParkingSpot > &spot)
|    |  72|+    {
|    |  73|+        pImpl_->park_in_spot (spot);
|    |  74|+    }
|    |  75|+
|    |  76|+    void clear_spots ()
|    |  77|+    {
|    |  78|+        pImpl_->clear_spots ();
|    |  79|+    }
|    |  80|+
|    |  81|+    virtual bool can_fit_in_spot (const shared_ptr < ParkingSpot > &spot)
|    |  82|+        const noexcept
|    |  83|+    {
|    |  84|+        return pImpl_->can_fit_in_spot (spot);
|    |  85|+    }
|    |  86|+
|    |  87|+  protected:
|    |  88|+      shared_ptr < VehicleImpl > pImpl_;
|    |  89|+};
|    |  90|+
|    |  91|+class ParkingSpot:public
|    |  92|+    std::enable_shared_from_this <
|    |  93|+    ParkingSpot >
|    |  94|+{
|    |  95|+  public:
|    |  96|+    ParkingSpot (const shared_ptr < Level > &level, int row,
|    |  97|+                 int spot_number, VehicleSize spot_size):
|    |  98|+    level_ (level),
|    |  99|+    row_ (row),
|    | 100|+    spot_number_ (spot_number),
|    | 101|+    spot_size_ (spot_size),
|    | 102|+    vehicle_ (nullptr)
|    | 103|+    {
|    | 104|+    }
|    | 105|+
|    | 106|+    bool
|    | 107|+    is_available () const
|    | 108|+        noexcept
|    | 109|+    {
|    | 110|+        return
|    | 111|+            vehicle_ == nullptr;
|    | 112|+    }
|    | 113|+
|    | 114|+    bool
|    | 115|+    can_fit_vehicle (Vehicle * vehicle)
|    | 116|+    {
|    | 117|+        return is_available ()
|    | 118|+            && vehicle->can_fit_in_spot (shared_from_this ());
|    | 119|+    }
|    | 120|+
|    | 121|+    void
|    | 122|+    park (Vehicle * vehicle)
|    | 123|+    {
|  99| 124|         vehicle_ = vehicle;
| 100|    |-        vehicle_->park_in_spot(shared_from_this());
| 101|    |-    }
| 102|    |-
| 103|    |-    void remove_vehicle();
| 104|    |-
| 105|    |-    int row() const noexcept {
| 106|    |-        return row_;
| 107|    |-    }
| 108|    |-
| 109|    |-    int spot_number() const noexcept {
| 110|    |-        return spot_number_;
| 111|    |-    }
| 112|    |-
| 113|    |-    VehicleSize size() const noexcept {
| 114|    |-        return spot_size_;
| 115|    |-    }
| 116|    |-
| 117|    |-private:
| 118|    |-    weak_ptr<Level> level_;
| 119|    |-    int row_, spot_number_;
| 120|    |-    VehicleSize spot_size_;
| 121|    |-    Vehicle *vehicle_;
|    | 125|+        vehicle_->park_in_spot (shared_from_this ());
|    | 126|+    }
|    | 127|+
|    | 128|+    void
|    | 129|+    remove_vehicle ();
|    | 130|+
|    | 131|+    int
|    | 132|+    row () const
|    | 133|+        noexcept
|    | 134|+    {
|    | 135|+        return
|    | 136|+            row_;
|    | 137|+    }
|    | 138|+
|    | 139|+    int
|    | 140|+    spot_number () const
|    | 141|+        noexcept
|    | 142|+    {
|    | 143|+        return
|    | 144|+            spot_number_;
|    | 145|+    }
|    | 146|+
|    | 147|+    VehicleSize
|    | 148|+    size () const
|    | 149|+        noexcept
|    | 150|+    {
|    | 151|+        return
|    | 152|+            spot_size_;
|    | 153|+    }
|    | 154|+
|    | 155|+  private:
|    | 156|+    weak_ptr <
|    | 157|+        Level >
|    | 158|+        level_;
|    | 159|+    int
|    | 160|+        row_,
|    | 161|+        spot_number_;
|    | 162|+    VehicleSize
|    | 163|+        spot_size_;
|    | 164|+    Vehicle *
|    | 165|+        vehicle_;
| 122| 166| };
| 123| 167| 
| 124| 168| // Use pImpl idiom to make copy assignment work.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 122| 122| };
| 123| 123| 
| 124| 124| // Use pImpl idiom to make copy assignment work.
| 125|    |-class BusImpl: public VehicleImpl {
| 126|    |-public:
| 127|    |-    BusImpl() {
|    | 125|+class
|    | 126|+    BusImpl:
|    | 127|+    public
|    | 128|+    VehicleImpl
|    | 129|+{
|    | 130|+  public:
|    | 131|+    BusImpl ()
|    | 132|+    {
| 128| 133|         spots_needed_ = 5;
| 129| 134|         size_ = VehicleSize::Large;
| 130| 135|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 129| 129|         size_ = VehicleSize::Large;
| 130| 130|     }
| 131| 131| 
| 132|    |-    virtual bool can_fit_in_spot(const shared_ptr<ParkingSpot>& spot)
| 133|    |-        const noexcept {
| 134|    |-        return spot->size() == VehicleSize::Large;
| 135|    |-    }
| 136|    |-};
| 137|    |-
| 138|    |-class Bus: public Vehicle {
| 139|    |-public:
| 140|    |-    Bus() {
| 141|    |-        pImpl_ = make_shared<BusImpl>();
|    | 132|+    virtual bool
|    | 133|+    can_fit_in_spot (const shared_ptr < ParkingSpot > &spot) const
|    | 134|+        noexcept
|    | 135|+    {
|    | 136|+        return
|    | 137|+            spot->
|    | 138|+        size () == VehicleSize::Large;
|    | 139|+    }
|    | 140|+};
|    | 141|+
|    | 142|+class
|    | 143|+    Bus:
|    | 144|+    public
|    | 145|+    Vehicle
|    | 146|+{
|    | 147|+  public:
|    | 148|+    Bus ()
|    | 149|+    {
|    | 150|+        pImpl_ = make_shared < BusImpl > ();
| 142| 151|     }
| 143| 152| };
| 144| 153| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 143| 143| };
| 144| 144| 
| 145| 145| // Use pImpl idiom to make copy assignment work.
| 146|    |-class CarImpl: public VehicleImpl {
| 147|    |-public:
| 148|    |-    CarImpl() {
|    | 146|+class
|    | 147|+    CarImpl:
|    | 148|+    public
|    | 149|+    VehicleImpl
|    | 150|+{
|    | 151|+  public:
|    | 152|+    CarImpl ()
|    | 153|+    {
| 149| 154|         spots_needed_ = 1;
| 150| 155|         size_ = VehicleSize::Compact;
| 151| 156|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 150| 150|         size_ = VehicleSize::Compact;
| 151| 151|     }
| 152| 152| 
| 153|    |-    virtual bool can_fit_in_spot(const shared_ptr<ParkingSpot>& spot)
| 154|    |-        const noexcept {
| 155|    |-        return spot->size() != VehicleSize::Motorcycle;
| 156|    |-    }
| 157|    |-};
| 158|    |-
| 159|    |-class Car: public Vehicle {
| 160|    |-public:
| 161|    |-    Car() {
| 162|    |-        pImpl_ = make_shared<CarImpl>();
|    | 153|+    virtual bool
|    | 154|+    can_fit_in_spot (const shared_ptr < ParkingSpot > &spot) const
|    | 155|+        noexcept
|    | 156|+    {
|    | 157|+        return
|    | 158|+            spot->
|    | 159|+        size () !=
|    | 160|+            VehicleSize::Motorcycle;
|    | 161|+    }
|    | 162|+};
|    | 163|+
|    | 164|+class
|    | 165|+    Car:
|    | 166|+    public
|    | 167|+    Vehicle
|    | 168|+{
|    | 169|+  public:
|    | 170|+    Car ()
|    | 171|+    {
|    | 172|+        pImpl_ = make_shared < CarImpl > ();
| 163| 173|     }
| 164| 174| };
| 165| 175| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 164| 164| };
| 165| 165| 
| 166| 166| // Use pImpl idiom to make copy assignment work.
| 167|    |-class MotorcycleImpl: public VehicleImpl {
| 168|    |-public:
| 169|    |-    MotorcycleImpl() {
|    | 167|+class
|    | 168|+    MotorcycleImpl:
|    | 169|+    public
|    | 170|+    VehicleImpl
|    | 171|+{
|    | 172|+  public:
|    | 173|+    MotorcycleImpl ()
|    | 174|+    {
| 170| 175|         spots_needed_ = 1;
| 171| 176|         size_ = VehicleSize::Motorcycle;
| 172| 177|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 171| 171|         size_ = VehicleSize::Motorcycle;
| 172| 172|     }
| 173| 173| 
| 174|    |-    virtual bool can_fit_in_spot(const shared_ptr<ParkingSpot>& spot)
| 175|    |-        const noexcept {
| 176|    |-        return true;
| 177|    |-    }
| 178|    |-};
| 179|    |-
| 180|    |-class Motorcycle: public Vehicle {
| 181|    |-public:
| 182|    |-    Motorcycle() {
| 183|    |-        pImpl_ = make_shared<MotorcycleImpl>();
| 184|    |-    }
| 185|    |-};
| 186|    |-
| 187|    |-class Level : public std::enable_shared_from_this<Level> {
| 188|    |-public:
| 189|    |-    Level(int flr, int num_rows, int spots_per_row) :
| 190|    |-        num_rows_(num_rows),
| 191|    |-        floor_(flr),
| 192|    |-        spots_per_row_(spots_per_row),
| 193|    |-        number_spots_(0),
| 194|    |-        available_spots_(0) {
|    | 174|+    virtual bool
|    | 175|+    can_fit_in_spot (const shared_ptr < ParkingSpot > &spot) const
|    | 176|+        noexcept
|    | 177|+    {
|    | 178|+        return
|    | 179|+            true;
|    | 180|+    }
|    | 181|+};
|    | 182|+
|    | 183|+class
|    | 184|+    Motorcycle:
|    | 185|+    public
|    | 186|+    Vehicle
|    | 187|+{
|    | 188|+  public:
|    | 189|+    Motorcycle ()
|    | 190|+    {
|    | 191|+        pImpl_ = make_shared < MotorcycleImpl > ();
|    | 192|+    }
|    | 193|+};
|    | 194|+
|    | 195|+class
|    | 196|+    Level:
|    | 197|+    public
|    | 198|+    std::enable_shared_from_this <
|    | 199|+    Level >
|    | 200|+{
|    | 201|+  public:
|    | 202|+    Level (int flr, int num_rows, int spots_per_row):
|    | 203|+    num_rows_ (num_rows),
|    | 204|+    floor_ (flr),
|    | 205|+    spots_per_row_ (spots_per_row),
|    | 206|+    number_spots_ (0),
|    | 207|+    available_spots_ (0)
|    | 208|+    {
| 195| 209|     }
| 196| 210| 
| 197| 211|     // Use two-phase construction to avoid the problem that
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 196| 196| 
| 197| 197|     // Use two-phase construction to avoid the problem that
| 198| 198|     // shared_from_this() cannot be used in ctor!
| 199|    |-    void init() {
| 200|    |-        for (int row = 0; row < num_rows_; ++row) {
| 201|    |-            int i = 0;
| 202|    |-            for (; i < spots_per_row_ / 4; ++i) {
| 203|    |-                spots_.emplace_back(
| 204|    |-                    make_shared<ParkingSpot>(shared_from_this(),
| 205|    |-                                             row, number_spots_,
| 206|    |-                                             VehicleSize::Motorcycle));
| 207|    |-                ++number_spots_;
|    | 199|+    void
|    | 200|+    init ()
|    | 201|+    {
|    | 202|+        for (int row = 0; row < num_rows_; ++row)
|    | 203|+          {
|    | 204|+              int
|    | 205|+                  i = 0;
|    | 206|+              for (; i < spots_per_row_ / 4; ++i)
|    | 207|+                {
|    | 208|+                    spots_.emplace_back (make_shared < ParkingSpot >
|    | 209|+                                         (shared_from_this (), row,
|    | 210|+                                          number_spots_,
|    | 211|+                                          VehicleSize::Motorcycle));
|    | 212|+                    ++number_spots_;
|    | 213|+                }
|    | 214|+
|    | 215|+              for (; i < spots_per_row_ / 4 * 3; ++i)
|    | 216|+                {
|    | 217|+                    spots_.emplace_back (make_shared < ParkingSpot >
|    | 218|+                                         (shared_from_this (), row,
|    | 219|+                                          number_spots_,
|    | 220|+                                          VehicleSize::Compact));
|    | 221|+                    ++number_spots_;
|    | 222|+                }
|    | 223|+
|    | 224|+              for (; i < spots_per_row_; ++i)
|    | 225|+                {
|    | 226|+                    spots_.emplace_back (make_shared < ParkingSpot >
|    | 227|+                                         (shared_from_this (), row,
|    | 228|+                                          number_spots_, VehicleSize::Large));
|    | 229|+                    ++number_spots_;
|    | 230|+                }
|    | 231|+          }
|    | 232|+        available_spots_ = number_spots_;
|    | 233|+    }
|    | 234|+
|    | 235|+    bool
|    | 236|+    park_vehicle (Vehicle * vehicle)
|    | 237|+    {
|    | 238|+        if (available_spots () < vehicle->spots_needed ())
|    | 239|+          {
|    | 240|+              return false;
|    | 241|+          }
|    | 242|+
|    | 243|+        const
|    | 244|+            auto &
|    | 245|+            spot_num = find_available_spots (vehicle);
|    | 246|+        if (spot_num < 0)
|    | 247|+          {
|    | 248|+              return false;
|    | 249|+          }
|    | 250|+        else
|    | 251|+          {
|    | 252|+              park_starting_at_spot (spot_num, vehicle);
|    | 253|+              return true;
|    | 254|+          }
|    | 255|+    }
|    | 256|+
|    | 257|+    int
|    | 258|+    find_available_spots (Vehicle * vehicle)
|    | 259|+    {
|    | 260|+        const
|    | 261|+            auto &
|    | 262|+            spots_needed = vehicle->spots_needed ();
|    | 263|+        int
|    | 264|+            last_row = -1;
|    | 265|+        int
|    | 266|+            spots_found = 0;
|    | 267|+
|    | 268|+        for (int i = 0; i < spots_.size (); ++i)
|    | 269|+          {
|    | 270|+              auto & spot = spots_[i];
|    | 271|+              if (last_row != spot->row ())
|    | 272|+                {
|    | 273|+                    spots_found = 0;
|    | 274|+                    last_row = spot->row ();
|    | 275|+                }
|    | 276|+              if (spot->can_fit_vehicle (vehicle))
|    | 277|+                {
|    | 278|+                    ++spots_found;
|    | 279|+                }
|    | 280|+              else
|    | 281|+                {
|    | 282|+                    spots_found = 0;
|    | 283|+                }
|    | 284|+
|    | 285|+              if (spots_found == spots_needed)
|    | 286|+                {
|    | 287|+                    return i - (spots_needed - 1);
|    | 288|+                }
|    | 289|+          }
|    | 290|+
|    | 291|+        return -1;
|    | 292|+    }
|    | 293|+
|    | 294|+    void
|    | 295|+    park_starting_at_spot (int spot_num, Vehicle * vehicle)
|    | 296|+    {
|    | 297|+        for (int i = spot_num; i < spot_num + vehicle->spots_needed (); ++i)
|    | 298|+          {
|    | 299|+              spots_[i]->park (vehicle);
|    | 300|+          }
|    | 301|+        available_spots_ -= vehicle->spots_needed ();
|    | 302|+    }
|    | 303|+
|    | 304|+    void
|    | 305|+    spot_freed ()
|    | 306|+        noexcept
|    | 307|+    {
|    | 308|+        ++available_spots_;
|    | 309|+    }
|    | 310|+
|    | 311|+    int
|    | 312|+    available_spots () const
|    | 313|+        noexcept
|    | 314|+    {
|    | 315|+        return
|    | 316|+            available_spots_;
|    | 317|+    }
|    | 318|+
|    | 319|+  private:
|    | 320|+    int
|    | 321|+        num_rows_;
|    | 322|+    int
|    | 323|+        floor_;
|    | 324|+    int
|    | 325|+        spots_per_row_;
|    | 326|+    int
|    | 327|+        number_spots_;
|    | 328|+    int
|    | 329|+        available_spots_;
|    | 330|+    vector < shared_ptr < ParkingSpot >> spots_;
|    | 331|+};
|    | 332|+
|    | 333|+void
|    | 334|+VehicleImpl::clear_spots ()
|    | 335|+{
|    | 336|+  for (const auto & spot:parking_spots_)
|    | 337|+      {
|    | 338|+          if (auto spt = spot.lock ())
|    | 339|+            {
|    | 340|+                spt->remove_vehicle ();
| 208| 341|             }
| 209|    |-
| 210|    |-            for (; i < spots_per_row_ / 4 * 3; ++i) {
| 211|    |-                spots_.emplace_back(
| 212|    |-                    make_shared<ParkingSpot>(shared_from_this(),
| 213|    |-                                             row, number_spots_,
| 214|    |-                                             VehicleSize::Compact));
| 215|    |-                ++number_spots_;
| 216|    |-            }
| 217|    |-
| 218|    |-            for (; i < spots_per_row_; ++i) {
| 219|    |-                spots_.emplace_back(
| 220|    |-                    make_shared<ParkingSpot>(shared_from_this(),
| 221|    |-                                             row, number_spots_,
| 222|    |-                                             VehicleSize::Large));
| 223|    |-                ++number_spots_;
| 224|    |-            }
| 225|    |-        }
| 226|    |-        available_spots_ = number_spots_;
| 227|    |-    }
| 228|    |-
| 229|    |-    bool park_vehicle(Vehicle *vehicle) {
| 230|    |-        if (available_spots() < vehicle->spots_needed()) {
| 231|    |-            return false;
| 232|    |-        }
| 233|    |-
| 234|    |-        const auto& spot_num = find_available_spots(vehicle);
| 235|    |-        if (spot_num < 0) {
| 236|    |-            return false;
| 237|    |-        } else {
| 238|    |-            park_starting_at_spot(spot_num, vehicle);
| 239|    |-            return true;
| 240|    |-        }
| 241|    |-    }
| 242|    |-
| 243|    |-    int find_available_spots(Vehicle *vehicle) {
| 244|    |-        const auto& spots_needed = vehicle->spots_needed();
| 245|    |-        int last_row = -1;
| 246|    |-        int spots_found = 0;
| 247|    |-
| 248|    |-        for (int i = 0; i < spots_.size(); ++i) {
| 249|    |-            auto& spot = spots_[i];
| 250|    |-            if (last_row != spot->row()) {
| 251|    |-                spots_found = 0;
| 252|    |-                last_row = spot->row();
| 253|    |-            }
| 254|    |-            if (spot->can_fit_vehicle(vehicle)) {
| 255|    |-                ++spots_found;
| 256|    |-            } else {
| 257|    |-                spots_found = 0;
| 258|    |-            }
| 259|    |-
| 260|    |-            if (spots_found == spots_needed) {
| 261|    |-                return i - (spots_needed - 1);
| 262|    |-            }
| 263|    |-        }
| 264|    |-
| 265|    |-        return -1;
| 266|    |-    }
| 267|    |-
| 268|    |-    void park_starting_at_spot(int spot_num, Vehicle *vehicle) {
| 269|    |-        for (int i = spot_num; i < spot_num + vehicle->spots_needed(); ++i) {
| 270|    |-            spots_[i]->park(vehicle);
| 271|    |-        }
| 272|    |-        available_spots_ -= vehicle->spots_needed();
| 273|    |-    }
| 274|    |-
| 275|    |-    void spot_freed() noexcept {
| 276|    |-        ++available_spots_;
| 277|    |-    }
| 278|    |-
| 279|    |-    int available_spots() const noexcept {
| 280|    |-        return available_spots_;
| 281|    |-    }
| 282|    |-
| 283|    |-private:
| 284|    |-    int num_rows_;
| 285|    |-    int floor_;
| 286|    |-    int spots_per_row_;
| 287|    |-    int number_spots_;
| 288|    |-    int available_spots_;
| 289|    |-    vector<shared_ptr<ParkingSpot>> spots_;
| 290|    |-};
| 291|    |-
| 292|    |-void VehicleImpl::clear_spots() {
| 293|    |-    for (const auto& spot : parking_spots_) {
| 294|    |-        if (auto spt = spot.lock()) {
| 295|    |-            spt->remove_vehicle();
| 296|    |-        }
| 297|    |-    }
| 298|    |-    parking_spots_.clear();
|    | 342|+      }
|    | 343|+    parking_spots_.clear ();
| 299| 344| }
| 300| 345| 
| 301| 346| void ParkingSpot::remove_vehicle() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 298| 298|     parking_spots_.clear();
| 299| 299| }
| 300| 300| 
| 301|    |-void ParkingSpot::remove_vehicle() {
| 302|    |-    if (auto spt = level_.lock()) {
| 303|    |-        spt->spot_freed();
| 304|    |-    }
|    | 301|+void
|    | 302|+ParkingSpot::remove_vehicle ()
|    | 303|+{
|    | 304|+    if (auto spt = level_.lock ())
|    | 305|+      {
|    | 306|+          spt->spot_freed ();
|    | 307|+      }
| 305| 308|     vehicle_ = nullptr;
| 306| 309| }
| 307| 310| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 305| 305|     vehicle_ = nullptr;
| 306| 306| }
| 307| 307| 
| 308|    |-class ParkingLot {
| 309|    |-public:
|    | 308|+class ParkingLot
|    | 309|+{
|    | 310|+  public:
| 310| 311|     // @param n number of leves
| 311| 312|     // @param num_rows  each level has num_rows rows of spots
| 312| 313|     // @param spots_per_row each row has spots_per_row spots
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 310| 310|     // @param n number of leves
| 311| 311|     // @param num_rows  each level has num_rows rows of spots
| 312| 312|     // @param spots_per_row each row has spots_per_row spots
| 313|    |-    ParkingLot(int n, int num_rows, int spots_per_row) {
| 314|    |-        for (int i = 0; i < n; ++i) {
| 315|    |-            auto&& ptr = make_shared<Level>(i, num_rows, spots_per_row);
| 316|    |-            ptr->init();
| 317|    |-            levels_.emplace_back(ptr);
| 318|    |-        }
|    | 313|+    ParkingLot (int n, int num_rows, int spots_per_row)
|    | 314|+    {
|    | 315|+        for (int i = 0; i < n; ++i)
|    | 316|+          {
|    | 317|+              auto && ptr = make_shared < Level > (i, num_rows, spots_per_row);
|    | 318|+              ptr->init ();
|    | 319|+              levels_.emplace_back (ptr);
|    | 320|+          }
| 319| 321|     }
| 320| 322| 
| 321| 323|     // Park the vehicle in a spot (or multiple spots)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 320| 320| 
| 321| 321|     // Park the vehicle in a spot (or multiple spots)
| 322| 322|     // Return false if failed
| 323|    |-    bool parkVehicle(Vehicle &vehicle) {
| 324|    |-        unParkVehicle(vehicle);  // This may make the parked vehicle move to another place.
| 325|    |-
| 326|    |-        for (auto& level : levels_) {
| 327|    |-            if (level->park_vehicle(&vehicle)) {
| 328|    |-                return true;
| 329|    |-            }
| 330|    |-        }
|    | 323|+    bool parkVehicle (Vehicle & vehicle)
|    | 324|+    {
|    | 325|+        unParkVehicle (vehicle);    // This may make the parked vehicle move to another place.
|    | 326|+
|    | 327|+      for (auto & level:levels_)
|    | 328|+          {
|    | 329|+              if (level->park_vehicle (&vehicle))
|    | 330|+                {
|    | 331|+                    return true;
|    | 332|+                }
|    | 333|+          }
| 331| 334|         return false;
| 332| 335|     }
| 333| 336| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/parking-lot.cpp
|    |++++| /app/C++/parking-lot.cpp
| 332| 332|     }
| 333| 333| 
| 334| 334|     // unPark the vehicle
| 335|    |-    void unParkVehicle(Vehicle &vehicle) {
| 336|    |-        vehicle.clear_spots();
| 337|    |-    }
| 338|    |-
| 339|    |-private:
| 340|    |-    vector<shared_ptr<Level>> levels_;
| 341|    |-};
|    | 335|+    void unParkVehicle (Vehicle & vehicle)
|    | 336|+    {
|    | 337|+        vehicle.clear_spots ();
|    | 338|+    }
|    | 339|+
|    | 340|+  private:
|    | 341|+    vector < shared_ptr < Level >> levels_;
|    | 342|+};

C++/parking-lot.cpp
|  14| class•ParkingSpot;
|    | [NORMAL] CPPCleanBear:
|    | 'ParkingSpot' forward declaration not expected in source file

C++/parking-lot.cpp
|  15| class•Level;
|    | [NORMAL] CPPCleanBear:
|    | 'Level' forward declaration not expected in source file
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trailing-zeros.cpp
|    |++++| /app/C++/trailing-zeros.cpp
|   1|   1| // Time:  O(logn) = O(1)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     // param n : description of n
|   7|   8|     // return: description of return
|   8|   9|     long long trailingZeros(long long n) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/trailing-zeros.cpp
|    |++++| /app/C++/trailing-zeros.cpp
|   5|   5| public:
|   6|   6|     // param n : description of n
|   7|   7|     // return: description of return
|   8|    |-    long long trailingZeros(long long n) {
|    |   8|+    long long trailingZeros (long long n)
|    |   9|+    {
|   9|  10|         long long zero_num = 0;
|  10|    |-        while (n > 0) {
|  11|    |-            n /= 5;
|  12|    |-            zero_num += n;
|  13|    |-        }
|    |  11|+        while (n > 0)
|    |  12|+          {
|    |  13|+              n /= 5;
|    |  14|+              zero_num += n;
|    |  15|+          }
|  14|  16|         return zero_num;
|  15|  17|     }
|  16|  18| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  15|  15|  */
|  16|  16| 
|  17|  17| // Using stack.
|  18|    |-class Solution {
|    |  18|+class Solution
|    |  19|+{
|  19|  20|     /**
|  20|  21|      * @param root: The root of binary tree.
|  21|  22|      * @return: A list of lists of integer include
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  21|  21|      * @return: A list of lists of integer include
|  22|  22|      *          the zigzag level order traversal of its nodes' values
|  23|  23|      */
|  24|    |-public:
|  25|    |-    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
|  26|    |-        vector<vector<int>> result;
|  27|    |-        stack<TreeNode *> current_level;
|    |  24|+  public:
|    |  25|+    vector < vector < int >>zigzagLevelOrder (TreeNode * root)
|    |  26|+    {
|    |  27|+        vector < vector < int >>result;
|    |  28|+          stack < TreeNode * >current_level;
|  28|  29| 
|  29|    |-        if (root != nullptr) {
|  30|    |-            current_level.emplace(root);
|  31|    |-        }
|    |  30|+        if (root != nullptr)
|    |  31|+          {
|    |  32|+              current_level.emplace (root);
|    |  33|+          }
|  32|  34| 
|  33|  35|         bool normal_order = true;
|  34|  36|         while (!current_level.empty()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  31|  31|         }
|  32|  32| 
|  33|  33|         bool normal_order = true;
|  34|    |-        while (!current_level.empty()) {
|  35|    |-            vector<int> level;
|  36|    |-            stack<TreeNode *> next_level;
|  37|    |-            int size = current_level.size();
|  38|    |-            while (!current_level.empty()) {
|  39|    |-                auto *top = current_level.top();
|  40|    |-                current_level.pop();
|  41|    |-                level.emplace_back(top->val);
|  42|    |-                if (normal_order) {
|  43|    |-                    if (top->left != nullptr) {
|  44|    |-                        next_level.emplace(top->left);
|  45|    |-                    }
|  46|    |-                    if (top->right != nullptr) {
|  47|    |-                        next_level.emplace(top->right);
|  48|    |-                    }
|  49|    |-                } else {
|  50|    |-                    if (top->right != nullptr) {
|  51|    |-                        next_level.emplace(top->right);
|  52|    |-                    }
|  53|    |-                    if (top->left != nullptr) {
|  54|    |-                        next_level.emplace(top->left);
|  55|    |-                    }
|    |  34|+        while (!current_level.empty ())
|    |  35|+          {
|    |  36|+              vector < int >level;
|    |  37|+              stack < TreeNode * >next_level;
|    |  38|+              int size = current_level.size ();
|    |  39|+              while (!current_level.empty ())
|    |  40|+                {
|    |  41|+                    auto *top = current_level.top ();
|    |  42|+                    current_level.pop ();
|    |  43|+                    level.emplace_back (top->val);
|    |  44|+                    if (normal_order)
|    |  45|+                      {
|    |  46|+                          if (top->left != nullptr)
|    |  47|+                            {
|    |  48|+                                next_level.emplace (top->left);
|    |  49|+                            }
|    |  50|+                          if (top->right != nullptr)
|    |  51|+                            {
|    |  52|+                                next_level.emplace (top->right);
|    |  53|+                            }
|    |  54|+                      }
|    |  55|+                    else
|    |  56|+                      {
|    |  57|+                          if (top->right != nullptr)
|    |  58|+                            {
|    |  59|+                                next_level.emplace (top->right);
|    |  60|+                            }
|    |  61|+                          if (top->left != nullptr)
|    |  62|+                            {
|    |  63|+                                next_level.emplace (top->left);
|    |  64|+                            }
|    |  65|+                      }
|  56|  66|                 }
|  57|    |-            }
|  58|    |-            result.emplace_back(move(level));
|  59|    |-            normal_order = !normal_order;
|  60|    |-            swap(current_level, next_level);
|  61|    |-        }
|    |  67|+              result.emplace_back (move (level));
|    |  68|+              normal_order = !normal_order;
|    |  69|+              swap (current_level, next_level);
|    |  70|+          }
|  62|  71| 
|  63|  72|         return result;
|  64|  73|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  65|  65| };
|  66|  66| 
|  67|  67| // Useing queue.
|  68|    |-class Solution2 {
|    |  68|+class Solution2
|    |  69|+{
|  69|  70|     /**
|  70|  71|      * @param root: The root of binary tree.
|  71|  72|      * @return: A list of lists of integer include
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  71|  71|      * @return: A list of lists of integer include
|  72|  72|      *          the zigzag level order traversal of its nodes' values
|  73|  73|      */
|  74|    |-public:
|  75|    |-    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
|  76|    |-        vector<vector<int>> result;
|  77|    |-        queue<TreeNode *> que;
|    |  74|+  public:
|    |  75|+    vector < vector < int >>zigzagLevelOrder (TreeNode * root)
|    |  76|+    {
|    |  77|+        vector < vector < int >>result;
|    |  78|+          queue < TreeNode * >que;
|  78|  79| 
|  79|    |-        if (root != nullptr) {
|  80|    |-            que.emplace(root);
|  81|    |-        }
|    |  80|+        if (root != nullptr)
|    |  81|+          {
|    |  82|+              que.emplace (root);
|    |  83|+          }
|  82|  84| 
|  83|  85|         bool normal_order = true;
|  84|  86|         while (!que.empty()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|    |++++| /app/C++/binary-tree-zigzag-level-order-traversal.cpp
|  81|  81|         }
|  82|  82| 
|  83|  83|         bool normal_order = true;
|  84|    |-        while (!que.empty()) {
|  85|    |-            vector<int> level;
|  86|    |-            int size = que.size();
|  87|    |-            for (int i = 0; i < size; i++) {
|  88|    |-                auto *front = que.front();
|  89|    |-                que.pop();
|  90|    |-                level.emplace_back(front->val);
|  91|    |-                if (front->left != nullptr) {
|  92|    |-                    que.emplace(front->left);
|    |  84|+        while (!que.empty ())
|    |  85|+          {
|    |  86|+              vector < int >level;
|    |  87|+              int size = que.size ();
|    |  88|+              for (int i = 0; i < size; i++)
|    |  89|+                {
|    |  90|+                    auto *front = que.front ();
|    |  91|+                    que.pop ();
|    |  92|+                    level.emplace_back (front->val);
|    |  93|+                    if (front->left != nullptr)
|    |  94|+                      {
|    |  95|+                          que.emplace (front->left);
|    |  96|+                      }
|    |  97|+                    if (front->right != nullptr)
|    |  98|+                      {
|    |  99|+                          que.emplace (front->right);
|    | 100|+                      }
|  93| 101|                 }
|  94|    |-                if (front->right != nullptr) {
|  95|    |-                    que.emplace(front->right);
|    | 102|+              if (!normal_order)
|    | 103|+                {
|    | 104|+                    reverse (level.begin (), level.end ());
|  96| 105|                 }
|  97|    |-            }
|  98|    |-            if (!normal_order) {
|  99|    |-                reverse(level.begin(), level.end());
| 100|    |-            }
| 101|    |-            result.emplace_back(move(level));
| 102|    |-            normal_order = !normal_order;
| 103|    |-        }
|    | 106|+              result.emplace_back (move (level));
|    | 107|+              normal_order = !normal_order;
|    | 108|+          }
| 104| 109| 
| 105| 110|         return result;
| 106| 111|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum.cpp
|    |++++| /app/C++/subarray-sum.cpp
|   1|    |-class Solution {
|   2|    |-public:
|    |   1|+class Solution
|    |   2|+{
|    |   3|+  public:
|   3|   4|     /**
|   4|   5|      * @param nums: A list of integers
|   5|   6|      * @return: A list of integers includes the index of the first number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum.cpp
|    |++++| /app/C++/subarray-sum.cpp
|   5|   5|      * @return: A list of integers includes the index of the first number
|   6|   6|      *          and the index of the last number
|   7|   7|      */
|   8|    |-    vector<int> subarraySum(vector<int> nums) {
|   9|    |-        unordered_map<int, int> table;
|  10|    |-        table[0] = -1;
|  11|    |-        for (int i = 0, sum = 0; i < nums.size(); ++i) {
|  12|    |-            sum += nums[i];
|  13|    |-            if (!table.emplace(sum, i).second) {  // Already exists.
|  14|    |-                return {table[sum] + 1, i};
|  15|    |-            }
|  16|    |-        }
|  17|    |-        return {};
|    |   8|+    vector < int >subarraySum (vector < int >nums)
|    |   9|+    {
|    |  10|+        unordered_map < int, int >table;
|    |  11|+          table[0] = -1;
|    |  12|+        for (int i = 0, sum = 0; i < nums.size (); ++i)
|    |  13|+          {
|    |  14|+              sum += nums[i];
|    |  15|+              if (!table.emplace (sum, i).second)
|    |  16|+                {               // Already exists.
|    |  17|+                    return
|    |  18|+                    {
|    |  19|+                    table[sum] + 1, i};
|    |  20|+                }
|    |  21|+          }
|    |  22|+        return
|    |  23|+        {
|    |  24|+        };
|  18|  25|     }
|  19|  26| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum-closest.cpp
|    |++++| /app/C++/3-sum-closest.cpp
|   1|   1| // Time:  O(n^2)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param numbers: Give an array numbers of n integer
|   8|   9|      * @param target: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum-closest.cpp
|    |++++| /app/C++/3-sum-closest.cpp
|   8|   8|      * @param target: An integer
|   9|   9|      * @return: return the sum of the three integers, the sum closest target.
|  10|  10|      */
|  11|    |-    int threeSumClosest(vector<int> nums, int target) {
|  12|    |-        int ans = numeric_limits<int>::max();
|  13|    |-        int min_diff = numeric_limits<int>::max();
|    |  11|+    int threeSumClosest (vector < int >nums, int target)
|    |  12|+    {
|    |  13|+        int ans = numeric_limits < int >::max ();
|    |  14|+        int min_diff = numeric_limits < int >::max ();
|  14|  15| 
|  15|  16|         // Make nums in increasing order. Time: O(nlogn)
|  16|  17|         sort(nums.begin(), nums.end());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum-closest.cpp
|    |++++| /app/C++/3-sum-closest.cpp
|  13|  13|         int min_diff = numeric_limits<int>::max();
|  14|  14| 
|  15|  15|         // Make nums in increasing order. Time: O(nlogn)
|  16|    |-        sort(nums.begin(), nums.end());
|    |  16|+          sort (nums.begin (), nums.end ());
|  17|  17| 
|  18|    |-        for (int i = 0; i < static_cast<int>(nums.size()) - 2; ++i) {
|  19|    |-            if (i == 0 || nums[i] != nums[i - 1]) {  // Skip duplicated.
|  20|    |-                int j = i + 1;
|  21|    |-                int k = nums.size() - 1;
|  22|    |-    
|  23|    |-                while (j < k) {  // Time: O(n) for each i.
|  24|    |-                    const auto sum = nums[i] + nums[j] + nums[k];
|  25|    |-    
|  26|    |-                    if (sum > target) {  // Should decrease sum.
|  27|    |-                        --k;
|  28|    |-                    } else if (sum < target) {  // Should increase sum.
|  29|    |-                        ++j;
|  30|    |-                    } else {
|  31|    |-                        return target;
|  32|    |-                    }
|  33|    |-    
|  34|    |-                    if (abs(sum - target) < min_diff) {
|  35|    |-                        min_diff = abs(sum - target);
|  36|    |-                        ans = sum;
|  37|    |-                    }
|    |  18|+        for (int i = 0; i < static_cast < int >(nums.size ()) - 2; ++i)
|    |  19|+          {
|    |  20|+              if (i == 0 || nums[i] != nums[i - 1])
|    |  21|+                {               // Skip duplicated.
|    |  22|+                    int j = i + 1;
|    |  23|+                    int k = nums.size () - 1;
|    |  24|+
|    |  25|+                    while (j < k)
|    |  26|+                      {         // Time: O(n) for each i.
|    |  27|+                          const auto sum = nums[i] + nums[j] + nums[k];
|    |  28|+
|    |  29|+                          if (sum > target)
|    |  30|+                            {   // Should decrease sum.
|    |  31|+                                --k;
|    |  32|+                            }
|    |  33|+                          else if (sum < target)
|    |  34|+                            {   // Should increase sum.
|    |  35|+                                ++j;
|    |  36|+                            }
|    |  37|+                          else
|    |  38|+                            {
|    |  39|+                                return target;
|    |  40|+                            }
|    |  41|+
|    |  42|+                          if (abs (sum - target) < min_diff)
|    |  43|+                            {
|    |  44|+                                min_diff = abs (sum - target);
|    |  45|+                                ans = sum;
|    |  46|+                            }
|    |  47|+                      }
|  38|  48|                 }
|  39|    |-            }
|  40|    |-        }
|    |  49|+          }
|  41|  50| 
|  42|  51|         return ans;
|  43|  52|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/3-sum-closest.cpp
|    |++++| /app/C++/3-sum-closest.cpp
|  42|  42|         return ans;
|  43|  43|     }
|  44|  44| };
|  45|    |-
|  46|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|   1|   1| // Time:  O(n * d), n is length of the string, d is size of the dictionary
|   2|   2| // Space: O(d)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param start, a string
|   8|   9|      * @param end, a string
|   9|  10|      * @param dict, a set of string
|  10|  11|      * @return an integer
|  11|  12|      */
|  12|    |-    int ladderLength(string start, string end, unordered_set<string> &dict) {
|  13|    |-        unordered_map<string, unordered_set<string>> trace;
|    |  13|+    int ladderLength (string start, string end, unordered_set < string > &dict)
|    |  14|+    {
|    |  15|+        unordered_map < string, unordered_set < string >> trace;
|  14|  16| 
|  15|  17|         // BFS, each round is a level
|  16|  18|         unordered_set<string> levels[2];
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|  13|  13|         unordered_map<string, unordered_set<string>> trace;
|  14|  14| 
|  15|  15|         // BFS, each round is a level
|  16|    |-        unordered_set<string> levels[2];
|    |  16|+        unordered_set < string > levels[2];
|  17|  17|         int cur_level = 0;
|  18|  18| 
|  19|  19|         levels[cur_level].emplace(start);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|  16|  16|         unordered_set<string> levels[2];
|  17|  17|         int cur_level = 0;
|  18|  18| 
|  19|    |-        levels[cur_level].emplace(start);
|  20|    |-        while (dict.size() > 0 && levels[cur_level % 2].size() > 0) {
|  21|    |-            // end is in current level, stop
|  22|    |-            if (trace.count(end) == 1) {
|  23|    |-                ++cur_level;
|  24|    |-                break;
|  25|    |-            }
|    |  19|+          levels[cur_level].emplace (start);
|    |  20|+        while (dict.size () > 0 && levels[cur_level % 2].size () > 0)
|    |  21|+          {
|    |  22|+              // end is in current level, stop
|    |  23|+              if (trace.count (end) == 1)
|    |  24|+                {
|    |  25|+                    ++cur_level;
|    |  26|+                    break;
|    |  27|+                }
|  26|  28| 
|  27|    |-            // clear words from the dictionary to avoid it' apear in future level again
|  28|    |-            for (const auto& word : levels[cur_level % 2]) {
|  29|    |-                dict.erase(word);
|  30|    |-            }
|    |  29|+              // clear words from the dictionary to avoid it' apear in future level again
|    |  30|+              for (const auto & word:levels[cur_level % 2])
|    |  31|+                {
|    |  32|+                    dict.erase (word);
|    |  33|+                }
|  31|  34| 
|  32|    |-            levels[(cur_level + 1) % 2].clear();
|  33|    |-            for (const auto& from : levels[cur_level % 2]) {
|  34|    |-                string new_word = from;
|  35|    |-                for (int i = 0; i < new_word.length(); i++) {
|  36|    |-                    char orig_c = from[i];
|  37|    |-                    for (char c = 'a'; c <= 'z'; c++) {
|  38|    |-                        new_word[i] = c;
|  39|    |-                        if (dict.count(new_word) == 1) {
|  40|    |-                            trace[new_word].emplace(from);
|  41|    |-                            levels[(cur_level + 1) % 2].emplace(new_word);
|  42|    |-                        }
|  43|    |-                    }
|  44|    |-                    new_word[i] = orig_c;
|    |  35|+              levels[(cur_level + 1) % 2].clear ();
|    |  36|+            for (const auto & from:levels[cur_level % 2])
|    |  37|+                {
|    |  38|+                    string new_word = from;
|    |  39|+                    for (int i = 0; i < new_word.length (); i++)
|    |  40|+                      {
|    |  41|+                          char orig_c = from[i];
|    |  42|+                          for (char c = 'a'; c <= 'z'; c++)
|    |  43|+                            {
|    |  44|+                                new_word[i] = c;
|    |  45|+                                if (dict.count (new_word) == 1)
|    |  46|+                                  {
|    |  47|+                                      trace[new_word].emplace (from);
|    |  48|+                                      levels[(cur_level +
|    |  49|+                                              1) % 2].emplace (new_word);
|    |  50|+                                  }
|    |  51|+                            }
|    |  52|+                          new_word[i] = orig_c;
|    |  53|+                      }
|  45|  54|                 }
|  46|    |-            }
|  47|  55| 
|  48|    |-            ++cur_level;
|  49|    |-        }
|    |  56|+              ++cur_level;
|    |  57|+          }
|  50|  58| 
|  51|  59|         return cur_level;
|  52|  60|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|  52|  52|     }
|  53|  53| };
|  54|  54| 
|  55|    |-class Solution2 {
|  56|    |-public:
|    |  55|+class Solution2
|    |  56|+{
|    |  57|+  public:
|  57|  58|     /**
|  58|  59|      * @param start, a string
|  59|  60|      * @param end, a string
|  60|  61|      * @param dict, a set of string
|  61|  62|      * @return an integer
|  62|  63|      */
|  63|    |-    int ladderLength(string start, string end, unordered_set<string> &dict) {
|    |  64|+    int ladderLength (string start, string end, unordered_set < string > &dict)
|    |  65|+    {
|  64|  66|         int rounds = 1;
|  65|    |-        vector<vector<string>> level(2, vector<string>());
|  66|    |-        level[rounds % 2].emplace_back(start);
|  67|    |-        unordered_set<string> visited;
|    |  67|+          vector < vector < string >> level (2, vector < string > ());
|    |  68|+          level[rounds % 2].emplace_back (start);
|    |  69|+          unordered_set < string > visited;
|  68|  70| 
|  69|  71|         // BFS
|  70|  72|         while (level[rounds % 2].size() > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|  67|  67|         unordered_set<string> visited;
|  68|  68| 
|  69|  69|         // BFS
|  70|    |-        while (level[rounds % 2].size() > 0) {
|  71|    |-            for (auto& word : level[rounds % 2]) {
|  72|    |-                if (word == end) {
|  73|    |-                    return rounds;
|    |  70|+        while (level[rounds % 2].size () > 0)
|    |  71|+          {
|    |  72|+            for (auto & word:level[rounds % 2])
|    |  73|+                {
|    |  74|+                    if (word == end)
|    |  75|+                      {
|    |  76|+                          return rounds;
|    |  77|+                      }
|    |  78|+
|    |  79|+                    for (int i = 0; i < word.length (); ++i)
|    |  80|+                      {
|    |  81|+                          for (int j = 'a'; j <= 'z'; ++j)
|    |  82|+                            {
|    |  83|+                                string candidate (word);
|    |  84|+                                candidate[i] = j;   // Change one character.
|    |  85|+                                if (visited.count (candidate) == 0
|    |  86|+                                    && dict.count (candidate) == 1)
|    |  87|+                                  {
|    |  88|+                                      level[(rounds +
|    |  89|+                                             1) % 2].emplace_back (candidate);
|    |  90|+                                      visited.emplace (candidate);  // Marked as visited
|    |  91|+                                  }
|    |  92|+                            }
|    |  93|+                      }
|  74|  94|                 }
|  75|    |-
|  76|    |-                for (int i = 0; i < word.length(); ++i) {
|  77|    |-                    for (int j= 'a'; j <= 'z'; ++j) {
|  78|    |-                        string candidate(word);
|  79|    |-                        candidate[i] = j; // Change one character.
|  80|    |-                        if (visited.count(candidate) == 0 && dict.count(candidate) == 1) {
|  81|    |-                            level[(rounds + 1) % 2].emplace_back(candidate);
|  82|    |-                            visited.emplace(candidate); // Marked as visited
|  83|    |-                        }
|  84|    |-                    }
|  85|    |-                }
|  86|    |-            }
|  87|    |-            level[rounds % 2].clear();
|  88|    |-            ++rounds;
|  89|    |-        }
|    |  95|+              level[rounds % 2].clear ();
|    |  96|+              ++rounds;
|    |  97|+          }
|  90|  98| 
|  91|  99|         return 0;
|  92| 100|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
|  92|  92|     }
|  93|  93| };
|  94|  94| 
|  95|    |-class Solution3 {
|  96|    |-public:
|    |  95|+class Solution3
|    |  96|+{
|    |  97|+  public:
|  97|  98|     /**
|  98|  99|      * @param start, a string
|  99| 100|      * @param end, a string
| 100| 101|      * @param dict, a set of string
| 101| 102|      * @return an integer
| 102| 103|      */
| 103|    |-    int ladderLength(string start, string end, unordered_set<string> &dict) {
|    | 104|+    int ladderLength (string start, string end, unordered_set < string > &dict)
|    | 105|+    {
| 104| 106|         int rounds = 1;
| 105|    |-        queue<string> que;
| 106|    |-        que.emplace(start);
| 107|    |-        unordered_set<string> visited;
|    | 107|+          queue < string > que;
|    | 108|+          que.emplace (start);
|    | 109|+          unordered_set < string > visited;
| 108| 110| 
| 109| 111|         // BFS
| 110| 112|         while (que.size() > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
| 107| 107|         unordered_set<string> visited;
| 108| 108| 
| 109| 109|         // BFS
| 110|    |-        while (que.size() > 0) {
| 111|    |-            int qSize = que.size();
| 112|    |-            while (--qSize >= 0) {
| 113|    |-                string w = que.front();
| 114|    |-                que.pop();
|    | 110|+        while (que.size () > 0)
|    | 111|+          {
|    | 112|+              int qSize = que.size ();
|    | 113|+              while (--qSize >= 0)
|    | 114|+                {
|    | 115|+                    string w = que.front ();
|    | 116|+                      que.pop ();
| 115| 117| 
| 116|    |-                if (w == end) {
| 117|    |-                    return rounds;
|    | 118|+                    if (w == end)
|    | 119|+                      {
|    | 120|+                          return rounds;
|    | 121|+                      }
|    | 122|+
|    | 123|+                    for (int i = 0; i < w.length (); ++i)
|    | 124|+                      {
|    | 125|+                          char c = w[i];    // Keep the original character.
|    | 126|+                          for (int j = 'a'; j <= 'z'; ++j)
|    | 127|+                            {
|    | 128|+                                w[i] = j;   // Change one character.
|    | 129|+                                if (j != c && visited.count (w) == 0
|    | 130|+                                    && dict.count (w) == 1)
|    | 131|+                                  {
|    | 132|+                                      que.emplace (w);
|    | 133|+                                      visited.emplace (w);  // Marked as visited.
|    | 134|+                                  }
|    | 135|+                            }
|    | 136|+                          w[i] = c; // Rollback.
|    | 137|+                      }
| 118| 138|                 }
| 119|    |-
| 120|    |-                for (int i = 0; i < w.length(); ++i) {
| 121|    |-                    char c = w[i]; // Keep the original character.
| 122|    |-                    for (int j= 'a'; j <= 'z'; ++j) {
| 123|    |-                        w[i] = j; // Change one character.
| 124|    |-                        if (j != c && visited.count(w) == 0 && dict.count(w) == 1) {
| 125|    |-                            que.emplace(w);
| 126|    |-                            visited.emplace(w); // Marked as visited.
| 127|    |-                        }
| 128|    |-                    }
| 129|    |-                    w[i] = c; // Rollback.
| 130|    |-                }
| 131|    |-            }
| 132|    |-            ++rounds;
| 133|    |-        }
|    | 139|+              ++rounds;
|    | 140|+          }
| 134| 141| 
| 135| 142|         return 0;
| 136| 143|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
| 136| 136|     }
| 137| 137| };
| 138| 138| 
| 139|    |-class Solution2 {
| 140|    |-public:
|    | 139|+class Solution2
|    | 140|+{
|    | 141|+  public:
| 141| 142|     /**
| 142| 143|      * @param start, a string
| 143| 144|      * @param end, a string
| 144| 145|      * @param dict, a set of string
| 145| 146|      * @return an integer
| 146| 147|      */
| 147|    |-    int ladderLength(string start, string end, unordered_set<string> &dict) {
|    | 148|+    int ladderLength (string start, string end, unordered_set < string > &dict)
|    | 149|+    {
| 148| 150|         int rounds = 1;
| 149|    |-        queue<string> que;
| 150|    |-        que.emplace(start);
|    | 151|+          queue < string > que;
|    | 152|+          que.emplace (start);
| 151| 153| 
| 152| 154|         // BFS
| 153| 155|         while (que.size() > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/word-ladder.cpp
|    |++++| /app/C++/word-ladder.cpp
| 150| 150|         que.emplace(start);
| 151| 151| 
| 152| 152|         // BFS
| 153|    |-        while (que.size() > 0) {
| 154|    |-            int qSize = que.size();
| 155|    |-            while (--qSize >= 0) {
| 156|    |-                string w = que.front();
| 157|    |-                que.pop();
|    | 153|+        while (que.size () > 0)
|    | 154|+          {
|    | 155|+              int qSize = que.size ();
|    | 156|+              while (--qSize >= 0)
|    | 157|+                {
|    | 158|+                    string w = que.front ();
|    | 159|+                      que.pop ();
| 158| 160| 
| 159|    |-                if (w == end) {
| 160|    |-                    return rounds;
|    | 161|+                    if (w == end)
|    | 162|+                      {
|    | 163|+                          return rounds;
|    | 164|+                      }
|    | 165|+
|    | 166|+                    for (int i = 0; i < w.length (); ++i)
|    | 167|+                      {
|    | 168|+                          char c = w[i];    // Keep the original character.
|    | 169|+                          for (int j = 'a'; j <= 'z'; ++j)
|    | 170|+                            {
|    | 171|+                                w[i] = j;   // Change one character.
|    | 172|+                                if (j != c && dict.count (w) == 1)
|    | 173|+                                  {
|    | 174|+                                      que.emplace (w);
|    | 175|+                                      dict.erase (w);   // Marked as visited.
|    | 176|+                                  }
|    | 177|+                            }
|    | 178|+                          w[i] = c; // Rollback.
|    | 179|+                      }
| 161| 180|                 }
| 162|    |-
| 163|    |-                for (int i = 0; i < w.length(); ++i) {
| 164|    |-                    char c = w[i]; // Keep the original character.
| 165|    |-                    for (int j= 'a'; j <= 'z'; ++j) {
| 166|    |-                        w[i] = j; // Change one character.
| 167|    |-                        if (j != c && dict.count(w) == 1) {
| 168|    |-                            que.emplace(w);
| 169|    |-                            dict.erase(w); // Marked as visited.
| 170|    |-                        }
| 171|    |-                    }
| 172|    |-                    w[i] = c; // Rollback.
| 173|    |-                }
| 174|    |-            }
| 175|    |-            ++rounds;
| 176|    |-        }
|    | 181|+              ++rounds;
|    | 182|+          }
| 177| 183| 
| 178| 184|         return 0;
| 179| 185|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array-ii.cpp
|    |++++| /app/C++/merge-sorted-array-ii.cpp
|   3|   3| 
|   4|   4| // If size of A >>>> size of B, you can use binary search to insert the smaller array.
|   5|   5| // It only cost O(mlogn) comparisons instead of O(n), much better.
|   6|    |-class Solution {
|   7|    |-public:
|    |   6|+class Solution
|    |   7|+{
|    |   8|+  public:
|   8|   9|     /**
|   9|  10|      * @param A and B: sorted integer array A and B.
|  10|  11|      * @return: A new sorted integer array
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array-ii.cpp
|    |++++| /app/C++/merge-sorted-array-ii.cpp
|   9|   9|      * @param A and B: sorted integer array A and B.
|  10|  10|      * @return: A new sorted integer array
|  11|  11|      */
|  12|    |-    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
|  13|    |-        vector<int> C(A.size() + B.size());
|    |  12|+    vector < int >mergeSortedArray (vector < int >&A, vector < int >&B)
|    |  13|+    {
|    |  14|+        vector < int >C (A.size () + B.size ());
|  14|  15| 
|  15|  16|         int i = 0;
|  16|  17|         int j = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array-ii.cpp
|    |++++| /app/C++/merge-sorted-array-ii.cpp
|  17|  17| 
|  18|  18|         // Stop comparing while one of array ends.
|  19|  19|         // Smaller one has high possibility to end first.
|  20|    |-        while (i < A.size() && j < B.size()) {
|  21|    |-            if (A[i] >= B[j]) {
|  22|    |-                C[i + j] = B[j];
|  23|    |-                ++j;
|  24|    |-            } else {
|  25|    |-                C[i + j] = A[i];
|  26|    |-                ++i;
|  27|    |-            }
|  28|    |-        }
|    |  20|+        while (i < A.size () && j < B.size ())
|    |  21|+          {
|    |  22|+              if (A[i] >= B[j])
|    |  23|+                {
|    |  24|+                    C[i + j] = B[j];
|    |  25|+                    ++j;
|    |  26|+                }
|    |  27|+              else
|    |  28|+                {
|    |  29|+                    C[i + j] = A[i];
|    |  30|+                    ++i;
|    |  31|+                }
|    |  32|+          }
|  29|  33| 
|  30|  34|         // Copy the remaining elements to the new array.
|  31|  35|         if (i < A.size()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-sorted-array-ii.cpp
|    |++++| /app/C++/merge-sorted-array-ii.cpp
|  28|  28|         }
|  29|  29| 
|  30|  30|         // Copy the remaining elements to the new array.
|  31|    |-        if (i < A.size()) {
|  32|    |-            copy(A.cbegin() + i, A.cend(), C.begin() + i + j);
|  33|    |-        } else if (j < B.size()) {
|  34|    |-            copy(B.cbegin() + j, B.cend(), C.begin() + i + j);
|  35|    |-        }
|    |  31|+        if (i < A.size ())
|    |  32|+          {
|    |  33|+              copy (A.cbegin () + i, A.cend (), C.begin () + i + j);
|    |  34|+          }
|    |  35|+        else if (j < B.size ())
|    |  36|+          {
|    |  37|+              copy (B.cbegin () + j, B.cend (), C.begin () + i + j);
|    |  38|+          }
|  36|  39| 
|  37|  40|         return C;
|  38|  41|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-binary-tree-to-linked-list.cpp
|    |++++| /app/C++/flatten-binary-tree-to-linked-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: a TreeNode, the root of the binary tree
|  20|  21|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-binary-tree-to-linked-list.cpp
|    |++++| /app/C++/flatten-binary-tree-to-linked-list.cpp
|  19|  19|      * @param root: a TreeNode, the root of the binary tree
|  20|  20|      * @return: nothing
|  21|  21|      */
|  22|    |-    void flatten(TreeNode *root) {
|    |  22|+    void flatten (TreeNode * root)
|    |  23|+    {
|  23|  24|         TreeNode *list_head = nullptr;
|  24|    |-        flattenHelper(root, &list_head);
|    |  25|+          flattenHelper (root, &list_head);
|  25|  26|     }
|  26|  27| 
|  27|  28|     TreeNode *flattenHelper(TreeNode *root, TreeNode **list_head) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-binary-tree-to-linked-list.cpp
|    |++++| /app/C++/flatten-binary-tree-to-linked-list.cpp
|  24|  24|         flattenHelper(root, &list_head);
|  25|  25|     }
|  26|  26| 
|  27|    |-    TreeNode *flattenHelper(TreeNode *root, TreeNode **list_head) {
|  28|    |-        if (root) {
|  29|    |-            flattenHelper(root->right, list_head);
|  30|    |-            flattenHelper(root->left, list_head);
|  31|    |-            root->right = *list_head;
|  32|    |-            root->left = nullptr;
|  33|    |-            *list_head = root;
|  34|    |-        }
|    |  27|+    TreeNode *flattenHelper (TreeNode * root, TreeNode ** list_head)
|    |  28|+    {
|    |  29|+        if (root)
|    |  30|+          {
|    |  31|+              flattenHelper (root->right, list_head);
|    |  32|+              flattenHelper (root->left, list_head);
|    |  33|+              root->right = *list_head;
|    |  34|+              root->left = nullptr;
|    |  35|+              *list_head = root;
|    |  36|+          }
|  35|  37|     }
|  36|  38| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/move-zeroes.cpp
|    |++++| /app/C++/move-zeroes.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums an integer array
|   8|   9|      * @return nothing, do this in-place
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/move-zeroes.cpp
|    |++++| /app/C++/move-zeroes.cpp
|   7|   7|      * @param nums an integer array
|   8|   8|      * @return nothing, do this in-place
|   9|   9|      */
|  10|    |-    void moveZeroes(vector<int>& nums) {
|    |  10|+    void moveZeroes (vector < int >&nums)
|    |  11|+    {
|  11|  12|         int pos = 0;
|  12|    |-        for (auto& num : nums) {
|  13|    |-            if (num) {
|  14|    |-                swap(nums[pos++], num);
|  15|    |-            }
|  16|    |-        }
|    |  13|+        for (auto & num:nums)
|    |  14|+          {
|    |  15|+              if (num)
|    |  16|+                {
|    |  17|+                    swap (nums[pos++], num);
|    |  18|+                }
|    |  19|+          }
|  17|  20|     }
|  18|  21| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|   9|   9|  *     DirectedGraphNode(int x) : label(x) {};
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param nodes a array of directed graph node
|  16|  17|      * @return a connected set of a directed graph
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  15|  15|      * @param nodes a array of directed graph node
|  16|  16|      * @return a connected set of a directed graph
|  17|  17|      */
|  18|    |-    vector<vector<int>> connectedSet2(vector<DirectedGraphNode*>& nodes) {
|    |  18|+    vector < vector < int >>connectedSet2 (vector <
|    |  19|+                                           DirectedGraphNode * >&nodes)
|    |  20|+    {
|  19|  21|         // Sort nodes by its index. Time: O(nlogn)
|  20|    |-        sort(nodes.begin(), nodes.end(),
|  21|    |-             [](const DirectedGraphNode* a, const DirectedGraphNode* b) {
|  22|    |-                return a->label < b->label;
|  23|    |-             });
|    |  22|+        sort (nodes.begin (), nodes.end (),
|    |  23|+              [](const DirectedGraphNode * a, const DirectedGraphNode * b)
|    |  24|+              {
|    |  25|+              return a->label < b->label;}
|    |  26|+        );
|  24|  27|         // The disjoint-set.
|  25|    |-        unordered_map<int, int> set;
|    |  28|+        unordered_map < int, int >set;
|  26|  29|         // Initialize the disjoint-set.
|  27|    |-        for (const auto& node : nodes) {
|  28|    |-            set[node->label] = node->label;
|  29|    |-        }
|    |  30|+      for (const auto & node:nodes)
|    |  31|+          {
|    |  32|+              set[node->label] = node->label;
|    |  33|+          }
|  30|  34| 
|  31|  35|         // Union-Find each edge.
|  32|  36|         for (const auto& node : nodes) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Union-Find each edge.
|  32|    |-        for (const auto& node : nodes) {
|  33|    |-            for (const auto& neighbor : node->neighbors) {
|  34|    |-                union_set(&set, node->label, neighbor->label);
|  35|    |-            }
|  36|    |-        }
|    |  32|+      for (const auto & node:nodes)
|    |  33|+          {
|    |  34|+            for (const auto & neighbor:node->neighbors)
|    |  35|+                {
|    |  36|+                    union_set (&set, node->label, neighbor->label);
|    |  37|+                }
|    |  38|+          }
|  37|  39| 
|  38|  40|         // Group each component.
|  39|  41|         unordered_map<int, vector<int>> group;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  36|  36|         }
|  37|  37| 
|  38|  38|         // Group each component.
|  39|    |-        unordered_map<int, vector<int>> group;
|  40|    |-        for (const auto& node : nodes) {
|  41|    |-            group[find_set(node->label, &set)].emplace_back(node->label);
|  42|    |-        }
|    |  39|+        unordered_map < int, vector < int >>group;
|    |  40|+      for (const auto & node:nodes)
|    |  41|+          {
|    |  42|+              group[find_set (node->label, &set)].emplace_back (node->label);
|    |  43|+          }
|  43|  44| 
|  44|  45|         // Sort elements in each group.
|  45|  46|         vector<vector<int>> result;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  42|  42|         }
|  43|  43| 
|  44|  44|         // Sort elements in each group.
|  45|    |-        vector<vector<int>> result;
|  46|    |-        for (auto& kvp : group) {
|  47|    |-            result.emplace_back(move(kvp.second));
|  48|    |-        }
|    |  45|+        vector < vector < int >>result;
|    |  46|+      for (auto & kvp:group)
|    |  47|+          {
|    |  48|+              result.emplace_back (move (kvp.second));
|    |  49|+          }
|  49|  50|         return result;
|  50|  51|     }
|  51|  52| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  49|  49|         return result;
|  50|  50|     }
|  51|  51| 
|  52|    |-    int find_set(int x, unordered_map<int, int> *set) {
|  53|    |-       if ((*set)[x] != x) {
|  54|    |-           (*set)[x] = find_set((*set)[x], set);  // path compression.
|  55|    |-       }
|  56|    |-       return (*set)[x];
|    |  52|+    int find_set (int x, unordered_map < int, int >*set)
|    |  53|+    {
|    |  54|+        if ((*set)[x] != x)
|    |  55|+          {
|    |  56|+              (*set)[x] = find_set ((*set)[x], set);    // path compression.
|    |  57|+          }
|    |  58|+        return (*set)[x];
|  57|  59|     }
|  58|  60| 
|  59|  61|     void union_set(unordered_map<int, int> *set, int x, int y) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|    |++++| /app/C++/find-the-weak-connected-component-in-the-directed-graph.cpp
|  56|  56|        return (*set)[x];
|  57|  57|     }
|  58|  58| 
|  59|    |-    void union_set(unordered_map<int, int> *set, int x, int y) {
|  60|    |-        int x_root = find_set(x, set), y_root = find_set(y, set);
|  61|    |-        (*set)[min(x_root, y_root)] = max(x_root, y_root);
|    |  59|+    void union_set (unordered_map < int, int >*set, int x, int y)
|    |  60|+    {
|    |  61|+        int x_root = find_set (x, set), y_root = find_set (y, set);
|    |  62|+        (*set)[min (x_root, y_root)] = max (x_root, y_root);
|  62|  63|     }
|  63|  64| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/two-lists-sum.cpp
|    |++++| /app/C++/two-lists-sum.cpp
|   9|   9|  *     ListNode(int x) : val(x), next(NULL) {}
|  10|  10|  * };
|  11|  11|  */
|  12|    |-class Solution {
|  13|    |-public:
|    |  12|+class Solution
|    |  13|+{
|    |  14|+  public:
|  14|  15|     /**
|  15|  16|      * @param l1: the first list
|  16|  17|      * @param l2: the second list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/two-lists-sum.cpp
|    |++++| /app/C++/two-lists-sum.cpp
|  16|  16|      * @param l2: the second list
|  17|  17|      * @return: the sum list of l1 and l2
|  18|  18|      */
|  19|    |-    ListNode *addLists(ListNode *l1, ListNode *l2) {
|  20|    |-        ListNode dummy{0};
|    |  19|+    ListNode * addLists (ListNode * l1, ListNode * l2)
|    |  20|+    {
|    |  21|+        ListNode dummy
|    |  22|+        {
|    |  23|+        0};
|  21|  24|         auto curr = &dummy;
|  22|  25| 
|  23|  26|         auto carry = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/two-lists-sum.cpp
|    |++++| /app/C++/two-lists-sum.cpp
|  21|  21|         auto curr = &dummy;
|  22|  22| 
|  23|  23|         auto carry = 0;
|  24|    |-        while (l1 || l2 || carry) {
|  25|    |-            auto a = l1? l1->val : 0, b = l2? l2->val : 0;
|  26|    |-            auto val = carry + a + b;
|  27|    |-            curr->next = new ListNode(val % 10);
|  28|    |-            carry = val / 10;
|  29|    |-            l1 = l1 ? l1->next : nullptr;
|  30|    |-            l2 = l2 ? l2->next : nullptr;
|  31|    |-            curr = curr->next;
|  32|    |-        }
|    |  24|+        while (l1 || l2 || carry)
|    |  25|+          {
|    |  26|+              auto a = l1 ? l1->val : 0, b = l2 ? l2->val : 0;
|    |  27|+              auto val = carry + a + b;
|    |  28|+                curr->next = new ListNode (val % 10);
|    |  29|+                carry = val / 10;
|    |  30|+                l1 = l1 ? l1->next : nullptr;
|    |  31|+                l2 = l2 ? l2->next : nullptr;
|    |  32|+                curr = curr->next;
|    |  33|+          }
|  33|  34| 
|  34|  35|         return dummy.next;
|  35|  36|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-characters.cpp
|    |++++| /app/C++/unique-characters.cpp
|   3|   3| 
|   4|   4| #include <bitset>
|   5|   5| 
|   6|    |-class Solution {
|   7|    |-public:
|    |   6|+class Solution
|    |   7|+{
|    |   8|+  public:
|   8|   9|     /**
|   9|  10|      * @param str: a string
|  10|  11|      * @return: a boolean
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-characters.cpp
|    |++++| /app/C++/unique-characters.cpp
|   9|   9|      * @param str: a string
|  10|  10|      * @return: a boolean
|  11|  11|      */
|  12|    |-    bool isUnique(string &str) {
|  13|    |-        bitset<256> lookup;
|  14|    |-        for (const auto& c : str) {
|  15|    |-            if (lookup[c]) {
|  16|    |-                return false;
|  17|    |-            }
|  18|    |-            lookup.flip(c);
|  19|    |-        }
|    |  12|+    bool isUnique (string & str)
|    |  13|+    {
|    |  14|+        bitset < 256 > lookup;
|    |  15|+        for (const auto & c:str)
|    |  16|+          {
|    |  17|+              if (lookup[c])
|    |  18|+                {
|    |  19|+                    return false;
|    |  20|+                }
|    |  21|+              lookup.flip (c);
|    |  22|+          }
|  20|  23| 
|  21|  24|         return true;
|  22|  25|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/evaluate-reverse-polish-notation.cpp
|    |++++| /app/C++/evaluate-reverse-polish-notation.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param tokens The Reverse Polish Notation
|   8|   9|      * @return the value
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/evaluate-reverse-polish-notation.cpp
|    |++++| /app/C++/evaluate-reverse-polish-notation.cpp
|   7|   7|      * @param tokens The Reverse Polish Notation
|   8|   8|      * @return the value
|   9|   9|      */
|  10|    |-    int evalRPN(vector<string>& tokens) {
|  11|    |-        if (tokens.empty()) {
|  12|    |-            return 0;
|  13|    |-        }
|  14|    |-        stack<string> s;
|  15|    |-        for (const auto& tok : tokens) {
|  16|    |-            if (!is_operator(tok)) {
|  17|    |-                s.emplace(tok);
|  18|    |-            } else {
|  19|    |-                int y = stoi(s.top());
|  20|    |-                s.pop();
|  21|    |-                int x = stoi(s.top());
|  22|    |-                s.pop();
|  23|    |-                if (tok[0] == '+') {
|  24|    |-                    x += y;
|  25|    |-                } else if (tok[0] == '-') {
|  26|    |-                    x -= y;
|  27|    |-                } else if (tok[0] == '*') {
|  28|    |-                    x *= y;
|  29|    |-                } else {
|  30|    |-                    x /= y;
|    |  10|+    int evalRPN (vector < string > &tokens)
|    |  11|+    {
|    |  12|+        if (tokens.empty ())
|    |  13|+          {
|    |  14|+              return 0;
|    |  15|+          }
|    |  16|+        stack < string > s;
|    |  17|+      for (const auto & tok:tokens)
|    |  18|+          {
|    |  19|+              if (!is_operator (tok))
|    |  20|+                {
|    |  21|+                    s.emplace (tok);
|  31|  22|                 }
|  32|    |-                s.emplace(to_string(x));
|  33|    |-            }
|  34|    |-        }
|  35|    |-        return stoi(s.top());
|    |  23|+              else
|    |  24|+                {
|    |  25|+                    int y = stoi (s.top ());
|    |  26|+                    s.pop ();
|    |  27|+                    int x = stoi (s.top ());
|    |  28|+                    s.pop ();
|    |  29|+                    if (tok[0] == '+')
|    |  30|+                      {
|    |  31|+                          x += y;
|    |  32|+                      }
|    |  33|+                    else if (tok[0] == '-')
|    |  34|+                      {
|    |  35|+                          x -= y;
|    |  36|+                      }
|    |  37|+                    else if (tok[0] == '*')
|    |  38|+                      {
|    |  39|+                          x *= y;
|    |  40|+                      }
|    |  41|+                    else
|    |  42|+                      {
|    |  43|+                          x /= y;
|    |  44|+                      }
|    |  45|+                    s.emplace (to_string (x));
|    |  46|+                }
|    |  47|+          }
|    |  48|+        return stoi (s.top ());
|  36|  49|     }
|  37|  50| 
|  38|  51|     bool is_operator(const string &op) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/evaluate-reverse-polish-notation.cpp
|    |++++| /app/C++/evaluate-reverse-polish-notation.cpp
|  35|  35|         return stoi(s.top());
|  36|  36|     }
|  37|  37| 
|  38|    |-    bool is_operator(const string &op) {
|  39|    |-        return op.length() == 1 && string("+-*/").find(op) != string::npos;
|    |  38|+    bool is_operator (const string & op)
|    |  39|+    {
|    |  40|+        return op.length () == 1 && string ("+-*/").find (op) != string::npos;
|  40|  41|     }
|  41|  42| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list-ii.cpp
|    |++++| /app/C++/reverse-linked-list-ii.cpp
|  14|  14|  *     }
|  15|  15|  * }
|  16|  16|  */
|  17|    |-class Solution {
|  18|    |-public:
|    |  17|+class Solution
|    |  18|+{
|    |  19|+  public:
|  19|  20|     /**
|  20|  21|      * @param head: The head of linked list.
|  21|  22|      * @param m: The start position need to reverse.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list-ii.cpp
|    |++++| /app/C++/reverse-linked-list-ii.cpp
|  22|  22|      * @param n: The end position need to reverse.
|  23|  23|      * @return: The new head of partial reversed linked list.
|  24|  24|      */
|  25|    |-    ListNode *reverseBetween(ListNode *head, int m, int n) {
|  26|    |-        ListNode dummy{0};
|  27|    |-        dummy.next = head;
|    |  25|+    ListNode * reverseBetween (ListNode * head, int m, int n)
|    |  26|+    {
|    |  27|+        ListNode dummy
|    |  28|+        {
|    |  29|+        0};
|    |  30|+          dummy.next = head;
|  28|  31| 
|  29|  32|         auto prev = &dummy;
|  30|  33|         for (int i = 0; i < m - 1; ++i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list-ii.cpp
|    |++++| /app/C++/reverse-linked-list-ii.cpp
|  27|  27|         dummy.next = head;
|  28|  28| 
|  29|  29|         auto prev = &dummy;
|  30|    |-        for (int i = 0; i < m - 1; ++i) {
|  31|    |-            prev = prev->next;
|  32|    |-        }
|    |  30|+        for (int i = 0; i < m - 1; ++i)
|    |  31|+          {
|    |  32|+              prev = prev->next;
|    |  33|+          }
|  33|  34| 
|  34|  35|         auto head2 = prev;
|  35|  36|         prev = prev->next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/reverse-linked-list-ii.cpp
|    |++++| /app/C++/reverse-linked-list-ii.cpp
|  34|  34|         auto head2 = prev;
|  35|  35|         prev = prev->next;
|  36|  36|         auto curr = prev->next;
|  37|    |-        for (int i = m; i < n; ++i) {
|  38|    |-            prev->next = curr->next;  // Remove curr from the list.
|  39|    |-            curr->next = head2->next; // Add curr to the head.
|  40|    |-            head2->next = curr;       // Add curr to the head.
|  41|    |-            curr = prev->next;        // Get next curr.
|  42|    |-        }
|    |  37|+        for (int i = m; i < n; ++i)
|    |  38|+          {
|    |  39|+              prev->next = curr->next;  // Remove curr from the list.
|    |  40|+              curr->next = head2->next; // Add curr to the head.
|    |  41|+              head2->next = curr;   // Add curr to the head.
|    |  42|+              curr = prev->next;    // Get next curr.
|    |  43|+          }
|  43|  44| 
|  44|  45|         return dummy.next;
|  45|  46|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: The majority number occurs more than 1/3.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|   7|   7|      * @param nums: A list of integers
|   8|   8|      * @return: The majority number occurs more than 1/3.
|   9|   9|      */
|  10|    |-    int majorityNumber(vector<int> nums) {
|    |  10|+    int majorityNumber (vector < int >nums)
|    |  11|+    {
|  11|  12|         const int k = 3;
|  12|    |-        unordered_map<int, int> hash;
|    |  13|+          unordered_map < int, int >hash;
|  13|  14| 
|  14|    |-        for (const auto& i : nums) {
|  15|    |-            ++hash[i];
|  16|    |-            // Detecting k items in hash, at least one of them must have exactly
|  17|    |-            // one in it. We will discard those k items by one for each.
|  18|    |-            // This action keeps the same mojority numbers in the remaining numbers.
|  19|    |-            // Because if x / n  > 1 / k is true, then (x - 1) / (n - k) > 1 / k is also true.
|  20|    |-            if (hash.size() == k) {
|  21|    |-                auto it = hash.begin();
|  22|    |-                while (it != hash.end()) {
|  23|    |-                    if (--(it->second) == 0) {
|  24|    |-                        hash.erase(it++);
|  25|    |-                    } else {
|  26|    |-                        ++it;
|  27|    |-                    }
|    |  15|+        for (const auto & i:nums)
|    |  16|+          {
|    |  17|+              ++hash[i];
|    |  18|+              // Detecting k items in hash, at least one of them must have exactly
|    |  19|+              // one in it. We will discard those k items by one for each.
|    |  20|+              // This action keeps the same mojority numbers in the remaining numbers.
|    |  21|+              // Because if x / n  > 1 / k is true, then (x - 1) / (n - k) > 1 / k is also true.
|    |  22|+              if (hash.size () == k)
|    |  23|+                {
|    |  24|+                    auto it = hash.begin ();
|    |  25|+                    while (it != hash.end ())
|    |  26|+                      {
|    |  27|+                          if (--(it->second) == 0)
|    |  28|+                            {
|    |  29|+                                hash.erase (it++);
|    |  30|+                            }
|    |  31|+                          else
|    |  32|+                            {
|    |  33|+                                ++it;
|    |  34|+                            }
|    |  35|+                      }
|  28|  36|                 }
|  29|    |-            }
|  30|    |-        }
|    |  37|+          }
|  31|  38| 
|  32|  39|         // Resets hash for the following counting.
|  33|  40|         for (auto& it : hash) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|  30|  30|         }
|  31|  31| 
|  32|  32|         // Resets hash for the following counting.
|  33|    |-        for (auto& it : hash) {
|  34|    |-            it.second = 0;
|  35|    |-        }
|    |  33|+      for (auto & it:hash)
|    |  34|+          {
|    |  35|+              it.second = 0;
|    |  36|+          }
|  36|  37| 
|  37|  38|         // Counts the occurrence of each candidate word.
|  38|  39|         for (const auto& i : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|  35|  35|         }
|  36|  36| 
|  37|  37|         // Counts the occurrence of each candidate word.
|  38|    |-        for (const auto& i : nums) {
|  39|    |-            auto it = hash.find(i);
|  40|    |-            if (it != hash.end()) {
|  41|    |-                ++it->second;
|  42|    |-            }
|  43|    |-        }
|    |  38|+      for (const auto & i:nums)
|    |  39|+          {
|    |  40|+              auto it = hash.find (i);
|    |  41|+              if (it != hash.end ())
|    |  42|+                {
|    |  43|+                    ++it->second;
|    |  44|+                }
|    |  45|+          }
|  44|  46| 
|  45|  47|         // Selects the integer which occurs > n / k times.
|  46|  48|         vector<int> ret;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|  43|  43|         }
|  44|  44| 
|  45|  45|         // Selects the integer which occurs > n / k times.
|  46|    |-        vector<int> ret;
|  47|    |-        for (const pair<int, int>& it : hash) {
|  48|    |-            if (it.second > static_cast<double>(nums.size()) / k) {
|  49|    |-                ret.emplace_back(it.first);
|  50|    |-            }
|  51|    |-        }
|    |  46|+        vector < int >ret;
|    |  47|+      for (const pair < int, int >&it:hash)
|    |  48|+          {
|    |  49|+              if (it.second > static_cast < double >(nums.size ()) / k)
|    |  50|+                {
|    |  51|+                    ret.emplace_back (it.first);
|    |  52|+                }
|    |  53|+          }
|  52|  54| 
|  53|  55|         return ret[0];
|  54|  56|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-ii.cpp
|    |++++| /app/C++/majority-number-ii.cpp
|  53|  53|         return ret[0];
|  54|  54|     }
|  55|  55| };
|  56|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-path-sum.cpp
|    |++++| /app/C++/binary-tree-path-sum.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root the root of binary tree
|  20|  21|      * @param target an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/binary-tree-path-sum.cpp
|    |++++| /app/C++/binary-tree-path-sum.cpp
|  20|  20|      * @param target an integer
|  21|  21|      * @return all valid paths
|  22|  22|      */
|  23|    |-    vector<vector<int>> binaryTreePathSum(TreeNode *root, int target) {
|  24|    |-        vector<vector<int>> res;
|  25|    |-        vector<int> cur;
|  26|    |-        binaryTreePathHelper(root, target, &cur, &res);
|  27|    |-        return res;
|    |  23|+    vector < vector < int >>binaryTreePathSum (TreeNode * root, int target)
|    |  24|+    {
|    |  25|+        vector < vector < int >>res;
|    |  26|+          vector < int >cur;
|    |  27|+          binaryTreePathHelper (root, target, &cur, &res);
|    |  28|+          return res;
|  28|  29|     }
|  29|    |-    
|  30|    |-    void binaryTreePathHelper(const TreeNode *root, const int target,
|  31|    |-                              vector<int> *cur,  vector<vector<int>> *res) {
|  32|    |-        if (!root) {
|  33|    |-            return;
|  34|    |-        }
|  35|  30| 
|  36|    |-        cur->emplace_back(root->val);
|  37|    |-        if (!root->left && !root->right && root->val == target) {
|  38|    |-            res->emplace_back(*cur);
|  39|    |-        } else {
|  40|    |-            binaryTreePathHelper(root->left, target - root->val, cur, res);
|  41|    |-            binaryTreePathHelper(root->right, target - root->val, cur, res);
|  42|    |-        }
|  43|    |-        cur->pop_back();
|    |  31|+    void binaryTreePathHelper (const TreeNode * root, const int target,
|    |  32|+                               vector < int >*cur,
|    |  33|+                               vector < vector < int >>*res)
|    |  34|+    {
|    |  35|+        if (!root)
|    |  36|+          {
|    |  37|+              return;
|    |  38|+          }
|    |  39|+
|    |  40|+        cur->emplace_back (root->val);
|    |  41|+        if (!root->left && !root->right && root->val == target)
|    |  42|+          {
|    |  43|+              res->emplace_back (*cur);
|    |  44|+          }
|    |  45|+        else
|    |  46|+          {
|    |  47|+              binaryTreePathHelper (root->left, target - root->val, cur, res);
|    |  48|+              binaryTreePathHelper (root->right, target - root->val, cur, res);
|    |  49|+          }
|    |  50|+        cur->pop_back ();
|  44|  51|     }
|  45|  52| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wood-cut.cpp
|    |++++| /app/C++/wood-cut.cpp
|   1|   1| // Time:  O(nlogL)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      *@param L: Given n pieces of wood with length L[i]
|   8|   9|      *@param k: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wood-cut.cpp
|    |++++| /app/C++/wood-cut.cpp
|   8|   8|      *@param k: An integer
|   9|   9|      *return: The maximum length of the small pieces.
|  10|  10|      */
|  11|    |-    int woodCut(vector<int> L, int k) {
|  12|    |-        const int n = L.size();
|  13|    |-        if (n == 0) {
|  14|    |-            return 0;
|  15|    |-        }
|    |  11|+    int woodCut (vector < int >L, int k)
|    |  12|+    {
|    |  13|+        const int n = L.size ();
|    |  14|+        if (n == 0)
|    |  15|+          {
|    |  16|+              return 0;
|    |  17|+          }
|  16|  18| 
|  17|    |-        int left = 1, right = *max_element(L.cbegin(), L.cend());
|  18|    |-        while (left <= right) {
|  19|    |-            const auto mid = left + (right - left) / 2;
|    |  19|+        int left = 1, right = *max_element (L.cbegin (), L.cend ());
|    |  20|+        while (left <= right)
|    |  21|+          {
|    |  22|+              const auto mid = left + (right - left) / 2;
|  20|  23| 
|  21|    |-            // Find the smallest x,  s.t. pieceCount(x) < k <= pieceCound(x - 1)
|  22|    |-            if (pieceCount(L, mid) < k) {
|  23|    |-                right = mid - 1;
|  24|    |-            } else {
|  25|    |-                left = mid + 1;
|  26|    |-            }
|  27|    |-        }
|    |  24|+              // Find the smallest x,  s.t. pieceCount(x) < k <= pieceCound(x - 1)
|    |  25|+              if (pieceCount (L, mid) < k)
|    |  26|+                {
|    |  27|+                    right = mid - 1;
|    |  28|+                }
|    |  29|+              else
|    |  30|+                {
|    |  31|+                    left = mid + 1;
|    |  32|+                }
|    |  33|+          }
|  28|  34| 
|  29|  35|         // The max length is x - 1
|  30|  36|         return left - 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/wood-cut.cpp
|    |++++| /app/C++/wood-cut.cpp
|  30|  30|         return left - 1;
|  31|  31|     }
|  32|  32| 
|  33|    |-private:
|  34|    |-    int pieceCount(vector<int>& L, int x) {
|    |  33|+  private:
|    |  34|+    int pieceCount (vector < int >&L, int x)
|    |  35|+    {
|  35|  36|         int cnt = 0;
|  36|    |-        for (const auto& len : L) {
|  37|    |-            cnt += len / x;
|  38|    |-        }
|    |  37|+      for (const auto & len:L)
|    |  38|+          {
|    |  39|+              cnt += len / x;
|    |  40|+          }
|  39|  41|         return cnt;
|  40|  42|     }
|  41|  43| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fast-power.cpp
|    |++++| /app/C++/fast-power.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Iterative solution.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /*
|   8|   9|      * @param a, b, n: 32bit integers
|   9|  10|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fast-power.cpp
|    |++++| /app/C++/fast-power.cpp
|   8|   8|      * @param a, b, n: 32bit integers
|   9|   9|      * @return: An integer
|  10|  10|      */
|  11|    |-    int fastPower(int a, int b, int n) {
|    |  11|+    int fastPower (int a, int b, int n)
|    |  12|+    {
|  12|  13|         long long result = 1;
|  13|  14|         long long x = a % b;
|  14|  15|         while (n > 0) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fast-power.cpp
|    |++++| /app/C++/fast-power.cpp
|  11|  11|     int fastPower(int a, int b, int n) {
|  12|  12|         long long result = 1;
|  13|  13|         long long x = a % b;
|  14|    |-        while (n > 0) {
|  15|    |-            if (n & 1) {
|  16|    |-                result = result * x % b;
|  17|    |-            }
|  18|    |-            n >>= 1;
|  19|    |-            x = x * x % b;
|  20|    |-        }
|    |  14|+        while (n > 0)
|    |  15|+          {
|    |  16|+              if (n & 1)
|    |  17|+                {
|    |  18|+                    result = result * x % b;
|    |  19|+                }
|    |  20|+              n >>= 1;
|    |  21|+              x = x * x % b;
|    |  22|+          }
|  21|  23|         return result % b;
|  22|  24|     }
|  23|  25| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fast-power.cpp
|    |++++| /app/C++/fast-power.cpp
|  25|  25| // Time:  O(logn)
|  26|  26| // Space: O(logn)
|  27|  27| // Recursive solution.
|  28|    |-class Solution2 {
|  29|    |-public:
|    |  28|+class Solution2
|    |  29|+{
|    |  30|+  public:
|  30|  31|     /*
|  31|  32|      * @param a, b, n: 32bit integers
|  32|  33|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/fast-power.cpp
|    |++++| /app/C++/fast-power.cpp
|  31|  31|      * @param a, b, n: 32bit integers
|  32|  32|      * @return: An integer
|  33|  33|      */
|  34|    |-    int fastPower(int a, int b, int n) {
|  35|    |-        if (n == 0) {
|  36|    |-            return 1 % b;
|  37|    |-        }
|  38|    |-        if (n == 1) {
|  39|    |-            return a % b;
|  40|    |-        }
|  41|    |-        long long tmp = fastPower(a, b, n / 2);
|  42|    |-        if (n % 2 == 0) {
|  43|    |-            return (tmp * tmp) % b;
|  44|    |-        } else {
|  45|    |-            return ((tmp * tmp) % b * a) % b;
|  46|    |-        }
|    |  34|+    int fastPower (int a, int b, int n)
|    |  35|+    {
|    |  36|+        if (n == 0)
|    |  37|+          {
|    |  38|+              return 1 % b;
|    |  39|+          }
|    |  40|+        if (n == 1)
|    |  41|+          {
|    |  42|+              return a % b;
|    |  43|+          }
|    |  44|+        long long tmp = fastPower (a, b, n / 2);
|    |  45|+        if (n % 2 == 0)
|    |  46|+          {
|    |  47|+              return (tmp * tmp) % b;
|    |  48|+          }
|    |  49|+        else
|    |  50|+          {
|    |  51|+              return ((tmp * tmp) % b * a) % b;
|    |  52|+          }
|  47|  53|     }
|  48|  54| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix-ii.cpp
|    |++++| /app/C++/search-a-2d-matrix-ii.cpp
|   1|   1| // Time:  O(m + n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param matrix: A list of lists of integers
|   8|   9|      * @param target: An integer you want to search in matrix
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix-ii.cpp
|    |++++| /app/C++/search-a-2d-matrix-ii.cpp
|   8|   8|      * @param target: An integer you want to search in matrix
|   9|   9|      * @return: An integer indicate the total occurrence of target in the given matrix
|  10|  10|      */
|  11|    |-    int searchMatrix(vector<vector<int>> &matrix, int target) {
|  12|    |-        const int m = matrix.size();
|  13|    |-        if (m == 0) {
|  14|    |-            return 0;
|  15|    |-        }
|  16|    |-        const int n = matrix[0].size();
|  17|    |-        if  (n == 0) {
|  18|    |-            return 0;
|  19|    |-        }
|    |  11|+    int searchMatrix (vector < vector < int >>&matrix, int target)
|    |  12|+    {
|    |  13|+        const int m = matrix.size ();
|    |  14|+        if (m == 0)
|    |  15|+          {
|    |  16|+              return 0;
|    |  17|+          }
|    |  18|+        const int n = matrix[0].size ();
|    |  19|+        if (n == 0)
|    |  20|+          {
|    |  21|+              return 0;
|    |  22|+          }
|  20|  23|         int count = 0;
|  21|  24| 
|  22|  25|         int i = 0, j = n - 1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/search-a-2d-matrix-ii.cpp
|    |++++| /app/C++/search-a-2d-matrix-ii.cpp
|  20|  20|         int count = 0;
|  21|  21| 
|  22|  22|         int i = 0, j = n - 1;
|  23|    |-        while (i < m && j >= 0) {
|  24|    |-            if (matrix[i][j] == target) {
|  25|    |-                ++count;
|  26|    |-                ++i;
|  27|    |-                --j;
|  28|    |-            } else if (matrix[i][j] > target) {
|  29|    |-                --j;
|  30|    |-            } else {
|  31|    |-                ++i;
|  32|    |-            }
|  33|    |-        }
|    |  23|+        while (i < m && j >= 0)
|    |  24|+          {
|    |  25|+              if (matrix[i][j] == target)
|    |  26|+                {
|    |  27|+                    ++count;
|    |  28|+                    ++i;
|    |  29|+                    --j;
|    |  30|+                }
|    |  31|+              else if (matrix[i][j] > target)
|    |  32|+                {
|    |  33|+                    --j;
|    |  34|+                }
|    |  35|+              else
|    |  36|+                {
|    |  37|+                    ++i;
|    |  38|+                }
|    |  39|+          }
|  34|  40| 
|  35|  41|         return count;
|  36|  42|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths-ii.cpp
|    |++++| /app/C++/unique-paths-ii.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param obstacleGrid: A list of lists of integers
|   8|   9|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-paths-ii.cpp
|    |++++| /app/C++/unique-paths-ii.cpp
|   7|   7|      * @param obstacleGrid: A list of lists of integers
|   8|   8|      * @return: An integer
|   9|   9|      */
|  10|    |-    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid) {
|  11|    |-        const int m = obstacleGrid.size();
|  12|    |-        const int n = obstacleGrid[0].size();
|    |  10|+    int uniquePathsWithObstacles (vector < vector < int >>&obstacleGrid)
|    |  11|+    {
|    |  12|+        const int m = obstacleGrid.size ();
|    |  13|+        const int n = obstacleGrid[0].size ();
|  13|  14| 
|  14|    |-        vector<vector<int>> path(2, vector<int>(n, 0));
|    |  15|+          vector < vector < int >>path (2, vector < int >(n, 0));
|  15|  16| 
|  16|    |-        path[0][0] = obstacleGrid[0][0] == 0? 1 : 0;
|  17|    |-        for (int j = 1; j < n; ++j) {
|  18|    |-            path[0][j] = obstacleGrid[0][j] == 0? path[0][j - 1] : 0;
|  19|    |-        }
|    |  17|+          path[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
|    |  18|+        for (int j = 1; j < n; ++j)
|    |  19|+          {
|    |  20|+              path[0][j] = obstacleGrid[0][j] == 0 ? path[0][j - 1] : 0;
|    |  21|+          }
|  20|  22| 
|  21|    |-        for (int i = 1; i < m; ++i) {
|  22|    |-            path[i % 2][0] = obstacleGrid[i][0] == 0? path[(i - 1) % 2][0] : 0;
|  23|    |-            for (int j = 1; j < n; ++j) {
|  24|    |-                path[i % 2][j] = obstacleGrid[i][j] == 0?
|  25|    |-                path[(i - 1) % 2][j] + path[i % 2][j - 1] : 0;
|  26|    |-            }
|  27|    |-        }
|    |  23|+        for (int i = 1; i < m; ++i)
|    |  24|+          {
|    |  25|+              path[i % 2][0] =
|    |  26|+                  obstacleGrid[i][0] == 0 ? path[(i - 1) % 2][0] : 0;
|    |  27|+              for (int j = 1; j < n; ++j)
|    |  28|+                {
|    |  29|+                    path[i % 2][j] = obstacleGrid[i][j] == 0 ?
|    |  30|+                        path[(i - 1) % 2][j] + path[i % 2][j - 1] : 0;
|    |  31|+                }
|    |  32|+          }
|  28|  33| 
|  29|  34|         return path[(m - 1) % 2][n - 1];
|  30|  35|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-closest.cpp
|    |++++| /app/C++/subarray-sum-closest.cpp
|   1|   1| // Time:  O(nlogn)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: A list of integers includes the index of the first number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-closest.cpp
|    |++++| /app/C++/subarray-sum-closest.cpp
|   8|   8|      * @return: A list of integers includes the index of the first number
|   9|   9|      *          and the index of the last number
|  10|  10|      */
|  11|    |-    vector<int> subarraySumClosest(vector<int> nums) {
|  12|    |-        const int n = nums.size();
|    |  11|+    vector < int >subarraySumClosest (vector < int >nums)
|    |  12|+    {
|    |  13|+        const int n = nums.size ();
|  13|  14| 
|  14|    |-        if (n == 1) {
|  15|    |-            return {0, 0};
|  16|    |-        }
|    |  15|+        if (n == 1)
|    |  16|+          {
|    |  17|+              return
|    |  18|+              {
|    |  19|+              0, 0};
|    |  20|+          }
|  17|  21| 
|  18|  22|         // sum_from_start[i] denotes sum for 0 ~ i - 1.
|  19|  23|         vector<pair<int,int>> sum_from_start(n + 1, {0, 0});
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-closest.cpp
|    |++++| /app/C++/subarray-sum-closest.cpp
|  16|  16|         }
|  17|  17| 
|  18|  18|         // sum_from_start[i] denotes sum for 0 ~ i - 1.
|  19|    |-        vector<pair<int,int>> sum_from_start(n + 1, {0, 0});
|  20|    |-        sum_from_start[0].second = -1; // For case closest sum is from 0.
|  21|    |-        for (int  i = 0; i < n; ++i) {
|  22|    |-            sum_from_start[i + 1].first = sum_from_start[i].first + nums[i];
|  23|    |-            sum_from_start[i + 1].second = i;
|  24|    |-        }
|    |  19|+        vector < pair < int, int >>sum_from_start (n + 1,
|    |  20|+                                                   {
|    |  21|+                                                   0, 0});
|    |  22|+        sum_from_start[0].second = -1;  // For case closest sum is from 0.
|    |  23|+        for (int i = 0; i < n; ++i)
|    |  24|+          {
|    |  25|+              sum_from_start[i + 1].first = sum_from_start[i].first + nums[i];
|    |  26|+              sum_from_start[i + 1].second = i;
|    |  27|+          }
|  25|  28| 
|  26|  29|         // Sort each sum from start.
|  27|  30|         sort(sum_from_start.begin(), sum_from_start.end());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-closest.cpp
|    |++++| /app/C++/subarray-sum-closest.cpp
|  24|  24|         }
|  25|  25| 
|  26|  26|         // Sort each sum from start.
|  27|    |-        sort(sum_from_start.begin(), sum_from_start.end());
|    |  27|+        sort (sum_from_start.begin (), sum_from_start.end ());
|  28|  28| 
|  29|  29|         int min_diff = INT_MAX;
|  30|  30|         int start = -1;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/subarray-sum-closest.cpp
|    |++++| /app/C++/subarray-sum-closest.cpp
|  31|  31|         int end = -1;
|  32|  32| 
|  33|  33|         // Find min difference of adjacent sum.
|  34|    |-        for (int i = 1; i <= n; ++i) {
|  35|    |-            int diff = abs(sum_from_start[i].first - sum_from_start[i - 1].first);
|  36|    |-            if (diff < min_diff) {
|  37|    |-                min_diff = diff;
|  38|    |-                start = min(sum_from_start[i].second, sum_from_start[i - 1].second) + 1;
|  39|    |-                end = max(sum_from_start[i].second, sum_from_start[i - 1].second);
|  40|    |-            }
|  41|    |-        }
|    |  34|+        for (int i = 1; i <= n; ++i)
|    |  35|+          {
|    |  36|+              int diff =
|    |  37|+                  abs (sum_from_start[i].first - sum_from_start[i - 1].first);
|    |  38|+              if (diff < min_diff)
|    |  39|+                {
|    |  40|+                    min_diff = diff;
|    |  41|+                    start =
|    |  42|+                        min (sum_from_start[i].second,
|    |  43|+                             sum_from_start[i - 1].second) + 1;
|    |  44|+                    end =
|    |  45|+                        max (sum_from_start[i].second,
|    |  46|+                             sum_from_start[i - 1].second);
|    |  47|+                }
|    |  48|+          }
|  42|  49| 
|  43|    |-        return {start, end};
|    |  50|+        return
|    |  51|+        {
|    |  52|+        start, end};
|  44|  53|     }
|  45|  54| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-substring.cpp
|    |++++| /app/C++/longest-common-substring.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A, B: Two string.
|   8|   9|      * @return: the length of the longest common substring.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-substring.cpp
|    |++++| /app/C++/longest-common-substring.cpp
|   7|   7|      * @param A, B: Two string.
|   8|   8|      * @return: the length of the longest common substring.
|   9|   9|      */
|  10|    |-    int longestCommonSubstring(string &A, string &B) {
|  11|    |-        if (A.length() < B.length()) {
|  12|    |-            return longestCommonSubstring(B, A);
|  13|    |-        }
|    |  10|+    int longestCommonSubstring (string & A, string & B)
|    |  11|+    {
|    |  12|+        if (A.length () < B.length ())
|    |  13|+          {
|    |  14|+              return longestCommonSubstring (B, A);
|    |  15|+          }
|  14|  16| 
|  15|  17|         // table[i][j] means the longest length of common substring
|  16|  18|         // of A which ends with A[i - 1] and B which ends with B[j - 1].
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-substring.cpp
|    |++++| /app/C++/longest-common-substring.cpp
|  14|  14| 
|  15|  15|         // table[i][j] means the longest length of common substring
|  16|  16|         // of A which ends with A[i - 1] and B which ends with B[j - 1].
|  17|    |-        vector<vector<int>> table(2, vector<int>(A.length() + 1, 0));
|    |  17|+        vector < vector < int >>table (2, vector < int >(A.length () + 1, 0));
|  18|  18|         int longest = 0;
|  19|  19| 
|  20|  20|         // if A[i - 1] != B[j - 1]:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-substring.cpp
|    |++++| /app/C++/longest-common-substring.cpp
|  21|  21|         //     table[i][j] = 0
|  22|  22|         // if A[i - 1] == B[j - 1]:
|  23|  23|         //     table[i][j] = table[i - 1][j - 1] + 1
|  24|    |-        for (int i = 1; i < A.length() + 1; ++i) {
|  25|    |-            for (int j = 1; j < B.length() + 1; ++j) {
|  26|    |-                if (A[i - 1] != B[j - 1]) {
|  27|    |-                    table[i % 2][j] = 0;
|  28|    |-                } else {
|  29|    |-                    table[i % 2][j] = table[(i - 1) % 2][j - 1] + 1;
|  30|    |-                    longest = max(longest, table[i % 2][j]);
|    |  24|+        for (int i = 1; i < A.length () + 1; ++i)
|    |  25|+          {
|    |  26|+              for (int j = 1; j < B.length () + 1; ++j)
|    |  27|+                {
|    |  28|+                    if (A[i - 1] != B[j - 1])
|    |  29|+                      {
|    |  30|+                          table[i % 2][j] = 0;
|    |  31|+                      }
|    |  32|+                    else
|    |  33|+                      {
|    |  34|+                          table[i % 2][j] = table[(i - 1) % 2][j - 1] + 1;
|    |  35|+                          longest = max (longest, table[i % 2][j]);
|    |  36|+                      }
|  31|  37|                 }
|  32|    |-            }
|  33|    |-        }
|    |  38|+          }
|  34|  39| 
|  35|  40|         return longest;
|  36|  41|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-substring.cpp
|    |++++| /app/C++/longest-common-substring.cpp
|  35|  35|         return longest;
|  36|  36|     }
|  37|  37| };
|  38|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-string.cpp
|    |++++| /app/C++/rotate-string.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * param A: A string
|   8|   9|      * param offset: Rotate string with offset.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/rotate-string.cpp
|    |++++| /app/C++/rotate-string.cpp
|   8|   8|      * param offset: Rotate string with offset.
|   9|   9|      * return: Rotated string.
|  10|  10|      */
|  11|    |-    string rotateString(string A, int offset) {
|  12|    |-        if (!A.empty()) {
|  13|    |-            offset %= A.length();
|  14|    |-            reverse(A.begin(), A.begin() + A.length() - offset);
|  15|    |-            reverse(A.begin() + A.length() - offset, A.end());
|  16|    |-            reverse(A.begin(), A.end());
|  17|    |-        }
|    |  11|+    string rotateString (string A, int offset)
|    |  12|+    {
|    |  13|+        if (!A.empty ())
|    |  14|+          {
|    |  15|+              offset %= A.length ();
|    |  16|+              reverse (A.begin (), A.begin () + A.length () - offset);
|    |  17|+              reverse (A.begin () + A.length () - offset, A.end ());
|    |  18|+              reverse (A.begin (), A.end ());
|    |  19|+          }
|  18|  20|         return A;
|  19|  21|     }
|  20|  22| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/toy-factory.cpp
|    |++++| /app/C++/toy-factory.cpp
|   7|   7|  * Toy* toy = tf->getToy(type);
|   8|   8|  * toy->talk();
|   9|   9|  */
|  10|    |-class Toy {
|  11|    |-public:
|  12|    |-    virtual void talk() const=0;
|    |  10|+class Toy
|    |  11|+{
|    |  12|+  public:
|    |  13|+    virtual void talk () const = 0;
|  13|  14| };
|  14|  15| 
|  15|  16| class Dog: public Toy {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/toy-factory.cpp
|    |++++| /app/C++/toy-factory.cpp
|  12|  12|     virtual void talk() const=0;
|  13|  13| };
|  14|  14| 
|  15|    |-class Dog: public Toy {
|  16|    |-public:
|  17|    |-    virtual void talk() const {
|    |  15|+class Dog:public Toy
|    |  16|+{
|    |  17|+  public:
|    |  18|+    virtual void talk () const
|    |  19|+    {
|  18|  20|         cout << "Wow" << endl;
|  19|  21|     }
|  20|  22| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/toy-factory.cpp
|    |++++| /app/C++/toy-factory.cpp
|  19|  19|     }
|  20|  20| };
|  21|  21| 
|  22|    |-class Cat: public Toy {
|  23|    |-public:
|  24|    |-    virtual void talk() const {
|    |  22|+class Cat:public Toy
|    |  23|+{
|    |  24|+  public:
|    |  25|+    virtual void talk () const
|    |  26|+    {
|  25|  27|         cout << "Meow" << endl;
|  26|  28|     }
|  27|  29| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/toy-factory.cpp
|    |++++| /app/C++/toy-factory.cpp
|  26|  26|     }
|  27|  27| };
|  28|  28| 
|  29|    |-class ToyFactory {
|  30|    |-public:
|    |  29|+class ToyFactory
|    |  30|+{
|    |  31|+  public:
|  31|  32|     /**
|  32|  33|      * @param type a string
|  33|  34|      * @return Get object of the type
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/toy-factory.cpp
|    |++++| /app/C++/toy-factory.cpp
|  32|  32|      * @param type a string
|  33|  33|      * @return Get object of the type
|  34|  34|      */
|  35|    |-    Toy* getToy(string& type) {
|  36|    |-        if (type == "Dog") {
|  37|    |-            return new Dog();
|  38|    |-        } else if (type == "Cat") {
|  39|    |-            return new Cat();
|  40|    |-        }
|    |  35|+    Toy * getToy (string & type)
|    |  36|+    {
|    |  37|+        if (type == "Dog")
|    |  38|+          {
|    |  39|+              return new Dog ();
|    |  40|+          }
|    |  41|+        else if (type == "Cat")
|    |  42|+          {
|    |  43|+              return new Cat ();
|    |  44|+          }
|  41|  45|     }
|  42|  46| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|   1|   1| // Time:  O(k * n^2)
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A an integer array
|   8|   9|      * @param k an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|   8|   8|      * @param k an integer
|   9|   9|      * @return an integer
|  10|  10|      */
|  11|    |-    int postOffice(vector<int>& A, int k) {
|  12|    |-        const int n = A.size();
|  13|    |-        if (A.empty() || k >= n) {
|  14|    |-            return 0;
|  15|    |-        }
|    |  11|+    int postOffice (vector < int >&A, int k)
|    |  12|+    {
|    |  13|+        const int n = A.size ();
|    |  14|+        if (A.empty () || k >= n)
|    |  15|+          {
|    |  16|+              return 0;
|    |  17|+          }
|  16|  18| 
|  17|    |-        sort(A.begin(), A.end());  // Time:  O(nlogn)
|    |  19|+        sort (A.begin (), A.end ());    // Time:  O(nlogn)
|  18|  20| 
|  19|  21|         // Precompute cost.
|  20|  22|         // Time:  O(n)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  19|  19|         // Precompute cost.
|  20|  20|         // Time:  O(n)
|  21|  21|         // Space: O(n)
|  22|    |-        vector<int> before_cost(n), after_cost(n);
|  23|    |-        computeCost(A, &before_cost, &after_cost);
|    |  22|+        vector < int >before_cost (n), after_cost (n);
|    |  23|+        computeCost (A, &before_cost, &after_cost);
|  24|  24| 
|  25|  25|         // DP of sum.
|  26|  26|         // Time:  O(k * n^2)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  27|  27|         // Space: O(n)
|  28|  28|         // sum[i][j] denotes the smallest sum of
|  29|  29|         // picking i post offices for the first j houses.
|  30|    |-        vector<vector<int>> sum(2, vector<int>(A.size() + 1, INT_MAX));
|    |  30|+        vector < vector < int >>sum (2,
|    |  31|+                                     vector < int >(A.size () + 1, INT_MAX));
|  31|  32|         sum[0][0] = 0;
|  32|    |-        for (int i = 1; i <= k; ++i) {
|  33|    |-            for (int j = 0; j <= n; ++j) {
|  34|    |-                // We can skip this line due to sum[i][j] <= sum[i - 2][j]
|  35|    |-                // sum[i % 2][j] = INT_MAX;
|  36|    |-                for (int r = 1; r <= j; ++r) {
|  37|    |-                    if (sum[(i - 1) % 2][j - r] != INT_MAX) {
|  38|    |-                        sum[i % 2][j] = min(sum[i % 2][j],
|  39|    |-                                            sum[(i - 1) % 2][j - r] +
|  40|    |-                                            minCost(A,
|  41|    |-                                                    before_cost, after_cost,
|  42|    |-                                                    j - r, j - 1));
|  43|    |-                    }
|    |  33|+        for (int i = 1; i <= k; ++i)
|    |  34|+          {
|    |  35|+              for (int j = 0; j <= n; ++j)
|    |  36|+                {
|    |  37|+                    // We can skip this line due to sum[i][j] <= sum[i - 2][j]
|    |  38|+                    // sum[i % 2][j] = INT_MAX;
|    |  39|+                    for (int r = 1; r <= j; ++r)
|    |  40|+                      {
|    |  41|+                          if (sum[(i - 1) % 2][j - r] != INT_MAX)
|    |  42|+                            {
|    |  43|+                                sum[i % 2][j] = min (sum[i % 2][j],
|    |  44|+                                                     sum[(i - 1) % 2][j - r] +
|    |  45|+                                                     minCost (A,
|    |  46|+                                                              before_cost,
|    |  47|+                                                              after_cost,
|    |  48|+                                                              j - r, j - 1));
|    |  49|+                            }
|    |  50|+                      }
|  44|  51|                 }
|  45|    |-            }
|  46|    |-        }
|    |  52|+          }
|  47|  53|         return sum[k % 2][n];
|  48|  54|     }
|  49|  55| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  47|  47|         return sum[k % 2][n];
|  48|  48|     }
|  49|  49| 
|  50|    |-    void computeCost(const vector<int>& A,
|  51|    |-                     vector<int> *before_cost, vector<int> *after_cost) {
|  52|    |-        const int n = A.size();
|  53|    |-        for (int i = 1; i < n; ++i) {
|  54|    |-            // before_cost[i] = Sum(A[i] - A[k]) for k < i
|  55|    |-            (*before_cost)[i] = (*before_cost)[i - 1] +
|  56|    |-                                i * (A[i] - A[i - 1]);
|  57|    |-        }
|  58|    |-        for (int i = n - 2; i >= 0; --i) {
|  59|    |-            // after_cost[i] = Sum(A[k] - A[i]) for k > i
|  60|    |-            (*after_cost)[i] = (*after_cost)[i + 1] +
|  61|    |-                               (n - 1 - i) * (A[i + 1] - A[i]);
|  62|    |-        }
|    |  50|+    void computeCost (const vector < int >&A,
|    |  51|+                      vector < int >*before_cost, vector < int >*after_cost)
|    |  52|+    {
|    |  53|+        const int n = A.size ();
|    |  54|+        for (int i = 1; i < n; ++i)
|    |  55|+          {
|    |  56|+              // before_cost[i] = Sum(A[i] - A[k]) for k < i
|    |  57|+              (*before_cost)[i] = (*before_cost)[i - 1] +
|    |  58|+                  i * (A[i] - A[i - 1]);
|    |  59|+          }
|    |  60|+        for (int i = n - 2; i >= 0; --i)
|    |  61|+          {
|    |  62|+              // after_cost[i] = Sum(A[k] - A[i]) for k > i
|    |  63|+              (*after_cost)[i] = (*after_cost)[i + 1] +
|    |  64|+                  (n - 1 - i) * (A[i + 1] - A[i]);
|    |  65|+          }
|  63|  66|     }
|  64|  67| 
|  65|  68|     int minCost(const vector<int>& A,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  62|  62|         }
|  63|  63|     }
|  64|  64| 
|  65|    |-    int minCost(const vector<int>& A,
|  66|    |-                const vector<int> &before_cost, const vector<int> &after_cost,
|  67|    |-                const int i, const int j) {
|  68|    |-            // Min cost of building a post office between house (i, j).
|  69|    |-            // This post office must be in median position.
|  70|    |-            const int n = A.size();
|  71|    |-            int mid = i + (j - i) / 2;
|  72|    |-            int before_mid = before_cost[mid] -
|  73|    |-                             (before_cost[i] + i * (A[mid] - A[i]));
|  74|    |-            int after_mid = after_cost[mid] -
|  75|    |-                            (after_cost[j] + (n - 1 - j) * (A[j] - A[mid]));
|  76|    |-            return before_mid + after_mid;
|    |  65|+    int minCost (const vector < int >&A,
|    |  66|+                 const vector < int >&before_cost,
|    |  67|+                 const vector < int >&after_cost, const int i, const int j)
|    |  68|+    {
|    |  69|+        // Min cost of building a post office between house (i, j).
|    |  70|+        // This post office must be in median position.
|    |  71|+        const int n = A.size ();
|    |  72|+        int mid = i + (j - i) / 2;
|    |  73|+        int before_mid = before_cost[mid] -
|    |  74|+            (before_cost[i] + i * (A[mid] - A[i]));
|    |  75|+        int after_mid = after_cost[mid] -
|    |  76|+            (after_cost[j] + (n - 1 - j) * (A[j] - A[mid]));
|    |  77|+        return before_mid + after_mid;
|  77|  78|     }
|  78|  79| };
|  79|  80| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  79|  79| 
|  80|  80| // Time:  O(n^3)
|  81|  81| // Space: O(n^2)
|  82|    |-class Solution2 {
|  83|    |-public:
|    |  82|+class Solution2
|    |  83|+{
|    |  84|+  public:
|  84|  85|     /**
|  85|  86|      * @param A an integer array
|  86|  87|      * @param k an integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  86|  86|      * @param k an integer
|  87|  87|      * @return an integer
|  88|  88|      */
|  89|    |-    int postOffice(vector<int>& A, int k) {
|  90|    |-        const int n = A.size();
|  91|    |-        if (A.empty() || k >= n) {
|  92|    |-            return 0;
|  93|    |-        }
|    |  89|+    int postOffice (vector < int >&A, int k)
|    |  90|+    {
|    |  91|+        const int n = A.size ();
|    |  92|+        if (A.empty () || k >= n)
|    |  93|+          {
|    |  94|+              return 0;
|    |  95|+          }
|  94|  96| 
|  95|    |-        sort(A.begin(), A.end());  // Time:  O(nlogn)
|    |  97|+        sort (A.begin (), A.end ());    // Time:  O(nlogn)
|  96|  98| 
|  97|  99|         // Precompute cost.
|  98| 100|         // Time:  O(n^3)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
|  97|  97|         // Precompute cost.
|  98|  98|         // Time:  O(n^3)
|  99|  99|         // Space: O(n^2)
| 100|    |-        vector<vector<int>> cost(A.size() + 1, vector<int>(A.size() + 1, 0));
| 101|    |-        computeMinCost(A, &cost);
|    | 100|+        vector < vector < int >>cost (A.size () + 1,
|    | 101|+                                      vector < int >(A.size () + 1, 0));
|    | 102|+        computeMinCost (A, &cost);
| 102| 103| 
| 103| 104|         // DP of sum.
| 104| 105|         // Time:  O(k * n^2)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
| 105| 105|         // Space: O(k * n)
| 106| 106|         // sum[i][j] denotes the smallest sum of
| 107| 107|         // picking i post offices for the first j houses.
| 108|    |-        vector<vector<int>> sum(k + 1, vector<int>(A.size() + 1, INT_MAX));
|    | 108|+        vector < vector < int >>sum (k + 1,
|    | 109|+                                     vector < int >(A.size () + 1, INT_MAX));
| 109| 110|         sum[0][0] = 0;
| 110|    |-        for (int i = 1; i <= k; ++i) {
| 111|    |-            for (int j = 0; j < n; ++j) {
| 112|    |-                if (sum[i - 1][j] != INT_MAX) {
| 113|    |-                    for (int r = 1; j + r <= n; ++r) {
| 114|    |-                       sum[i][j + r] = min(sum[i][j + r],
| 115|    |-                                           sum[i - 1][j] + cost[j + 1][j + r]);
| 116|    |-                    }
|    | 111|+        for (int i = 1; i <= k; ++i)
|    | 112|+          {
|    | 113|+              for (int j = 0; j < n; ++j)
|    | 114|+                {
|    | 115|+                    if (sum[i - 1][j] != INT_MAX)
|    | 116|+                      {
|    | 117|+                          for (int r = 1; j + r <= n; ++r)
|    | 118|+                            {
|    | 119|+                                sum[i][j + r] = min (sum[i][j + r],
|    | 120|+                                                     sum[i - 1][j] + cost[j +
|    | 121|+                                                                          1][j
|    | 122|+                                                                             +
|    | 123|+                                                                             r]);
|    | 124|+                            }
|    | 125|+                      }
| 117| 126|                 }
| 118|    |-            }
| 119|    |-        }
|    | 127|+          }
| 120| 128|         return sum[k][n];
| 121| 129|     }
| 122| 130| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
| 120| 120|         return sum[k][n];
| 121| 121|     }
| 122| 122| 
| 123|    |-    void computeMinCost(const vector<int>& A, vector<vector<int>> *cost) {
|    | 123|+    void computeMinCost (const vector < int >&A, vector < vector < int >>*cost)
|    | 124|+    {
| 124| 125|         // Min cost of building a post office between house (i, j).
| 125| 126|         // This post office must be in median position.
| 126| 127|         const int n = A.size();
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/post-office-problem.cpp
|    |++++| /app/C++/post-office-problem.cpp
| 123| 123|     void computeMinCost(const vector<int>& A, vector<vector<int>> *cost) {
| 124| 124|         // Min cost of building a post office between house (i, j).
| 125| 125|         // This post office must be in median position.
| 126|    |-        const int n = A.size();
| 127|    |-        for (int i = 0; i < n; ++i) {
| 128|    |-            for (int j = i; j < n; ++j) {
| 129|    |-                int mid = (i + j) / 2;
| 130|    |-                for (int r = i; r <= mid; ++r) {
| 131|    |-                    (*cost)[i + 1][j + 1] += A[mid] - A[r];
|    | 126|+        const int n = A.size ();
|    | 127|+        for (int i = 0; i < n; ++i)
|    | 128|+          {
|    | 129|+              for (int j = i; j < n; ++j)
|    | 130|+                {
|    | 131|+                    int mid = (i + j) / 2;
|    | 132|+                    for (int r = i; r <= mid; ++r)
|    | 133|+                      {
|    | 134|+                          (*cost)[i + 1][j + 1] += A[mid] - A[r];
|    | 135|+                      }
|    | 136|+                    for (int r = mid + 1; r <= j; ++r)
|    | 137|+                      {
|    | 138|+                          (*cost)[i + 1][j + 1] += A[r] - A[mid];
|    | 139|+                      }
| 132| 140|                 }
| 133|    |-                for (int r = mid + 1; r <= j; ++r) {
| 134|    |-                    (*cost)[i + 1][j + 1] += A[r] - A[mid];
| 135|    |-                }
| 136|    |-            }
| 137|    |-        }
|    | 141|+          }
| 138| 142|     }
| 139| 143| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/surrounded-regions.cpp
|    |++++| /app/C++/surrounded-regions.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(m + n)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param board a 2D board containing 'X' and 'O'
|   8|   9|      * @return void
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/surrounded-regions.cpp
|    |++++| /app/C++/surrounded-regions.cpp
|   7|   7|      * @param board a 2D board containing 'X' and 'O'
|   8|   8|      * @return void
|   9|   9|      */
|  10|    |-    void surroundedRegions(vector<vector<char>>& board) {
|  11|    |-        if (board.empty()) {
|  12|    |-            return;
|  13|    |-        }
|    |  10|+    void surroundedRegions (vector < vector < char >>&board)
|    |  11|+    {
|    |  12|+        if (board.empty ())
|    |  13|+          {
|    |  14|+              return;
|    |  15|+          }
|  14|  16| 
|  15|    |-        queue<pair<int, int>> q;
|  16|    |-        for (int i = 0; i < board.size(); ++i) {
|  17|    |-            q.emplace(make_pair(i, 0));
|  18|    |-            q.emplace(make_pair(i, board[0].size() - 1));
|  19|    |-        }
|    |  17|+        queue < pair < int, int >>q;
|    |  18|+        for (int i = 0; i < board.size (); ++i)
|    |  19|+          {
|    |  20|+              q.emplace (make_pair (i, 0));
|    |  21|+              q.emplace (make_pair (i, board[0].size () - 1));
|    |  22|+          }
|  20|  23| 
|  21|    |-        for (int j = 0; j < board[0].size(); ++j) {
|  22|    |-            q.emplace(make_pair(0, j));
|  23|    |-            q.emplace(make_pair(board.size() - 1, j));
|  24|    |-        }
|  25|    |-        while (!q.empty()) {
|  26|    |-            int i, j;
|  27|    |-            tie(i, j) = q.front();
|  28|    |-            q.pop();
|  29|    |-            if (board[i][j] == 'O' || board[i][j] == 'V') {
|  30|    |-                board[i][j] = 'V';
|  31|    |-                const vector<pair<int, int>> directions{{0, -1}, {0, 1},
|  32|    |-                                                        {-1, 0}, {1, 0}};
|  33|    |-                for (const auto& d : directions) {
|  34|    |-                    const int x = i + d.first, y = j + d.second;
|  35|    |-                    if (0 <= x  && x < board.size() &&
|  36|    |-                        0 <= y && y < board[0].size() &&
|  37|    |-                        board[x][y] == 'O') {
|  38|    |-                        board[x][y] = 'V';
|  39|    |-                        q.emplace(make_pair(x, y));
|  40|    |-                    }
|    |  24|+        for (int j = 0; j < board[0].size (); ++j)
|    |  25|+          {
|    |  26|+              q.emplace (make_pair (0, j));
|    |  27|+              q.emplace (make_pair (board.size () - 1, j));
|    |  28|+          }
|    |  29|+        while (!q.empty ())
|    |  30|+          {
|    |  31|+              int i, j;
|    |  32|+              tie (i, j) = q.front ();
|    |  33|+              q.pop ();
|    |  34|+              if (board[i][j] == 'O' || board[i][j] == 'V')
|    |  35|+                {
|    |  36|+                    board[i][j] = 'V';
|    |  37|+                    const vector < pair < int, int >>directions
|    |  38|+                    {
|    |  39|+                        {
|    |  40|+                        0, -1},
|    |  41|+                        {
|    |  42|+                        0, 1},
|    |  43|+                        {
|    |  44|+                        -1, 0},
|    |  45|+                        {
|    |  46|+                    1, 0}};
|    |  47|+                  for (const auto & d:directions)
|    |  48|+                      {
|    |  49|+                          const int x = i + d.first, y = j + d.second;
|    |  50|+                          if (0 <= x && x < board.size () &&
|    |  51|+                              0 <= y && y < board[0].size () &&
|    |  52|+                              board[x][y] == 'O')
|    |  53|+                            {
|    |  54|+                                board[x][y] = 'V';
|    |  55|+                                q.emplace (make_pair (x, y));
|    |  56|+                            }
|    |  57|+                      }
|  41|  58|                 }
|  42|    |-            }
|  43|    |-        }
|    |  59|+          }
|  44|  60| 
|  45|    |-        for (int i = 0; i < board.size(); ++i) {
|  46|    |-            for (int j = 0; j < board[0].size(); ++j) {
|  47|    |-                if (board[i][j] != 'V') {
|  48|    |-                    board[i][j] = 'X';
|  49|    |-                } else {
|  50|    |-                    board[i][j] = 'O';
|    |  61|+        for (int i = 0; i < board.size (); ++i)
|    |  62|+          {
|    |  63|+              for (int j = 0; j < board[0].size (); ++j)
|    |  64|+                {
|    |  65|+                    if (board[i][j] != 'V')
|    |  66|+                      {
|    |  67|+                          board[i][j] = 'X';
|    |  68|+                      }
|    |  69|+                    else
|    |  70|+                      {
|    |  71|+                          board[i][j] = 'O';
|    |  72|+                      }
|  51|  73|                 }
|  52|    |-            }
|  53|    |-        }
|    |  74|+          }
|  54|  75|     }
|  55|  76| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|   1|   1| // Time:  O(logn)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param x: An integer
|   8|   9|      * @return: The sqrt of x
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|   7|   7|      * @param x: An integer
|   8|   8|      * @return: The sqrt of x
|   9|   9|      */
|  10|    |-    int sqrt(int x) {
|    |  10|+    int sqrt (int x)
|    |  11|+    {
|  11|  12|         int left = 1;
|  12|  13|         int right = x / 2;
|  13|  14| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  12|  12|         int right = x / 2;
|  13|  13| 
|  14|  14|         // Find min of left s.t. left > x / left.
|  15|    |-        while (left <= right) {
|  16|    |-            int mid = left + (right - left) / 2;
|  17|    |-            if (mid > x / mid) {
|  18|    |-                right = mid - 1;
|  19|    |-            } else {
|  20|    |-                left = mid + 1;
|  21|    |-            }
|  22|    |-        }
|    |  15|+        while (left <= right)
|    |  16|+          {
|    |  17|+              int mid = left + (right - left) / 2;
|    |  18|+              if (mid > x / mid)
|    |  19|+                {
|    |  20|+                    right = mid - 1;
|    |  21|+                }
|    |  22|+              else
|    |  23|+                {
|    |  24|+                    left = mid + 1;
|    |  25|+                }
|    |  26|+          }
|  23|  27| 
|  24|  28|         return left - 1;
|  25|  29|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  25|  25|     }
|  26|  26| };
|  27|  27| 
|  28|    |-class Solution2 {
|  29|    |-public:
|    |  28|+class Solution2
|    |  29|+{
|    |  30|+  public:
|  30|  31|     /**
|  31|  32|      * @param x: An integer
|  32|  33|      * @return: The sqrt of x
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  31|  31|      * @param x: An integer
|  32|  32|      * @return: The sqrt of x
|  33|  33|      */
|  34|    |-    int sqrt(int x) {
|    |  34|+    int sqrt (int x)
|    |  35|+    {
|  35|  36|         int left = 1;
|  36|  37|         int right = x / 2 + 1;
|  37|  38| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  36|  36|         int right = x / 2 + 1;
|  37|  37| 
|  38|  38|         // Find min of left s.t. left > x / left.
|  39|    |-        while (left < right) {
|  40|    |-            int mid = left + (right - left) / 2;
|  41|    |-            if (mid > x / mid) {
|  42|    |-                right = mid;
|  43|    |-            } else {
|  44|    |-                left = mid + 1;
|  45|    |-            }
|  46|    |-        }
|    |  39|+        while (left < right)
|    |  40|+          {
|    |  41|+              int mid = left + (right - left) / 2;
|    |  42|+              if (mid > x / mid)
|    |  43|+                {
|    |  44|+                    right = mid;
|    |  45|+                }
|    |  46|+              else
|    |  47|+                {
|    |  48|+                    left = mid + 1;
|    |  49|+                }
|    |  50|+          }
|  47|  51| 
|  48|  52|         return left - 1;
|  49|  53|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  49|  49|     }
|  50|  50| };
|  51|  51| 
|  52|    |-class Solution3 {
|  53|    |-public:
|    |  52|+class Solution3
|    |  53|+{
|    |  54|+  public:
|  54|  55|     /**
|  55|  56|      * @param x: An integer
|  56|  57|      * @return: The sqrt of x
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  55|  55|      * @param x: An integer
|  56|  56|      * @return: The sqrt of x
|  57|  57|      */
|  58|    |-    int sqrt(int x) {
|    |  58|+    int sqrt (int x)
|    |  59|+    {
|  59|  60|         int left = 0;
|  60|  61|         int right = x / 2 + 1;
|  61|  62| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  60|  60|         int right = x / 2 + 1;
|  61|  61| 
|  62|  62|         // Find min of right s.t. right > x / right.
|  63|    |-        while (right - left > 1) {
|  64|    |-            int mid = left + (right - left) / 2;
|  65|    |-            if (mid > x / mid) {
|  66|    |-                right = mid;
|  67|    |-            } else {
|  68|    |-                left = mid;
|  69|    |-            }
|  70|    |-        }
|    |  63|+        while (right - left > 1)
|    |  64|+          {
|    |  65|+              int mid = left + (right - left) / 2;
|    |  66|+              if (mid > x / mid)
|    |  67|+                {
|    |  68|+                    right = mid;
|    |  69|+                }
|    |  70|+              else
|    |  71|+                {
|    |  72|+                    left = mid;
|    |  73|+                }
|    |  74|+          }
|  71|  75| 
|  72|  76|         return right - 1;
|  73|  77|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sqrtx.cpp
|    |++++| /app/C++/sqrtx.cpp
|  72|  72|         return right - 1;
|  73|  73|     }
|  74|  74| };
|  75|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-palindrome.cpp
|    |++++| /app/C++/valid-palindrome.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param s A string
|   8|   9|      * @return Whether the string is a valid palindrome
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-palindrome.cpp
|    |++++| /app/C++/valid-palindrome.cpp
|   7|   7|      * @param s A string
|   8|   8|      * @return Whether the string is a valid palindrome
|   9|   9|      */
|  10|    |-    bool isPalindrome(string& s) {
|  11|    |-        int i = 0, j = s.size() - 1;
|  12|    |-        while (i < j) {
|  13|    |-            while (i < j && !isalnum(s[i])) {
|  14|    |-                ++i;
|  15|    |-            }
|  16|    |-            while (i < j && !isalnum(s[j])) {
|  17|    |-                --j;
|  18|    |-            }
|  19|    |-            if (tolower(s[i]) != tolower(s[j])) {
|  20|    |-                return false;
|  21|    |-            }
|  22|    |-            ++i, --j;
|  23|    |-        }
|    |  10|+    bool isPalindrome (string & s)
|    |  11|+    {
|    |  12|+        int i = 0, j = s.size () - 1;
|    |  13|+        while (i < j)
|    |  14|+          {
|    |  15|+              while (i < j && !isalnum (s[i]))
|    |  16|+                {
|    |  17|+                    ++i;
|    |  18|+                }
|    |  19|+              while (i < j && !isalnum (s[j]))
|    |  20|+                {
|    |  21|+                    --j;
|    |  22|+                }
|    |  23|+              if (tolower (s[i]) != tolower (s[j]))
|    |  24|+                {
|    |  25|+                    return false;
|    |  26|+                }
|    |  27|+              ++i, --j;
|    |  28|+          }
|  24|  29|         return true;
|  25|  30|     }
|  26|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @param k: As described
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|   8|   8|      * @param k: As described
|   9|   9|      * @return: The majority number
|  10|  10|      */
|  11|    |-    int majorityNumber(vector<int> nums, int k) {
|  12|    |-        const int n = nums.size();
|  13|    |-        unordered_map<int, int> hash;
|    |  11|+    int majorityNumber (vector < int >nums, int k)
|    |  12|+    {
|    |  13|+        const int n = nums.size ();
|    |  14|+          unordered_map < int, int >hash;
|  14|  15| 
|  15|    |-        for (const auto& i : nums) {
|  16|    |-            ++hash[i];
|  17|    |-            // Detecting k items in hash, at least one of them must have exactly
|  18|    |-            // one in it. We will discard those k items by one for each.
|  19|    |-            // This action keeps the same mojority numbers in the remaining numbers.
|  20|    |-            // Because if x / n  > 1 / k is true, then (x - 1) / (n - k) > 1 / k is also true.
|  21|    |-            if (hash.size() == k) {
|  22|    |-                auto it = hash.begin();
|  23|    |-                while (it != hash.end()) {
|  24|    |-                    if (--(it->second) == 0) {
|  25|    |-                        hash.erase(it++);
|  26|    |-                    } else {
|  27|    |-                        ++it;
|  28|    |-                    }
|    |  16|+        for (const auto & i:nums)
|    |  17|+          {
|    |  18|+              ++hash[i];
|    |  19|+              // Detecting k items in hash, at least one of them must have exactly
|    |  20|+              // one in it. We will discard those k items by one for each.
|    |  21|+              // This action keeps the same mojority numbers in the remaining numbers.
|    |  22|+              // Because if x / n  > 1 / k is true, then (x - 1) / (n - k) > 1 / k is also true.
|    |  23|+              if (hash.size () == k)
|    |  24|+                {
|    |  25|+                    auto it = hash.begin ();
|    |  26|+                    while (it != hash.end ())
|    |  27|+                      {
|    |  28|+                          if (--(it->second) == 0)
|    |  29|+                            {
|    |  30|+                                hash.erase (it++);
|    |  31|+                            }
|    |  32|+                          else
|    |  33|+                            {
|    |  34|+                                ++it;
|    |  35|+                            }
|    |  36|+                      }
|  29|  37|                 }
|  30|    |-            }
|  31|    |-        }
|    |  38|+          }
|  32|  39| 
|  33|  40|         // Resets hash for the following counting.
|  34|  41|         for (auto& it : hash) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|  31|  31|         }
|  32|  32| 
|  33|  33|         // Resets hash for the following counting.
|  34|    |-        for (auto& it : hash) {
|  35|    |-            it.second = 0;
|  36|    |-        }
|    |  34|+      for (auto & it:hash)
|    |  35|+          {
|    |  36|+              it.second = 0;
|    |  37|+          }
|  37|  38| 
|  38|  39|         // Counts the occurrence of each candidate integer.
|  39|  40|         for (const auto& i : nums) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|  36|  36|         }
|  37|  37| 
|  38|  38|         // Counts the occurrence of each candidate integer.
|  39|    |-        for (const auto& i : nums) {
|  40|    |-            auto it = hash.find(i);
|  41|    |-            if (it != hash.end()) {
|  42|    |-                ++it->second;
|  43|    |-            }
|  44|    |-        }
|    |  39|+      for (const auto & i:nums)
|    |  40|+          {
|    |  41|+              auto it = hash.find (i);
|    |  42|+              if (it != hash.end ())
|    |  43|+                {
|    |  44|+                    ++it->second;
|    |  45|+                }
|    |  46|+          }
|  45|  47| 
|  46|  48|         // Selects the integer which occurs > n / k times.
|  47|  49|         vector<int> ret;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|  44|  44|         }
|  45|  45| 
|  46|  46|         // Selects the integer which occurs > n / k times.
|  47|    |-        vector<int> ret;
|  48|    |-        for (const pair<int, int>& it : hash) {
|  49|    |-            if (it.second > static_cast<double>(n) / k) {
|  50|    |-                ret.emplace_back(it.first);
|  51|    |-            }
|  52|    |-        }
|    |  47|+        vector < int >ret;
|    |  48|+      for (const pair < int, int >&it:hash)
|    |  49|+          {
|    |  50|+              if (it.second > static_cast < double >(n) / k)
|    |  51|+                {
|    |  52|+                    ret.emplace_back (it.first);
|    |  53|+                }
|    |  54|+          }
|  53|  55| 
|  54|  56|         return ret[0];
|  55|  57|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number-iii.cpp
|    |++++| /app/C++/majority-number-iii.cpp
|  54|  54|         return ret[0];
|  55|  55|     }
|  56|  56| };
|  57|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query-ii.cpp
|    |++++| /app/C++/segment-tree-query-ii.cpp
|  15|  15|  *     }
|  16|  16|  * }
|  17|  17|  */
|  18|    |-class Solution {
|  19|    |-public:
|    |  18|+class Solution
|    |  19|+{
|    |  20|+  public:
|  20|  21|     /**
|  21|  22|      *@param root, start, end: The root of segment tree and
|  22|  23|      *                         an segment / interval
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query-ii.cpp
|    |++++| /app/C++/segment-tree-query-ii.cpp
|  22|  22|      *                         an segment / interval
|  23|  23|      *@return: The count number in the interval [start, end]
|  24|  24|      */
|  25|    |-    int query(SegmentTreeNode *root, int start, int end) {
|    |  25|+    int query (SegmentTreeNode * root, int start, int end)
|    |  26|+    {
|  26|  27|         // Out of range.
|  27|    |-        if (root == nullptr || root->start > end || root->end <  start) {
|  28|    |-            return 0;
|  29|    |-        }
|    |  28|+        if (root == nullptr || root->start > end || root->end < start)
|    |  29|+          {
|    |  30|+              return 0;
|    |  31|+          }
|  30|  32| 
|  31|  33|         // Current segment is totally within range [start, end]
|  32|  34|         if (root->start >= start && root->end <= end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/segment-tree-query-ii.cpp
|    |++++| /app/C++/segment-tree-query-ii.cpp
|  29|  29|         }
|  30|  30| 
|  31|  31|         // Current segment is totally within range [start, end]
|  32|    |-        if (root->start >= start && root->end <= end) {
|  33|    |-            return root->count;
|  34|    |-        }
|    |  32|+        if (root->start >= start && root->end <= end)
|    |  33|+          {
|    |  34|+              return root->count;
|    |  35|+          }
|  35|  36| 
|  36|    |-        int left = query(root->left, start, end);
|  37|    |-        int right = query(root->right, start, end);
|    |  37|+        int left = query (root->left, start, end);
|    |  38|+        int right = query (root->right, start, end);
|  38|  39| 
|  39|  40|         // Find max in the children.
|  40|  41|         return left + right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  13|  13|  */
|  14|  14| 
|  15|  15| // Segment Tree solution.
|  16|    |-class SegmentTreeSumNode {
|  17|    |-public:
|    |  16|+class SegmentTreeSumNode
|    |  17|+{
|    |  18|+  public:
|  18|  19|     int start, end;
|  19|  20|     long long sum;
|  20|  21|     SegmentTreeSumNode *left, *right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  18|  18|     int start, end;
|  19|  19|     long long sum;
|  20|  20|     SegmentTreeSumNode *left, *right;
|  21|    |-    SegmentTreeSumNode(int start, int end, long long sum) {
|    |  21|+      SegmentTreeSumNode (int start, int end, long long sum)
|    |  22|+    {
|  22|  23|         this->start = start;
|  23|  24|         this->end = end;
|  24|  25|         this->sum = sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  26|  26|     }
|  27|  27| };
|  28|  28| 
|  29|    |-class Solution {
|  30|    |-public:
|    |  29|+class Solution
|    |  30|+{
|    |  31|+  public:
|  31|  32|     /**
|  32|  33|      *@param A, queries: Given an integer array and an query list
|  33|  34|      *@return: The result list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  32|  32|      *@param A, queries: Given an integer array and an query list
|  33|  33|      *@return: The result list
|  34|  34|      */
|  35|    |-    vector<long long> intervalSum(vector<int> &A, vector<Interval> &queries) {
|  36|    |-        vector<long long> res;
|    |  35|+    vector < long long >intervalSum (vector < int >&A,
|    |  36|+                                     vector < Interval > &queries)
|    |  37|+    {
|    |  38|+        vector < long long >res;
|  37|  39| 
|  38|  40|         // Build segment tree.
|  39|  41|         SegmentTreeSumNode *root = build(A, 0, A.size() - 1);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  36|  36|         vector<long long> res;
|  37|  37| 
|  38|  38|         // Build segment tree.
|  39|    |-        SegmentTreeSumNode *root = build(A, 0, A.size() - 1);
|    |  39|+        SegmentTreeSumNode *root = build (A, 0, A.size () - 1);
|  40|  40| 
|  41|  41|         // Do each query.
|  42|  42|         for (const auto& q : queries) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  39|  39|         SegmentTreeSumNode *root = build(A, 0, A.size() - 1);
|  40|  40| 
|  41|  41|         // Do each query.
|  42|    |-        for (const auto& q : queries) {
|  43|    |-            res.emplace_back(query(root, q.start, q.end));
|  44|    |-        }
|    |  42|+        for (const auto & q:queries)
|    |  43|+          {
|    |  44|+              res.emplace_back (query (root, q.start, q.end));
|    |  45|+          }
|  45|  46| 
|  46|  47|         return res;
|  47|  48|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  46|  46|         return res;
|  47|  47|     }
|  48|  48| 
|  49|    |-
|  50|  49|     // Build segment tree.
|  51|    |-    SegmentTreeSumNode *build(vector<int> &A, int start, int end) {
|  52|    |-        if (start > end) {
|  53|    |-            return nullptr;
|  54|    |-        }
|    |  50|+    SegmentTreeSumNode *build (vector < int >&A, int start, int end)
|    |  51|+    {
|    |  52|+        if (start > end)
|    |  53|+          {
|    |  54|+              return nullptr;
|    |  55|+          }
|  55|  56| 
|  56|  57|         // The root's start and end is given by build method.
|  57|  58|         SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  54|  54|         }
|  55|  55| 
|  56|  56|         // The root's start and end is given by build method.
|  57|    |-        SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
|    |  57|+        SegmentTreeSumNode *root = new SegmentTreeSumNode (start, end, 0);
|  58|  58| 
|  59|  59|         // If start equals to end, there will be no children for this node.
|  60|  60|         if (start == end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  57|  57|         SegmentTreeSumNode *root = new SegmentTreeSumNode(start, end, 0);
|  58|  58| 
|  59|  59|         // If start equals to end, there will be no children for this node.
|  60|    |-        if (start == end) {
|  61|    |-            root->sum = A[start];
|  62|    |-            return root;
|  63|    |-        }
|    |  60|+        if (start == end)
|    |  61|+          {
|    |  62|+              root->sum = A[start];
|    |  63|+              return root;
|    |  64|+          }
|  64|  65| 
|  65|  66|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  66|  67|         root->left = build(A, start, (start + end) / 2);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  63|  63|         }
|  64|  64| 
|  65|  65|         // Left child: start=A.left, end=(A.left + A.right) / 2.
|  66|    |-        root->left = build(A, start, (start + end) / 2);
|    |  66|+        root->left = build (A, start, (start + end) / 2);
|  67|  67| 
|  68|  68|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  69|  69|         root->right = build(A, (start + end) / 2 + 1, end);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  66|  66|         root->left = build(A, start, (start + end) / 2);
|  67|  67| 
|  68|  68|         // Right child: start=(A.left + A.right) / 2 + 1, end=A.right.
|  69|    |-        root->right = build(A, (start + end) / 2 + 1, end);
|    |  69|+        root->right = build (A, (start + end) / 2 + 1, end);
|  70|  70| 
|  71|    |-        long long left_sum = root->left != nullptr? root->left->sum : 0;
|  72|    |-        long long right_sum = root->right != nullptr? root->right->sum : 0;
|    |  71|+        long long left_sum = root->left != nullptr ? root->left->sum : 0;
|    |  72|+        long long right_sum = root->right != nullptr ? root->right->sum : 0;
|  73|  73| 
|  74|  74|         // Update sum.
|  75|  75|         root->sum = left_sum + right_sum;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  76|  76|         return root;
|  77|  77|     }
|  78|  78| 
|  79|    |-
|  80|  79|     // Query sum in given range.
|  81|    |-    long long query(SegmentTreeSumNode *root, int start, int end) {
|    |  80|+    long long query (SegmentTreeSumNode * root, int start, int end)
|    |  81|+    {
|  82|  82|         // Out of range.
|  83|    |-        if (root == nullptr || root->start > end || root->end <  start) {
|  84|    |-            return 0;
|  85|    |-        }
|    |  83|+        if (root == nullptr || root->start > end || root->end < start)
|    |  84|+          {
|    |  85|+              return 0;
|    |  86|+          }
|  86|  87| 
|  87|  88|         // Current segment is totally within range [start, end]
|  88|  89|         if (root->start >= start && root->end <= end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
|  85|  85|         }
|  86|  86| 
|  87|  87|         // Current segment is totally within range [start, end]
|  88|    |-        if (root->start >= start && root->end <= end) {
|  89|    |-            return root->sum;
|  90|    |-        }
|    |  88|+        if (root->start >= start && root->end <= end)
|    |  89|+          {
|    |  90|+              return root->sum;
|    |  91|+          }
|  91|  92| 
|  92|    |-        long long left = query(root->left, start, end);
|  93|    |-        long long right = query(root->right, start, end);
|    |  93|+        long long left = query (root->left, start, end);
|    |  94|+        long long right = query (root->right, start, end);
|  94|  95| 
|  95|  96|         // Find sum in the children.
|  96|  97|         return left + right;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 101| 101| //        query:  O(logn)
| 102| 102| // Space: O(n)
| 103| 103| // Binary Indexed Tree (BIT) solution.
| 104|    |-class Solution2 { 
| 105|    |-public:
|    | 104|+class Solution2
|    | 105|+{
|    | 106|+  public:
| 106| 107|     /**
| 107| 108|      *@param A, queries: Given an integer array and an query list
| 108| 109|      *@return: The result list
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 107| 107|      *@param A, queries: Given an integer array and an query list
| 108| 108|      *@return: The result list
| 109| 109|      */
| 110|    |-    vector<long long> intervalSum(vector<int> &A, vector<Interval> &queries) {
|    | 110|+    vector < long long >intervalSum (vector < int >&A,
|    | 111|+                                     vector < Interval > &queries)
|    | 112|+    {
| 111| 113|         nums_ = A;
| 112| 114| 
| 113| 115|         vector<long long> res;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 110| 110|     vector<long long> intervalSum(vector<int> &A, vector<Interval> &queries) {
| 111| 111|         nums_ = A;
| 112| 112| 
| 113|    |-        vector<long long> res;
|    | 113|+        vector < long long >res;
| 114| 114| 
| 115|    |-        bit_ = vector<long long>(nums_.size() + 1);
| 116|    |-        for (int i = 1; i < bit_.size(); ++i) {
| 117|    |-            bit_[i] = A[i - 1] + bit_[i - 1];
| 118|    |-        }
| 119|    |-        for (int i = bit_.size() - 1; i >= 1; --i) {
| 120|    |-            int last_i = i - lower_bit(i);
| 121|    |-            bit_[i] -= bit_[last_i];
| 122|    |-        }
|    | 115|+          bit_ = vector < long long >(nums_.size () + 1);
|    | 116|+        for (int i = 1; i < bit_.size (); ++i)
|    | 117|+          {
|    | 118|+              bit_[i] = A[i - 1] + bit_[i - 1];
|    | 119|+          }
|    | 120|+        for (int i = bit_.size () - 1; i >= 1; --i)
|    | 121|+          {
|    | 122|+              int last_i = i - lower_bit (i);
|    | 123|+              bit_[i] -= bit_[last_i];
|    | 124|+          }
| 123| 125| 
| 124|    |-        for (const auto& q : queries) {
| 125|    |-            res.emplace_back(query(q.start, q.end));
| 126|    |-        }
|    | 126|+      for (const auto & q:queries)
|    | 127|+          {
|    | 128|+              res.emplace_back (query (q.start, q.end));
|    | 129|+          }
| 127| 130| 
| 128| 131|         return res;
| 129| 132|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 128| 128|         return res;
| 129| 129|     }
| 130| 130| 
| 131|    |-private:
| 132|    |-    vector<int> nums_;
| 133|    |-    vector<long long> bit_;
|    | 131|+  private:
|    | 132|+    vector < int >nums_;
|    | 133|+    vector < long long >bit_;
| 134| 134| 
| 135|    |-    long long query(int start, int end) {
| 136|    |-        long long sum = sumRegion_bit(end);
| 137|    |-        if (start > 0) {
| 138|    |-            sum -= sumRegion_bit(start - 1);
| 139|    |-        }
|    | 135|+    long long query (int start, int end)
|    | 136|+    {
|    | 137|+        long long sum = sumRegion_bit (end);
|    | 138|+        if (start > 0)
|    | 139|+          {
|    | 140|+              sum -= sumRegion_bit (start - 1);
|    | 141|+          }
| 140| 142|         return sum;
| 141| 143|     }
| 142| 144| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 140| 140|         return sum;
| 141| 141|     }
| 142| 142| 
| 143|    |-    long long sumRegion_bit(long long i) {
|    | 143|+    long long sumRegion_bit (long long i)
|    | 144|+    {
| 144| 145|         ++i;
| 145| 146|         long long sum = 0;
| 146| 147|         for (; i > 0; i -= lower_bit(i)) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 143| 143|     long long sumRegion_bit(long long i) {
| 144| 144|         ++i;
| 145| 145|         long long sum = 0;
| 146|    |-        for (; i > 0; i -= lower_bit(i)) {
| 147|    |-            sum += bit_[i];
| 148|    |-        }
|    | 146|+        for (; i > 0; i -= lower_bit (i))
|    | 147|+          {
|    | 148|+              sum += bit_[i];
|    | 149|+          }
| 149| 150|         return sum;
| 150| 151|     }
| 151| 152| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 149| 149|         return sum;
| 150| 150|     }
| 151| 151| 
| 152|    |-    void add(int i, int val) {
|    | 152|+    void add (int i, int val)
|    | 153|+    {
| 153| 154|         ++i;
| 154|    |-        for (; i <= nums_.size(); i += lower_bit(i)) {
| 155|    |-            bit_[i] += val;
| 156|    |-        }
|    | 155|+        for (; i <= nums_.size (); i += lower_bit (i))
|    | 156|+          {
|    | 157|+              bit_[i] += val;
|    | 158|+          }
| 157| 159|     }
| 158| 160| 
| 159| 161|     int lower_bit(int i) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/interval-sum.cpp
|    |++++| /app/C++/interval-sum.cpp
| 156| 156|         }
| 157| 157|     }
| 158| 158| 
| 159|    |-    int lower_bit(int i) {
|    | 159|+    int lower_bit (int i)
|    | 160|+    {
| 160| 161|         return i & -i;
| 161| 162|     }
| 162| 163| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number.cpp
|    |++++| /app/C++/majority-number.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers
|   8|   9|      * @return: The majority number
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number.cpp
|    |++++| /app/C++/majority-number.cpp
|   7|   7|      * @param nums: A list of integers
|   8|   8|      * @return: The majority number
|   9|   9|      */
|  10|    |-    int majorityNumber(vector<int> nums) {
|    |  10|+    int majorityNumber (vector < int >nums)
|    |  11|+    {
|  11|  12|         int ans = nums[0], cnt = 1;
|  12|    |-        for (const auto& i : nums) {
|  13|    |-            if (i == ans) {
|  14|    |-                ++cnt;
|  15|    |-            } else {
|  16|    |-                --cnt;
|  17|    |-                if (cnt == 0) {
|  18|    |-                    ans = i;
|  19|    |-                    cnt = 1;
|    |  13|+        for (const auto & i:nums)
|    |  14|+          {
|    |  15|+              if (i == ans)
|    |  16|+                {
|    |  17|+                    ++cnt;
|  20|  18|                 }
|  21|    |-            }
|  22|    |-        }
|    |  19|+              else
|    |  20|+                {
|    |  21|+                    --cnt;
|    |  22|+                    if (cnt == 0)
|    |  23|+                      {
|    |  24|+                          ans = i;
|    |  25|+                          cnt = 1;
|    |  26|+                      }
|    |  27|+                }
|    |  28|+          }
|  23|  29|         return ans;
|  24|  30|     }
|  25|  31| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/majority-number.cpp
|    |++++| /app/C++/majority-number.cpp
|  23|  23|         return ans;
|  24|  24|     }
|  25|  25| };
|  26|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-sudoku.cpp
|    |++++| /app/C++/valid-sudoku.cpp
|   1|   1| // Time:  O(9^2)
|   2|   2| // Space: O(9)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param board: the board
|   8|   9|      * @return: wether the Sudoku is valid
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-sudoku.cpp
|    |++++| /app/C++/valid-sudoku.cpp
|   7|   7|      * @param board: the board
|   8|   8|      * @return: wether the Sudoku is valid
|   9|   9|      */
|  10|    |-    bool isValidSudoku(const vector<vector<char>>& board) {
|    |  10|+    bool isValidSudoku (const vector < vector < char >>&board)
|    |  11|+    {
|  11|  12|         // Check row constraints.
|  12|    |-        for (int i = 0; i < board.size(); ++i) {
|  13|    |-            if (anyDuplicate(board, i, i + 1, 0, board.size(), board.size())) {
|  14|    |-                return false;
|  15|    |-            }
|  16|    |-        }
|    |  13|+        for (int i = 0; i < board.size (); ++i)
|    |  14|+          {
|    |  15|+              if (anyDuplicate
|    |  16|+                  (board, i, i + 1, 0, board.size (), board.size ()))
|    |  17|+                {
|    |  18|+                    return false;
|    |  19|+                }
|    |  20|+          }
|  17|  21| 
|  18|  22|         // Check column constraints.
|  19|  23|         for (int j = 0; j < board.size(); ++j) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-sudoku.cpp
|    |++++| /app/C++/valid-sudoku.cpp
|  16|  16|         }
|  17|  17| 
|  18|  18|         // Check column constraints.
|  19|    |-        for (int j = 0; j < board.size(); ++j) {
|  20|    |-            if (anyDuplicate(board, 0, board.size(), j, j + 1, board.size())) {
|  21|    |-                return false;
|  22|    |-            }
|  23|    |-        }
|    |  19|+        for (int j = 0; j < board.size (); ++j)
|    |  20|+          {
|    |  21|+              if (anyDuplicate
|    |  22|+                  (board, 0, board.size (), j, j + 1, board.size ()))
|    |  23|+                {
|    |  24|+                    return false;
|    |  25|+                }
|    |  26|+          }
|  24|  27| 
|  25|  28|         // Check region constraints.
|  26|  29|         int region_size = sqrt(board.size());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-sudoku.cpp
|    |++++| /app/C++/valid-sudoku.cpp
|  23|  23|         }
|  24|  24| 
|  25|  25|         // Check region constraints.
|  26|    |-        int region_size = sqrt(board.size());
|  27|    |-        for (int i = 0; i < region_size; ++i) {
|  28|    |-            for (int j = 0; j < region_size; ++j) {
|  29|    |-                if (anyDuplicate(board, region_size * i, region_size * (i + 1),
|  30|    |-                                 region_size * j, region_size * (j + 1), board.size())) {
|  31|    |-                    return false;
|    |  26|+        int region_size = sqrt (board.size ());
|    |  27|+        for (int i = 0; i < region_size; ++i)
|    |  28|+          {
|    |  29|+              for (int j = 0; j < region_size; ++j)
|    |  30|+                {
|    |  31|+                    if (anyDuplicate
|    |  32|+                        (board, region_size * i, region_size * (i + 1),
|    |  33|+                         region_size * j, region_size * (j + 1),
|    |  34|+                         board.size ()))
|    |  35|+                      {
|    |  36|+                          return false;
|    |  37|+                      }
|  32|  38|                 }
|  33|    |-            }
|  34|    |-        }
|    |  39|+          }
|  35|  40|         return true;
|  36|  41|     }
|  37|  42| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/valid-sudoku.cpp
|    |++++| /app/C++/valid-sudoku.cpp
|  37|  37| 
|  38|  38|     // Return true if subarray board[start_row : end_row - 1][start_col : end_col - 1]
|  39|  39|     // contains any duplicates in [1 : num_elements]; otherwise return false.
|  40|    |-    bool anyDuplicate(const vector<vector<char>>& board, int start_row, int end_row,
|  41|    |-                      int start_col, int end_col, int num_elements) {
|  42|    |-        vector<bool> is_present(num_elements + 1, false);
|  43|    |-        for (int i = start_row; i < end_row; ++i) {
|  44|    |-            for (int j = start_col; j < end_col; ++j) {
|  45|    |-                if (board[i][j] != '.') {
|  46|    |-                    if (is_present[board[i][j] - '0']) {
|  47|    |-                        return true;
|  48|    |-                    }
|  49|    |-                    is_present[board[i][j] - '0'] = true;
|    |  40|+    bool anyDuplicate (const vector < vector < char >>&board, int start_row,
|    |  41|+                       int end_row, int start_col, int end_col,
|    |  42|+                       int num_elements)
|    |  43|+    {
|    |  44|+        vector < bool > is_present (num_elements + 1, false);
|    |  45|+        for (int i = start_row; i < end_row; ++i)
|    |  46|+          {
|    |  47|+              for (int j = start_col; j < end_col; ++j)
|    |  48|+                {
|    |  49|+                    if (board[i][j] != '.')
|    |  50|+                      {
|    |  51|+                          if (is_present[board[i][j] - '0'])
|    |  52|+                            {
|    |  53|+                                return true;
|    |  54|+                            }
|    |  55|+                          is_present[board[i][j] - '0'] = true;
|    |  56|+                      }
|  50|  57|                 }
|  51|    |-            }
|  52|    |-        }
|    |  58|+          }
|  53|  59|         return false;
|  54|  60|     }
|  55|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-nested-list-iterator.cpp
|    |++++| /app/C++/flatten-nested-list-iterator.cpp
|  21|  21|  *     const vector<NestedInteger> &getList() const;
|  22|  22|  * };
|  23|  23|  */
|  24|    |-class NestedIterator {
|  25|    |-public:
|  26|    |-    using IT = vector<NestedInteger>::const_iterator;
|  27|    |-    NestedIterator(vector<NestedInteger> &nestedList) {
|  28|    |-        depth_.emplace(nestedList.cbegin(), nestedList.cend());
|    |  24|+class NestedIterator
|    |  25|+{
|    |  26|+  public:
|    |  27|+    using IT = vector < NestedInteger >::const_iterator;
|    |  28|+    NestedIterator (vector < NestedInteger > &nestedList)
|    |  29|+    {
|    |  30|+        depth_.emplace (nestedList.cbegin (), nestedList.cend ());
|  29|  31|     }
|  30|  32| 
|  31|  33|     // @return {int} the next element in the iteration
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-nested-list-iterator.cpp
|    |++++| /app/C++/flatten-nested-list-iterator.cpp
|  29|  29|     }
|  30|  30| 
|  31|  31|     // @return {int} the next element in the iteration
|  32|    |-    int next() {
|  33|    |-        return (depth_.top().first++)->getInteger();
|    |  32|+    int next ()
|    |  33|+    {
|    |  34|+        return (depth_.top ().first++)->getInteger ();
|  34|  35|     }
|  35|    |-    
|    |  36|+
|  36|  37|     // @return {boolean} true if the iteration has more element or false
|  37|    |-    bool hasNext() {
|  38|    |-        while (!depth_.empty()) {
|  39|    |-            auto& cur = depth_.top();
|  40|    |-            if (cur.first == cur.second) {
|  41|    |-                depth_.pop();
|  42|    |-            } else if (cur.first->isInteger()) {
|  43|    |-                return true;
|  44|    |-            } else {
|  45|    |-                auto& nestedList = cur.first->getList();
|  46|    |-                ++cur.first;
|  47|    |-                depth_.emplace(nestedList.cbegin(), nestedList.cend());
|  48|    |-            }
|  49|    |-        }
|    |  38|+    bool hasNext ()
|    |  39|+    {
|    |  40|+        while (!depth_.empty ())
|    |  41|+          {
|    |  42|+              auto & cur = depth_.top ();
|    |  43|+              if (cur.first == cur.second)
|    |  44|+                {
|    |  45|+                    depth_.pop ();
|    |  46|+                }
|    |  47|+              else if (cur.first->isInteger ())
|    |  48|+                {
|    |  49|+                    return true;
|    |  50|+                }
|    |  51|+              else
|    |  52|+                {
|    |  53|+                    auto & nestedList = cur.first->getList ();
|    |  54|+                    ++cur.first;
|    |  55|+                    depth_.emplace (nestedList.cbegin (), nestedList.cend ());
|    |  56|+                }
|    |  57|+          }
|  50|  58|         return false;
|  51|  59|     }
|  52|  60| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-nested-list-iterator.cpp
|    |++++| /app/C++/flatten-nested-list-iterator.cpp
|  50|  50|         return false;
|  51|  51|     }
|  52|  52| 
|  53|    |-private:
|  54|    |-    stack<pair<IT, IT>> depth_;
|    |  53|+  private:
|    |  54|+    stack < pair < IT, IT >> depth_;
|  55|  55| };
|  56|  56| 
|  57|  57| /**
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/flatten-nested-list-iterator.cpp
|    |++++| /app/C++/flatten-nested-list-iterator.cpp
|  59|  59|  * NestedIterator i(nestedList);
|  60|  60|  * while (i.hasNext()) v.push_back(i.next());
|  61|  61|  */
|  62|    |- 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16|  // Merge two by two solution.
|  17|    |-class Solution {
|  18|    |-public:
|    |  17|+class Solution
|    |  18|+{
|    |  19|+  public:
|  19|  20|     /**
|  20|  21|      * @param lists: a list of ListNode
|  21|  22|      * @return: The head of one sorted list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  20|  20|      * @param lists: a list of ListNode
|  21|  21|      * @return: The head of one sorted list.
|  22|  22|      */
|  23|    |-    ListNode *mergeKLists(vector<ListNode *> &lists) {
|  24|    |-        if (lists.empty()) {
|  25|    |-            return nullptr;
|  26|    |-        }
|    |  23|+    ListNode * mergeKLists (vector < ListNode * >&lists)
|    |  24|+    {
|    |  25|+        if (lists.empty ())
|    |  26|+          {
|    |  27|+              return nullptr;
|    |  28|+          }
|  27|  29| 
|  28|    |-        int left = 0, right = lists.size() - 1;
|  29|    |-        while (right > 0) {
|  30|    |-            if (left >= right) {
|  31|    |-                left = 0;
|  32|    |-            } else {
|  33|    |-                lists[left] = mergeTwoLists(lists[left], lists[right]);
|  34|    |-                ++left;
|  35|    |-                --right;
|  36|    |-            }
|  37|    |-        }
|    |  30|+        int left = 0, right = lists.size () - 1;
|    |  31|+        while (right > 0)
|    |  32|+          {
|    |  33|+              if (left >= right)
|    |  34|+                {
|    |  35|+                    left = 0;
|    |  36|+                }
|    |  37|+              else
|    |  38|+                {
|    |  39|+                    lists[left] = mergeTwoLists (lists[left], lists[right]);
|    |  40|+                    ++left;
|    |  41|+                    --right;
|    |  42|+                }
|    |  43|+          }
|  38|  44|         return lists[0];
|  39|  45|     }
|  40|  46|     
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  37|  37|         }
|  38|  38|         return lists[0];
|  39|  39|     }
|  40|    |-    
|  41|    |-private:
|  42|    |-    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
|  43|    |-        ListNode dummy{0};
|    |  40|+
|    |  41|+  private:
|    |  42|+    ListNode * mergeTwoLists (ListNode * l1, ListNode * l2)
|    |  43|+    {
|    |  44|+        ListNode dummy
|    |  45|+        {
|    |  46|+        0};
|  44|  47|         auto curr = &dummy;
|  45|  48| 
|  46|  49|         while (l1 && l2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  43|  43|         ListNode dummy{0};
|  44|  44|         auto curr = &dummy;
|  45|  45| 
|  46|    |-        while (l1 && l2) {
|  47|    |-            if (l1->val <= l2->val) {
|  48|    |-                curr->next = l1;
|  49|    |-                l1 = l1->next;
|  50|    |-            } else {
|  51|    |-                curr->next = l2;
|  52|    |-                l2 = l2->next;
|  53|    |-            }
|  54|    |-            curr = curr->next;
|  55|    |-        }
|    |  46|+        while (l1 && l2)
|    |  47|+          {
|    |  48|+              if (l1->val <= l2->val)
|    |  49|+                {
|    |  50|+                    curr->next = l1;
|    |  51|+                    l1 = l1->next;
|    |  52|+                }
|    |  53|+              else
|    |  54|+                {
|    |  55|+                    curr->next = l2;
|    |  56|+                    l2 = l2->next;
|    |  57|+                }
|    |  58|+              curr = curr->next;
|    |  59|+          }
|  56|  60|         curr->next = l1 ? l1 : l2;
|  57|  61| 
|  58|  62|         return dummy.next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  58|  58|         return dummy.next;
|  59|  59|     }
|  60|  60| };
|  61|    |-
|  62|  61| 
|  63|  62| // Time:  O(n * logk)
|  64|  63| // Space: O(logk)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  63|  63| // Time:  O(n * logk)
|  64|  64| // Space: O(logk)
|  65|  65| // Divide and Conquer solution.
|  66|    |-class Solution2 {
|  67|    |-public:
|    |  66|+class Solution2
|    |  67|+{
|    |  68|+  public:
|  68|  69|     /**
|  69|  70|      * @param lists: a list of ListNode
|  70|  71|      * @return: The head of one sorted list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  69|  69|      * @param lists: a list of ListNode
|  70|  70|      * @return: The head of one sorted list.
|  71|  71|      */
|  72|    |-    ListNode *mergeKLists(vector<ListNode *> &lists) {
|  73|    |-        return mergeKListsHelper(lists, 0, lists.size() - 1);
|    |  72|+    ListNode * mergeKLists (vector < ListNode * >&lists)
|    |  73|+    {
|    |  74|+        return mergeKListsHelper (lists, 0, lists.size () - 1);
|  74|  75|     }
|  75|  76| 
|  76|  77| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  73|  73|         return mergeKListsHelper(lists, 0, lists.size() - 1);
|  74|  74|     }
|  75|  75| 
|  76|    |-private:
|  77|    |-    ListNode *mergeKListsHelper(const vector<ListNode *> &lists,
|  78|    |-                                int begin, int end) {
|  79|    |-        if (begin > end) {
|  80|    |-            return nullptr;
|  81|    |-        }
|  82|    |-        if (begin == end) {
|  83|    |-            return lists[begin];
|  84|    |-        }
|  85|    |-        return mergeTwoLists(
|  86|    |-                   mergeKListsHelper(lists, begin, (begin + end) / 2),
|  87|    |-                   mergeKListsHelper(lists, (begin + end) / 2 + 1, end));
|    |  76|+  private:
|    |  77|+      ListNode * mergeKListsHelper (const vector < ListNode * >&lists,
|    |  78|+                                    int begin, int end)
|    |  79|+    {
|    |  80|+        if (begin > end)
|    |  81|+          {
|    |  82|+              return nullptr;
|    |  83|+          }
|    |  84|+        if (begin == end)
|    |  85|+          {
|    |  86|+              return lists[begin];
|    |  87|+          }
|    |  88|+        return
|    |  89|+            mergeTwoLists (mergeKListsHelper (lists, begin, (begin + end) / 2),
|    |  90|+                           mergeKListsHelper (lists, (begin + end) / 2 + 1,
|    |  91|+                                              end));
|  88|  92|     }
|  89|  93| 
|  90|  94|     ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  87|  87|                    mergeKListsHelper(lists, (begin + end) / 2 + 1, end));
|  88|  88|     }
|  89|  89| 
|  90|    |-    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
|  91|    |-        ListNode dummy{0};
|    |  90|+    ListNode *mergeTwoLists (ListNode * l1, ListNode * l2)
|    |  91|+    {
|    |  92|+        ListNode dummy
|    |  93|+        {
|    |  94|+        0};
|  92|  95|         auto curr = &dummy;
|  93|  96| 
|  94|  97|         while (l1 && l2) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
|  91|  91|         ListNode dummy{0};
|  92|  92|         auto curr = &dummy;
|  93|  93| 
|  94|    |-        while (l1 && l2) {
|  95|    |-            if (l1->val <= l2->val) {
|  96|    |-                curr->next = l1;
|  97|    |-                l1 = l1->next;
|  98|    |-            } else {
|  99|    |-                curr->next = l2;
| 100|    |-                l2 = l2->next;
| 101|    |-            }
| 102|    |-            curr = curr->next;
| 103|    |-        }
|    |  94|+        while (l1 && l2)
|    |  95|+          {
|    |  96|+              if (l1->val <= l2->val)
|    |  97|+                {
|    |  98|+                    curr->next = l1;
|    |  99|+                    l1 = l1->next;
|    | 100|+                }
|    | 101|+              else
|    | 102|+                {
|    | 103|+                    curr->next = l2;
|    | 104|+                    l2 = l2->next;
|    | 105|+                }
|    | 106|+              curr = curr->next;
|    | 107|+          }
| 104| 108|         curr->next = l1 ? l1 : l2;
| 105| 109| 
| 106| 110|         return dummy.next;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
| 107| 107|     }
| 108| 108| };
| 109| 109| 
| 110|    |-
| 111| 110| // Time:  O(n * logk)
| 112| 111| // Space: O(k)
| 113| 112| // Heap solution.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
| 111| 111| // Time:  O(n * logk)
| 112| 112| // Space: O(k)
| 113| 113| // Heap solution.
| 114|    |-class Solution3 {
| 115|    |-public:
|    | 114|+class Solution3
|    | 115|+{
|    | 116|+  public:
| 116| 117|     /**
| 117| 118|      * @param lists: a list of ListNode
| 118| 119|      * @return: The head of one sorted list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
| 117| 117|      * @param lists: a list of ListNode
| 118| 118|      * @return: The head of one sorted list.
| 119| 119|      */
| 120|    |-    ListNode *mergeKLists(vector<ListNode *> &lists) {
| 121|    |-        ListNode dummy(0);
|    | 120|+    ListNode * mergeKLists (vector < ListNode * >&lists)
|    | 121|+    {
|    | 122|+        ListNode dummy (0);
| 122| 123|         auto *cur = &dummy;
| 123| 124| 
| 124| 125|         struct Compare {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
| 121| 121|         ListNode dummy(0);
| 122| 122|         auto *cur = &dummy;
| 123| 123| 
| 124|    |-        struct Compare {
| 125|    |-            bool operator() (const ListNode *a, const ListNode *b) {
|    | 124|+        struct Compare
|    | 125|+        {
|    | 126|+            bool operator () (const ListNode * a, const ListNode * b)
|    | 127|+            {
| 126| 128|                 return a->val > b->val;
| 127| 129|             }
| 128| 130|         };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/merge-k-sorted-lists.cpp
|    |++++| /app/C++/merge-k-sorted-lists.cpp
| 128| 128|         };
| 129| 129| 
| 130| 130|         // Use min heap to keep the smallest node of each list
| 131|    |-        priority_queue<ListNode *, vector<ListNode *>, Compare> min_heap;
| 132|    |-        for (const auto& n : lists) {
| 133|    |-            if (n != nullptr) {
| 134|    |-                min_heap.emplace(n);
| 135|    |-            }
| 136|    |-        }
|    | 131|+        priority_queue < ListNode *, vector < ListNode * >, Compare > min_heap;
|    | 132|+      for (const auto & n:lists)
|    | 133|+          {
|    | 134|+              if (n != nullptr)
|    | 135|+                {
|    | 136|+                    min_heap.emplace (n);
|    | 137|+                }
|    | 138|+          }
| 137| 139| 
| 138|    |-        while (!min_heap.empty()) {
| 139|    |-            // Get min of k lists.
| 140|    |-            ListNode *node = min_heap.top();
| 141|    |-            min_heap.pop();
| 142|    |-            cur->next = node;
| 143|    |-            cur = cur->next;
| 144|    |-            if (node->next != nullptr) {
| 145|    |-                min_heap.emplace(node->next);
| 146|    |-            }
| 147|    |-        }
|    | 140|+        while (!min_heap.empty ())
|    | 141|+          {
|    | 142|+              // Get min of k lists.
|    | 143|+              ListNode *node = min_heap.top ();
|    | 144|+              min_heap.pop ();
|    | 145|+              cur->next = node;
|    | 146|+              cur = cur->next;
|    | 147|+              if (node->next != nullptr)
|    | 148|+                {
|    | 149|+                    min_heap.emplace (node->next);
|    | 150|+                }
|    | 151|+          }
| 148| 152| 
| 149| 153|         return dummy.next;
| 150| 154|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/distinct-subsequences.cpp
|    |++++| /app/C++/distinct-subsequences.cpp
|   2|   2| // Space: O(m)
|   3|   3| 
|   4|   4| // DP with rolling window.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param S, T: Two string.
|   9|  10|      * @return: Count the number of distinct subsequences
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/distinct-subsequences.cpp
|    |++++| /app/C++/distinct-subsequences.cpp
|   8|   8|      * @param S, T: Two string.
|   9|   9|      * @return: Count the number of distinct subsequences
|  10|  10|      */
|  11|    |-    int numDistinct(string &S, string &T) {
|  12|    |-        vector<vector<int>> ways(2, vector<int>(T.length() + 1, 0));
|    |  11|+    int numDistinct (string & S, string & T)
|    |  12|+    {
|    |  13|+        vector < vector < int >>ways (2, vector < int >(T.length () + 1, 0));
|  13|  14|         // ways[i][j] means number of distinct subsequence of S[0, i] with T[0, j]
|  14|    |-        ways[0][0] = 1;
|  15|    |-        for (int i = 0; i < S.length(); ++i) {
|  16|    |-            ways[(i + 1) % 2][0] = ways[i % 2][0];
|  17|    |-            for (int j = 0; j < T.length(); ++j) {
|  18|    |-                ways[(i + 1) % 2][j + 1] = S[i] == T[j]?
|  19|    |-                                                ways[i % 2][j + 1] + ways[i % 2][j] :
|  20|    |-                                                ways[i % 2][j + 1];
|    |  15|+          ways[0][0] = 1;
|    |  16|+        for (int i = 0; i < S.length (); ++i)
|    |  17|+          {
|    |  18|+              ways[(i + 1) % 2][0] = ways[i % 2][0];
|    |  19|+              for (int j = 0; j < T.length (); ++j)
|    |  20|+                {
|    |  21|+                    ways[(i + 1) % 2][j + 1] = S[i] == T[j] ?
|    |  22|+                        ways[i % 2][j + 1] + ways[i % 2][j] :
|    |  23|+                        ways[i % 2][j + 1];
|  21|  24| 
|  22|    |-            }
|  23|    |-        }
|  24|    |-        return ways[S.length() % 2][T.length()];
|    |  25|+                }
|    |  26|+          }
|    |  27|+        return ways[S.length () % 2][T.length ()];
|  25|  28|     }
|  26|  29| };
|  27|  30| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/distinct-subsequences.cpp
|    |++++| /app/C++/distinct-subsequences.cpp
|  28|  28| // Time:  O(m * n)
|  29|  29| // Space: O(m * n)
|  30|  30| // DP
|  31|    |-class Solution2 {
|  32|    |-public:
|    |  31|+class Solution2
|    |  32|+{
|    |  33|+  public:
|  33|  34|     /**
|  34|  35|      * @param S, T: Two string.
|  35|  36|      * @return: Count the number of distinct subsequences
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/distinct-subsequences.cpp
|    |++++| /app/C++/distinct-subsequences.cpp
|  34|  34|      * @param S, T: Two string.
|  35|  35|      * @return: Count the number of distinct subsequences
|  36|  36|      */
|  37|    |-    int numDistinct(string &S, string &T) {
|  38|    |-        vector<vector<int>> ways(S.length() + 1, vector<int>(T.length() + 1, 0));
|    |  37|+    int numDistinct (string & S, string & T)
|    |  38|+    {
|    |  39|+        vector < vector < int >>ways (S.length () + 1,
|    |  40|+                                      vector < int >(T.length () + 1, 0));
|  39|  41|         // ways[i][j] means number of distinct subsequence of S[0, i] with T[0, j]
|  40|    |-        ways[0][0] = 1;
|  41|    |-        for (int i = 0; i < S.length(); ++i) {
|  42|    |-            ways[i + 1][0] = ways[i][0];
|  43|    |-            for (int j = 0; j < T.length(); ++j) {
|  44|    |-                ways[i + 1][j + 1] = S[i] == T[j]?
|  45|    |-                                          ways[i][j + 1] + ways[i][j] :
|  46|    |-                                          ways[i][j + 1];
|    |  42|+          ways[0][0] = 1;
|    |  43|+        for (int i = 0; i < S.length (); ++i)
|    |  44|+          {
|    |  45|+              ways[i + 1][0] = ways[i][0];
|    |  46|+              for (int j = 0; j < T.length (); ++j)
|    |  47|+                {
|    |  48|+                    ways[i + 1][j + 1] = S[i] == T[j] ?
|    |  49|+                        ways[i][j + 1] + ways[i][j] : ways[i][j + 1];
|  47|  50| 
|  48|    |-            }
|  49|    |-        }
|  50|    |-        return ways[S.length()][T.length()];
|    |  51|+                }
|    |  52|+          }
|    |  53|+        return ways[S.length ()][T.length ()];
|  51|  54|     }
|  52|  55| };
|  53|  56| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/distinct-subsequences.cpp
|    |++++| /app/C++/distinct-subsequences.cpp
|  50|  50|         return ways[S.length()][T.length()];
|  51|  51|     }
|  52|  52| };
|  53|    |-
|  54|    |-
|  55|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-letters-by-case.cpp
|    |++++| /app/C++/sort-letters-by-case.cpp
|   1|   1| // Time:   O(n)
|   2|   2| // Spacee: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /** 
|   7|   8|      * @param chars: The letters array you should sort.
|   8|   9|      */
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-letters-by-case.cpp
|    |++++| /app/C++/sort-letters-by-case.cpp
|   6|   6|     /** 
|   7|   7|      * @param chars: The letters array you should sort.
|   8|   8|      */
|   9|    |-    void sortLetters(string &letters) {
|  10|    |-        int left = 0, right = letters.size() - 1;
|    |   9|+    void sortLetters (string & letters)
|    |  10|+    {
|    |  11|+        int left = 0, right = letters.size () - 1;
|  11|  12| 
|  12|    |-        while (left < right) {
|  13|    |-            if (isupper(letters[left])) {
|  14|    |-                swap(letters[left], letters[right]);
|  15|    |-                --right;
|  16|    |-            } else {
|  17|    |-                ++left;
|  18|    |-            }
|  19|    |-        }
|    |  13|+        while (left < right)
|    |  14|+          {
|    |  15|+              if (isupper (letters[left]))
|    |  16|+                {
|    |  17|+                    swap (letters[left], letters[right]);
|    |  18|+                    --right;
|    |  19|+                }
|    |  20|+              else
|    |  21|+                {
|    |  22|+                    ++left;
|    |  23|+                }
|    |  24|+          }
|  20|  25|     }
|  21|  26| };
|  22|  27| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-letters-by-case.cpp
|    |++++| /app/C++/sort-letters-by-case.cpp
|  19|  19|         }
|  20|  20|     }
|  21|  21| };
|  22|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-window-substring.cpp
|    |++++| /app/C++/minimum-window-substring.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:    
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param source: A string
|   8|   9|      * @param target: A string
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-window-substring.cpp
|    |++++| /app/C++/minimum-window-substring.cpp
|   9|   9|      * @return: A string denote the minimum window
|  10|  10|      *          Return "" if there is no such a string
|  11|  11|      */
|  12|    |-    string minWindow(string &source, string &target) {
|  13|    |-        if (source.empty() || source.length() < target.length()) {
|  14|    |-            return "";
|  15|    |-        }
|    |  12|+    string minWindow (string & source, string & target)
|    |  13|+    {
|    |  14|+        if (source.empty () || source.length () < target.length ())
|    |  15|+          {
|    |  16|+              return "";
|    |  17|+          }
|  16|  18| 
|  17|  19|         const int ASCII_MAX = 256;
|  18|  20| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-window-substring.cpp
|    |++++| /app/C++/minimum-window-substring.cpp
|  16|  16| 
|  17|  17|         const int ASCII_MAX = 256;
|  18|  18| 
|  19|    |-        vector<int> exp_cnt(ASCII_MAX, 0);
|  20|    |-        vector<int> cur_cnt(ASCII_MAX, 0);
|    |  19|+        vector < int >exp_cnt (ASCII_MAX, 0);
|    |  20|+        vector < int >cur_cnt (ASCII_MAX, 0);
|  21|  21| 
|  22|  22|         int cnt = 0;
|  23|  23|         int start = 0;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-window-substring.cpp
|    |++++| /app/C++/minimum-window-substring.cpp
|  22|  22|         int cnt = 0;
|  23|  23|         int start = 0;
|  24|  24|         int min_start = 0;
|  25|    |-        int min_width = numeric_limits<int>::max();
|    |  25|+        int min_width = numeric_limits < int >::max ();
|  26|  26| 
|  27|    |-        for (const auto& c : target) {
|  28|    |-            ++exp_cnt[c];
|  29|    |-        }
|    |  27|+      for (const auto & c:target)
|    |  28|+          {
|    |  29|+              ++exp_cnt[c];
|    |  30|+          }
|  30|  31| 
|  31|    |-        for (int i = 0; i < source.length(); ++i) {
|  32|    |-            if (exp_cnt[source[i]] > 0) {
|  33|    |-                ++cur_cnt[source[i]];
|  34|    |-                if (cur_cnt[source[i]] <= exp_cnt[source[i]]) {  // Counting expected elements.
|  35|    |-                    ++cnt;
|    |  32|+        for (int i = 0; i < source.length (); ++i)
|    |  33|+          {
|    |  34|+              if (exp_cnt[source[i]] > 0)
|    |  35|+                {
|    |  36|+                    ++cur_cnt[source[i]];
|    |  37|+                    if (cur_cnt[source[i]] <= exp_cnt[source[i]])
|    |  38|+                      {         // Counting expected elements.
|    |  39|+                          ++cnt;
|    |  40|+                      }
|  36|  41|                 }
|  37|    |-            }
|  38|    |-            if (cnt == target.size()) {  // If window meets the requirement.
|  39|    |-                while (exp_cnt[source[start]] == 0 ||  // Adjust left bound of window.
|  40|    |-                       cur_cnt[source[start]] > exp_cnt[source[start]]) {
|  41|    |-                    --cur_cnt[source[start]];
|  42|    |-                    ++start;
|    |  42|+              if (cnt == target.size ())
|    |  43|+                {               // If window meets the requirement.
|    |  44|+                    while (exp_cnt[source[start]] == 0 ||   // Adjust left bound of window.
|    |  45|+                           cur_cnt[source[start]] > exp_cnt[source[start]])
|    |  46|+                      {
|    |  47|+                          --cur_cnt[source[start]];
|    |  48|+                          ++start;
|    |  49|+                      }
|    |  50|+
|    |  51|+                    if (min_width > i - start + 1)
|    |  52|+                      {         // Update minimum window.
|    |  53|+                          min_width = i - start + 1;
|    |  54|+                          min_start = start;
|    |  55|+                      }
|  43|  56|                 }
|    |  57|+          }
|  44|  58| 
|  45|    |-                if (min_width > i - start + 1) {  // Update minimum window.
|  46|    |-                    min_width = i - start + 1;
|  47|    |-                    min_start = start;
|  48|    |-                }
|  49|    |-            }
|  50|    |-        }
|    |  59|+        if (min_width == numeric_limits < int >::max ())
|    |  60|+          {
|    |  61|+              return "";
|    |  62|+          }
|  51|  63| 
|  52|    |-        if (min_width == numeric_limits<int>::max()) {
|  53|    |-            return "";
|  54|    |-        }
|  55|    |-
|  56|    |-        return source.substr(min_start, min_width);
|    |  64|+        return source.substr (min_start, min_width);
|  57|  65|     }
|  58|  66| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-subsequence.cpp
|    |++++| /app/C++/longest-common-subsequence.cpp
|   1|   1| // Time:  O(m * n)
|   2|   2| // Space: O(min(m, n))
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A, B: Two strings.
|   8|   9|      * @return: The length of longest common subsequence of A and B.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-subsequence.cpp
|    |++++| /app/C++/longest-common-subsequence.cpp
|   7|   7|      * @param A, B: Two strings.
|   8|   8|      * @return: The length of longest common subsequence of A and B.
|   9|   9|      */
|  10|    |-    int longestCommonSubsequence(string A, string B) {
|  11|    |-        if (A.length() < B.length()) {
|  12|    |-            return longestCommonSubsequence(B, A);
|  13|    |-        }
|    |  10|+    int longestCommonSubsequence (string A, string B)
|    |  11|+    {
|    |  12|+        if (A.length () < B.length ())
|    |  13|+          {
|    |  14|+              return longestCommonSubsequence (B, A);
|    |  15|+          }
|  14|  16| 
|  15|  17|         // table[i][j] means the longest length of common subsequence
|  16|  18|         // of A[0 : i] and B[0 : j].
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-subsequence.cpp
|    |++++| /app/C++/longest-common-subsequence.cpp
|  14|  14| 
|  15|  15|         // table[i][j] means the longest length of common subsequence
|  16|  16|         // of A[0 : i] and B[0 : j].
|  17|    |-        vector<vector<int>> table(2, vector<int>(A.length() + 1, 0));
|    |  17|+        vector < vector < int >>table (2, vector < int >(A.length () + 1, 0));
|  18|  18| 
|  19|  19|         // if A[i - 1] != B[j - 1]:
|  20|  20|         //     table[i][j] = max(table[i - 1][j], table[i][j - 1])
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-subsequence.cpp
|    |++++| /app/C++/longest-common-subsequence.cpp
|  20|  20|         //     table[i][j] = max(table[i - 1][j], table[i][j - 1])
|  21|  21|         // if A[i - 1] == B[j - 1]:
|  22|  22|         //     table[i][j] = table[i - 1][j - 1] + 1
|  23|    |-        for (int i = 1; i < A.length() + 1; ++i) {
|  24|    |-            for (int j = 1; j < B.length() + 1; ++j) {
|  25|    |-                if (A[i - 1] != B[j - 1]) {
|  26|    |-                    table[i % 2][j] = max(table[(i - 1) % 2][j],
|  27|    |-                                       table[i % 2][j - 1]);
|  28|    |-                } else {
|  29|    |-                    table[i % 2][j] = table[(i - 1) % 2][j - 1] + 1;
|    |  23|+        for (int i = 1; i < A.length () + 1; ++i)
|    |  24|+          {
|    |  25|+              for (int j = 1; j < B.length () + 1; ++j)
|    |  26|+                {
|    |  27|+                    if (A[i - 1] != B[j - 1])
|    |  28|+                      {
|    |  29|+                          table[i % 2][j] = max (table[(i - 1) % 2][j],
|    |  30|+                                                 table[i % 2][j - 1]);
|    |  31|+                      }
|    |  32|+                    else
|    |  33|+                      {
|    |  34|+                          table[i % 2][j] = table[(i - 1) % 2][j - 1] + 1;
|    |  35|+                      }
|  30|  36|                 }
|  31|    |-            }
|  32|    |-        }
|    |  37|+          }
|  33|  38| 
|  34|    |-        return table[A.length() % 2][B.length()];
|    |  39|+        return table[A.length () % 2][B.length ()];
|  35|  40|     }
|  36|  41| };
|  37|  42| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-common-subsequence.cpp
|    |++++| /app/C++/longest-common-subsequence.cpp
|  34|  34|         return table[A.length() % 2][B.length()];
|  35|  35|     }
|  36|  36| };
|  37|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|   2|   2| // Space: O(m)
|   3|   3| 
|   4|   4| // DP Solution with rolling window
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param s: A string
|   9|  10|      * @param p: A string includes "?" and "*"
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|   9|   9|      * @param p: A string includes "?" and "*"
|  10|  10|      * @return: A boolean
|  11|  11|      */
|  12|    |-    bool isMatch(const char *s, const char *p) {
|  13|    |-        const size_t s_len = strlen(s);
|  14|    |-        const size_t p_len = strlen(p);
|    |  12|+    bool isMatch (const char *s, const char *p)
|    |  13|+    {
|    |  14|+        const size_t s_len = strlen (s);
|    |  15|+        const size_t p_len = strlen (p);
|  15|  16| 
|  16|  17|         // match[i][j] denotes as:
|  17|  18|         // s[0, i - 1] matches p[0, j - 1] or not.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  15|  15| 
|  16|  16|         // match[i][j] denotes as:
|  17|  17|         // s[0, i - 1] matches p[0, j - 1] or not.
|  18|    |-        vector<vector<bool>> match(s_len + 1, vector<bool>(p_len + 1));
|    |  18|+          vector < vector < bool >> match (s_len + 1,
|    |  19|+                                           vector < bool > (p_len + 1));
|  19|  20| 
|  20|    |-        match[0][0] = true;
|  21|    |-        for (int i = 2; i <= p_len; ++i) {
|  22|    |-            if (p[i - 1] == '*') {
|  23|    |-                match[0 % 2][i] = match[0 % 2][i - 2];
|  24|    |-            }
|  25|    |-        }
|    |  21|+          match[0][0] = true;
|    |  22|+        for (int i = 2; i <= p_len; ++i)
|    |  23|+          {
|    |  24|+              if (p[i - 1] == '*')
|    |  25|+                {
|    |  26|+                    match[0 % 2][i] = match[0 % 2][i - 2];
|    |  27|+                }
|    |  28|+          }
|  26|  29| 
|  27|    |-        for (int i = 1; i <= s_len; ++i) {
|  28|    |-            match[i % 2][0] = false;
|  29|    |-            for (int j = 1; j <= p_len; ++j) {
|  30|    |-                if (p[j - 1] != '*') {
|  31|    |-                    match[i % 2][j] = match[(i - 1) % 2][j - 1] && (p[j - 1] == s[i - 1] || p[j - 1] == '.');
|  32|    |-                } else {
|  33|    |-                    match[i % 2][j] = j >= 2 && (match[i % 2][j - 2] || (match[(i - 1) % 2][j] && (p[j - 2] == s[i - 1] || p[j - 2]=='.')));
|    |  30|+        for (int i = 1; i <= s_len; ++i)
|    |  31|+          {
|    |  32|+              match[i % 2][0] = false;
|    |  33|+              for (int j = 1; j <= p_len; ++j)
|    |  34|+                {
|    |  35|+                    if (p[j - 1] != '*')
|    |  36|+                      {
|    |  37|+                          match[i % 2][j] = match[(i - 1) % 2][j - 1]
|    |  38|+                              && (p[j - 1] == s[i - 1] || p[j - 1] == '.');
|    |  39|+                      }
|    |  40|+                    else
|    |  41|+                      {
|    |  42|+                          match[i % 2][j] = j >= 2 && (match[i % 2][j - 2]
|    |  43|+                                                       ||
|    |  44|+                                                       (match[(i - 1) % 2][j]
|    |  45|+                                                        && (p[j - 2] ==
|    |  46|+                                                            s[i - 1]
|    |  47|+                                                            || p[j - 2] ==
|    |  48|+                                                            '.')));
|    |  49|+                      }
|  34|  50|                 }
|  35|    |-            }
|  36|    |-        }
|    |  51|+          }
|  37|  52|         return match[s_len % 2][p_len];
|  38|  53|     }
|  39|  54| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  41|  41| // Time:  O(m * n)
|  42|  42| // Space: O(m * n)
|  43|  43| // DP Solution
|  44|    |-class Solution2 {
|  45|    |-public:
|    |  44|+class Solution2
|    |  45|+{
|    |  46|+  public:
|  46|  47|     /**
|  47|  48|      * @param s: A string
|  48|  49|      * @param p: A string includes "?" and "*"
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  48|  48|      * @param p: A string includes "?" and "*"
|  49|  49|      * @return: A boolean
|  50|  50|      */
|  51|    |-    bool isMatch(const char *s, const char *p) {
|  52|    |-        const size_t s_len = strlen(s);
|  53|    |-        const size_t p_len = strlen(p);
|    |  51|+    bool isMatch (const char *s, const char *p)
|    |  52|+    {
|    |  53|+        const size_t s_len = strlen (s);
|    |  54|+        const size_t p_len = strlen (p);
|  54|  55| 
|  55|  56|         // match[i][j] denotes as:
|  56|  57|         // s[0, i - 1] matches p[0, j - 1] or not.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  54|  54| 
|  55|  55|         // match[i][j] denotes as:
|  56|  56|         // s[0, i - 1] matches p[0, j - 1] or not.
|  57|    |-        vector<vector<bool>> match(s_len + 1, vector<bool>(p_len + 1));
|    |  57|+          vector < vector < bool >> match (s_len + 1,
|    |  58|+                                           vector < bool > (p_len + 1));
|  58|  59| 
|  59|    |-        match[0][0] = true;
|  60|    |-        for (int i = 2; i <= p_len; ++i) {
|  61|    |-            if (p[i - 1] == '*') {
|  62|    |-                match[0][i] = match[0][i - 2];
|  63|    |-            }
|  64|    |-        }
|    |  60|+          match[0][0] = true;
|    |  61|+        for (int i = 2; i <= p_len; ++i)
|    |  62|+          {
|    |  63|+              if (p[i - 1] == '*')
|    |  64|+                {
|    |  65|+                    match[0][i] = match[0][i - 2];
|    |  66|+                }
|    |  67|+          }
|  65|  68| 
|  66|    |-        for (int i = 1; i <= s_len; ++i) {
|  67|    |-            match[i][0] = false;
|  68|    |-            for (int j = 1; j <= p_len; ++j) {
|  69|    |-                if (p[j - 1] != '*') {
|  70|    |-                    match[i][j] = match[i - 1][j - 1] && (p[j - 1] == s[i - 1] || p[j - 1] == '.');
|  71|    |-                } else {
|  72|    |-                    match[i][j] = j >= 2 && (match[i][j - 2] || (match[i - 1][j] && (p[j - 2] == s[i - 1] || p[j - 2] == '.')));
|    |  69|+        for (int i = 1; i <= s_len; ++i)
|    |  70|+          {
|    |  71|+              match[i][0] = false;
|    |  72|+              for (int j = 1; j <= p_len; ++j)
|    |  73|+                {
|    |  74|+                    if (p[j - 1] != '*')
|    |  75|+                      {
|    |  76|+                          match[i][j] = match[i - 1][j - 1]
|    |  77|+                              && (p[j - 1] == s[i - 1] || p[j - 1] == '.');
|    |  78|+                      }
|    |  79|+                    else
|    |  80|+                      {
|    |  81|+                          match[i][j] = j >= 2 && (match[i][j - 2]
|    |  82|+                                                   || (match[i - 1][j]
|    |  83|+                                                       && (p[j - 2] == s[i - 1]
|    |  84|+                                                           || p[j - 2] ==
|    |  85|+                                                           '.')));
|    |  86|+                      }
|  73|  87|                 }
|  74|    |-            }
|  75|    |-        }
|    |  88|+          }
|  76|  89|         return match[s_len][p_len];
|  77|  90|     }
|  78|  91| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  80|  80| // Time:  O(m * n^2)
|  81|  81| // Space: O(m + n)
|  82|  82| // Recursion solution
|  83|    |-class Solution3 {
|  84|    |-public:
|    |  83|+class Solution3
|    |  84|+{
|    |  85|+  public:
|  85|  86|     /**
|  86|  87|      * @param s: A string
|  87|  88|      * @param p: A string includes "?" and "*"
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
|  87|  87|      * @param p: A string includes "?" and "*"
|  88|  88|      * @return: A boolean
|  89|  89|      */
|  90|    |-    bool isMatch(const char *s, const char *p) {
|  91|    |-        if (*s == 0 || *p == 0) {
|  92|    |-            return *s == 0 && *p == 0;
|  93|    |-        }
|    |  90|+    bool isMatch (const char *s, const char *p)
|    |  91|+    {
|    |  92|+        if (*s == 0 || *p == 0)
|    |  93|+          {
|    |  94|+              return *s == 0 && *p == 0;
|    |  95|+          }
|  94|  96| 
|  95|    |-        if (*(p + 1) == 0 || p[1] != '*') {
|  96|    |-            if (*s != 0 && (p[0] == s[0] || p[0] == '.')) {
|  97|    |-                // Matched a char.
|  98|    |-                return isMatch(s + 1, p + 1);
|  99|    |-            } else {
| 100|    |-                return false;
| 101|    |-            }
| 102|    |-        } else {
| 103|    |-            // Try all possible matches with '*' in p.
| 104|    |-            while (*s != 0 && (p[0] == s[0] || p[0] == '.')) {
| 105|    |-                if (isMatch(s, p + 2)) {
| 106|    |-                    return true;
|    |  97|+        if (*(p + 1) == 0 || p[1] != '*')
|    |  98|+          {
|    |  99|+              if (*s != 0 && (p[0] == s[0] || p[0] == '.'))
|    | 100|+                {
|    | 101|+                    // Matched a char.
|    | 102|+                    return isMatch (s + 1, p + 1);
| 107| 103|                 }
| 108|    |-                ++s;
| 109|    |-            }
| 110|    |-            return isMatch(s, p + 2);
| 111|    |-        }
|    | 104|+              else
|    | 105|+                {
|    | 106|+                    return false;
|    | 107|+                }
|    | 108|+          }
|    | 109|+        else
|    | 110|+          {
|    | 111|+              // Try all possible matches with '*' in p.
|    | 112|+              while (*s != 0 && (p[0] == s[0] || p[0] == '.'))
|    | 113|+                {
|    | 114|+                    if (isMatch (s, p + 2))
|    | 115|+                      {
|    | 116|+                          return true;
|    | 117|+                      }
|    | 118|+                    ++s;
|    | 119|+                }
|    | 120|+              return isMatch (s, p + 2);
|    | 121|+          }
| 112| 122|     }
| 113| 123| };
| 114| 124| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
| 115| 115| // Time:  O(?)
| 116| 116| // Space: O(?)
| 117| 117| // Iteration solution (Greedy not work)
| 118|    |-class Solution4 {
| 119|    |-public:
|    | 118|+class Solution4
|    | 119|+{
|    | 120|+  public:
| 120| 121|     /**
| 121| 122|      * @param s: A string
| 122| 123|      * @param p: A string includes "." and "*"
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
| 122| 122|      * @param p: A string includes "." and "*"
| 123| 123|      * @return: A boolean
| 124| 124|      */
| 125|    |-    bool isMatch(const char *s, const char *p) {
|    | 125|+    bool isMatch (const char *s, const char *p)
|    | 126|+    {
| 126| 127|         int p_pos = 0, s_pos = 0;
| 127| 128|         int last_s_pos = -1, last_p_pos = -1;
| 128| 129|         const int s_len = strlen(s), p_len = strlen(p);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
| 125| 125|     bool isMatch(const char *s, const char *p) {
| 126| 126|         int p_pos = 0, s_pos = 0;
| 127| 127|         int last_s_pos = -1, last_p_pos = -1;
| 128|    |-        const int s_len = strlen(s), p_len = strlen(p);
| 129|    |-        stack<pair<int, int>> last_pos;
| 130|    |-        while (s_pos < s_len) {
| 131|    |-            if (p_pos < p_len && (p_pos == p_len - 1 || p[p_pos + 1] != '*') &&
| 132|    |-                (s_pos < s_len && (p[p_pos] == s[s_pos] || p[p_pos] == '.'))) {
| 133|    |-                // Matched a char.
| 134|    |-                ++s_pos;
| 135|    |-                ++p_pos;
| 136|    |-            } else if (p_pos < p_len && (p_pos != p_len - 1 && p[p_pos + 1] == '*')) {
| 137|    |-                // Matched '*'.
| 138|    |-                p_pos += 2;
| 139|    |-                last_pos.emplace(make_pair(s_pos, p_pos));
| 140|    |-            } else if (!last_pos.empty()) {
| 141|    |-                // Rollback to the last position of '*' plus 2.
| 142|    |-                // And try next position of last matched one.
| 143|    |-                tie(last_s_pos, last_p_pos) = last_pos.top();
| 144|    |-                last_pos.pop();
| 145|    |-                while (!last_pos.empty() && p[last_p_pos - 2] != s[last_s_pos] && p[last_p_pos - 2] != '.') {
| 146|    |-                    tie(last_s_pos, last_p_pos) = last_pos.top();
| 147|    |-                    last_pos.pop();
|    | 128|+        const int s_len = strlen (s), p_len = strlen (p);
|    | 129|+          stack < pair < int, int >>last_pos;
|    | 130|+        while (s_pos < s_len)
|    | 131|+          {
|    | 132|+              if (p_pos < p_len && (p_pos == p_len - 1 || p[p_pos + 1] != '*')
|    | 133|+                  && (s_pos < s_len
|    | 134|+                      && (p[p_pos] == s[s_pos] || p[p_pos] == '.')))
|    | 135|+                {
|    | 136|+                    // Matched a char.
|    | 137|+                    ++s_pos;
|    | 138|+                    ++p_pos;
| 148| 139|                 }
| 149|    |-                if (p[last_p_pos - 2] == s[last_s_pos] || p[last_p_pos - 2] == '.') {
| 150|    |-                    ++last_s_pos;
| 151|    |-                    s_pos = last_s_pos;
| 152|    |-                    p_pos = last_p_pos;
| 153|    |-                    last_pos.emplace(make_pair(s_pos, p_pos));
|    | 140|+              else if (p_pos < p_len
|    | 141|+                       && (p_pos != p_len - 1 && p[p_pos + 1] == '*'))
|    | 142|+                {
|    | 143|+                    // Matched '*'.
|    | 144|+                    p_pos += 2;
|    | 145|+                    last_pos.emplace (make_pair (s_pos, p_pos));
| 154| 146|                 }
| 155|    |-                else {
|    | 147|+              else if (!last_pos.empty ())
|    | 148|+                {
|    | 149|+                    // Rollback to the last position of '*' plus 2.
|    | 150|+                    // And try next position of last matched one.
|    | 151|+                    tie (last_s_pos, last_p_pos) = last_pos.top ();
|    | 152|+                    last_pos.pop ();
|    | 153|+                    while (!last_pos.empty ()
|    | 154|+                           && p[last_p_pos - 2] != s[last_s_pos]
|    | 155|+                           && p[last_p_pos - 2] != '.')
|    | 156|+                      {
|    | 157|+                          tie (last_s_pos, last_p_pos) = last_pos.top ();
|    | 158|+                          last_pos.pop ();
|    | 159|+                      }
|    | 160|+                    if (p[last_p_pos - 2] == s[last_s_pos]
|    | 161|+                        || p[last_p_pos - 2] == '.')
|    | 162|+                      {
|    | 163|+                          ++last_s_pos;
|    | 164|+                          s_pos = last_s_pos;
|    | 165|+                          p_pos = last_p_pos;
|    | 166|+                          last_pos.emplace (make_pair (s_pos, p_pos));
|    | 167|+                      }
|    | 168|+                    else
|    | 169|+                      {
|    | 170|+                          return false;
|    | 171|+                      }
|    | 172|+                }
|    | 173|+              else
|    | 174|+                {
|    | 175|+                    // s_pos < s_len && no matched p, no position to retry.
| 156| 176|                     return false;
| 157| 177|                 }
| 158| 178|             } else {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
| 155| 155|                 else {
| 156| 156|                     return false;
| 157| 157|                 }
| 158|    |-            } else {
| 159|    |-                // s_pos < s_len && no matched p, no position to retry.
| 160|    |-                return false;
| 161|    |-            }
| 162|    |-        }
|    | 158|+          }
| 163| 159| 
| 164| 160|         // Skip '*' in p.
| 165| 161|         while (p_pos < p_len - 1 && p[p_pos] == '.' && p[p_pos + 1] == '*') {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/regular-expression-matching.cpp
|    |++++| /app/C++/regular-expression-matching.cpp
| 162| 162|         }
| 163| 163| 
| 164| 164|         // Skip '*' in p.
| 165|    |-        while (p_pos < p_len - 1 && p[p_pos] == '.' && p[p_pos + 1] == '*') {
| 166|    |-            p_pos += 2;
| 167|    |-        }
|    | 165|+        while (p_pos < p_len - 1 && p[p_pos] == '.' && p[p_pos + 1] == '*')
|    | 166|+          {
|    | 167|+              p_pos += 2;
|    | 168|+          }
| 168| 169| 
| 169| 170|         // Check if pattern is all matched.
| 170| 171|         return p_pos == p_len;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // Binary search solution with STL.
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums: The integer array
|   9|  10|      * @return: The length of LIS (longest increasing subsequence)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|   8|   8|      * @param nums: The integer array
|   9|   9|      * @return: The length of LIS (longest increasing subsequence)
|  10|  10|      */
|  11|    |-    int longestIncreasingSubsequence(vector<int> nums) {
|  12|    |-        vector<int> LIS;
|    |  11|+    int longestIncreasingSubsequence (vector < int >nums)
|    |  12|+    {
|    |  13|+        vector < int >LIS;
|  13|  14| 
|  14|    |-        for (const auto& i : nums) {
|  15|    |-            insert(&LIS, i);
|  16|    |-        }
|    |  15|+        for (const auto & i:nums)
|    |  16|+          {
|    |  17|+              insert (&LIS, i);
|    |  18|+          }
|  17|  19| 
|  18|    |-        return LIS.size();
|    |  20|+        return LIS.size ();
|  19|  21|     }
|  20|  22| 
|  21|  23| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  18|  18|         return LIS.size();
|  19|  19|     }
|  20|  20| 
|  21|    |-private:
|  22|    |-    void insert(vector<int> *LIS, const int target) {
|    |  21|+  private:
|    |  22|+    void insert (vector < int >*LIS, const int target)
|    |  23|+    {
|  23|  24|         // Find the first index "left" which satisfies LIS[left] > target
|  24|    |-        auto it = upper_bound(LIS->begin(), LIS->end(), target);
|    |  25|+        auto it = upper_bound (LIS->begin (), LIS->end (), target);
|  25|  26| 
|  26|  27|         // If not found, append the target.
|  27|  28|         if (it == LIS->end()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  24|  24|         auto it = upper_bound(LIS->begin(), LIS->end(), target);
|  25|  25| 
|  26|  26|         // If not found, append the target.
|  27|    |-        if (it == LIS->end()) {
|  28|    |-            LIS->emplace_back(target);
|  29|    |-        } else {
|  30|    |-            *it = target;
|  31|    |-        }
|    |  27|+        if (it == LIS->end ())
|    |  28|+          {
|    |  29|+              LIS->emplace_back (target);
|    |  30|+          }
|    |  31|+        else
|    |  32|+          {
|    |  33|+              *it = target;
|    |  34|+          }
|  32|  35|     }
|  33|  36| };
|  34|  37| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  33|  33| };
|  34|  34| 
|  35|  35| // Binary search solution.
|  36|    |-class Solution2 {
|  37|    |-public:
|    |  36|+class Solution2
|    |  37|+{
|    |  38|+  public:
|  38|  39|     /**
|  39|  40|      * @param nums: The integer array
|  40|  41|      * @return: The length of LIS (longest increasing subsequence)
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  39|  39|      * @param nums: The integer array
|  40|  40|      * @return: The length of LIS (longest increasing subsequence)
|  41|  41|      */
|  42|    |-    int longestIncreasingSubsequence(vector<int> nums) {
|  43|    |-        vector<int> LIS;
|    |  42|+    int longestIncreasingSubsequence (vector < int >nums)
|    |  43|+    {
|    |  44|+        vector < int >LIS;
|  44|  45| 
|  45|    |-        for (const auto& i : nums) {
|  46|    |-            insert(&LIS, i);
|  47|    |-        }
|    |  46|+        for (const auto & i:nums)
|    |  47|+          {
|    |  48|+              insert (&LIS, i);
|    |  49|+          }
|  48|  50| 
|  49|    |-        return LIS.size();
|    |  51|+        return LIS.size ();
|  50|  52|     }
|  51|  53| 
|  52|  54| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  49|  49|         return LIS.size();
|  50|  50|     }
|  51|  51| 
|  52|    |-private:
|  53|    |-    void insert(vector<int> *LIS, const int target) {
|  54|    |-        int left = 0, right = LIS->size() - 1;
|  55|    |-        auto comp = [](int x, int target) { return x > target; };
|    |  52|+  private:
|    |  53|+    void insert (vector < int >*LIS, const int target)
|    |  54|+    {
|    |  55|+        int left = 0, right = LIS->size () - 1;
|    |  56|+        auto comp =[](int x, int target) { return x > target;
|    |  57|+        };
|  56|  58| 
|  57|  59|         // Find the first index "left" which satisfies LIS[left] > target
|  58|  60|         while (left <= right) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  55|  55|         auto comp = [](int x, int target) { return x > target; };
|  56|  56| 
|  57|  57|         // Find the first index "left" which satisfies LIS[left] > target
|  58|    |-        while (left <= right) {
|  59|    |-            int mid = left + (right - left) / 2;
|  60|    |-            if (comp((*LIS)[mid], target)) {
|  61|    |-                right = mid - 1;
|  62|    |-            } else {
|  63|    |-                left = mid + 1;
|  64|    |-            }
|  65|    |-        }
|    |  58|+        while (left <= right)
|    |  59|+          {
|    |  60|+              int mid = left + (right - left) / 2;
|    |  61|+              if (comp ((*LIS)[mid], target))
|    |  62|+                {
|    |  63|+                    right = mid - 1;
|    |  64|+                }
|    |  65|+              else
|    |  66|+                {
|    |  67|+                    left = mid + 1;
|    |  68|+                }
|    |  69|+          }
|  66|  70| 
|  67|  71|         // If not found, append the target.
|  68|  72|         if (left == LIS->size()) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  65|  65|         }
|  66|  66| 
|  67|  67|         // If not found, append the target.
|  68|    |-        if (left == LIS->size()) {
|  69|    |-            LIS->emplace_back(target);
|  70|    |-        } else {
|  71|    |-            (*LIS)[left] = target;
|  72|    |-        }
|    |  68|+        if (left == LIS->size ())
|    |  69|+          {
|    |  70|+              LIS->emplace_back (target);
|    |  71|+          }
|    |  72|+        else
|    |  73|+          {
|    |  74|+              (*LIS)[left] = target;
|    |  75|+          }
|  73|  76|     }
|  74|  77| };
|  75|  78| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/longest-increasing-subsequence.cpp
|    |++++| /app/C++/longest-increasing-subsequence.cpp
|  72|  72|         }
|  73|  73|     }
|  74|  74| };
|  75|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insertion-sort-list.cpp
|    |++++| /app/C++/insertion-sort-list.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param head: The first node of linked list.
|  20|  21|      * @return: The head of linked list.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insertion-sort-list.cpp
|    |++++| /app/C++/insertion-sort-list.cpp
|  19|  19|      * @param head: The first node of linked list.
|  20|  20|      * @return: The head of linked list.
|  21|  21|      */
|  22|    |-    ListNode *insertionSortList(ListNode *head) {
|  23|    |-        ListNode dummy{numeric_limits<int>::min()};
|    |  22|+    ListNode * insertionSortList (ListNode * head)
|    |  23|+    {
|    |  24|+        ListNode dummy
|    |  25|+        {
|    |  26|+        numeric_limits < int >::min ()};
|  24|  27| 
|  25|  28|         auto curr = head;
|  26|  29|         ListNode *position = nullptr;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insertion-sort-list.cpp
|    |++++| /app/C++/insertion-sort-list.cpp
|  25|  25|         auto curr = head;
|  26|  26|         ListNode *position = nullptr;
|  27|  27| 
|  28|    |-        while (curr) {
|  29|    |-            position = findInsertPosition(&dummy, curr->val);
|  30|    |-            ListNode *tmp = curr->next;
|  31|    |-            curr->next = position->next;
|  32|    |-            position->next = curr;
|  33|    |-            curr = tmp;
|  34|    |-        }
|    |  28|+        while (curr)
|    |  29|+          {
|    |  30|+              position = findInsertPosition (&dummy, curr->val);
|    |  31|+              ListNode *tmp = curr->next;
|    |  32|+                curr->next = position->next;
|    |  33|+                position->next = curr;
|    |  34|+                curr = tmp;
|    |  35|+          }
|  35|  36| 
|  36|  37|         return dummy.next;
|  37|  38|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insertion-sort-list.cpp
|    |++++| /app/C++/insertion-sort-list.cpp
|  36|  36|         return dummy.next;
|  37|  37|     }
|  38|  38| 
|  39|    |-    ListNode* findInsertPosition(ListNode *head, int x) {
|    |  39|+    ListNode *findInsertPosition (ListNode * head, int x)
|    |  40|+    {
|  40|  41|         ListNode *prev = nullptr;
|  41|  42|         for (auto curr = head; curr && curr->val <= x;
|  42|  43|              prev = curr, curr = curr->next);
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/insertion-sort-list.cpp
|    |++++| /app/C++/insertion-sort-list.cpp
|  39|  39|     ListNode* findInsertPosition(ListNode *head, int x) {
|  40|  40|         ListNode *prev = nullptr;
|  41|  41|         for (auto curr = head; curr && curr->val <= x;
|  42|    |-             prev = curr, curr = curr->next);
|    |  42|+             prev = curr, curr = curr->next) ;
|  43|  43|         return prev;
|  44|  44|     }
|  45|  45| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median.cpp
|    |++++| /app/C++/median.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums: A list of integers.
|   8|   9|      * @return: An integer denotes the middle number of the array.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median.cpp
|    |++++| /app/C++/median.cpp
|   7|   7|      * @param nums: A list of integers.
|   8|   8|      * @return: An integer denotes the middle number of the array.
|   9|   9|      */
|  10|    |-    int median(vector<int> &nums) {
|  11|    |-        auto target = nums.begin() + nums.size() / 2;
|  12|    |-        nth_element(nums.begin(), target, nums.end());
|  13|    |-        if (nums.size() % 2 == 1) {  // nums has odd number of elements.
|  14|    |-            return *target;
|  15|    |-        } else {  // nums has even number of elements.
|  16|    |-            int x = *target;
|  17|    |-            nth_element(nums.begin(), target - 1, nums.end());
|  18|    |-            return *(target - 1);
|  19|    |-        }
|    |  10|+    int median (vector < int >&nums)
|    |  11|+    {
|    |  12|+        auto target = nums.begin () + nums.size () / 2;
|    |  13|+          nth_element (nums.begin (), target, nums.end ());
|    |  14|+        if (nums.size () % 2 == 1)
|    |  15|+          {                     // nums has odd number of elements.
|    |  16|+              return *target;
|    |  17|+          }
|    |  18|+        else
|    |  19|+          {                     // nums has even number of elements.
|    |  20|+              int x = *target;
|    |  21|+              nth_element (nums.begin (), target - 1, nums.end ());
|    |  22|+              return *(target - 1);
|    |  23|+          }
|  20|  24|     }
|  21|  25| };
|  22|  26| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/median.cpp
|    |++++| /app/C++/median.cpp
|  19|  19|         }
|  20|  20|     }
|  21|  21| };
|  22|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|  14|  14|  * }
|  15|  15|  */
|  16|  16| 
|  17|    |-
|  18|    |-class Solution {
|    |  17|+class Solution
|    |  18|+{
|  19|  19|     /**
|  20|  20|      *@param inorder : A list of integers that inorder traversal of a tree
|  21|  21|      *@param postorder : A list of integers that postorder traversal of a tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|  21|  21|      *@param postorder : A list of integers that postorder traversal of a tree
|  22|  22|      *@return : Root of a tree
|  23|  23|      */
|  24|    |-public:
|  25|    |-    TreeNode *buildTree(vector<int> &in, vector<int> &post) {
|  26|    |-        unordered_map<int, size_t> in_entry_idx_map;
|  27|    |-        for (size_t i = 0; i < in.size(); ++i) {
|  28|    |-            in_entry_idx_map.emplace(in[i], i);
|  29|    |-        }
|  30|    |-        return ReconstructPostInOrdersHelper(post, 0, post.size(), in, 0, in.size(),
|  31|    |-                                             in_entry_idx_map);
|    |  24|+  public:
|    |  25|+    TreeNode * buildTree (vector < int >&in, vector < int >&post)
|    |  26|+    {
|    |  27|+        unordered_map < int, size_t > in_entry_idx_map;
|    |  28|+        for (size_t i = 0; i < in.size (); ++i)
|    |  29|+          {
|    |  30|+              in_entry_idx_map.emplace (in[i], i);
|    |  31|+          }
|    |  32|+        return ReconstructPostInOrdersHelper (post, 0, post.size (), in, 0,
|    |  33|+                                              in.size (), in_entry_idx_map);
|  32|  34|     }
|  33|  35| 
|  34|  36|     TreeNode * ReconstructPostInOrdersHelper(const vector<int>& post, size_t post_s, size_t post_e,
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|    |++++| /app/C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp
|  31|  31|                                              in_entry_idx_map);
|  32|  32|     }
|  33|  33| 
|  34|    |-    TreeNode * ReconstructPostInOrdersHelper(const vector<int>& post, size_t post_s, size_t post_e,
|  35|    |-                                             const vector<int>& in, size_t in_s, size_t in_e,
|  36|    |-                                             const unordered_map<int, size_t>& in_entry_idx_map) {
|  37|    |-        if (post_e > post_s && in_e > in_s) {
|  38|    |-            auto idx = in_entry_idx_map.at(post[post_e - 1]);
|  39|    |-            auto left_tree_size = idx - in_s;
|    |  34|+    TreeNode *ReconstructPostInOrdersHelper (const vector < int >&post,
|    |  35|+                                             size_t post_s, size_t post_e,
|    |  36|+                                             const vector < int >&in,
|    |  37|+                                             size_t in_s, size_t in_e,
|    |  38|+                                             const unordered_map < int,
|    |  39|+                                             size_t > &in_entry_idx_map)
|    |  40|+    {
|    |  41|+        if (post_e > post_s && in_e > in_s)
|    |  42|+          {
|    |  43|+              auto idx = in_entry_idx_map.at (post[post_e - 1]);
|    |  44|+              auto left_tree_size = idx - in_s;
|  40|  45| 
|  41|    |-            TreeNode *node = new TreeNode(post[post_e - 1]);
|  42|    |-            // Recursively builds the left subtree.
|  43|    |-            node->left =ReconstructPostInOrdersHelper(post, post_s, post_s + left_tree_size,
|  44|    |-                                                      in, in_s, idx, in_entry_idx_map);
|  45|    |-            // Recursively builds the right subtree.
|  46|    |-            node->right = ReconstructPostInOrdersHelper(post, post_s + left_tree_size, post_e - 1,
|  47|    |-                                                        in, idx + 1, in_e, in_entry_idx_map);
|  48|    |-            return node;
|  49|    |-        }
|    |  46|+              TreeNode *node = new TreeNode (post[post_e - 1]);
|    |  47|+              // Recursively builds the left subtree.
|    |  48|+              node->left =
|    |  49|+                  ReconstructPostInOrdersHelper (post, post_s,
|    |  50|+                                                 post_s + left_tree_size, in,
|    |  51|+                                                 in_s, idx, in_entry_idx_map);
|    |  52|+              // Recursively builds the right subtree.
|    |  53|+              node->right =
|    |  54|+                  ReconstructPostInOrdersHelper (post, post_s + left_tree_size,
|    |  55|+                                                 post_e - 1, in, idx + 1, in_e,
|    |  56|+                                                 in_entry_idx_map);
|    |  57|+              return node;
|    |  58|+          }
|  50|  59|         return nullptr;
|  51|  60|     }
|  52|  61| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-colors.cpp
|    |++++| /app/C++/sort-colors.cpp
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|   4| // Tri-Partition solution.
|   5|    |-class Solution{
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|     /**
|   8|   9|      * @param nums: A list of integer which is 0, 1 or 2
|   9|  10|      * @return: nothing
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/sort-colors.cpp
|    |++++| /app/C++/sort-colors.cpp
|   8|   8|      * @param nums: A list of integer which is 0, 1 or 2
|   9|   9|      * @return: nothing
|  10|  10|      */
|  11|    |-    void sortColors(vector<int> &nums) {
|    |  11|+    void sortColors (vector < int >&nums)
|    |  12|+    {
|  12|  13|         const int target = 1;
|  13|    |-        for (int i = 0, j = 0, n = nums.size() - 1; j <= n;) {
|  14|    |-            if (nums[j] < target) {
|  15|    |-                swap(nums[i++], nums[j++]);
|  16|    |-            } else if (nums[j] > target) {
|  17|    |-                swap(nums[j], nums[n--]);
|  18|    |-            } else {
|  19|    |-                ++j;
|  20|    |-            }
|  21|    |-        }
|    |  14|+        for (int i = 0, j = 0, n = nums.size () - 1; j <= n;)
|    |  15|+          {
|    |  16|+              if (nums[j] < target)
|    |  17|+                {
|    |  18|+                    swap (nums[i++], nums[j++]);
|    |  19|+                }
|    |  20|+              else if (nums[j] > target)
|    |  21|+                {
|    |  22|+                    swap (nums[j], nums[n--]);
|    |  23|+                }
|    |  24|+              else
|    |  25|+                {
|    |  26|+                    ++j;
|    |  27|+                }
|    |  28|+          }
|  22|  29|     }
|  23|  30| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-depth-of-binary-tree.cpp
|    |++++| /app/C++/maximum-depth-of-binary-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree.
|  20|  21|      * @return: An integer
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/maximum-depth-of-binary-tree.cpp
|    |++++| /app/C++/maximum-depth-of-binary-tree.cpp
|  19|  19|      * @param root: The root of binary tree.
|  20|  20|      * @return: An integer
|  21|  21|      */
|  22|    |-    int maxDepth(TreeNode *root) {
|  23|    |-        if (root == nullptr) {
|  24|    |-            return 0;
|  25|    |-        }
|  26|    |-        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
|    |  22|+    int maxDepth (TreeNode * root)
|    |  23|+    {
|    |  24|+        if (root == nullptr)
|    |  25|+          {
|    |  26|+              return 0;
|    |  27|+          }
|    |  28|+        return max (maxDepth (root->left), maxDepth (root->right)) + 1;
|  27|  29|     }
|  28|  30| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-queue-by-two-stacks.cpp
|    |++++| /app/C++/implement-queue-by-two-stacks.cpp
|   1|   1| // Time:  O(1), amortized
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|    |-class Queue {
|   5|    |-public:
|   6|    |-    stack<int> stack1;
|   7|    |-    stack<int> stack2;
|    |   4|+class Queue
|    |   5|+{
|    |   6|+  public:
|    |   7|+    stack < int >stack1;
|    |   8|+      stack < int >stack2;
|   8|   9| 
|   9|    |-    Queue() {
|    |  10|+      Queue ()
|    |  11|+    {
|  10|  12|         // do intialization if necessary
|  11|  13|     }
|  12|  14| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-queue-by-two-stacks.cpp
|    |++++| /app/C++/implement-queue-by-two-stacks.cpp
|  10|  10|         // do intialization if necessary
|  11|  11|     }
|  12|  12| 
|  13|    |-    void push(int element) {
|  14|    |-        stack1.emplace(element);
|    |  13|+    void push (int element)
|    |  14|+    {
|    |  15|+        stack1.emplace (element);
|  15|  16|     }
|  16|  17| 
|  17|  18|     int pop() {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-queue-by-two-stacks.cpp
|    |++++| /app/C++/implement-queue-by-two-stacks.cpp
|  14|  14|         stack1.emplace(element);
|  15|  15|     }
|  16|  16| 
|  17|    |-    int pop() {
|  18|    |-        int element = top();
|  19|    |-        stack2.pop();
|    |  17|+    int pop ()
|    |  18|+    {
|    |  19|+        int element = top ();
|    |  20|+        stack2.pop ();
|  20|  21|         return element;
|  21|  22|     }
|  22|  23| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-queue-by-two-stacks.cpp
|    |++++| /app/C++/implement-queue-by-two-stacks.cpp
|  20|  20|         return element;
|  21|  21|     }
|  22|  22| 
|  23|    |-    int top() {
|  24|    |-        if (stack2.empty()) {
|  25|    |-            while (!stack1.empty()) {
|  26|    |-                stack2.emplace(stack1.top());
|  27|    |-                stack1.pop();
|  28|    |-            }
|  29|    |-        }
|  30|    |-        return stack2.top();
|    |  23|+    int top ()
|    |  24|+    {
|    |  25|+        if (stack2.empty ())
|    |  26|+          {
|    |  27|+              while (!stack1.empty ())
|    |  28|+                {
|    |  29|+                    stack2.emplace (stack1.top ());
|    |  30|+                    stack1.pop ();
|    |  31|+                }
|    |  32|+          }
|    |  33|+        return stack2.top ();
|  31|  34|     }
|  32|  35| };
|  33|  36| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/implement-queue-by-two-stacks.cpp
|    |++++| /app/C++/implement-queue-by-two-stacks.cpp
|  30|  30|         return stack2.top();
|  31|  31|     }
|  32|  32| };
|  33|    |-
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-node-in-binary-search-tree.cpp
|    |++++| /app/C++/remove-node-in-binary-search-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of the binary search tree.
|  20|  21|      * @param value: Remove the node with given value.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-node-in-binary-search-tree.cpp
|    |++++| /app/C++/remove-node-in-binary-search-tree.cpp
|  20|  20|      * @param value: Remove the node with given value.
|  21|  21|      * @return: The root of the binary search tree after removal.
|  22|  22|      */
|  23|    |-    TreeNode* removeNode(TreeNode* root, int value) {
|  24|    |-        if (root == nullptr) {
|  25|    |-            return nullptr;
|  26|    |-        }
|  27|    |-        if (value < root->val) {
|  28|    |-            root->left = removeNode(root->left, value);
|  29|    |-        }
|  30|    |-        else if (value > root->val) {
|  31|    |-            root->right = removeNode(root->right, value);
|  32|    |-        }
|  33|    |-        else {  // Find the target node.
|  34|    |-            if (root->left == nullptr) {
|  35|    |-                return root->right;
|  36|    |-            } else if (root->right == nullptr) {
|  37|    |-                return root->left;
|  38|    |-            }
|  39|    |-            TreeNode *node = root;
|  40|    |-            root = findMin(node->right);
|  41|    |-            root->right = deleteMin(node->right);
|  42|    |-            root->left = node->left;
|  43|    |-        }
|    |  23|+    TreeNode * removeNode (TreeNode * root, int value)
|    |  24|+    {
|    |  25|+        if (root == nullptr)
|    |  26|+          {
|    |  27|+              return nullptr;
|    |  28|+          }
|    |  29|+        if (value < root->val)
|    |  30|+          {
|    |  31|+              root->left = removeNode (root->left, value);
|    |  32|+          }
|    |  33|+        else if (value > root->val)
|    |  34|+          {
|    |  35|+              root->right = removeNode (root->right, value);
|    |  36|+          }
|    |  37|+        else
|    |  38|+          {                     // Find the target node.
|    |  39|+              if (root->left == nullptr)
|    |  40|+                {
|    |  41|+                    return root->right;
|    |  42|+                }
|    |  43|+              else if (root->right == nullptr)
|    |  44|+                {
|    |  45|+                    return root->left;
|    |  46|+                }
|    |  47|+              TreeNode *node = root;
|    |  48|+              root = findMin (node->right);
|    |  49|+              root->right = deleteMin (node->right);
|    |  50|+              root->left = node->left;
|    |  51|+          }
|  44|  52|         return root;
|  45|  53|     }
|  46|  54| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-node-in-binary-search-tree.cpp
|    |++++| /app/C++/remove-node-in-binary-search-tree.cpp
|  45|  45|     }
|  46|  46| 
|  47|  47|     // Find the min node of the binary search tree.
|  48|    |-    TreeNode* findMin(TreeNode* node) {
|  49|    |-        while (node != nullptr && node->left != nullptr) {
|  50|    |-            node = node->left;
|  51|    |-        }
|    |  48|+    TreeNode *findMin (TreeNode * node)
|    |  49|+    {
|    |  50|+        while (node != nullptr && node->left != nullptr)
|    |  51|+          {
|    |  52|+              node = node->left;
|    |  53|+          }
|  52|  54|         return node;
|  53|  55|     }
|  54|  56| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-node-in-binary-search-tree.cpp
|    |++++| /app/C++/remove-node-in-binary-search-tree.cpp
|  53|  53|     }
|  54|  54| 
|  55|  55|     // Delete the min node of the binary search tree.
|  56|    |-    TreeNode* deleteMin(TreeNode* node) {
|    |  56|+    TreeNode *deleteMin (TreeNode * node)
|    |  57|+    {
|  57|  58|         // No left child.
|  58|    |-        if (node->left == nullptr) {
|  59|    |-            return node->right;
|  60|    |-        }
|    |  59|+        if (node->left == nullptr)
|    |  60|+          {
|    |  61|+              return node->right;
|    |  62|+          }
|  61|  63| 
|  62|  64|         TreeNode *root = node;
|  63|  65| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/remove-node-in-binary-search-tree.cpp
|    |++++| /app/C++/remove-node-in-binary-search-tree.cpp
|  62|  62|         TreeNode *root = node;
|  63|  63| 
|  64|  64|         // Find the parent of the min.
|  65|    |-        TreeNode* parent;
|  66|    |-        while (node != nullptr && node->left != nullptr) {
|  67|    |-            parent = node;
|  68|    |-            node = node->left;
|  69|    |-        }
|    |  65|+        TreeNode *parent;
|    |  66|+        while (node != nullptr && node->left != nullptr)
|    |  67|+          {
|    |  68|+              parent = node;
|    |  69|+              node = node->left;
|    |  70|+          }
|  70|  71| 
|  71|  72|         // Cut the parent relationship to the min,
|  72|  73|         // and take the right child of the min.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-iii.cpp
|    |++++| /app/C++/house-robber-iii.cpp
|  10|  10|  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
|  11|  11|  * }
|  12|  12|  */
|  13|    |-class Solution {
|  14|    |-public:
|    |  13|+class Solution
|    |  14|+{
|    |  15|+  public:
|  15|  16|     /**
|  16|  17|      * @param root: The root of binary tree.
|  17|  18|      * @return: The maximum amount of money you can rob tonight
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-iii.cpp
|    |++++| /app/C++/house-robber-iii.cpp
|  16|  16|      * @param root: The root of binary tree.
|  17|  17|      * @return: The maximum amount of money you can rob tonight
|  18|  18|      */
|  19|    |-    int houseRobber3(TreeNode* root) {
|  20|    |-        const auto& res = houseRobber3Helper(root);
|  21|    |-        return max(res.first, res.second);
|    |  19|+    int houseRobber3 (TreeNode * root)
|    |  20|+    {
|    |  21|+        const auto & res = houseRobber3Helper (root);
|    |  22|+          return max (res.first, res.second);
|  22|  23|     }
|  23|  24| 
|  24|  25| private:
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/house-robber-iii.cpp
|    |++++| /app/C++/house-robber-iii.cpp
|  21|  21|         return max(res.first, res.second);
|  22|  22|     }
|  23|  23| 
|  24|    |-private:
|  25|    |-    pair<int, int> houseRobber3Helper(TreeNode* root) {
|  26|    |-        if (!root) {
|  27|    |-            return {0, 0};
|  28|    |-        }
|  29|    |-        const auto& left = houseRobber3Helper(root->left);
|  30|    |-        const auto& right = houseRobber3Helper(root->right);
|  31|    |-        return {root->val + left.second + right.second,
|  32|    |-                max(left.first, left.second) + max(right.first, right.second)};
|    |  24|+  private:
|    |  25|+      pair < int, int >houseRobber3Helper (TreeNode * root)
|    |  26|+    {
|    |  27|+        if (!root)
|    |  28|+          {
|    |  29|+              return
|    |  30|+              {
|    |  31|+              0, 0};
|    |  32|+          }
|    |  33|+        const auto & left = houseRobber3Helper (root->left);
|    |  34|+        const auto & right = houseRobber3Helper (root->right);
|    |  35|+        return
|    |  36|+        {
|    |  37|+        root->val + left.second + right.second,
|    |  38|+                max (left.first, left.second) + max (right.first,
|    |  39|+                                                         right.second)};
|  33|  40|     }
|  34|  41| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-adjustment-cost.cpp
|    |++++| /app/C++/minimum-adjustment-cost.cpp
|   1|   1| // Time:  O(k * n * t), n is size of array, k is the largest number in array, t is target
|   2|   2| // Space: O(k)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param A: An integer array.
|   8|   9|      * @param target: An integer.
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-adjustment-cost.cpp
|    |++++| /app/C++/minimum-adjustment-cost.cpp
|   7|   7|      * @param A: An integer array.
|   8|   8|      * @param target: An integer.
|   9|   9|      */
|  10|    |-    int MinAdjustmentCost(vector<int> A, int target) {
|  11|    |-        const int n = A.size();
|    |  10|+    int MinAdjustmentCost (vector < int >A, int target)
|    |  11|+    {
|    |  12|+        const int n = A.size ();
|  12|  13|         const int max_num = 100;
|  13|  14| 
|  14|  15|         // min_cost[i][j] denotes the min cost of the first i elements
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-adjustment-cost.cpp
|    |++++| /app/C++/minimum-adjustment-cost.cpp
|  13|  13| 
|  14|  14|         // min_cost[i][j] denotes the min cost of the first i elements
|  15|  15|         // with target j.
|  16|    |-        vector<vector<int>> min_cost(2, vector<int>(max_num + 1, 0));
|    |  16|+          vector < vector < int >>min_cost (2, vector < int >(max_num + 1, 0));
|  17|  17| 
|  18|    |-        for (int i = 1; i <= n; ++i) {
|  19|    |-            for (int j = 1; j <= max_num; ++j) {
|  20|    |-                // min_cost[i][j] = abs(A[i - 1] - j) +
|  21|    |-                //                  min(min_cost[i][k],
|  22|    |-                //                  for each k s.t. | k - j | <= target)
|  23|    |-                int upper = min(max_num, j + target);
|  24|    |-                int lower = max(1, j - target);
|  25|    |-                min_cost[i % 2][j] = INT_MAX;
|  26|    |-                for (int k = lower; k <= upper; ++k) {
|  27|    |-                    min_cost[i % 2][j] = min(min_cost[i % 2][j],
|  28|    |-                                             min_cost[(i - 1) % 2][k]);
|    |  18|+        for (int i = 1; i <= n; ++i)
|    |  19|+          {
|    |  20|+              for (int j = 1; j <= max_num; ++j)
|    |  21|+                {
|    |  22|+                    // min_cost[i][j] = abs(A[i - 1] - j) +
|    |  23|+                    //                  min(min_cost[i][k],
|    |  24|+                    //                  for each k s.t. | k - j | <= target)
|    |  25|+                    int upper = min (max_num, j + target);
|    |  26|+                    int lower = max (1, j - target);
|    |  27|+                      min_cost[i % 2][j] = INT_MAX;
|    |  28|+                    for (int k = lower; k <= upper; ++k)
|    |  29|+                      {
|    |  30|+                          min_cost[i % 2][j] = min (min_cost[i % 2][j],
|    |  31|+                                                    min_cost[(i - 1) % 2][k]);
|    |  32|+                      }
|    |  33|+                    min_cost[i % 2][j] += abs (A[i - 1] - j);
|  29|  34|                 }
|  30|    |-                min_cost[i % 2][j] += abs(A[i - 1] - j);
|  31|    |-            }
|  32|    |-        }
|    |  35|+          }
|  33|  36| 
|  34|  37|         // return min of min_cost[n] excluding min_cost[n][0]
|  35|  38|         return *min_element(next(min_cost[n % 2].cbegin()), min_cost[n % 2].cend());
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/minimum-adjustment-cost.cpp
|    |++++| /app/C++/minimum-adjustment-cost.cpp
|  32|  32|         }
|  33|  33| 
|  34|  34|         // return min of min_cost[n] excluding min_cost[n][0]
|  35|    |-        return *min_element(next(min_cost[n % 2].cbegin()), min_cost[n % 2].cend());
|    |  35|+        return *min_element (next (min_cost[n % 2].cbegin ()),
|    |  36|+                             min_cost[n % 2].cend ());
|  36|  37|     }
|  37|  38| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|   2|   2| // Space: O(n)
|   3|   3| 
|   4|   4| // BIT solution. (281ms)
|   5|    |-class Solution {
|   6|    |-public:
|    |   5|+class Solution
|    |   6|+{
|    |   7|+  public:
|   7|   8|    /**
|   8|   9|      * @param A: An integer array
|   9|  10|      * @return: Count the number of element before this element 'ai' is 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|   9|   9|      * @return: Count the number of element before this element 'ai' is 
|  10|  10|      *          smaller than it and return count number array
|  11|  11|      */
|  12|    |-    vector<int> countOfSmallerNumberII(vector<int> &A) {
|    |  12|+    vector < int >countOfSmallerNumberII (vector < int >&A)
|    |  13|+    {
|  13|  14|         // Get the place (position in the ascending order) of each number.
|  14|    |-        vector<int> sorted_A(A), places(A.size());
|  15|    |-        sort(sorted_A.begin(), sorted_A.end());
|  16|    |-        for (int i = 0; i < A.size(); ++i) {
|  17|    |-            places[i] = 
|  18|    |-                lower_bound(sorted_A.begin(), sorted_A.end(), A[i]) -
|  19|    |-                sorted_A.begin();
|  20|    |-        }
|    |  15|+        vector < int >sorted_A (A), places (A.size ());
|    |  16|+          sort (sorted_A.begin (), sorted_A.end ());
|    |  17|+        for (int i = 0; i < A.size (); ++i)
|    |  18|+          {
|    |  19|+              places[i] =
|    |  20|+                  lower_bound (sorted_A.begin (), sorted_A.end (), A[i]) -
|    |  21|+                  sorted_A.begin ();
|    |  22|+          }
|  21|  23|         // Count the smaller elements before the number.
|  22|    |-        vector<int> bit(A.size() + 1), ans(A.size());
|  23|    |-        for (int i = 0; i < A.size(); ++i) {
|  24|    |-            ans[i] = query(bit, places[i]);
|  25|    |-            add(bit, places[i] + 1, 1);
|  26|    |-        }
|    |  24|+        vector < int >bit (A.size () + 1), ans (A.size ());
|    |  25|+        for (int i = 0; i < A.size (); ++i)
|    |  26|+          {
|    |  27|+              ans[i] = query (bit, places[i]);
|    |  28|+              add (bit, places[i] + 1, 1);
|    |  29|+          }
|  27|  30|         return ans;
|  28|  31|     }
|  29|  32| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  27|  27|         return ans;
|  28|  28|     }
|  29|  29| 
|  30|    |-private:
|  31|    |-    void add(vector<int>& bit, int i, int val) {
|  32|    |-        for (; i < bit.size(); i += lower_bit(i)) {
|  33|    |-            bit[i] += val;
|  34|    |-        }
|    |  30|+  private:
|    |  31|+    void add (vector < int >&bit, int i, int val)
|    |  32|+    {
|    |  33|+        for (; i < bit.size (); i += lower_bit (i))
|    |  34|+          {
|    |  35|+              bit[i] += val;
|    |  36|+          }
|  35|  37|     }
|  36|  38| 
|  37|    |-    int query(const vector<int>& bit, int i) {
|    |  39|+    int query (const vector < int >&bit, int i)
|    |  40|+    {
|  38|  41|         int sum = 0;
|  39|    |-        for (; i > 0; i -= lower_bit(i)) {
|  40|    |-            sum += bit[i];
|  41|    |-        }
|    |  42|+        for (; i > 0; i -= lower_bit (i))
|    |  43|+          {
|    |  44|+              sum += bit[i];
|    |  45|+          }
|  42|  46|         return sum;
|  43|  47|     }
|  44|  48| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  42|  42|         return sum;
|  43|  43|     }
|  44|  44| 
|  45|    |-    int lower_bit(int i) {
|    |  45|+    int lower_bit (int i)
|    |  46|+    {
|  46|  47|         return i & -i;
|  47|  48|     }
|  48|  49| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  50|  50| // Time:  O(nlogn)
|  51|  51| // Space: O(n)
|  52|  52| // Divide and Conqure solution. (653ms)
|  53|    |-class Solution2 {
|  54|    |-public:
|    |  53|+class Solution2
|    |  54|+{
|    |  55|+  public:
|  55|  56|    /**
|  56|  57|      * @param A: An integer array
|  57|  58|      * @return: Count the number of element before this element 'ai' is 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  57|  57|      * @return: Count the number of element before this element 'ai' is 
|  58|  58|      *          smaller than it and return count number array
|  59|  59|      */
|  60|    |-    vector<int> countOfSmallerNumberII(vector<int> &A) {
|  61|    |-        vector<int> counts(A.size());
|  62|    |-        vector<pair<int, int>> num_idxs;
|  63|    |-        for (int i = 0; i < A.size(); ++i) {
|  64|    |-            num_idxs.emplace_back(A[i], i);
|  65|    |-        }
|  66|    |-        countAndMergeSort(&num_idxs, 0, num_idxs.size() - 1, &counts);
|    |  60|+    vector < int >countOfSmallerNumberII (vector < int >&A)
|    |  61|+    {
|    |  62|+        vector < int >counts (A.size ());
|    |  63|+          vector < pair < int, int >>num_idxs;
|    |  64|+        for (int i = 0; i < A.size (); ++i)
|    |  65|+          {
|    |  66|+              num_idxs.emplace_back (A[i], i);
|    |  67|+          }
|    |  68|+        countAndMergeSort (&num_idxs, 0, num_idxs.size () - 1, &counts);
|  67|  69|         return counts;
|  68|  70|     }
|  69|  71| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  67|  67|         return counts;
|  68|  68|     }
|  69|  69| 
|  70|    |-    void countAndMergeSort(vector<pair<int, int>> *num_idxs, int start, int end, vector<int> *counts) {
|  71|    |-        if (end - start <= 0) {  // The number of range [start, end] of which size is less than 2 doesn't need sort.
|  72|    |-            return;
|  73|    |-        }
|    |  70|+    void countAndMergeSort (vector < pair < int, int >>*num_idxs, int start,
|    |  71|+                            int end, vector < int >*counts)
|    |  72|+    {
|    |  73|+        if (end - start <= 0)
|    |  74|+          {                     // The number of range [start, end] of which size is less than 2 doesn't need sort.
|    |  75|+              return;
|    |  76|+          }
|  74|  77|         int mid = start + (end - start) / 2;
|  75|    |-        countAndMergeSort(num_idxs, start, mid, counts);
|  76|    |-        countAndMergeSort(num_idxs, mid + 1, end, counts);
|    |  78|+        countAndMergeSort (num_idxs, start, mid, counts);
|    |  79|+        countAndMergeSort (num_idxs, mid + 1, end, counts);
|  77|  80| 
|  78|  81|         int l = start;
|  79|  82|         vector<pair<int, int>> tmp;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  76|  76|         countAndMergeSort(num_idxs, mid + 1, end, counts);
|  77|  77| 
|  78|  78|         int l = start;
|  79|    |-        vector<pair<int, int>> tmp;
|  80|    |-        for (int i = mid + 1; i <= end; ++i) {
|  81|    |-            // Merge the two sorted arrays into tmp.
|  82|    |-            while (l <= mid && (*num_idxs)[l].first < (*num_idxs)[i].first) {
|  83|    |-                tmp.emplace_back((*num_idxs)[l++]);
|  84|    |-            }
|  85|    |-            tmp.emplace_back((*num_idxs)[i]);
|  86|    |-            (*counts)[(*num_idxs)[i].second] += l - start;
|  87|    |-        }
|  88|    |-        while (l <= mid) {
|  89|    |-            tmp.emplace_back((*num_idxs)[l++]);
|  90|    |-        }
|    |  79|+        vector < pair < int, int >>tmp;
|    |  80|+        for (int i = mid + 1; i <= end; ++i)
|    |  81|+          {
|    |  82|+              // Merge the two sorted arrays into tmp.
|    |  83|+              while (l <= mid && (*num_idxs)[l].first < (*num_idxs)[i].first)
|    |  84|+                {
|    |  85|+                    tmp.emplace_back ((*num_idxs)[l++]);
|    |  86|+                }
|    |  87|+              tmp.emplace_back ((*num_idxs)[i]);
|    |  88|+              (*counts)[(*num_idxs)[i].second] += l - start;
|    |  89|+          }
|    |  90|+        while (l <= mid)
|    |  91|+          {
|    |  92|+              tmp.emplace_back ((*num_idxs)[l++]);
|    |  93|+          }
|  91|  94|         // Copy tmp back to num_idxs.
|  92|    |-        copy(tmp.begin(), tmp.end(), num_idxs->begin() + start);
|    |  95|+        copy (tmp.begin (), tmp.end (), num_idxs->begin () + start);
|  93|  96|     }
|  94|  97| };
|  95|  98| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
|  96|  96| // Time:  O(nlogn)
|  97|  97| // Space: O(n)
|  98|  98| // BST solution. (743ms)
|  99|    |-class Solution3 {
| 100|    |-public:
| 101|    |-    class BSTreeNode {
| 102|    |-    public:
|    |  99|+class Solution3
|    | 100|+{
|    | 101|+  public:
|    | 102|+    class BSTreeNode
|    | 103|+    {
|    | 104|+      public:
| 103| 105|         int val, count;
| 104| 106|         BSTreeNode *left, *right;
| 105| 107|         BSTreeNode(int val, int count) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
| 102| 102|     public:
| 103| 103|         int val, count;
| 104| 104|         BSTreeNode *left, *right;
| 105|    |-        BSTreeNode(int val, int count) {
|    | 105|+          BSTreeNode (int val, int count)
|    | 106|+        {
| 106| 107|             this->val = val;
| 107| 108|             this->count = count;
| 108| 109|             this->left = this->right = nullptr;
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
| 113| 113|      * @return: Count the number of element before this element 'ai' is
| 114| 114|      *          smaller than it and return count number array
| 115| 115|      */
| 116|    |-    vector<int> countOfSmallerNumberII(vector<int> &A) {
| 117|    |-        vector<int> res;
|    | 116|+    vector < int >countOfSmallerNumberII (vector < int >&A)
|    | 117|+    {
|    | 118|+        vector < int >res;
| 118| 119| 
| 119| 120|         BSTreeNode *root = nullptr;
| 120| 121| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
| 119| 119|         BSTreeNode *root = nullptr;
| 120| 120| 
| 121| 121|         // Insert into BST and get left count.
| 122|    |-        for (int i = 0; i < A.size(); ++i) {
| 123|    |-            BSTreeNode *node = new BSTreeNode(A[i], 0);
| 124|    |-            root = insertNode(root, node);
| 125|    |-            res.emplace_back(query(root, A[i]));
| 126|    |-        }
|    | 122|+        for (int i = 0; i < A.size (); ++i)
|    | 123|+          {
|    | 124|+              BSTreeNode *node = new BSTreeNode (A[i], 0);
|    | 125|+              root = insertNode (root, node);
|    | 126|+              res.emplace_back (query (root, A[i]));
|    | 127|+          }
| 127| 128| 
| 128| 129|         return res;
| 129| 130|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/count-of-smaller-number-before-itself.cpp
|    |++++| /app/C++/count-of-smaller-number-before-itself.cpp
| 129| 129|     }
| 130| 130| 
| 131| 131|     // Insert node into BST.
| 132|    |-    BSTreeNode* insertNode(BSTreeNode* root, BSTreeNode* node) {
| 133|    |-        if (root == nullptr) {
| 134|    |-            return node;
| 135|    |-        }
| 136|    |-        BSTreeNode* curr = root;
| 137|    |-        while (curr) {
| 138|    |-            // Insert left if smaller.
| 139|    |-            if (node->val < curr->val) {
| 140|    |-                ++curr->count; // Increase the number of left children.
| 141|    |-                if (curr->left != nullptr) {
| 142|    |-                    curr = curr->left;
| 143|    |-                } else {
| 144|    |-                    curr->left = node;
| 145|    |-                    break;
|    | 132|+    BSTreeNode *insertNode (BSTreeNode * root, BSTreeNode * node)
|    | 133|+    {
|    | 134|+        if (root == nullptr)
|    | 135|+          {
|    | 136|+              return node;
|    | 137|+          }
|    | 138|+        BSTreeNode *curr = root;
|    | 139|+        while (curr)
|    | 140|+          {
|    | 141|+              // Insert left if smaller.
|    | 142|+              if (node->val < curr->val)
|    | 143|+                {
|    | 144|+                    ++curr->count;  // Increase the number of left children.
|    | 145|+                    if (curr->left != nullptr)
|    | 146|+                      {
|    | 147|+                          curr = curr->left;
|    | 148|+                      }
|    | 149|+                    else
|    | 150|+                      {
|    | 151|+                          curr->left = node;
|    | 152|+                          break;
|    | 153|+                      }
| 146| 154|                 }
| 147|    |-            } else {  // Insert right if larger or equal.
| 148|    |-                if (curr->right != nullptr) {
| 149|    |-                    curr = curr->right;
| 150|    |-                } else {
| 151|    |-                    curr->right = node;
| 152|    |-                    break;
|    | 155|+              else
|    | 156|+                {               // Insert right if larger or equal.
|    | 157|+                    if (curr->right != nullptr)
|    | 158|+                      {
|    | 159|+                          curr = curr->right;
|    | 160|+                      }
|    | 161|+                    else
|    | 162|+                      {
|    | 163|+                          curr->right = node;
|    | 164|+                          break;
|    | 165|+                      }
| 153| 166|                 }
| 154|    |-            }
| 155|    |-        }
|    | 167|+          }
| 156| 168|         return root;
| 157| 169|     }
| 158| 170| 
| 159| 171|     // Query the smaller count of the value.
| 160|    |-    int query(BSTreeNode* root, int val) {
| 161|    |-        if (root == nullptr) {
| 162|    |-            return 0;
| 163|    |-        }
|    | 172|+    int query (BSTreeNode * root, int val)
|    | 173|+    {
|    | 174|+        if (root == nullptr)
|    | 175|+          {
|    | 176|+              return 0;
|    | 177|+          }
| 164| 178|         int count = 0;
| 165|    |-        BSTreeNode* curr = root;
| 166|    |-        while (curr) {
| 167|    |-            // Insert left.
| 168|    |-            if (val < curr->val) {
| 169|    |-                curr = curr->left;
| 170|    |-            } else if (val > curr->val) {
| 171|    |-                count += 1 + curr->count; // Count the number of the smaller nodes.
| 172|    |-                curr = curr->right;
| 173|    |-            } else {  // Equal.
| 174|    |-                return count + curr->count;
| 175|    |-            }
| 176|    |-        }
|    | 179|+        BSTreeNode *curr = root;
|    | 180|+        while (curr)
|    | 181|+          {
|    | 182|+              // Insert left.
|    | 183|+              if (val < curr->val)
|    | 184|+                {
|    | 185|+                    curr = curr->left;
|    | 186|+                }
|    | 187|+              else if (val > curr->val)
|    | 188|+                {
|    | 189|+                    count += 1 + curr->count;   // Count the number of the smaller nodes.
|    | 190|+                    curr = curr->right;
|    | 191|+                }
|    | 192|+              else
|    | 193|+                {               // Equal.
|    | 194|+                    return count + curr->count;
|    | 195|+                }
|    | 196|+          }
| 177| 197|         return 0;
| 178| 198|     }
| 179| 199| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/burst-balloons.cpp
|    |++++| /app/C++/burst-balloons.cpp
|   1|   1| // Time:  O(n^3)
|   2|   2| // Space: O(n^2)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     /**
|   7|   8|      * @param nums a list of integer
|   8|   9|      * @return an integer, maximum coins
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/burst-balloons.cpp
|    |++++| /app/C++/burst-balloons.cpp
|   6|   6|     /**
|   7|   7|      * @param nums a list of integer
|   8|   8|      * @return an integer, maximum coins
|   9|    |-     */  
|  10|    |-    int maxCoins(vector<int>& nums) {
|  11|    |-        vector<int> coins;
|  12|    |-        coins.emplace_back(1);
|  13|    |-        for (const auto& n : nums) {
|  14|    |-            if (n > 0) {
|  15|    |-                coins.emplace_back(n);
|  16|    |-            }
|  17|    |-        }
|  18|    |-        coins.emplace_back(1);
|  19|    |-    
|  20|    |-        vector<vector<int>> max_coins(coins.size(), vector<int>(coins.size()));
|  21|    |-        for (int k = 2; k < coins.size(); ++k) {
|  22|    |-            for (int left = 0; left < coins.size() - k; ++left) {
|  23|    |-                for (int i = left + 1, right = left + k; i < right; ++i) {
|  24|    |-                    max_coins[left][right] = max(max_coins[left][right],
|  25|    |-                         coins[left] * coins[i] * coins[right] +
|  26|    |-                         max_coins[left][i] + max_coins[i][right]);
|    |   9|+     */
|    |  10|+    int maxCoins (vector < int >&nums)
|    |  11|+    {
|    |  12|+        vector < int >coins;
|    |  13|+          coins.emplace_back (1);
|    |  14|+        for (const auto & n:nums)
|    |  15|+          {
|    |  16|+              if (n > 0)
|    |  17|+                {
|    |  18|+                    coins.emplace_back (n);
|  27|  19|                 }
|  28|    |-            }
|  29|    |-        }
|  30|    |-    
|  31|    |-        return max_coins[0][coins.size() - 1];
|    |  20|+          }
|    |  21|+        coins.emplace_back (1);
|    |  22|+
|    |  23|+        vector < vector < int >>max_coins (coins.size (),
|    |  24|+                                           vector < int >(coins.size ()));
|    |  25|+        for (int k = 2; k < coins.size (); ++k)
|    |  26|+          {
|    |  27|+              for (int left = 0; left < coins.size () - k; ++left)
|    |  28|+                {
|    |  29|+                    for (int i = left + 1, right = left + k; i < right; ++i)
|    |  30|+                      {
|    |  31|+                          max_coins[left][right] = max (max_coins[left][right],
|    |  32|+                                                        coins[left] *
|    |  33|+                                                        coins[i] *
|    |  34|+                                                        coins[right] +
|    |  35|+                                                        max_coins[left][i] +
|    |  36|+                                                        max_coins[i][right]);
|    |  37|+                      }
|    |  38|+                }
|    |  39|+          }
|    |  40|+
|    |  41|+        return max_coins[0][coins.size () - 1];
|  32|  42|     }
|  33|  43| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/assignment-operator-overloading-c-only.cpp
|    |++++| /app/C++/assignment-operator-overloading-c-only.cpp
|   1|   1| // Time:  O(n)
|   2|   2| // Space: O(1)
|   3|   3| 
|   4|    |-class Solution {
|   5|    |-public:
|    |   4|+class Solution
|    |   5|+{
|    |   6|+  public:
|   6|   7|     char *m_pData;
|   7|    |-    Solution() {
|    |   8|+      Solution ()
|    |   9|+    {
|   8|  10|         this->m_pData = NULL;
|   9|  11|     }
|  10|  12|     Solution(char *pData) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/assignment-operator-overloading-c-only.cpp
|    |++++| /app/C++/assignment-operator-overloading-c-only.cpp
|   7|   7|     Solution() {
|   8|   8|         this->m_pData = NULL;
|   9|   9|     }
|  10|    |-    Solution(char *pData) {
|    |  10|+    Solution (char *pData)
|    |  11|+    {
|  11|  12|         this->m_pData = pData;
|  12|  13|     }
|  13|  14| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/assignment-operator-overloading-c-only.cpp
|    |++++| /app/C++/assignment-operator-overloading-c-only.cpp
|  12|  12|     }
|  13|  13| 
|  14|  14|     // Implement an assignment operator
|  15|    |-    Solution operator=(const Solution &object) {
|  16|    |-        if (this != &object) {
|  17|    |-            // 1: Allocate new memory and copy the elements.
|  18|    |-            char *new_pData = nullptr;
|  19|    |-            if (object.m_pData != nullptr) {
|  20|    |-                size_t count = strlen(object.m_pData);
|  21|    |-                new_pData = new char[count];
|  22|    |-                copy(object.m_pData, object.m_pData + count, new_pData);
|  23|    |-            }
|    |  15|+    Solution operator= (const Solution & object)
|    |  16|+    {
|    |  17|+        if (this != &object)
|    |  18|+          {
|    |  19|+              // 1: Allocate new memory and copy the elements.
|    |  20|+              char *new_pData = nullptr;
|    |  21|+              if (object.m_pData != nullptr)
|    |  22|+                {
|    |  23|+                    size_t count = strlen (object.m_pData);
|    |  24|+                    new_pData = new char[count];
|    |  25|+                    copy (object.m_pData, object.m_pData + count, new_pData);
|    |  26|+                }
|  24|  27| 
|  25|    |-            // 2: Deallocate old memory.
|  26|    |-            if (m_pData != nullptr) {
|  27|    |-                delete[] m_pData;
|  28|    |-            }
|    |  28|+              // 2: Deallocate old memory.
|    |  29|+              if (m_pData != nullptr)
|    |  30|+                {
|    |  31|+                    delete[]m_pData;
|    |  32|+                }
|  29|  33| 
|  30|    |-            // 3: Assign the new memory to the object.
|  31|    |-            m_pData = new_pData;;
|  32|    |-        }
|    |  34|+              // 3: Assign the new memory to the object.
|    |  35|+              m_pData = new_pData;;
|    |  36|+          }
|  33|  37|         return *this;
|  34|  38|     }
|  35|  39| };
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees-ii.cpp
|    |++++| /app/C++/unique-binary-search-trees-ii.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @paramn n: An integer
|  20|  21|      * @return: A list of root
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees-ii.cpp
|    |++++| /app/C++/unique-binary-search-trees-ii.cpp
|  19|  19|      * @paramn n: An integer
|  20|  20|      * @return: A list of root
|  21|  21|      */
|  22|    |-    vector<TreeNode *> generateTrees(int n) {
|  23|    |-        return generateTrees(1, n);
|    |  22|+    vector < TreeNode * >generateTrees (int n)
|    |  23|+    {
|    |  24|+        return generateTrees (1, n);
|  24|  25|     }
|  25|  26| 
|  26|  27|     vector<TreeNode *> generateTrees(int start, int end) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees-ii.cpp
|    |++++| /app/C++/unique-binary-search-trees-ii.cpp
|  23|  23|         return generateTrees(1, n);
|  24|  24|     }
|  25|  25| 
|  26|    |-    vector<TreeNode *> generateTrees(int start, int end) {
|  27|    |-        vector<TreeNode *> output;
|  28|    |-        if (start > end) {
|  29|    |-            output.emplace_back(nullptr);
|  30|    |-            return output;
|  31|    |-        }
|    |  26|+    vector < TreeNode * >generateTrees (int start, int end)
|    |  27|+    {
|    |  28|+        vector < TreeNode * >output;
|    |  29|+        if (start > end)
|    |  30|+          {
|    |  31|+              output.emplace_back (nullptr);
|    |  32|+              return output;
|    |  33|+          }
|  32|  34| 
|  33|    |-        for (int i = start; i <= end; i++) {
|  34|    |-            vector<TreeNode *> leftSubTrees = generateTrees(start, i - 1);
|  35|    |-            vector<TreeNode *> rightSubTrees = generateTrees(i + 1, end);
|  36|    |-            for (const auto& left : leftSubTrees) {
|  37|    |-                for (const auto& right : rightSubTrees) {
|  38|    |-                    TreeNode *root = new TreeNode(i);
|  39|    |-                    root->left = clone(left);
|  40|    |-                    root->right = clone(right);
|  41|    |-                    output.emplace_back(root);
|    |  35|+        for (int i = start; i <= end; i++)
|    |  36|+          {
|    |  37|+              vector < TreeNode * >leftSubTrees = generateTrees (start, i - 1);
|    |  38|+              vector < TreeNode * >rightSubTrees = generateTrees (i + 1, end);
|    |  39|+            for (const auto & left:leftSubTrees)
|    |  40|+                {
|    |  41|+                  for (const auto & right:rightSubTrees)
|    |  42|+                      {
|    |  43|+                          TreeNode *root = new TreeNode (i);
|    |  44|+                          root->left = clone (left);
|    |  45|+                          root->right = clone (right);
|    |  46|+                          output.emplace_back (root);
|    |  47|+                      }
|  42|  48|                 }
|  43|    |-            }
|  44|  49| 
|  45|    |-        }
|    |  50|+          }
|  46|  51|         return output;
|  47|  52|     }
|  48|  53| 
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees-ii.cpp
|    |++++| /app/C++/unique-binary-search-trees-ii.cpp
|  46|  46|         return output;
|  47|  47|     }
|  48|  48| 
|  49|    |-    TreeNode *clone(TreeNode *root) {
|    |  49|+    TreeNode *clone (TreeNode * root)
|    |  50|+    {
|  50|  51|         TreeNode *newRoot = nullptr;
|  51|  52| 
|  52|  53|         if (root) {
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/unique-binary-search-trees-ii.cpp
|    |++++| /app/C++/unique-binary-search-trees-ii.cpp
|  49|  49|     TreeNode *clone(TreeNode *root) {
|  50|  50|         TreeNode *newRoot = nullptr;
|  51|  51| 
|  52|    |-        if (root) {
|  53|    |-            newRoot = new TreeNode(root->val);
|  54|    |-            newRoot->left = clone(root->left);
|  55|    |-            newRoot->right = clone(root->right);
|  56|    |-        }
|    |  52|+        if (root)
|    |  53|+          {
|    |  54|+              newRoot = new TreeNode (root->val);
|    |  55|+              newRoot->left = clone (root->left);
|    |  56|+              newRoot->right = clone (root->right);
|    |  57|+          }
|  57|  58| 
|  58|  59|         return newRoot;
|  59|  60|     }
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/clone-binary-tree.cpp
|    |++++| /app/C++/clone-binary-tree.cpp
|  13|  13|  *     }
|  14|  14|  * }
|  15|  15|  */
|  16|    |-class Solution {
|  17|    |-public:
|    |  16|+class Solution
|    |  17|+{
|    |  18|+  public:
|  18|  19|     /**
|  19|  20|      * @param root: The root of binary tree
|  20|  21|      * @return root of new tree
|    | [NORMAL] GNUIndentBear:
|    | Indentation can be improved.
|----|    | /app/C++/clone-binary-tree.cpp
|    |++++| /app/C++/clone-binary-tree.cpp
|  19|  19|      * @param root: The root of binary tree
|  20|  20|      * @return root of new tree
|  21|  21|      */
|  22|    |-    TreeNode* cloneTree(TreeNode *root) {
|  23|    |-        if (root == nullptr) {
|  24|    |-            return nullptr;
|  25|    |-        }
|    |  22|+    TreeNode * cloneTree (TreeNode * root)
|    |  23|+    {
|    |  24|+        if (root == nullptr)
|    |  25|+          {
|    |  26|+              return nullptr;
|    |  27|+          }
|  26|  28| 
|  27|    |-        auto clone_root = new TreeNode(root->val);
|  28|    |-        clone_root->left = cloneTree(root->left);
|  29|    |-        clone_root->right = cloneTree(root->right);
|  30|    |-        
|    |  29|+        auto clone_root = new TreeNode (root->val);
|    |  30|+        clone_root->left = cloneTree (root->left);
|    |  31|+        clone_root->right = cloneTree (root->right);
|    |  32|+
|  31|  33|         return clone_root;
|  32|  34|     }
|  33|  35| };
Executing section java...

Java/find-peak-element-ii.java
|   4| class•Solution•{
|    | [NORMAL] CheckstyleBear (OuterTypeFilename):
|    | The name of the outer type and the file do not match.

Java/find-peak-element-ii.java
|   5| ••••/**
|    | [NORMAL] CheckstyleBear (SummaryJavadoc):
|    | First sentence of Javadoc is incomplete (period is missing) or not present.

Java/find-peak-element-ii.java
|   9| ••••public•List<Integer>•findPeakII(int[][]•A)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def modifier' have incorrect indentation level 4, expected level should be 2.

Java/find-peak-element-ii.java
|   9| ••••public•List<Integer>•findPeakII(int[][]•A)•{
|    | [NORMAL] CheckstyleBear (AbbreviationAsWordInName):
|    | Abbreviation in name 'findPeakII' must contain no more than '1' capital letters.

Java/find-peak-element-ii.java
|   9| ••••public•List<Integer>•findPeakII(int[][]•A)•{
|    | [NORMAL] CheckstyleBear (ParameterName):
|    | Parameter name 'A' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  10| ••••••••int•upper•=•0,•down•=•A.length•-•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  10| ••••••••int•upper•=•0,•down•=•A.length•-•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  10| ••••••••int•upper•=•0,•down•=•A.length•-•1;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  11| ••••••••int•left•=•0,•right•=•A[0].length•-•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  11| ••••••••int•left•=•0,•right•=•A[0].length•-•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  11| ••••••••int•left•=•0,•right•=•A[0].length•-•1;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  13| ••••••••while•(upper•<•down•&&•left•<•right)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'while' have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  14| ••••••••••••int•height•=•down•-•upper•+•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  14| ••••••••••••int•height•=•down•-•upper•+•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'while' child have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  15| ••••••••••••int•width•=•right•-•left•+•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  15| ••••••••••••int•width•=•right•-•left•+•1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'while' child have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  17| ••••••••••••//•T(m,•n)•=•T(m,•n•/•2)•+•O(m)•=•T(m•/•2,•n•/•2)•+•O(m)•+•O(n•/•2)•=•...•=•O(2m)•+•O(2n)•=•O(max(m,•n))
|    | [NORMAL] CheckstyleBear (LineLength):
|    | Line is longer than 100 characters (found 116).

Java/find-peak-element-ii.java
|  18| ••••••••••••if•(width•>•height)•{•//•Vertical•split.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  19| ••••••••••••••••int•mid_j•=•left•+•(right•-•left)•/•2;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  19| ••••••••••••••••int•mid_j•=•left•+•(right•-•left)•/•2;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  19| ••••••••••••••••int•mid_j•=•left•+•(right•-•left)•/•2;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'mid_j' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'left_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'central_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  20| ••••••••••••••••int•left_max•=•0,•central_max•=•0,•right_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'right_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  21| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  21| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  21| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  21| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'max_i' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  21| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'max_j' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  22| ••••••••••••••••for•(int•i•=•upper•+•1;•i•<•down;•++i)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  23| ••••••••••••••••••••if•(A[i][mid_j]•>•central_max)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  24| ••••••••••••••••••••••••max_i•=•i;•max_j•=•mid_j;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 24, expected level should be 12.

Java/find-peak-element-ii.java
|  24| ••••••••••••••••••••••••max_i•=•i;•max_j•=•mid_j;
|    | [NORMAL] CheckstyleBear (OneStatementPerLine):
|    | Only one statement per line allowed.

Java/find-peak-element-ii.java
|  25| ••••••••••••••••••••••••central_max•=•A[i][mid_j];
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 24, expected level should be 12.

Java/find-peak-element-ii.java
|  26| ••••••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  27| ••••••••••••••••••••left_max•=•Math.max(left_max,•A[i][mid_j•-•1]);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  28| ••••••••••••••••••••right_max•=•Math.max(right_max,•A[i][mid_j•+••1]);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  29| ••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  30| ••••••••••••••••if•(left_max•>•central_max•&&•left_max•>•right_max)•{•//•Find•left.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  31| ••••••••••••••••••••right•=•mid_j;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  32| ••••••••••••••••}•else•if•(right_max•>•central_max•&&•right_max•>•left_max)•{•//•Find•right.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  33| ••••••••••••••••••••left•=•mid_j;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  34| ••••••••••••••••}•else•{•//•Find•one•peak.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  35| ••••••••••••••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  35| ••••••••••••••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  36| ••••••••••••••••••••numbers.add(max_i);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  37| ••••••••••••••••••••numbers.add(max_j);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  38| ••••••••••••••••••••return•numbers;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  39| ••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  40| ••••••••••••}•else•{•//•Horizontal•split.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  41| ••••••••••••••••int•mid_i•=•upper•+•(down•-•upper)•/•2;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  41| ••••••••••••••••int•mid_i•=•upper•+•(down•-•upper)•/•2;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  41| ••••••••••••••••int•mid_i•=•upper•+•(down•-•upper)•/•2;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'mid_i' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'upper_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'central_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  42| ••••••••••••••••int•upper_max•=•0,•central_max•=•0,•down_max•=•0;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'down_max' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  43| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  43| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  43| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (MultipleVariableDeclarations):
|    | Each variable declaration must be in its own statement.

Java/find-peak-element-ii.java
|  43| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'max_i' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  43| ••••••••••••••••int•max_i•=•-1,•max_j•=•-1;
|    | [NORMAL] CheckstyleBear (LocalVariableName):
|    | Local variable name 'max_j' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.

Java/find-peak-element-ii.java
|  44| ••••••••••••••••for•(int•j•=•left•+•1;•j•<•right;•++j)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  45| ••••••••••••••••••••if•(A[mid_i][j]•>•central_max)•{
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  46| ••••••••••••••••••••••••max_i•=•mid_i;•max_j•=•j;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 24, expected level should be 12.

Java/find-peak-element-ii.java
|  46| ••••••••••••••••••••••••max_i•=•mid_i;•max_j•=•j;
|    | [NORMAL] CheckstyleBear (OneStatementPerLine):
|    | Only one statement per line allowed.

Java/find-peak-element-ii.java
|  47| ••••••••••••••••••••••••central_max•=•A[mid_i][j];
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 24, expected level should be 12.

Java/find-peak-element-ii.java
|  48| ••••••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  49| ••••••••••••••••••••upper_max•=•Math.max(upper_max,•A[mid_i•-•1][j]);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  50| ••••••••••••••••••••down_max•=•Math.max(down_max,•A[mid_i•+•1][j]);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  51| ••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'for rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  52| ••••••••••••••••if•(upper_max•>•central_max•&&•upper_max•>•down_max)•{•//•Find•upper.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  53| ••••••••••••••••••••down•=•mid_i;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  54| ••••••••••••••••}•else•if•(down_max•>•central_max•&&•down_max•>•upper_max)•{•//•Find•down.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  55| ••••••••••••••••••••upper•=•mid_i;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  56| ••••••••••••••••}•else•{•//•Find•one•peak.
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'if rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  57| ••••••••••••••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  57| ••••••••••••••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  58| ••••••••••••••••••••numbers.add(max_i);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  59| ••••••••••••••••••••numbers.add(max_j);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  60| ••••••••••••••••••••return•numbers;
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else' child have incorrect indentation level 20, expected level should be 10.

Java/find-peak-element-ii.java
|  61| ••••••••••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else rcurly' have incorrect indentation level 16, expected level should be 8.

Java/find-peak-element-ii.java
|  62| ••••••••••••}•
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'else rcurly' have incorrect indentation level 12, expected level should be 6.

Java/find-peak-element-ii.java
|  64| ••••••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'while rcurly' have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  66| ••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'member def type' have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  66| ••••••••ArrayList<Integer>•numbers•=•new•ArrayList<Integer>();
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  67| ••••••••numbers.add(-1);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  68| ••••••••numbers.add(-1);
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  70| ••••••••return•numbers;•//•Not•found.••••
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def' child have incorrect indentation level 8, expected level should be 4.

Java/find-peak-element-ii.java
|  71| ••••}
|    | [NORMAL] CheckstyleBear (Indentation):
|    | 'method def rcurly' have incorrect indentation level 4, expected level should be 2.
Executing section yaml...
Executing section python...

Python/cosine-similarity.py
|   6| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 1'

Python/cosine-similarity.py
|  22| •••••••••••••••••••••••••••••••••••••••••••••••••••••••else•invalid
|    | [NORMAL] PycodestyleBear (E127):
|    | E127 continuation line over-indented for visual indent'

Python/maximum-gap.py
|   3| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 0'

Python/maximum-gap.py
|   4| •••••#•@param•numss:•a•list•of•integers
|    | [NORMAL] PycodestyleBear (E114):
|    | E114 indentation is not a multiple of four (comment)'

Python/maximum-gap.py
|   5| •••••#•@return:•the•maximum•difference
|    | [NORMAL] PycodestyleBear (E114):
|    | E114 indentation is not a multiple of four (comment)'

Python/maximum-gap.py
|   9| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/maximum-gap.py
|  14| ••••••••bucket•=•[{'min':float("inf"),•'max':float("-inf")}•\
|    | [NORMAL] PycodestyleBear (E231):
|    | E231 missing whitespace after ':''

Python/maximum-gap.py
|  14| ••••••••bucket•=•[{'min':float("inf"),•'max':float("-inf")}•\
|    | [NORMAL] PycodestyleBear (E231):
|    | E231 missing whitespace after ':''

Python/maximum-gap.py
|  14| ••••••••bucket•=•[{'min':float("inf"),•'max':float("-inf")}•\
|    | [NORMAL] PycodestyleBear (E502):
|    | E502 the backslash is redundant between brackets'

Python/maximum-gap.py
|  15| ••••••••••••••••••••for•_•in•xrange(bucket_size)]
|    | [NORMAL] PycodestyleBear (E127):
|    | E127 continuation line over-indented for visual indent'

Python/maximum-gap.py
|  21| ••••••••••••••••continue••••••
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/maximum-gap.py
|  25| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/maximum-gap.py
|  31| ••••••••••••••••bucket[i]['max']•==•float("-inf"):
|    | [NORMAL] PycodestyleBear (E125):
|    | E125 continuation line with same indent as next logical line'

Python/maximum-gap.py
|  36| ••••••••max_gap•=•max(max_gap,•max_val•-•pre_bucket_max)•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/maximum-gap.py
|  37| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/single-number-iii.py
|  13| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 1'

Python/single-number-iii.py
|  24| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/single-number-iii.py
|  29| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element-ii.py
|   4| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 1'

Python/find-peak-element-ii.py
|   5| ••••#@param•A:•An•list•of•list•integer•
|    | [NORMAL] PycodestyleBear (E265):
|    | E265 block comment should start with '# ''

Python/find-peak-element-ii.py
|   5| ••••#@param•A:•An•list•of•list•integer•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/find-peak-element-ii.py
|   6| ••••#@return:•The•index•of•position•is•a•list•of•integer,•for•example•[2,2]
|    | [NORMAL] PycodestyleBear (E265):
|    | E265 block comment should start with '# ''

Python/find-peak-element-ii.py
|  14| ••••••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element-ii.py
|  15| ••••••••••••#•T(m,•n)•=•T(m,•n•/•2)•+•O(m)•=•T(m•/•2,•n•/•2)•+•O(m)•+•O(n•/•2)•=•...•=•O(2m)•+•O(2n)•=•O(max(m,•n))
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (115 > 79 characters)'

Python/find-peak-element-ii.py
|  16| ••••••••••••if•width•>•height:•#•Vertical•split.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  25| ••••••••••••••••••••right_max•=•max(right_max,•A[i][mid_j•+••1])
|    | [NORMAL] PycodestyleBear (E222):
|    | E222 multiple spaces after operator'

Python/find-peak-element-ii.py
|  26| ••••••••••••••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element-ii.py
|  27| ••••••••••••••••if•left_max•>•central_max•and•left_max•>•right_max:•#•Find•left.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  27| ••••••••••••••••if•left_max•>•central_max•and•left_max•>•right_max:•#•Find•left.
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (80 > 79 characters)'

Python/find-peak-element-ii.py
|  29| ••••••••••••••••elif•right_max•>•central_max•and•right_max•>•left_max:•#•Find•right.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  29| ••••••••••••••••elif•right_max•>•central_max•and•right_max•>•left_max:•#•Find•right.
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (84 > 79 characters)'

Python/find-peak-element-ii.py
|  31| ••••••••••••••••else:•#•Find•one•peak.••••••••
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  31| ••••••••••••••••else:•#•Find•one•peak.••••••••
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/find-peak-element-ii.py
|  33| ••••••••••••••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element-ii.py
|  34| ••••••••••••else:•#•Horizontal•split.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  44| ••••••••••••••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element-ii.py
|  45| ••••••••••••••••if•upper_max•>•central_max•and•upper_max•>•down_max:•#•Find•upper.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  45| ••••••••••••••••if•upper_max•>•central_max•and•upper_max•>•down_max:•#•Find•upper.
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (82 > 79 characters)'

Python/find-peak-element-ii.py
|  47| ••••••••••••••••elif•down_max•>•central_max•and•down_max•>•upper_max:•#•Find•down.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  47| ••••••••••••••••elif•down_max•>•central_max•and•down_max•>•upper_max:•#•Find•down.
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (82 > 79 characters)'

Python/find-peak-element-ii.py
|  49| ••••••••••••••••else:•#•Find•one•peak.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/find-peak-element-ii.py
|  52| ••••••••return•[-1,•-1]•#•Not•found.
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/building-outline.py
|   6| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 1'

Python/building-outline.py
|  11| ••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/building-outline.py
|  13| ••••def•ComputeSkylineInInterval(self,•buildings,•left_endpoint,•right_endpoint):
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (81 > 79 characters)'

Python/building-outline.py
|  17| ••••••••left_skyline•=•self.ComputeSkylineInInterval(buildings,•left_endpoint,•mid)
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (83 > 79 characters)'

Python/building-outline.py
|  18| ••••••••right_skyline•=•self.ComputeSkylineInInterval(buildings,•mid,•right_endpoint)
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (85 > 79 characters)'

Python/building-outline.py
|  20| ••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/building-outline.py
|  25| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/building-outline.py
|  34| ••••••••••••••••i,•j•=•self.MergeIntersectSkylines(merged,•left_skyline[i],•i,\
|    | [NORMAL] PycodestyleBear (E502):
|    | E502 the backslash is redundant between brackets'

Python/building-outline.py
|  35| ••••••••••••••••••••••••••••••••••••••••••••right_skyline[j],•j)
|    | [NORMAL] PycodestyleBear (E128):
|    | E128 continuation line under-indented for visual indent'

Python/building-outline.py
|  36| ••••••••••••else:•#•left_skyline[i][start]•>•right_skyline[j][start].
|    | [NORMAL] PycodestyleBear (E261):
|    | E261 at least two spaces before inline comment'

Python/building-outline.py
|  37| ••••••••••••••••j,•i•=•self.MergeIntersectSkylines(merged,•right_skyline[j],•j,•\
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (81 > 79 characters)'

Python/building-outline.py
|  37| ••••••••••••••••j,•i•=•self.MergeIntersectSkylines(merged,•right_skyline[j],•j,•\
|    | [NORMAL] PycodestyleBear (E502):
|    | E502 the backslash is redundant between brackets'

Python/building-outline.py
|  38| •••••••••••••••••••••••••••••••••••••••left_skyline[i],•i)
|    | [NORMAL] PycodestyleBear (E128):
|    | E128 continuation line under-indented for visual indent'

Python/building-outline.py
|  39| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/building-outline.py
|  44| ••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/building-outline.py
|  59| ••••••••••••••••if•a[start]•!=•b[start]:••••••••••••••••••••••••••••#••••bb
|    | [NORMAL] PycodestyleBear (E262):
|    | E262 inline comment should start with '# ''

Python/find-peak-element.py
|   9| #•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/find-peak-element.py
|  16| #•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/find-peak-element.py
|  26| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 1'

Python/find-peak-element.py
|  27| ••••#@param•A:•An•integers•list.
|    | [NORMAL] PycodestyleBear (E265):
|    | E265 block comment should start with '# ''

Python/find-peak-element.py
|  28| ••••#@return:•return•any•of•peek•positions.
|    | [NORMAL] PycodestyleBear (E265):
|    | E265 block comment should start with '# ''

Python/find-peak-element.py
|  31| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/find-peak-element.py
|  42| •••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/backpack.py
|   4| #•Given•n•items•with•size•A[i],•an•integer•m•denotes•the•size•of•a•backpack.•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|   5| #•How•full•you•can•fill•this•backpack?•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|  11| #•If•we•have•4•items•with•size•[2,•3,•5,•7],•the•backpack•size•is•11,•we•can•select•2,•3•and•5,•
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (95 > 79 characters)'

Python/backpack.py
|  11| #•If•we•have•4•items•with•size•[2,•3,•5,•7],•the•backpack•size•is•11,•we•can•select•2,•3•and•5,•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|  12| #•so•that•the•max•size•we•can•fill•this•backpack•is•10.•If•the•backpack•size•is•12.•
|    | [NORMAL] PycodestyleBear (E501):
|    | E501 line too long (83 > 79 characters)'

Python/backpack.py
|  12| #•so•that•the•max•size•we•can•fill•this•backpack•is•10.•If•the•backpack•size•is•12.•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|  17| class•Solution:
|    | [NORMAL] PycodestyleBear (E302):
|    | E302 expected 2 blank lines, found 0'

Python/backpack.py
|  25| ••••••••d[0][0]•=•True•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|  26| ••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'

Python/backpack.py
|  28| ••••••••••••d[i%2][0]•=•True•
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  28| ••••••••••••d[i%2][0]•=•True•
|    | [NORMAL] PycodestyleBear (W291):
|    | W291 trailing whitespace'

Python/backpack.py
|  30| ••••••••••••••••d[i%2][j]•=•d[(i-1)%2][j]
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  30| ••••••••••••••••d[i%2][j]•=•d[(i-1)%2][j]
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  32| ••••••••••••••••••••d[i%2][j]•=•d[(i-1)%2][j]•or•d[(i-1)%2][j-A[i-1]]
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  32| ••••••••••••••••••••d[i%2][j]•=•d[(i-1)%2][j]•or•d[(i-1)%2][j-A[i-1]]
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  32| ••••••••••••••••••••d[i%2][j]•=•d[(i-1)%2][j]•or•d[(i-1)%2][j-A[i-1]]
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  33| ••••••••••••••••if•d[i%2][j]:
|    | [NORMAL] PycodestyleBear (E228):
|    | E228 missing whitespace around modulo operator'

Python/backpack.py
|  35| ••••••••••••••••••••
|    | [NORMAL] PycodestyleBear (W293):
|    | W293 blank line contains whitespace'
Executing section markdown...
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/LICENSE.md
|    |++++| /app/LICENSE.md
|   1|   1| The MIT License (MIT)
|   2|   2| 
|   3|    |-Copyright (c) 2016 https://github.com/kamyu104/LintCode
|    |   3|+Copyright (c) 2016 <https://github.com/kamyu104/LintCode>
|   4|   4| 
|   5|   5| Permission is hereby granted, free of charge, to any person obtaining a copy
|   6|   6| of this software and associated documentation files (the "Software"), to deal
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
|   7|   7| I'll keep updating for full summary and better solutions. Stay tuned for updates.
|   8|   8| 
|   9|   9| ## Algorithms
|  10|    |-* [Bit Manipulation](https://github.com/kamyu104/LintCode#bit-manipulation)
|  11|    |-* [Array](https://github.com/kamyu104/LintCode#array)
|  12|    |-* [String](https://github.com/kamyu104/LintCode#string)
|  13|    |-* [Linked List](https://github.com/kamyu104/LintCode#linked-list)
|  14|    |-* [Math](https://github.com/kamyu104/LintCode#math)
|  15|    |-* [Tree](https://github.com/kamyu104/LintCode#tree)
|  16|    |-* [Stack](https://github.com/kamyu104/LintCode#stack)
|  17|    |-* [Queue](https://github.com/kamyu104/LintCode#queue)
|  18|    |-* [Heap](https://github.com/kamyu104/LintCode#heap)
|  19|    |-* [Hash Tables](https://github.com/kamyu104/LintCode#hash-tables)
|  20|    |-* [Data Structure](https://github.com/kamyu104/LintCode#data-structure)
|  21|    |-* [Sort](https://github.com/kamyu104/LintCode#sort)
|  22|    |-* [Recursion](https://github.com/kamyu104/LintCode#recursion)
|  23|    |-* [Binary Search](https://github.com/kamyu104/LintCode#binary-search)
|  24|    |-* [Breadth-First Search](https://github.com/kamyu104/LintCode#breadth-first-search)
|  25|    |-* [Depth-First Search](https://github.com/kamyu104/LintCode#depth-first-search)
|  26|    |-* [Backtracking](https://github.com/kamyu104/LintCode#backtracking)
|  27|    |-* [Binary Search Trees](https://github.com/kamyu104/LintCode#binary-search-trees)
|  28|    |-* [Dynamic Programming](https://github.com/kamyu104/LintCode#dynamic-programming)
|  29|    |-* [Greedy](https://github.com/kamyu104/LintCode#greedy)
|  30|    |-* [OO Design](https://github.com/kamyu104/LintCode#oo-design)
|  31|    |-* [System Design](https://github.com/kamyu104/LintCode#system-design)
|    |  10|+
|    |  11|+- [Bit Manipulation](https://github.com/kamyu104/LintCode#bit-manipulation)
|    |  12|+- [Array](https://github.com/kamyu104/LintCode#array)
|    |  13|+- [String](https://github.com/kamyu104/LintCode#string)
|    |  14|+- [Linked List](https://github.com/kamyu104/LintCode#linked-list)
|    |  15|+- [Math](https://github.com/kamyu104/LintCode#math)
|    |  16|+- [Tree](https://github.com/kamyu104/LintCode#tree)
|    |  17|+- [Stack](https://github.com/kamyu104/LintCode#stack)
|    |  18|+- [Queue](https://github.com/kamyu104/LintCode#queue)
|    |  19|+- [Heap](https://github.com/kamyu104/LintCode#heap)
|    |  20|+- [Hash Tables](https://github.com/kamyu104/LintCode#hash-tables)
|    |  21|+- [Data Structure](https://github.com/kamyu104/LintCode#data-structure)
|    |  22|+- [Sort](https://github.com/kamyu104/LintCode#sort)
|    |  23|+- [Recursion](https://github.com/kamyu104/LintCode#recursion)
|    |  24|+- [Binary Search](https://github.com/kamyu104/LintCode#binary-search)
|    |  25|+- [Breadth-First Search](https://github.com/kamyu104/LintCode#breadth-first-search)
|    |  26|+- [Depth-First Search](https://github.com/kamyu104/LintCode#depth-first-search)
|    |  27|+- [Backtracking](https://github.com/kamyu104/LintCode#backtracking)
|    |  28|+- [Binary Search Trees](https://github.com/kamyu104/LintCode#binary-search-trees)
|    |  29|+- [Dynamic Programming](https://github.com/kamyu104/LintCode#dynamic-programming)
|    |  30|+- [Greedy](https://github.com/kamyu104/LintCode#greedy)
|    |  31|+- [OO Design](https://github.com/kamyu104/LintCode#oo-design)
|    |  32|+- [System Design](https://github.com/kamyu104/LintCode#system-design)
|  32|  33| 
|  33|  34| ## Bit Manipulation
|  34|  35| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
|  31|  31| * [System Design](https://github.com/kamyu104/LintCode#system-design)
|  32|  32| 
|  33|  33| ## Bit Manipulation
|  34|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|  35|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
|  36|    |-|1|[A + B Problem](http://lintcode.com/en/problem/a-b-problem/)| [C++](./C++/a-b-problem.cpp)| _O(1)_ | _O(1)_ | Medium | | |
|  37|    |-|82|[Single Number](http://lintcode.com/en/problem/single-number/)| [C++](./C++/single-number.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode| |
|  38|    |-|83|[Single Number II](http://lintcode.com/en/problem/single-number-ii/)| [C++](./C++/single-number-ii.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
|  39|    |-|84|[Single Number III](http://lintcode.com/en/problem/single-number-iii/)| [C++](./C++/single-number-iii.cpp)| _O(n)_ | _O(1)_ | Medium | CTCI | |
|  40|    |-|142|[O(1) Check Power of 2](http://lintcode.com/en/problem/o1-check-power-of-2/)| [C++](./C++/o1-check-power-of-2.cpp)| _O(1)_ | _O(1)_ | Easy | | |
|  41|    |-|179|[Update Bits](http://lintcode.com/en/problem/update-bits/)| [C++](./C++/update-bits.cpp)| _O(1)_ | _O(1)_ | Medium | CTCI | |
|  42|    |-|181|[Flip Bits](http://lintcode.com/en/problem/flip-bits/)| [C++](./C++/flip-bits.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI | |
|  43|    |-|196|[Find the Missing Number](http://lintcode.com/en/problem/find-the-missing-number/)| [C++](./C++/find-the-missing-number.cpp)| _O(n)_ | _O(1)_ | Medium | | |
|  44|    |-|365|[Count 1 in Binary](http://lintcode.com/en/problem/count-1-in-binary/)| [C++](./C++/count-1-in-binary.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI | |
|    |  34|+
|    |  35|+| #   | Title                                                                              | Solution                                 | Time   | Space  | Difficulty | Tag      | Note |
|    |  36|+| --- | ---------------------------------------------------------------------------------- | ---------------------------------------- | ------ | ------ | ---------- | -------- | ---- |
|    |  37|+| 1   | [A + B Problem](http://lintcode.com/en/problem/a-b-problem/)                       | [C++](./C++/a-b-problem.cpp)             | *O(1)* | *O(1)* | Medium     |          |      |
|    |  38|+| 82  | [Single Number](http://lintcode.com/en/problem/single-number/)                     | [C++](./C++/single-number.cpp)           | *O(n)* | *O(1)* | Easy       | LeetCode |      |
|    |  39|+| 83  | [Single Number II](http://lintcode.com/en/problem/single-number-ii/)               | [C++](./C++/single-number-ii.cpp)        | *O(n)* | *O(1)* | Easy       | LeetCode |      |
|    |  40|+| 84  | [Single Number III](http://lintcode.com/en/problem/single-number-iii/)             | [C++](./C++/single-number-iii.cpp)       | *O(n)* | *O(1)* | Medium     | CTCI     |      |
|    |  41|+| 142 | [O(1) Check Power of 2](http://lintcode.com/en/problem/o1-check-power-of-2/)       | [C++](./C++/o1-check-power-of-2.cpp)     | *O(1)* | *O(1)* | Easy       |          |      |
|    |  42|+| 179 | [Update Bits](http://lintcode.com/en/problem/update-bits/)                         | [C++](./C++/update-bits.cpp)             | *O(1)* | *O(1)* | Medium     | CTCI     |      |
|    |  43|+| 181 | [Flip Bits](http://lintcode.com/en/problem/flip-bits/)                             | [C++](./C++/flip-bits.cpp)               | *O(1)* | *O(1)* | Easy       | CTCI     |      |
|    |  44|+| 196 | [Find the Missing Number](http://lintcode.com/en/problem/find-the-missing-number/) | [C++](./C++/find-the-missing-number.cpp) | *O(n)* | *O(1)* | Medium     |          |      |
|    |  45|+| 365 | [Count 1 in Binary](http://lintcode.com/en/problem/count-1-in-binary/)             | [C++](./C++/count-1-in-binary.cpp)       | *O(1)* | *O(1)* | Easy       | CTCI     |      |
|  45|  46| 
|  46|  47| ## Array
|  47|  48| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
|  44|  44| |365|[Count 1 in Binary](http://lintcode.com/en/problem/count-1-in-binary/)| [C++](./C++/count-1-in-binary.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI | |
|  45|  45| 
|  46|  46| ## Array
|  47|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|  48|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
|  49|    |-|6|[Merge Sorted Array](http://lintcode.com/en/problem/merge-sorted-array/)| [C++](./C++/merge-sorted-array.cpp)| _O(m + n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  50|    |-|8|[Rotate String](http://lintcode.com/en/problem/rotate-string/)| [C++](./C++/rotate-string.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
|  51|    |-|9|[Fizz Buzz](http://lintcode.com/en/problem/fizz-buzz/)| [C++](./C++/fizz-buzz.cpp)| _O(n)_ | _O(1)_ | Easy | | |
|  52|    |-|30|[Insert Interval](http://lintcode.com/en/problem/insert-interval/)| [C++](./C++/insert-interval.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | |
|  53|    |-|31|[Partition Array](http://lintcode.com/en/problem/partition-array/)| [C++](./C++/partition-array.cpp)| _O(n)_ | _O(1)_ | Medium | | Two Pointers |
|  54|    |-|32|[Minimum Window Substring](http://lintcode.com/en/problem/minimum-window-substring/)| [C++](./C++/minimum-window-substring.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
|  55|    |-|38|[Search a 2D Matrix II](http://lintcode.com/en/problem/search-a-2d-matrix-ii/)| [C++](./C++/search-a-2d-matrix-ii.cpp)| _O(m + n)_ | _O(1)_ | Medium | EPI | |
|  56|    |-|39|[Recover Rotated Sorted Array](http://lintcode.com/en/problem/recover-rotated-sorted-array/)| [C++](./C++/recover-rotated-sorted-array.cpp)| _O(n)_ | _O(1)_ | Easy | | |
|  57|    |-|46|[Majority Number](http://lintcode.com/en/problem/majority-number/)| [C++](./C++/majority-number.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
|  58|    |-|47|[Majority Number II](http://lintcode.com/en/problem/majority-number/)| [C++](./C++/majority-number-ii.cpp)| _O(n)_ | _O(1)_ | Medium | EPI | |
|  59|    |-|48|[Majority Number III](http://lintcode.com/en/problem/majority-number-iii/)| [C++](./C++/majority-number-iii.cpp)| _O(n)_ | _O(k)_ | Medium | EPI | |
|  60|    |-|49|[Sort Letters by Case](http://lintcode.com/en/problem/sort-letters-by-case/)| [C++](./C++/sort-letters-by-case.cpp)| _O(n)_ | _O(1)_ | Medium | | Two Pointers |
|  61|    |-|50|[Product of Array Exclude Itself](http://lintcode.com/en/problem/product-of-array-exclude-itself/)| [C++](./C++/product-of-array-exclude-itself.cpp)| _O(n)_ | _O(1)_ | Easy | | |
|  62|    |-|51|[Previous Permutation](http://lintcode.com/en/problem/previous-permutation/)| [C++](./C++/previous-permutation.cpp)| _O(n)_ | _O(1)_ | Medium | | |
|  63|    |-|52|[Next Permutation](http://lintcode.com/en/problem/next-permutation/)| [C++](./C++/next-permutation.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
|  64|    |-|57|[3 Sum](http://lintcode.com/en/problem/3-sum/)| [C++](./C++/3-sum.cpp)| _O(n^2)_ | _O(1)_ | Medium | LeetCode | Two Pointers, Sort |
|  65|    |-|58|[4 Sum](http://lintcode.com/en/problem/4-sum/)| [C++](./C++/4-sum.cpp)| _O(n^3)_ | _O(1)_ | Medium | LeetCode | Hash |
|  66|    |-|59|[3 Sum Closest](http://lintcode.com/en/problem/3-sum-closest/)| [C++](./C++/3-sum-closest.cpp)| _O(n^2)_ | _O(1)_ | Medium | LeetCode | Two Pointers, Sort |
|  67|    |-|64|[Merge Sorted Array II](http://lintcode.com/en/problem/merge-sorted-array-ii/)| [C++](./C++/merge-sorted-array-ii.cpp)| _O(m + n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  68|    |-|100|[Remove Duplicates from Sorted Array](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array/)| [C++](./C++/remove-duplicates-from-sorted-array.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  69|    |-|101|[Remove Duplicates from Sorted Array II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array-ii/)| [C++](./C++/remove-duplicates-from-sorted-array-ii.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  70|    |-|133|[Longest Words](http://lintcode.com/en/problem/longest-words/)| [C++](./C++/longest-words.cpp)| _O(n)_ | _O(n)_ | Easy | | |
|  71|    |-|144|[Interleaving Positive and Negative Numbers](http://lintcode.com/en/problem/interleaving-positive-and-negative-numbers/)| [C++](./C++/interleaving-positive-and-negative-numbers.cpp)| _O(n)_ | _O(1)_ | Medium | | Two Pointers |
|  72|    |-|161|[Rotate Image](http://lintcode.com/en/problem/rotate-image/)| [C++](./C++/rotate-image.cpp)| _O(n^2)_ | _O(1)_ | Medium | LeetCode | |
|  73|    |-|162|[Set Matrix Zeroes](http://lintcode.com/en/problem/set-matrix-zeroes/)| [C++](./C++/set-matrix-zeroes.cpp)| _O(m * n)_ | _O(1)_ | Medium | LeetCode | |
|  74|    |-|172|[Remove Element](http://lintcode.com/en/problem/remove-element/)| [C++](./C++/remove-element.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  75|    |-|185|[Matrix Zigzag Traversal](http://lintcode.com/en/problem/matrix-zigzag-traversal/)| [C++](./C++/matrix-zigzag-traversal.cpp)| _O(m * n)_ | _O(1)_ | Easy | | |
|  76|    |-|189|[First Missing Positive](http://lintcode.com/en/problem/first-missing-positive/)| [C++](./C++/first-missing-positive.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | Hash |
|  77|    |-|190|[Next Permutation II](http://lintcode.com/en/problem/next-permutation-ii/)| [C++](./C++/next-permutation-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
|  78|    |-|200|[Longest Palindromic Substring](http://lintcode.com/en/problem/longest-palindromic-substring/)| [C++](./C++/longest-palindromic-substring.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | `Manacher's Algorithm` |
|  79|    |-|363|[Trapping Rain Water](http://lintcode.com/en/problem/trapping-rain-water/)| [C++](./C++/trapping-rain-water.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | Two Pointers, Tricky |
|  80|    |-|373|[Partition Array by Odd and Even](http://lintcode.com/en/problem/partition-array-by-odd-and-even/)| [C++](./C++/partition-array-by-odd-and-even.cpp)| _O(n)_ | _O(1)_ | Easy | | Two Pointers |
|  81|    |-|374| [Spiral Matrix](http://lintcode.com/en/problem/spiral-matrix/) | [C++](./C++/spiral-matrix.cpp) | _O(m * n)_    | _O(1)_         | Medium         | LeetCode | |
|  82|    |-|381| [Spiral Matrix II](http://lintcode.com/en/problem/spiral-matrix-ii/) | [C++](./C++/spiral-matrix-ii.cpp) | _O(n^2)_ | _O(1)_      | Medium         | LeetCode | |
|  83|    |-|382|[Triangle Count](http://lintcode.com/en/problem/triangle-count/)| [C++](./C++/triangle-count.cpp)| _O(n^2)_ | _O(1)_ | Medium | | Two Pointers |
|  84|    |-|383|[Container With Most Water](http://lintcode.com/en/problem/container-with-most-water/)| [C++](./C++/container-with-most-water.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | Two Pointers |
|  85|    |-|388|[Permutation Sequence](http://lintcode.com/en/problem/permutation-sequence/)| [C++](./C++/permutation-sequence.cpp)| _O(n^2)_ | _O(n)_ | Medium | LeetCode | |
|  86|    |-|389|[Valid Sudoku](http://lintcode.com/en/problem/valid-sudoku/)| [C++](./C++/valid-sudoku.cpp)| _O(9^2)_ | _O(9)_ | Easy | LeetCode | |
|  87|    |-|404|[Subarray Sum II](http://lintcode.com/en/problem/subarray-sum-ii/)| [C++](./C++/subarray-sum-ii.cpp)| _O(nlogn)_ | _O(n)_ | Hard | | Two Pointers, Binary Search |
|  88|    |-|405|[Submatrix Sum](http://lintcode.com/en/problem/submatrix-sum/)| [C++](./C++/submatrix-sum.cpp)| _O(m * n^2)_ | _O(m)_ | Hard | | Hash |
|  89|    |-|406|[Minimum Size Subarray Sum](http://lintcode.com/en/problem/minimum-size-subarray-sum/)| [C++](./C++/minimum-size-subarray-sum.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | Two Pointers, Binary Search |
|  90|    |-|539|[Move Zeroes](http://lintcode.com/en/problem/move-zeroes/)| [C++](./C++/move-zeroes.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|    |  47|+
|    |  48|+| #   | Title                                                                                                                    | Solution                                                    | Time          | Space  | Difficulty | Tag           | Note                        |
|    |  49|+| --- | ------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------- | ------------- | ------ | ---------- | ------------- | --------------------------- |
|    |  50|+| 6   | [Merge Sorted Array](http://lintcode.com/en/problem/merge-sorted-array/)                                                 | [C++](./C++/merge-sorted-array.cpp)                         | *O(m + n)*    | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|    |  51|+| 8   | [Rotate String](http://lintcode.com/en/problem/rotate-string/)                                                           | [C++](./C++/rotate-string.cpp)                              | *O(n)*        | *O(1)* | Easy       | LeetCode      |                             |
|    |  52|+| 9   | [Fizz Buzz](http://lintcode.com/en/problem/fizz-buzz/)                                                                   | [C++](./C++/fizz-buzz.cpp)                                  | *O(n)*        | *O(1)* | Easy       |               |                             |
|    |  53|+| 30  | [Insert Interval](http://lintcode.com/en/problem/insert-interval/)                                                       | [C++](./C++/insert-interval.cpp)                            | *O(n)*        | *O(1)* | Easy       | LeetCode, EPI |                             |
|    |  54|+| 31  | [Partition Array](http://lintcode.com/en/problem/partition-array/)                                                       | [C++](./C++/partition-array.cpp)                            | *O(n)*        | *O(1)* | Medium     |               | Two Pointers                |
|    |  55|+| 32  | [Minimum Window Substring](http://lintcode.com/en/problem/minimum-window-substring/)                                     | [C++](./C++/minimum-window-substring.cpp)                   | *O(n)*        | *O(1)* | Medium     | LeetCode      |                             |
|    |  56|+| 38  | [Search a 2D Matrix II](http://lintcode.com/en/problem/search-a-2d-matrix-ii/)                                           | [C++](./C++/search-a-2d-matrix-ii.cpp)                      | *O(m + n)*    | *O(1)* | Medium     | EPI           |                             |
|    |  57|+| 39  | [Recover Rotated Sorted Array](http://lintcode.com/en/problem/recover-rotated-sorted-array/)                             | [C++](./C++/recover-rotated-sorted-array.cpp)               | *O(n)*        | *O(1)* | Easy       |               |                             |
|    |  58|+| 46  | [Majority Number](http://lintcode.com/en/problem/majority-number/)                                                       | [C++](./C++/majority-number.cpp)                            | *O(n)*        | *O(1)* | Easy       | LeetCode      |                             |
|    |  59|+| 47  | [Majority Number II](http://lintcode.com/en/problem/majority-number/)                                                    | [C++](./C++/majority-number-ii.cpp)                         | *O(n)*        | *O(1)* | Medium     | EPI           |                             |
|    |  60|+| 48  | [Majority Number III](http://lintcode.com/en/problem/majority-number-iii/)                                               | [C++](./C++/majority-number-iii.cpp)                        | *O(n)*        | *O(k)* | Medium     | EPI           |                             |
|    |  61|+| 49  | [Sort Letters by Case](http://lintcode.com/en/problem/sort-letters-by-case/)                                             | [C++](./C++/sort-letters-by-case.cpp)                       | *O(n)*        | *O(1)* | Medium     |               | Two Pointers                |
|    |  62|+| 50  | [Product of Array Exclude Itself](http://lintcode.com/en/problem/product-of-array-exclude-itself/)                       | [C++](./C++/product-of-array-exclude-itself.cpp)            | *O(n)*        | *O(1)* | Easy       |               |                             |
|    |  63|+| 51  | [Previous Permutation](http://lintcode.com/en/problem/previous-permutation/)                                             | [C++](./C++/previous-permutation.cpp)                       | *O(n)*        | *O(1)* | Medium     |               |                             |
|    |  64|+| 52  | [Next Permutation](http://lintcode.com/en/problem/next-permutation/)                                                     | [C++](./C++/next-permutation.cpp)                           | *O(n)*        | *O(1)* | Medium     | LeetCode      |                             |
|    |  65|+| 57  | [3 Sum](http://lintcode.com/en/problem/3-sum/)                                                                           | [C++](./C++/3-sum.cpp)                                      | *O(n^2)*      | *O(1)* | Medium     | LeetCode      | Two Pointers, Sort          |
|    |  66|+| 58  | [4 Sum](http://lintcode.com/en/problem/4-sum/)                                                                           | [C++](./C++/4-sum.cpp)                                      | *O(n^3)*      | *O(1)* | Medium     | LeetCode      | Hash                        |
|    |  67|+| 59  | [3 Sum Closest](http://lintcode.com/en/problem/3-sum-closest/)                                                           | [C++](./C++/3-sum-closest.cpp)                              | *O(n^2)*      | *O(1)* | Medium     | LeetCode      | Two Pointers, Sort          |
|    |  68|+| 64  | [Merge Sorted Array II](http://lintcode.com/en/problem/merge-sorted-array-ii/)                                           | [C++](./C++/merge-sorted-array-ii.cpp)                      | *O(m + n)*    | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|    |  69|+| 100 | [Remove Duplicates from Sorted Array](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array/)               | [C++](./C++/remove-duplicates-from-sorted-array.cpp)        | *O(n)*        | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|    |  70|+| 101 | [Remove Duplicates from Sorted Array II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array-ii/)         | [C++](./C++/remove-duplicates-from-sorted-array-ii.cpp)     | *O(n)*        | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|    |  71|+| 133 | [Longest Words](http://lintcode.com/en/problem/longest-words/)                                                           | [C++](./C++/longest-words.cpp)                              | *O(n)*        | *O(n)* | Easy       |               |                             |
|    |  72|+| 144 | [Interleaving Positive and Negative Numbers](http://lintcode.com/en/problem/interleaving-positive-and-negative-numbers/) | [C++](./C++/interleaving-positive-and-negative-numbers.cpp) | *O(n)*        | *O(1)* | Medium     |               | Two Pointers                |
|    |  73|+| 161 | [Rotate Image](http://lintcode.com/en/problem/rotate-image/)                                                             | [C++](./C++/rotate-image.cpp)                               | *O(n^2)*      | *O(1)* | Medium     | LeetCode      |                             |
|    |  74|+| 162 | [Set Matrix Zeroes](http://lintcode.com/en/problem/set-matrix-zeroes/)                                                   | [C++](./C++/set-matrix-zeroes.cpp)                          | *O(m \* n)*   | *O(1)* | Medium     | LeetCode      |                             |
|    |  75|+| 172 | [Remove Element](http://lintcode.com/en/problem/remove-element/)                                                         | [C++](./C++/remove-element.cpp)                             | *O(n)*        | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|    |  76|+| 185 | [Matrix Zigzag Traversal](http://lintcode.com/en/problem/matrix-zigzag-traversal/)                                       | [C++](./C++/matrix-zigzag-traversal.cpp)                    | *O(m \* n)*   | *O(1)* | Easy       |               |                             |
|    |  77|+| 189 | [First Missing Positive](http://lintcode.com/en/problem/first-missing-positive/)                                         | [C++](./C++/first-missing-positive.cpp)                     | *O(n)*        | *O(1)* | Easy       | LeetCode, EPI | Hash                        |
|    |  78|+| 190 | [Next Permutation II](http://lintcode.com/en/problem/next-permutation-ii/)                                               | [C++](./C++/next-permutation-ii.cpp)                        | *O(n)*        | *O(1)* | Medium     | LeetCode      |                             |
|    |  79|+| 200 | [Longest Palindromic Substring](http://lintcode.com/en/problem/longest-palindromic-substring/)                           | [C++](./C++/longest-palindromic-substring.cpp)              | *O(n)*        | *O(n)* | Medium     | LeetCode      | `Manacher's Algorithm`      |
|    |  80|+| 363 | [Trapping Rain Water](http://lintcode.com/en/problem/trapping-rain-water/)                                               | [C++](./C++/trapping-rain-water.cpp)                        | *O(n)*        | *O(1)* | Medium     | LeetCode      | Two Pointers, Tricky        |
|    |  81|+| 373 | [Partition Array by Odd and Even](http://lintcode.com/en/problem/partition-array-by-odd-and-even/)                       | [C++](./C++/partition-array-by-odd-and-even.cpp)            | *O(n)*        | *O(1)* | Easy       |               | Two Pointers                |
|    |  82|+| 374 | [Spiral Matrix](http://lintcode.com/en/problem/spiral-matrix/)                                                           | [C++](./C++/spiral-matrix.cpp)                              | *O(m \* n)*   | *O(1)* | Medium     | LeetCode      |                             |
|    |  83|+| 381 | [Spiral Matrix II](http://lintcode.com/en/problem/spiral-matrix-ii/)                                                     | [C++](./C++/spiral-matrix-ii.cpp)                           | *O(n^2)*      | *O(1)* | Medium     | LeetCode      |                             |
|    |  84|+| 382 | [Triangle Count](http://lintcode.com/en/problem/triangle-count/)                                                         | [C++](./C++/triangle-count.cpp)                             | *O(n^2)*      | *O(1)* | Medium     |               | Two Pointers                |
|    |  85|+| 383 | [Container With Most Water](http://lintcode.com/en/problem/container-with-most-water/)                                   | [C++](./C++/container-with-most-water.cpp)                  | *O(n)*        | *O(1)* | Medium     | LeetCode, EPI | Two Pointers                |
|    |  86|+| 388 | [Permutation Sequence](http://lintcode.com/en/problem/permutation-sequence/)                                             | [C++](./C++/permutation-sequence.cpp)                       | *O(n^2)*      | *O(n)* | Medium     | LeetCode      |                             |
|    |  87|+| 389 | [Valid Sudoku](http://lintcode.com/en/problem/valid-sudoku/)                                                             | [C++](./C++/valid-sudoku.cpp)                               | *O(9^2)*      | *O(9)* | Easy       | LeetCode      |                             |
|    |  88|+| 404 | [Subarray Sum II](http://lintcode.com/en/problem/subarray-sum-ii/)                                                       | [C++](./C++/subarray-sum-ii.cpp)                            | *O(nlogn)*    | *O(n)* | Hard       |               | Two Pointers, Binary Search |
|    |  89|+| 405 | [Submatrix Sum](http://lintcode.com/en/problem/submatrix-sum/)                                                           | [C++](./C++/submatrix-sum.cpp)                              | *O(m \* n^2)* | *O(m)* | Hard       |               | Hash                        |
|    |  90|+| 406 | [Minimum Size Subarray Sum](http://lintcode.com/en/problem/minimum-size-subarray-sum/)                                   | [C++](./C++/minimum-size-subarray-sum.cpp)                  | *O(n)*        | *O(1)* | Medium     | LeetCode      | Two Pointers, Binary Search |
|    |  91|+| 539 | [Move Zeroes](http://lintcode.com/en/problem/move-zeroes/)                                                               | [C++](./C++/move-zeroes.cpp)                                | *O(n)*        | *O(1)* | Easy       | LeetCode      | Two Pointers                |
|  91|  92| 
|  92|  93| ## String
|  93|  94| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
|  90|  90| |539|[Move Zeroes](http://lintcode.com/en/problem/move-zeroes/)| [C++](./C++/move-zeroes.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | Two Pointers |
|  91|  91| 
|  92|  92| ## String
|  93|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|  94|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
|  95|    |-|13|[strStr](http://lintcode.com/en/problem/strstr/)|[C++](./C++/strstr.cpp)| _O(n + k)_ | _O(k)_ | Easy | LeetCode | `KMP Algorithm` |
|  96|    |-|53|[Reverse Words in a String](http://lintcode.com/en/problem/reverse-words-in-a-string/)|[C++](./C++/reverse-words-in-a-string.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | |
|  97|    |-|54|[String to Integer(atoi)](http://lintcode.com/en/problem/string-to-integeratoi/)|[C++](./C++/string-to-integeratoi.cpp)| _O(n)_ | _O(1)_ | Hard | LeetCode | |
|  98|    |-|55|[Compare Strings](http://lintcode.com/en/problem/compare-strings/)|[C++](./C++/compare-strings.cpp)| _O(n)_ | _O(c)_ | Easy | | |
|  99|    |-|78|[Longest Common Prefix](http://lintcode.com/en/problem/longest-common-prefix/)|[C++](./C++/longest-common-prefix.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 100|    |-|157|[Unique Characters](http://lintcode.com/en/problem/unique-characters/)|[C++](./C++/unique-characters.cpp)| _O(n)_ | _O(1)_ | Easy | CTCI | |
| 101|    |-|158|[Two Strings Are Anagrams](http://lintcode.com/en/problem/two-strings-are-anagrams/)|[C++](./C++/two-strings-are-anagrams.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 102|    |-|171|[Anagrams](http://lintcode.com/en/problem/anagrams/)|[C++](./C++/anagrams.cpp)| _O(n * klogk)_ | _O(m)_ | Easy | LeetCode, EPI | |
| 103|    |-|212|[Space Replacement](http://lintcode.com/en/problem/space-replacement/)|[C++](./C++/space-replacement.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 104|    |-|407|[Plus One](http://lintcode.com/en/problem/plus-one.cpp/)|[C++](./C++/plus-one.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 105|    |-|408|[Add Binary](http://lintcode.com/en/problem/add-binary/)|[C++](./C++/add-binary.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 106|    |-|415|[Valid Palindrome](http://lintcode.com/en/problem/valid-palindrome/)|[C++](./C++/valid-palindrome.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 107|    |-|417|[Valid Number](http://lintcode.com/en/problem/valid-number/)|[C++](./C++/valid-number.cpp)| _O(n)_ | _O(1)_ | Hard | LeetCode | Automata |
| 108|    |-|420|[Count and Say](http://lintcode.com/en/problem/count-and-say/)|[C++](./C++/count-and-say.cpp)| _O(n * 2^n)_ | _O(2^n)_ | Easy | LeetCode | |
| 109|    |-|422|[Length of Last Word](http://lintcode.com/en/problem/length-of-last-word/)|[C++](./C++/length-of-last-word.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 110|    |-|524|[Left Pad](http://lintcode.com/en/problem/left-pad/)|[C++](./C++/left-pad.cpp)| _O(p + n)_ | _O(1)_ | Easy | LeetCode | |
|    |  93|+
|    |  94|+| #   | Title                                                                                  | Solution                                   | Time            | Space    | Difficulty | Tag           | Note            |
|    |  95|+| --- | -------------------------------------------------------------------------------------- | ------------------------------------------ | --------------- | -------- | ---------- | ------------- | --------------- |
|    |  96|+| 13  | [strStr](http://lintcode.com/en/problem/strstr/)                                       | [C++](./C++/strstr.cpp)                    | *O(n + k)*      | *O(k)*   | Easy       | LeetCode      | `KMP Algorithm` |
|    |  97|+| 53  | [Reverse Words in a String](http://lintcode.com/en/problem/reverse-words-in-a-string/) | [C++](./C++/reverse-words-in-a-string.cpp) | *O(n)*          | *O(1)*   | Easy       | LeetCode, EPI |                 |
|    |  98|+| 54  | [String to Integer(atoi)](http://lintcode.com/en/problem/string-to-integeratoi/)       | [C++](./C++/string-to-integeratoi.cpp)     | *O(n)*          | *O(1)*   | Hard       | LeetCode      |                 |
|    |  99|+| 55  | [Compare Strings](http://lintcode.com/en/problem/compare-strings/)                     | [C++](./C++/compare-strings.cpp)           | *O(n)*          | *O(c)*   | Easy       |               |                 |
|    | 100|+| 78  | [Longest Common Prefix](http://lintcode.com/en/problem/longest-common-prefix/)         | [C++](./C++/longest-common-prefix.cpp)     | *O(n)*          | *O(1)*   | Medium     |               |                 |
|    | 101|+| 157 | [Unique Characters](http://lintcode.com/en/problem/unique-characters/)                 | [C++](./C++/unique-characters.cpp)         | *O(n)*          | *O(1)*   | Easy       | CTCI          |                 |
|    | 102|+| 158 | [Two Strings Are Anagrams](http://lintcode.com/en/problem/two-strings-are-anagrams/)   | [C++](./C++/two-strings-are-anagrams.cpp)  | *O(n)*          | *O(1)*   | Easy       |               |                 |
|    | 103|+| 171 | [Anagrams](http://lintcode.com/en/problem/anagrams/)                                   | [C++](./C++/anagrams.cpp)                  | *O(n \* klogk)* | *O(m)*   | Easy       | LeetCode, EPI |                 |
|    | 104|+| 212 | [Space Replacement](http://lintcode.com/en/problem/space-replacement/)                 | [C++](./C++/space-replacement.cpp)         | *O(n)*          | *O(1)*   | Easy       |               |                 |
|    | 105|+| 407 | [Plus One](http://lintcode.com/en/problem/plus-one.cpp/)                               | [C++](./C++/plus-one.cpp)                  | *O(n)*          | *O(1)*   | Easy       | LeetCode      |                 |
|    | 106|+| 408 | [Add Binary](http://lintcode.com/en/problem/add-binary/)                               | [C++](./C++/add-binary.cpp)                | *O(n)*          | *O(1)*   | Easy       | LeetCode      |                 |
|    | 107|+| 415 | [Valid Palindrome](http://lintcode.com/en/problem/valid-palindrome/)                   | [C++](./C++/valid-palindrome.cpp)          | *O(n)*          | *O(1)*   | Easy       | LeetCode      |                 |
|    | 108|+| 417 | [Valid Number](http://lintcode.com/en/problem/valid-number/)                           | [C++](./C++/valid-number.cpp)              | *O(n)*          | *O(1)*   | Hard       | LeetCode      | Automata        |
|    | 109|+| 420 | [Count and Say](http://lintcode.com/en/problem/count-and-say/)                         | [C++](./C++/count-and-say.cpp)             | *O(n \* 2^n)*   | *O(2^n)* | Easy       | LeetCode      |                 |
|    | 110|+| 422 | [Length of Last Word](http://lintcode.com/en/problem/length-of-last-word/)             | [C++](./C++/length-of-last-word.cpp)       | *O(n)*          | *O(1)*   | Easy       | LeetCode      |                 |
|    | 111|+| 524 | [Left Pad](http://lintcode.com/en/problem/left-pad/)                                   | [C++](./C++/left-pad.cpp)                  | *O(p + n)*      | *O(1)*   | Easy       | LeetCode      |                 |
| 111| 112| 
| 112| 113| ## Linked List
| 113| 114| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 110| 110| |524|[Left Pad](http://lintcode.com/en/problem/left-pad/)|[C++](./C++/left-pad.cpp)| _O(p + n)_ | _O(1)_ | Easy | LeetCode | |
| 111| 111| 
| 112| 112| ## Linked List
| 113|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 114|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 115|    |-|16|[Merge Two Sorted Lists](http://lintcode.com/en/problem/merge-two-sorted-lists/)|[C++](./C++/merge-two-sorted-lists.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | |
| 116|    |-|35|[Reverse Linked List](http://lintcode.com/en/problem/reverse-linked-list/)|[C++](./C++/reverse-linked-list.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | |
| 117|    |-|36|[Reverse Linked List II](http://lintcode.com/en/problem/reverse-linked-list-ii/)|[C++](./C++/reverse-linked-list-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 118|    |-|96|[Partition List](http://lintcode.com/en/problem/partition-list/)|[C++](./C++/partition-list.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 119|    |-|98|[Sort List](http://lintcode.com/en/problem/sort-list/)|[C++](./C++/sort-list.cpp)| _O(nlogn)_ | _O(logn)_ | Medium | LeetCode, EPI | |
| 120|    |-|99|[Reorder List](http://lintcode.com/en/problem/reorder-list/)|[C++](./C++/reorder-list.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 121|    |-|102|[Linked List Cycle](http://lintcode.com/en/problem/linked-list-cycle/)|[C++](./C++/linked-list-cycle.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 122|    |-|103|[Linked List Cycle II](http://lintcode.com/en/problem/linked-list-cycle-ii/)|[C++](./C++/linked-list-cycle-ii.cpp)| _O(n)_ | _O(1)_ | Hard | LeetCode | |
| 123|    |-|104|[Merge k Sorted Lists](http://lintcode.com/en/problem/merge-k-sorted-lists/)| [C++](./C++/merge-k-sorted-lists.cpp)| _O(n * logk)_ | _O(1)_ | Medium | LeetCode | Heap, Divide and Conquer |
| 124|    |-|105|[Copy List with Random Pointer](http://lintcode.com/en/problem/copy-list-with-random-pointer/)|[C++](./C++/copy-list-with-random-pointer.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 125|    |-|106|[Convert Sorted List to Binary Search Tree](http://lintcode.com/en/problem/convert-sorted-list-to-binary-search-tree/)|[C++](./C++/convert-sorted-list-to-binary-search-tree.cpp)| _O(n)_ | _O(logn)_ | Medium | LeetCode, EPI | |
| 126|    |-|112|[Remove Duplicates from Sorted List](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list/)|[C++](./C++/remove-duplicates-from-sorted-list.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | |
| 127|    |-|113|[Remove Duplicates from Sorted List II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list-ii/)|[C++](./C++/remove-duplicates-from-sorted-list-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 128|    |-|166|[Nth to Last Node in List](http://lintcode.com/en/problem/nth-to-last-node-in-list/)|[C++](./C++/nth-to-last-node-in-list.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 129|    |-|167|[Two Lists Sum](http://lintcode.com/en/problem/two-lists-sum/)|[C++](./C++/two-lists-sum.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 130|    |-|170|[Rotate List](http://lintcode.com/en/problem/rotate-list/)|[C++](./C++/rotate-list.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 131|    |-|173|[Insertion Sort List](http://lintcode.com/en/problem/insertion-sort-list/)|[C++](./C++/insertion-sort-list.cpp)| _O(n^2)_ | _O(1)_ | Easy | LeetCode | |
| 132|    |-|174|[Remove Nth Node From End of List](http://lintcode.com/en/problem/remove-nth-node-from-end-of-list/)|[C++](./C++/remove-nth-node-from-end-of-list.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 133|    |-|223|[Palindrome Linked List](http://lintcode.com/en/problem/palindrome-linked-list/)|[C++](./C++/palindrome-linked-list.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 134|    |-|372|[Delete Node in the Middle of Singly Linked List](http://lintcode.com/en/problem/delete-node-in-the-middle-of-singly-linked-list/)|[C++](./C++/delete-node-in-the-middle-of-singly-linked-list.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI | |
| 135|    |-|380|[Intersection of Two Linked Lists](http://lintcode.com/en/problem/intersection-of-two-linked-lists/)|[C++](./C++/intersection-of-two-linked-lists.cpp)| _O(m + n)_ | _O(1)_ | Easy | LeetCode | |
| 136|    |-|450|[Reverse Nodes in k-Group](http://lintcode.com/en/problem/reverse-nodes-in-k-group/)|[C++](./C++/reverse-nodes-in-k-group.cpp)| _O(n)_ | _O(1)_ | Hard | LeetCode | |
| 137|    |-|451|[Swap Nodes in Pairs](http://lintcode.com/en/problem/swap-nodes-in-pairs/)|[C++](./C++/swap-nodes-in-pairs.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 138|    |-|452|[Remove Linked List Elements](http://lintcode.com/en/problem/remove-linked-list-elements/)|[C++](./C++/remove-linked-list-elements.cpp)| _O(n)_ | _O(1)_ | Naive | LeetCode | |
| 139|    |-|511|[Swap Two Nodes in Linked List](http://lintcode.com/en/problem/swap-two-nodes-in-linked-list/)|[C++](./C++/swap-two-nodes-in-linked-list.cpp)| _O(n)_ | _O(1)_ | Medium | | |
|    | 113|+
|    | 114|+| #   | Title                                                                                                                              | Solution                                                         | Time           | Space     | Difficulty | Tag           | Note                     |
|    | 115|+| --- | ---------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------- | --------- | ---------- | ------------- | ------------------------ |
|    | 116|+| 16  | [Merge Two Sorted Lists](http://lintcode.com/en/problem/merge-two-sorted-lists/)                                                   | [C++](./C++/merge-two-sorted-lists.cpp)                          | *O(n)*         | *O(1)*    | Easy       | LeetCode, EPI |                          |
|    | 117|+| 35  | [Reverse Linked List](http://lintcode.com/en/problem/reverse-linked-list/)                                                         | [C++](./C++/reverse-linked-list.cpp)                             | *O(n)*         | *O(1)*    | Easy       | LeetCode, EPI |                          |
|    | 118|+| 36  | [Reverse Linked List II](http://lintcode.com/en/problem/reverse-linked-list-ii/)                                                   | [C++](./C++/reverse-linked-list-ii.cpp)                          | *O(n)*         | *O(1)*    | Medium     | LeetCode, EPI |                          |
|    | 119|+| 96  | [Partition List](http://lintcode.com/en/problem/partition-list/)                                                                   | [C++](./C++/partition-list.cpp)                                  | *O(n)*         | *O(1)*    | Easy       | LeetCode      |                          |
|    | 120|+| 98  | [Sort List](http://lintcode.com/en/problem/sort-list/)                                                                             | [C++](./C++/sort-list.cpp)                                       | *O(nlogn)*     | *O(logn)* | Medium     | LeetCode, EPI |                          |
|    | 121|+| 99  | [Reorder List](http://lintcode.com/en/problem/reorder-list/)                                                                       | [C++](./C++/reorder-list.cpp)                                    | *O(n)*         | *O(1)*    | Medium     | LeetCode      |                          |
|    | 122|+| 102 | [Linked List Cycle](http://lintcode.com/en/problem/linked-list-cycle/)                                                             | [C++](./C++/linked-list-cycle.cpp)                               | *O(n)*         | *O(1)*    | Medium     | LeetCode      |                          |
|    | 123|+| 103 | [Linked List Cycle II](http://lintcode.com/en/problem/linked-list-cycle-ii/)                                                       | [C++](./C++/linked-list-cycle-ii.cpp)                            | *O(n)*         | *O(1)*    | Hard       | LeetCode      |                          |
|    | 124|+| 104 | [Merge k Sorted Lists](http://lintcode.com/en/problem/merge-k-sorted-lists/)                                                       | [C++](./C++/merge-k-sorted-lists.cpp)                            | *O(n \* logk)* | *O(1)*    | Medium     | LeetCode      | Heap, Divide and Conquer |
|    | 125|+| 105 | [Copy List with Random Pointer](http://lintcode.com/en/problem/copy-list-with-random-pointer/)                                     | [C++](./C++/copy-list-with-random-pointer.cpp)                   | *O(n)*         | *O(1)*    | Medium     | LeetCode      |                          |
|    | 126|+| 106 | [Convert Sorted List to Binary Search Tree](http://lintcode.com/en/problem/convert-sorted-list-to-binary-search-tree/)             | [C++](./C++/convert-sorted-list-to-binary-search-tree.cpp)       | *O(n)*         | *O(logn)* | Medium     | LeetCode, EPI |                          |
|    | 127|+| 112 | [Remove Duplicates from Sorted List](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list/)                           | [C++](./C++/remove-duplicates-from-sorted-list.cpp)              | *O(n)*         | *O(1)*    | Easy       | LeetCode, EPI |                          |
|    | 128|+| 113 | [Remove Duplicates from Sorted List II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list-ii/)                     | [C++](./C++/remove-duplicates-from-sorted-list-ii.cpp)           | *O(n)*         | *O(1)*    | Medium     | LeetCode, EPI |                          |
|    | 129|+| 166 | [Nth to Last Node in List](http://lintcode.com/en/problem/nth-to-last-node-in-list/)                                               | [C++](./C++/nth-to-last-node-in-list.cpp)                        | *O(n)*         | *O(1)*    | Easy       | LeetCode      |                          |
|    | 130|+| 167 | [Two Lists Sum](http://lintcode.com/en/problem/two-lists-sum/)                                                                     | [C++](./C++/two-lists-sum.cpp)                                   | *O(n)*         | *O(1)*    | Easy       | LeetCode      |                          |
|    | 131|+| 170 | [Rotate List](http://lintcode.com/en/problem/rotate-list/)                                                                         | [C++](./C++/rotate-list.cpp)                                     | *O(n)*         | *O(1)*    | Medium     | LeetCode      |                          |
|    | 132|+| 173 | [Insertion Sort List](http://lintcode.com/en/problem/insertion-sort-list/)                                                         | [C++](./C++/insertion-sort-list.cpp)                             | *O(n^2)*       | *O(1)*    | Easy       | LeetCode      |                          |
|    | 133|+| 174 | [Remove Nth Node From End of List](http://lintcode.com/en/problem/remove-nth-node-from-end-of-list/)                               | [C++](./C++/remove-nth-node-from-end-of-list.cpp)                | *O(n)*         | *O(1)*    | Easy       | LeetCode      |                          |
|    | 134|+| 223 | [Palindrome Linked List](http://lintcode.com/en/problem/palindrome-linked-list/)                                                   | [C++](./C++/palindrome-linked-list.cpp)                          | *O(n)*         | *O(1)*    | Medium     | LeetCode      |                          |
|    | 135|+| 372 | [Delete Node in the Middle of Singly Linked List](http://lintcode.com/en/problem/delete-node-in-the-middle-of-singly-linked-list/) | [C++](./C++/delete-node-in-the-middle-of-singly-linked-list.cpp) | *O(1)*         | *O(1)*    | Easy       | CTCI          |                          |
|    | 136|+| 380 | [Intersection of Two Linked Lists](http://lintcode.com/en/problem/intersection-of-two-linked-lists/)                               | [C++](./C++/intersection-of-two-linked-lists.cpp)                | *O(m + n)*     | *O(1)*    | Easy       | LeetCode      |                          |
|    | 137|+| 450 | [Reverse Nodes in k-Group](http://lintcode.com/en/problem/reverse-nodes-in-k-group/)                                               | [C++](./C++/reverse-nodes-in-k-group.cpp)                        | *O(n)*         | *O(1)*    | Hard       | LeetCode      |                          |
|    | 138|+| 451 | [Swap Nodes in Pairs](http://lintcode.com/en/problem/swap-nodes-in-pairs/)                                                         | [C++](./C++/swap-nodes-in-pairs.cpp)                             | *O(n)*         | *O(1)*    | Easy       | LeetCode      |                          |
|    | 139|+| 452 | [Remove Linked List Elements](http://lintcode.com/en/problem/remove-linked-list-elements/)                                         | [C++](./C++/remove-linked-list-elements.cpp)                     | *O(n)*         | *O(1)*    | Naive      | LeetCode      |                          |
|    | 140|+| 511 | [Swap Two Nodes in Linked List](http://lintcode.com/en/problem/swap-two-nodes-in-linked-list/)                                     | [C++](./C++/swap-two-nodes-in-linked-list.cpp)                   | *O(n)*         | *O(1)*    | Medium     |               |                          |
| 140| 141| 
| 141| 142| ## Tree
| 142| 143| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 139| 139| |511|[Swap Two Nodes in Linked List](http://lintcode.com/en/problem/swap-two-nodes-in-linked-list/)|[C++](./C++/swap-two-nodes-in-linked-list.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 140| 140| 
| 141| 141| ## Tree
| 142|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 143|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 144|    |-|7|[Binary Tree Serialization](http://lintcode.com/en/problem/binary-tree-serialization/)| [C++](./C++/binary-tree-serialization.cpp)| _O(n)_ | _O(h)_ | Medium | | |
| 145|    |-|85|[Insert Node in a Binary Search Tree](http://lintcode.com/en/problem/insert-node-in-a-binary-search-tree/)| [C++](./C++/insert-node-in-a-binary-search-tree.cpp)| _O(h)_ | _O(1)_ | Easy | | |
| 146|    |-|88|[Lowest Common Ancestor](http://lintcode.com/en/problem/lowest-common-ancestor/)| [C++](./C++/lowest-common-ancestor.cpp)| _O(n)_ | _O(h)_ | Medium | EPI | |
| 147|    |-|175|[Invert Binary Tree](http://lintcode.com/en/problem/invert-binary-tree/)| [C++](./C++/invert-binary-tree.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 148|    |-|442|[Implement Trie](http://lintcode.com/en/problem/implement-trie/)| [C++](./C++/implement-trie.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | Trie |
|    | 142|+
|    | 143|+| #   | Title                                                                                                      | Solution                                             | Time   | Space  | Difficulty | Tag      | Note |
|    | 144|+| --- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | ------ | ------ | ---------- | -------- | ---- |
|    | 145|+| 7   | [Binary Tree Serialization](http://lintcode.com/en/problem/binary-tree-serialization/)                     | [C++](./C++/binary-tree-serialization.cpp)           | *O(n)* | *O(h)* | Medium     |          |      |
|    | 146|+| 85  | [Insert Node in a Binary Search Tree](http://lintcode.com/en/problem/insert-node-in-a-binary-search-tree/) | [C++](./C++/insert-node-in-a-binary-search-tree.cpp) | *O(h)* | *O(1)* | Easy       |          |      |
|    | 147|+| 88  | [Lowest Common Ancestor](http://lintcode.com/en/problem/lowest-common-ancestor/)                           | [C++](./C++/lowest-common-ancestor.cpp)              | *O(n)* | *O(h)* | Medium     | EPI      |      |
|    | 148|+| 175 | [Invert Binary Tree](http://lintcode.com/en/problem/invert-binary-tree/)                                   | [C++](./C++/invert-binary-tree.cpp)                  | *O(n)* | *O(h)* | Easy       | LeetCode |      |
|    | 149|+| 442 | [Implement Trie](http://lintcode.com/en/problem/implement-trie/)                                           | [C++](./C++/implement-trie.cpp)                      | *O(n)* | *O(1)* | Medium     | LeetCode | Trie |
| 149| 150| 
| 150| 151| ## Stack
| 151| 152| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 148| 148| |442|[Implement Trie](http://lintcode.com/en/problem/implement-trie/)| [C++](./C++/implement-trie.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | Trie |
| 149| 149| 
| 150| 150| ## Stack
| 151|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 152|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 153|    |-|12|[Min Stack](http://lintcode.com/en/problem/min-stack/)| [C++](./C++/min-stack.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 154|    |-|40|[Implement Queue by Two Stacks](http://lintcode.com/en/problem/implement-queue-by-two-stacks/)| [C++](./C++/implement-queue-by-two-stacks.cpp)| _O(1), amortized_ | _O(n)_ | Medium | EPI | |
| 155|    |-|66|[Binary Tree Preorder Traversal](http://lintcode.com/en/problem/binary-tree-preorder-traversal/)| [C++](./C++/binary-tree-preorder-traversal.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | `Morris Traversal` |
| 156|    |-|67|[Binary Tree Inorder Traversal](http://lintcode.com/en/problem/binary-tree-inorder-traversal/)| [C++](./C++/binary-tree-inorder-traversal.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | `Morris Traversal` |
| 157|    |-|68|[Binary Tree Postorder Traversal](http://lintcode.com/en/problem/binary-tree-postorder-traversal/)| [C++](./C++/binary-tree-postorder-traversal.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode, EPI | `Morris Traversal` |
| 158|    |-|122|[Largest Rectangle in Histogram](http://lintcode.com/en/problem/largest-rectangle-in-histogram/)| [C++](./C++/largest-rectangle-in-histogram.cpp)| _O(n)_ | _O(n)_ | Hard | LeetCode, EPI | Ascending Stack |
| 159|    |-|126|[Max Tree](http://lintcode.com/en/problem/max-tree/)| [C++](./C++/max-tree.cpp)| _O(n)_ | _O(n)_ | Hard | | Descending Stack |
| 160|    |-|367|[Expression Tree Build](http://lintcode.com/en/problem/expression-tree-build/)| [C++](./C++/expression-tree-build.cpp)| _O(n)_ | _O(n)_ | Hard | | |
| 161|    |-|368|[Expression Evaluation](http://lintcode.com/en/problem/expression-evaluation/)| [C++](./C++/expression-evaluation.cpp)| _O(n)_ | _O(n)_ | Hard | | |
| 162|    |-|369|[Convert Expression to Polish Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-notation/)| [C++](./C++/convert-expression-to-polish-notation.cpp)| _O(n)_ | _O(n)_ | Hard | | |
| 163|    |-|370|[Convert Expression to Reverse Polish Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-polish-notation/)| [C++](./C++/convert-expression-to-reverse-polish-notation.cpp)| _O(n)_ | _O(n)_ | Hard | | |
| 164|    |-|421|[Simplify Path](http://lintcode.com/en/problem/simplify-path/)| [C++](./C++/simplify-path.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | |
| 165|    |-|423|[Valid Parentheses](http://lintcode.com/en/problem/valid-parentheses.cpp/)| [C++](./C++/valid-parentheses.cpp.cpp)| _O(n)_ | _O(n)_ | Easy | LeetCode | |
| 166|    |-|424|[Evaluate Reverse Polish Notation](http://lintcode.com/en/problem/evaluate-reverse-polish-notation/)| [C++](./C++/evaluate-reverse-polish-notation.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | |
| 167|    |-|473|[Add and Search Word](http://lintcode.com/en/problem/add-and-search-word/)| [C++](./C++/add-and-search-word.cpp)| _O(min(n, h))_ | _O(min(n, h)_ | Medium | LeetCode | Trie |
| 168|    |-|510|[Maximal Rectangle](http://lintcode.com/en/problem/maximal-rectangle/)| [C++](./C++/maximal-rectangle.cpp)| _O(m * n)_ | _O(n)_ | Hard | LeetCode | Ascending Stack |
| 169|    |-|528|[Flatten Nested List Iterator](http://lintcode.com/en/problem/flatten-nested-list-iterator/)| [C++](./C++/flatten-nested-list-iterator.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
|    | 151|+
|    | 152|+| #   | Title                                                                                                                          | Solution                                                       | Time              | Space         | Difficulty | Tag           | Note               |
|    | 153|+| --- | ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------- | ----------------- | ------------- | ---------- | ------------- | ------------------ |
|    | 154|+| 12  | [Min Stack](http://lintcode.com/en/problem/min-stack/)                                                                         | [C++](./C++/min-stack.cpp)                                     | *O(n)*            | *O(1)*        | Medium     | LeetCode, EPI |                    |
|    | 155|+| 40  | [Implement Queue by Two Stacks](http://lintcode.com/en/problem/implement-queue-by-two-stacks/)                                 | [C++](./C++/implement-queue-by-two-stacks.cpp)                 | *O(1), amortized* | *O(n)*        | Medium     | EPI           |                    |
|    | 156|+| 66  | [Binary Tree Preorder Traversal](http://lintcode.com/en/problem/binary-tree-preorder-traversal/)                               | [C++](./C++/binary-tree-preorder-traversal.cpp)                | *O(n)*            | *O(1)*        | Easy       | LeetCode, EPI | `Morris Traversal` |
|    | 157|+| 67  | [Binary Tree Inorder Traversal](http://lintcode.com/en/problem/binary-tree-inorder-traversal/)                                 | [C++](./C++/binary-tree-inorder-traversal.cpp)                 | *O(n)*            | *O(1)*        | Easy       | LeetCode, EPI | `Morris Traversal` |
|    | 158|+| 68  | [Binary Tree Postorder Traversal](http://lintcode.com/en/problem/binary-tree-postorder-traversal/)                             | [C++](./C++/binary-tree-postorder-traversal.cpp)               | *O(n)*            | *O(1)*        | Easy       | LeetCode, EPI | `Morris Traversal` |
|    | 159|+| 122 | [Largest Rectangle in Histogram](http://lintcode.com/en/problem/largest-rectangle-in-histogram/)                               | [C++](./C++/largest-rectangle-in-histogram.cpp)                | *O(n)*            | *O(n)*        | Hard       | LeetCode, EPI | Ascending Stack    |
|    | 160|+| 126 | [Max Tree](http://lintcode.com/en/problem/max-tree/)                                                                           | [C++](./C++/max-tree.cpp)                                      | *O(n)*            | *O(n)*        | Hard       |               | Descending Stack   |
|    | 161|+| 367 | [Expression Tree Build](http://lintcode.com/en/problem/expression-tree-build/)                                                 | [C++](./C++/expression-tree-build.cpp)                         | *O(n)*            | *O(n)*        | Hard       |               |                    |
|    | 162|+| 368 | [Expression Evaluation](http://lintcode.com/en/problem/expression-evaluation/)                                                 | [C++](./C++/expression-evaluation.cpp)                         | *O(n)*            | *O(n)*        | Hard       |               |                    |
|    | 163|+| 369 | [Convert Expression to Polish Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-notation/)                | [C++](./C++/convert-expression-to-polish-notation.cpp)         | *O(n)*            | *O(n)*        | Hard       |               |                    |
|    | 164|+| 370 | [Convert Expression to Reverse Polish Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-polish-notation/) | [C++](./C++/convert-expression-to-reverse-polish-notation.cpp) | *O(n)*            | *O(n)*        | Hard       |               |                    |
|    | 165|+| 421 | [Simplify Path](http://lintcode.com/en/problem/simplify-path/)                                                                 | [C++](./C++/simplify-path.cpp)                                 | *O(n)*            | *O(n)*        | Medium     | LeetCode      |                    |
|    | 166|+| 423 | [Valid Parentheses](http://lintcode.com/en/problem/valid-parentheses.cpp/)                                                     | [C++](./C++/valid-parentheses.cpp.cpp)                         | *O(n)*            | *O(n)*        | Easy       | LeetCode      |                    |
|    | 167|+| 424 | [Evaluate Reverse Polish Notation](http://lintcode.com/en/problem/evaluate-reverse-polish-notation/)                           | [C++](./C++/evaluate-reverse-polish-notation.cpp)              | *O(n)*            | *O(n)*        | Medium     | LeetCode      |                    |
|    | 168|+| 473 | [Add and Search Word](http://lintcode.com/en/problem/add-and-search-word/)                                                     | [C++](./C++/add-and-search-word.cpp)                           | *O(min(n, h))*    | *O(min(n, h)* | Medium     | LeetCode      | Trie               |
|    | 169|+| 510 | [Maximal Rectangle](http://lintcode.com/en/problem/maximal-rectangle/)                                                         | [C++](./C++/maximal-rectangle.cpp)                             | *O(m \* n)*       | *O(n)*        | Hard       | LeetCode      | Ascending Stack    |
|    | 170|+| 528 | [Flatten Nested List Iterator](http://lintcode.com/en/problem/flatten-nested-list-iterator/)                                   | [C++](./C++/flatten-nested-list-iterator.cpp)                  | *O(n)*            | *O(h)*        | Medium     | LeetCode      |                    |
| 170| 171| 
| 171| 172| ## Queue
| 172| 173| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 169| 169| |528|[Flatten Nested List Iterator](http://lintcode.com/en/problem/flatten-nested-list-iterator/)| [C++](./C++/flatten-nested-list-iterator.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
| 170| 170| 
| 171| 171| ## Queue
| 172|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 173|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 174|    |-|362|[Sliding Window Maximum](http://lintcode.com/en/problem/sliding-window-maximum/)| [C++](./C++/sliding-window-maximum.cpp)| _O(n)_ | _O(k)_ | Hard | EPI | Deque, Tricky |
|    | 172|+
|    | 173|+| #   | Title                                                                            | Solution                                | Time   | Space  | Difficulty | Tag | Note          |
|    | 174|+| --- | -------------------------------------------------------------------------------- | --------------------------------------- | ------ | ------ | ---------- | --- | ------------- |
|    | 175|+| 362 | [Sliding Window Maximum](http://lintcode.com/en/problem/sliding-window-maximum/) | [C++](./C++/sliding-window-maximum.cpp) | *O(n)* | *O(k)* | Hard       | EPI | Deque, Tricky |
| 175| 176| 
| 176| 177| ## Heap
| 177| 178| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 174| 174| |362|[Sliding Window Maximum](http://lintcode.com/en/problem/sliding-window-maximum/)| [C++](./C++/sliding-window-maximum.cpp)| _O(n)_ | _O(k)_ | Hard | EPI | Deque, Tricky |
| 175| 175| 
| 176| 176| ## Heap
| 177|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 178|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 179|    |-|4|[Ugly Number II](http://lintcode.com/en/problem/ugly-number-ii/)| [C++](./C++/ugly-number-ii.cpp)| _O(n)_ | _O(1)_ | Medium | CTCI | BST, Heap |
| 180|    |-|81|[Data Stream Median](http://lintcode.com/en/problem/data-stream-median/)| [C++](./C++/data-stream-median.cpp)| _O(nlogn)_ | _O(n)_ | Hard | EPI | BST, Heap |
| 181|    |-|130|[Heapify](http://lintcode.com/en/problem/heapify/)| [C++](./C++/heapify.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 182|    |-|364|[Trapping Rain Water II](http://lintcode.com/en/problem/trapping-rain-water-ii/)| [C++](./C++/trapping-rain-water-ii.cpp)| _O(m * n * (logm + logn))_ | _O(m * n)_ | Hard | | BFS, Heap, Tricky |
| 183|    |-|518|[Super Ugly Number](http://lintcode.com/en/problem/super-ugly-number/)| [C++](./C++/super-ugly-number.cpp)| _O(n * k)_ | _O(n + k)_ | Medium | LeetCode | BST, Heap |
|    | 177|+
|    | 178|+| #   | Title                                                                            | Solution                                | Time                       | Space       | Difficulty | Tag      | Note              |
|    | 179|+| --- | -------------------------------------------------------------------------------- | --------------------------------------- | -------------------------- | ----------- | ---------- | -------- | ----------------- |
|    | 180|+| 4   | [Ugly Number II](http://lintcode.com/en/problem/ugly-number-ii/)                 | [C++](./C++/ugly-number-ii.cpp)         | *O(n)*                     | *O(1)*      | Medium     | CTCI     | BST, Heap         |
|    | 181|+| 81  | [Data Stream Median](http://lintcode.com/en/problem/data-stream-median/)         | [C++](./C++/data-stream-median.cpp)     | *O(nlogn)*                 | *O(n)*      | Hard       | EPI      | BST, Heap         |
|    | 182|+| 130 | [Heapify](http://lintcode.com/en/problem/heapify/)                               | [C++](./C++/heapify.cpp)                | *O(n)*                     | *O(1)*      | Medium     |          |                   |
|    | 183|+| 364 | [Trapping Rain Water II](http://lintcode.com/en/problem/trapping-rain-water-ii/) | [C++](./C++/trapping-rain-water-ii.cpp) | *O(m * n * (logm + logn))* | *O(m \* n)* | Hard       |          | BFS, Heap, Tricky |
|    | 184|+| 518 | [Super Ugly Number](http://lintcode.com/en/problem/super-ugly-number/)           | [C++](./C++/super-ugly-number.cpp)      | *O(n \* k)*                | *O(n + k)*  | Medium     | LeetCode | BST, Heap         |
| 184| 185| 
| 185| 186| ## Hash Tables
| 186| 187| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 183| 183| |518|[Super Ugly Number](http://lintcode.com/en/problem/super-ugly-number/)| [C++](./C++/super-ugly-number.cpp)| _O(n * k)_ | _O(n + k)_ | Medium | LeetCode | BST, Heap |
| 184| 184| 
| 185| 185| ## Hash Tables
| 186|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 187|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 188|    |-|56|[2 Sum](http://lintcode.com/en/problem/2-sum/)| [C++](./C++/2-sum.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | |
| 189|    |-|124|[Longest Consecutive Sequence](http://lintcode.com/en/problem/longest-consecutive-sequence/)| [C++](./C++/longest-consecutive-sequence.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 190|    |-|128|[Hash Function](http://lintcode.com/en/problem/hash-function/)| [C++](./C++/hash-function.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 191|    |-|129|[Rehashing](http://lintcode.com/en/problem/rehashing/)| [C++](./C++/rehashing.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 192|    |-|138|[Subarray Sum](http://lintcode.com/en/problem/subarray-sum/)| [C++](./C++/subarray-sum.cpp)| _O(n)_ | _O(n)_ | Easy | | |
| 193|    |-|186|[Max Points on a Line](http://lintcode.com/en/problem/max-points-on-a-line/)| [C++](./C++/max-points-on-a-line.cpp)| _O(n^2)_ | _O(n)_ | Medium | LeetCode | |
| 194|    |-|211|[String Permutation](http://lintcode.com/en/problem/string-permutation/)| [C++](./C++/string-permutation.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 195|    |-|384|[Longest Substring Without Repeating Characters](http://lintcode.com/en/problem/longest-substring-without-repeating-characters/)| [C++](./C++/longest-substring-without-repeating-characters.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 196|    |-|386|[Longest Substring with At Most K Distinct Characters](http://lintcode.com/en/problem/longest-substring-with-at-most-k-distinct-characters/)| [C++](./C++/longest-substring-with-at-most-k-distinct-characters.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 197|    |-|432|[Find the Weak Connected Component in the Directed Graph](http://lintcode.com/en/problem/find-the-weak-connected-component-in-the-directed-graph/)| [C++](./C++/find-the-weak-connected-component-in-the-directed-graph.cpp)| _O(nlogn)_ | _O(n)_ | Medium | | Union Find |
| 198|    |-|434|[Number of Islands II](http://lintcode.com/en/problem/number-of-islands-ii/)| [C++](./C++/number-of-islands-ii.cpp)| _O(k)_ | _O(k)_ | Hard | | Union Find |
| 199|    |-|488| [Happy Number](http://lintcode.com/en/problem/happy-number/)      | [C++](./C++/happy-number.cpp)   | _O(k)_  | _O(k)_          | Easy          | LeetCode |
| 200|    |-547| [Intersection of Two Arrays](http://lintcode.com/en/problem/intersection-of-two-arrays/) | [C++](./C++/intersection-of-two-arrays.cpp) | _O(m + n)_ | _O(min(m, n))_ | Easy         | EPI, LeetCode | Two Pointers, Binary Search
| 201|    |-548| [Intersection of Two Arrays II](http://lintcode.com/en/problem/intersection-of-two-arrays-ii/) | [C++](./C++/intersection-of-two-arrays-ii.cpp) | _O(m + n)_ | _O(min(m, n))_ | Easy         | EPI, LeetCode | Two Pointers, Binary Search
|    | 186|+
|    | 187|+| #   | Title                                                                                                                                              | Solution                                                                 | Time       | Space          | Difficulty | Tag           | Note                        |
|    | 188|+| --- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ | ---------- | -------------- | ---------- | ------------- | --------------------------- |
|    | 189|+| 56  | [2 Sum](http://lintcode.com/en/problem/2-sum/)                                                                                                     | [C++](./C++/2-sum.cpp)                                                   | *O(n)*     | *O(n)*         | Medium     | LeetCode      |                             |
|    | 190|+| 124 | [Longest Consecutive Sequence](http://lintcode.com/en/problem/longest-consecutive-sequence/)                                                       | [C++](./C++/longest-consecutive-sequence.cpp)                            | *O(n)*     | *O(n)*         | Medium     | LeetCode, EPI |                             |
|    | 191|+| 128 | [Hash Function](http://lintcode.com/en/problem/hash-function/)                                                                                     | [C++](./C++/hash-function.cpp)                                           | *O(n)*     | *O(1)*         | Easy       |               |                             |
|    | 192|+| 129 | [Rehashing](http://lintcode.com/en/problem/rehashing/)                                                                                             | [C++](./C++/rehashing.cpp)                                               | *O(n)*     | *O(n)*         | Medium     |               |                             |
|    | 193|+| 138 | [Subarray Sum](http://lintcode.com/en/problem/subarray-sum/)                                                                                       | [C++](./C++/subarray-sum.cpp)                                            | *O(n)*     | *O(n)*         | Easy       |               |                             |
|    | 194|+| 186 | [Max Points on a Line](http://lintcode.com/en/problem/max-points-on-a-line/)                                                                       | [C++](./C++/max-points-on-a-line.cpp)                                    | *O(n^2)*   | *O(n)*         | Medium     | LeetCode      |                             |
|    | 195|+| 211 | [String Permutation](http://lintcode.com/en/problem/string-permutation/)                                                                           | [C++](./C++/string-permutation.cpp)                                      | *O(n)*     | *O(1)*         | Easy       |               |                             |
|    | 196|+| 384 | [Longest Substring Without Repeating Characters](http://lintcode.com/en/problem/longest-substring-without-repeating-characters/)                   | [C++](./C++/longest-substring-without-repeating-characters.cpp)          | *O(n)*     | *O(1)*         | Medium     | LeetCode, EPI |                             |
|    | 197|+| 386 | [Longest Substring with At Most K Distinct Characters](http://lintcode.com/en/problem/longest-substring-with-at-most-k-distinct-characters/)       | [C++](./C++/longest-substring-with-at-most-k-distinct-characters.cpp)    | *O(n)*     | *O(n)*         | Medium     |               |                             |
|    | 198|+| 432 | [Find the Weak Connected Component in the Directed Graph](http://lintcode.com/en/problem/find-the-weak-connected-component-in-the-directed-graph/) | [C++](./C++/find-the-weak-connected-component-in-the-directed-graph.cpp) | *O(nlogn)* | *O(n)*         | Medium     |               | Union Find                  |
|    | 199|+| 434 | [Number of Islands II](http://lintcode.com/en/problem/number-of-islands-ii/)                                                                       | [C++](./C++/number-of-islands-ii.cpp)                                    | *O(k)*     | *O(k)*         | Hard       |               | Union Find                  |
|    | 200|+| 488 | [Happy Number](http://lintcode.com/en/problem/happy-number/)                                                                                       | [C++](./C++/happy-number.cpp)                                            | *O(k)*     | *O(k)*         | Easy       | LeetCode      |                             |
|    | 201|+| 547 | [Intersection of Two Arrays](http://lintcode.com/en/problem/intersection-of-two-arrays/)                                                           | [C++](./C++/intersection-of-two-arrays.cpp)                              | *O(m + n)* | *O(min(m, n))* | Easy       | EPI, LeetCode | Two Pointers, Binary Search |
|    | 202|+| 548 | [Intersection of Two Arrays II](http://lintcode.com/en/problem/intersection-of-two-arrays-ii/)                                                     | [C++](./C++/intersection-of-two-arrays-ii.cpp)                           | *O(m + n)* | *O(min(m, n))* | Easy       | EPI, LeetCode | Two Pointers, Binary Search |
| 202| 203| 
| 203| 204| ## Data Structure
| 204| 205| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 201| 201| 548| [Intersection of Two Arrays II](http://lintcode.com/en/problem/intersection-of-two-arrays-ii/) | [C++](./C++/intersection-of-two-arrays-ii.cpp) | _O(m + n)_ | _O(min(m, n))_ | Easy         | EPI, LeetCode | Two Pointers, Binary Search
| 202| 202| 
| 203| 203| ## Data Structure
| 204|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 205|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 206|    |-|134|[LRU Cache](http://lintcode.com/en/problem/lru-cache/)| [C++](./C++/lru-cache.cpp)| _O(1)_ | _O(k)_ | Hard | LeetCode, EPI | List, Hash |
|    | 204|+
|    | 205|+| #   | Title                                                  | Solution                   | Time   | Space  | Difficulty | Tag           | Note       |
|    | 206|+| --- | ------------------------------------------------------ | -------------------------- | ------ | ------ | ---------- | ------------- | ---------- |
|    | 207|+| 134 | [LRU Cache](http://lintcode.com/en/problem/lru-cache/) | [C++](./C++/lru-cache.cpp) | *O(1)* | *O(k)* | Hard       | LeetCode, EPI | List, Hash |
| 207| 208| 
| 208| 209| ## Math
| 209| 210| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 206| 206| |134|[LRU Cache](http://lintcode.com/en/problem/lru-cache/)| [C++](./C++/lru-cache.cpp)| _O(1)_ | _O(k)_ | Hard | LeetCode, EPI | List, Hash |
| 207| 207| 
| 208| 208| ## Math
| 209|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 210|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 211|    |-|2|[Trailing Zeros](http://lintcode.com/en/problem/trailing-zeros/)| [C++](./C++/trailing-zeros.cpp)| _O(1)_ | _O(1)_ | Easy | LeetCode | |
| 212|    |-|3|[Digit Counts](http://lintcode.com/en/problem/digit-counts/)| [C++](./C++/digit-counts.cpp)| _O(1)_ | _O(1)_ | Medium | CTCI | |
| 213|    |-|114|[Unique Paths](http://lintcode.com/en/problem/unique-paths/)| [C++](./C++/unique-paths.cpp)| _O(min(m, n))_ | _O(1)_ | Easy | LeetCode, CTCI | DP, Math |
| 214|    |-|163|[Unique Binary Search Trees](http://lintcode.com/en/problem/unique-binary-search-trees/)| [C++](./C++/unique-binary-search-trees.cpp)| _O(n)_ | _O(1)_ | Medium | CTCI | DP, Math, `Catalan Number` |
| 215|    |-|180|[Binary Represention](http://lintcode.com/en/problem/delete-digits/)| [C++](./C++/binary-representation.cpp)| _O(1)_ | _O(1)_ | Hard | CTCI | |
| 216|    |-|197|[Permutation Index](http://lintcode.com/en/problem/permutation-index/)| [C++](./C++/permutation-index.cpp)| _O(n^2)_ | _O(1)_ | Easy | | |
| 217|    |-|198|[Permutation Index II](http://lintcode.com/en/problem/permutation-index-ii/)| [C++](./C++/permutation-index-ii.cpp)| _O(n^2)_ | _O(n)_ | Medium | | |
| 218|    |-|394|[Coins in a Line](http://lintcode.com/en/problem/coins-in-a-line/)| [C++](./C++/coins-in-a-line.cpp)| _O(1)_ | _O(1)_ | Easy | | |
| 219|    |-|411|[Gray Code](http://lintcode.com/en/problem/gray-code/)| [C++](./C++/gray-code.cpp)| _O(2^n)_ | _O(1)_ | Medium | LeetCode | |
| 220|    |-|413|[Reverse Integer](http://lintcode.com/en/problem/reverse-integer/)| [C++](./C++/reverse-integer.cpp)| _O(1)_ | _O(1)_ | Medium | LeetCode | |
| 221|    |-|414|[Divide Two Integer](http://lintcode.com/en/problem/divide-two-integers/)| [C++](./C++/divide-two-integers.cpp)| _O(1)_ | _O(1)_ | Medium | LeetCode | |
| 222|    |-|418|[Integer to Roman](http://lintcode.com/en/problem/integer-to-roman/)| [C++](./C++/integer-to-roman.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 223|    |-|419|[Roman to Integer](http://lintcode.com/en/problem/roman-to-integer/)| [C++](./C++/roman-to-integer.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 224|    |-|428| [Pow(x, n)](http://lintcode.com/en/problem/powx-n/)     | [C++](./C++/powx-n.cpp)     | _O(1)_       | _O(1)_       | Medium         | LeetCode ||
| 225|    |-|445|[Cosine Similarity](http://lintcode.com/en/problem/cosine-similarity/)| [C++](./C++/cosine-similarity.cpp) [Python](./Python/cosine-similarity.py) | _O(n)_ | _O(1)_ | Easy | | |
| 226|    |-|517|[Ugly Number](http://lintcode.com/en/problem/ugly-number/)| [C++](./C++/ugly-number.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI, LeetCode |  |
|    | 209|+
|    | 210|+| #   | Title                                                                                    | Solution                                                                   | Time           | Space  | Difficulty | Tag            | Note                       |
|    | 211|+| --- | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------- | ------ | ---------- | -------------- | -------------------------- |
|    | 212|+| 2   | [Trailing Zeros](http://lintcode.com/en/problem/trailing-zeros/)                         | [C++](./C++/trailing-zeros.cpp)                                            | *O(1)*         | *O(1)* | Easy       | LeetCode       |                            |
|    | 213|+| 3   | [Digit Counts](http://lintcode.com/en/problem/digit-counts/)                             | [C++](./C++/digit-counts.cpp)                                              | *O(1)*         | *O(1)* | Medium     | CTCI           |                            |
|    | 214|+| 114 | [Unique Paths](http://lintcode.com/en/problem/unique-paths/)                             | [C++](./C++/unique-paths.cpp)                                              | *O(min(m, n))* | *O(1)* | Easy       | LeetCode, CTCI | DP, Math                   |
|    | 215|+| 163 | [Unique Binary Search Trees](http://lintcode.com/en/problem/unique-binary-search-trees/) | [C++](./C++/unique-binary-search-trees.cpp)                                | *O(n)*         | *O(1)* | Medium     | CTCI           | DP, Math, `Catalan Number` |
|    | 216|+| 180 | [Binary Represention](http://lintcode.com/en/problem/delete-digits/)                     | [C++](./C++/binary-representation.cpp)                                     | *O(1)*         | *O(1)* | Hard       | CTCI           |                            |
|    | 217|+| 197 | [Permutation Index](http://lintcode.com/en/problem/permutation-index/)                   | [C++](./C++/permutation-index.cpp)                                         | *O(n^2)*       | *O(1)* | Easy       |                |                            |
|    | 218|+| 198 | [Permutation Index II](http://lintcode.com/en/problem/permutation-index-ii/)             | [C++](./C++/permutation-index-ii.cpp)                                      | *O(n^2)*       | *O(n)* | Medium     |                |                            |
|    | 219|+| 394 | [Coins in a Line](http://lintcode.com/en/problem/coins-in-a-line/)                       | [C++](./C++/coins-in-a-line.cpp)                                           | *O(1)*         | *O(1)* | Easy       |                |                            |
|    | 220|+| 411 | [Gray Code](http://lintcode.com/en/problem/gray-code/)                                   | [C++](./C++/gray-code.cpp)                                                 | *O(2^n)*       | *O(1)* | Medium     | LeetCode       |                            |
|    | 221|+| 413 | [Reverse Integer](http://lintcode.com/en/problem/reverse-integer/)                       | [C++](./C++/reverse-integer.cpp)                                           | *O(1)*         | *O(1)* | Medium     | LeetCode       |                            |
|    | 222|+| 414 | [Divide Two Integer](http://lintcode.com/en/problem/divide-two-integers/)                | [C++](./C++/divide-two-integers.cpp)                                       | *O(1)*         | *O(1)* | Medium     | LeetCode       |                            |
|    | 223|+| 418 | [Integer to Roman](http://lintcode.com/en/problem/integer-to-roman/)                     | [C++](./C++/integer-to-roman.cpp)                                          | *O(n)*         | *O(1)* | Medium     | LeetCode       |                            |
|    | 224|+| 419 | [Roman to Integer](http://lintcode.com/en/problem/roman-to-integer/)                     | [C++](./C++/roman-to-integer.cpp)                                          | *O(n)*         | *O(1)* | Medium     | LeetCode       |                            |
|    | 225|+| 428 | [Pow(x, n)](http://lintcode.com/en/problem/powx-n/)                                      | [C++](./C++/powx-n.cpp)                                                    | *O(1)*         | *O(1)* | Medium     | LeetCode       |                            |
|    | 226|+| 445 | [Cosine Similarity](http://lintcode.com/en/problem/cosine-similarity/)                   | [C++](./C++/cosine-similarity.cpp) [Python](./Python/cosine-similarity.py) | *O(n)*         | *O(1)* | Easy       |                |                            |
|    | 227|+| 517 | [Ugly Number](http://lintcode.com/en/problem/ugly-number/)                               | [C++](./C++/ugly-number.cpp)                                               | *O(1)*         | *O(1)* | Easy       | CTCI, LeetCode |                            |
| 227| 228| 
| 228| 229| ## Sort
| 229| 230| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 226| 226| |517|[Ugly Number](http://lintcode.com/en/problem/ugly-number/)| [C++](./C++/ugly-number.cpp)| _O(1)_ | _O(1)_ | Easy | CTCI, LeetCode |  |
| 227| 227| 
| 228| 228| ## Sort
| 229|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 230|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 231|    |-|5|[Kth Largest Element](http://lintcode.com/en/problem/kth-largest-element/)| [C++](./C++/kth-largest-element.cpp)| _O(n)_ ~ _O(n^2)_ | _O(1)_ | Medium | EPI | Two Pointers, Quick Sort |
| 232|    |-|80|[Median](http://lintcode.com/en/problem/median/)| [C++](./C++/median.cpp)| _O(n)_ | _O(1)_ | Easy | EPI | |
| 233|    |-|139|[Subarray Sum Closest](http://lintcode.com/en/problem/subarray-sum-closest/)| [C++](./C++/subarray-sum-closest.cpp)| _O(nlogn)_ | _O(n)_ | Medium | | Sort |
| 234|    |-|143|[Sort Colors II](http://lintcode.com/en/problem/sort-colors-ii/)| [C++](./C++/sort-colors-ii.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 235|    |-|148|[Sort Colors](http://lintcode.com/en/problem/sort-colors/)| [C++](./C++/sort-colors.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 236|    |-|156|[Merge Intervals](http://lintcode.com/en/problem/merge-intervals/)| [C++](./C++/merge-intervals.cpp)| _O(nlogn)_ | _O(1)_ | Easy | LeetCode, EPI | |
| 237|    |-|184|[Largest Number](http://lintcode.com/en/problem/largest-number/)| [C++](./C++/largest-number.cpp)| _O(nlogn)_ | _O(1)_ | Medium | LeetCode | |
| 238|    |-|366|[Fibonacci](http://lintcode.com/en/problem/fibonacci/)| [C++](./C++/fibonacci.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 239|    |-|379|[Reorder array to construct the minimum number](http://lintcode.com/en/problem/reorder-array-to-construct-the-minimum-number/)| [C++](./C++/reorder-array-to-construct-the-minimum-number.cpp)| _O(nlogn)_ | _O(1)_ | Medium | LeetCode | |
| 240|    |-|387|[The Smallest Difference](http://lintcode.com/en/problem/the-smallest-difference/)| [C++](./C++/the-smallest-difference.cpp)| _O(max(m, n) * log(min(m, n)))_ | _O(1)_ | Medium | | Two Pointers, Binary Search |
| 241|    |-|399|[Nuts & Bolts Problem](http://lintcode.com/en/problem/nuts-bolts-problem/)| [C++](./C++/nuts-bolts-problem.cpp)| _O(nlogn)_ | _O(logn)_ | Medium | | Quick Sort |
| 242|    |-|400|[Maximum Gap](http://lintcode.com/en/problem/maximum-gap/)| [C++](./C++/maximum-gap.cpp) [Python](./Python/maximum-gap.py)| _O(n)_ | _O(n)_ | Hard | LeetCode | Bucket Sort |
| 243|    |-|463|[Sort Integers](http://lintcode.com/en/problem/sort-integers/)| [C++](./C++/sort-integers.cpp)| _O(n^2)_ | _O(1)_ | Easy | | Insertion Sort, Selection Sort, Bubble Sort |
| 244|    |-|464|[Sort Integers II](http://lintcode.com/en/problem/sort-integers-ii/)| [C++](./C++/sort-integers-ii.cpp)| _O(nlogn)_ | _O(n)_ | Easy | | Merge Sort, Heap Sort, Quick Sort |
| 245|    |-|507|[Wiggle Sort II](http://lintcode.com/en/problem/wiggle-sort-ii/)| [C++](./C++/wiggle-sort-ii.cpp)|  _O(n)_ on average | _O(1)_ | Medium | LeetCode | Tri Partition |
| 246|    |-|508|[Wiggle Sort](http://lintcode.com/en/problem/wiggle-sort/)| [C++](./C++/wiggle-sort.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
|    | 229|+
|    | 230|+| #   | Title                                                                                                                          | Solution                                                       | Time                             | Space     | Difficulty | Tag           | Note                                        |
|    | 231|+| --- | ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------- | -------------------------------- | --------- | ---------- | ------------- | ------------------------------------------- |
|    | 232|+| 5   | [Kth Largest Element](http://lintcode.com/en/problem/kth-largest-element/)                                                     | [C++](./C++/kth-largest-element.cpp)                           | *O(n)* ~ *O(n^2)*                | *O(1)*    | Medium     | EPI           | Two Pointers, Quick Sort                    |
|    | 233|+| 80  | [Median](http://lintcode.com/en/problem/median/)                                                                               | [C++](./C++/median.cpp)                                        | *O(n)*                           | *O(1)*    | Easy       | EPI           |                                             |
|    | 234|+| 139 | [Subarray Sum Closest](http://lintcode.com/en/problem/subarray-sum-closest/)                                                   | [C++](./C++/subarray-sum-closest.cpp)                          | *O(nlogn)*                       | *O(n)*    | Medium     |               | Sort                                        |
|    | 235|+| 143 | [Sort Colors II](http://lintcode.com/en/problem/sort-colors-ii/)                                                               | [C++](./C++/sort-colors-ii.cpp)                                | *O(n)*                           | *O(1)*    | Medium     |               |                                             |
|    | 236|+| 148 | [Sort Colors](http://lintcode.com/en/problem/sort-colors/)                                                                     | [C++](./C++/sort-colors.cpp)                                   | *O(n)*                           | *O(1)*    | Medium     | LeetCode      |                                             |
|    | 237|+| 156 | [Merge Intervals](http://lintcode.com/en/problem/merge-intervals/)                                                             | [C++](./C++/merge-intervals.cpp)                               | *O(nlogn)*                       | *O(1)*    | Easy       | LeetCode, EPI |                                             |
|    | 238|+| 184 | [Largest Number](http://lintcode.com/en/problem/largest-number/)                                                               | [C++](./C++/largest-number.cpp)                                | *O(nlogn)*                       | *O(1)*    | Medium     | LeetCode      |                                             |
|    | 239|+| 366 | [Fibonacci](http://lintcode.com/en/problem/fibonacci/)                                                                         | [C++](./C++/fibonacci.cpp)                                     | *O(n)*                           | *O(1)*    | Easy       |               |                                             |
|    | 240|+| 379 | [Reorder array to construct the minimum number](http://lintcode.com/en/problem/reorder-array-to-construct-the-minimum-number/) | [C++](./C++/reorder-array-to-construct-the-minimum-number.cpp) | *O(nlogn)*                       | *O(1)*    | Medium     | LeetCode      |                                             |
|    | 241|+| 387 | [The Smallest Difference](http://lintcode.com/en/problem/the-smallest-difference/)                                             | [C++](./C++/the-smallest-difference.cpp)                       | *O(max(m, n) \* log(min(m, n)))* | *O(1)*    | Medium     |               | Two Pointers, Binary Search                 |
|    | 242|+| 399 | [Nuts & Bolts Problem](http://lintcode.com/en/problem/nuts-bolts-problem/)                                                     | [C++](./C++/nuts-bolts-problem.cpp)                            | *O(nlogn)*                       | *O(logn)* | Medium     |               | Quick Sort                                  |
|    | 243|+| 400 | [Maximum Gap](http://lintcode.com/en/problem/maximum-gap/)                                                                     | [C++](./C++/maximum-gap.cpp) [Python](./Python/maximum-gap.py) | *O(n)*                           | *O(n)*    | Hard       | LeetCode      | Bucket Sort                                 |
|    | 244|+| 463 | [Sort Integers](http://lintcode.com/en/problem/sort-integers/)                                                                 | [C++](./C++/sort-integers.cpp)                                 | *O(n^2)*                         | *O(1)*    | Easy       |               | Insertion Sort, Selection Sort, Bubble Sort |
|    | 245|+| 464 | [Sort Integers II](http://lintcode.com/en/problem/sort-integers-ii/)                                                           | [C++](./C++/sort-integers-ii.cpp)                              | *O(nlogn)*                       | *O(n)*    | Easy       |               | Merge Sort, Heap Sort, Quick Sort           |
|    | 246|+| 507 | [Wiggle Sort II](http://lintcode.com/en/problem/wiggle-sort-ii/)                                                               | [C++](./C++/wiggle-sort-ii.cpp)                                | *O(n)* on average                | *O(1)*    | Medium     | LeetCode      | Tri Partition                               |
|    | 247|+| 508 | [Wiggle Sort](http://lintcode.com/en/problem/wiggle-sort/)                                                                     | [C++](./C++/wiggle-sort.cpp)                                   | *O(n)*                           | *O(1)*    | Medium     | LeetCode      |                                             |
| 247| 248| 
| 248| 249| ## Recursion
| 249| 250| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 246| 246| |508|[Wiggle Sort](http://lintcode.com/en/problem/wiggle-sort/)| [C++](./C++/wiggle-sort.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 247| 247| 
| 248| 248| ## Recursion
| 249|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 250|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 251|    |-|22|[Flatten List](http://lintcode.com/en/problem/flatten-list/)| [C++](./C++/flatten-list.cpp)| _O(n)_ | _O(h)_ | Easy || |
| 252|    |-|72|[Construct Binary Tree from Inorder and Postorder Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-inorder-and-postorder-traversal/)| [C++](./C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 253|    |-|73|[Construct Binary Tree from Preorder and Inorder Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-preorder-and-inorder-traversal/)| [C++](./C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 254|    |-|93|[Balanced Binary Tree](http://lintcode.com/en/problem/balanced-binary-tree/)| [C++](./C++/balanced-binary-tree.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 255|    |-|94|[Binary Tree Maximum Path Sum](http://lintcode.com/en/problem/binary-tree-maximum-path-sum/)| [C++](./C++/binary-tree-maximum-path-sum.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
| 256|    |-|95|[Validate Binary Search Tree](http://lintcode.com/en/problem/validate-binary-search-tree/)| [C++](./C++/validate-binary-search-tree.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
| 257|    |-|97|[Maximum Depth of Binary Tree](http://lintcode.com/en/problem/maximum-depth-of-binary-tree/)| [C++](./C++/maximum-depth-of-binary-tree.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 258|    |-|131|[Building Outline](http://lintcode.com/en/problem/building-outline/)| [C++](./C++/building-outline.cpp) [Python](./Python/building-outline.py)| _O(nlogn)_ | _O(n)_ | Hard | EPI | Sort, BST |
| 259|    |-|140|[Fast Power](http://lintcode.com/en/problem/fast-power/)| [C++](./C++/fast-power.cpp)| _O(logn)_ | _O(1)_ | Medium | | |
| 260|    |-|155|[Minimum Depth of Binary Tree](http://lintcode.com/en/problem/minimum-depth-of-binary-tree/)| [C++](./C++/minimum-depth-of-binary-tree.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 261|    |-|164|[Unique Binary Search Trees II](http://lintcode.com/en/problem/unique-binary-search-trees-ii/)| [C++](./C++/unique-binary-search-trees-ii.cpp)| _O(n * 4^n / n^(3/2))_ | _O(n)_ | Medium | LeetCode | |
| 262|    |-|177|[Convert Sorted Array to Binary Search Tree With Minimal Height](http://lintcode.com/en/problem/convert-sorted-array-to-binary-search-tree-with-minimal-height/)| [C++](./C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp)| _O(n)_ | _O(logn)_ | Easy | LeetCode | |
| 263|    |-|201|[Segment Tree Build](http://lintcode.com/en/problem/segment-tree-build/)| [C++](./C++/segment-tree-build.cpp)| _O(n)_ | _O(h)_ | Medium | | Segment Tree, BST |
| 264|    |-|202|[Segment Tree Query](http://lintcode.com/en/problem/segment-tree-query/)| [C++](./C++/segment-tree-query.cpp)| _O(h)_ | _O(h)_ | Medium | | Segment Tree, BST |
| 265|    |-|203|[Segment Tree Modify](http://lintcode.com/en/problem/segment-tree-modify/)| [C++](./C++/segment-tree-modify.cpp)| _O(h)_ | _O(h)_ | Medium | | Segment Tree, BST |
| 266|    |-|205|[Interval Minimum Number](http://lintcode.com/en/problem/interval-minimum-number/)| [C++](./C++/interval-minimum-number.cpp)| build tree: _O(n)_, query: _(h)_ | _O(h)_ | Hard | | Segment Tree, BST |
| 267|    |-|206|[Interval Sum](http://lintcode.com/en/problem/interval-sum/)| [C++](./C++/interval-sum.cpp)| build tree: _O(n)_, query: _O(logn)_ | _O(n)_ | Hard | | Segment Tree, BIT |
| 268|    |-|207|[Interval Sum II](http://lintcode.com/en/problem/interval-sum-ii/)| [C++](./C++/interval-sum-ii.cpp)| build tree: _O(n)_, query: _O(logn)_, modify: _O(logn)_ | _O(n)_ | Hard | | Segment Tree, BIT |
| 269|    |-|245|[Subtree](http://lintcode.com/en/problem/subtree/)| [C++](./C++/subtree.cpp)| _O(m * n)_ | _O(1)_ | Easy | | `Morris Traversal` |
| 270|    |-|247|[Segment Tree Query II](http://lintcode.com/en/problem/segment-tree-query-ii/)| [C++](./C++/segment-tree-query-ii.cpp)| _O(h)_ | _O(h)_ | Hard | | Segment Tree, BST |
| 271|    |-|248|[Count of Smaller Number](http://lintcode.com/en/problem/count-of-smaller-number/)| [C++](./C++/count-of-smaller-number.cpp)| build tree: _O(n)_, query: _O(logn)_ | _O(h)_ | Medium | | Segment Tree, BST |
| 272|    |-|371|[Print Numbers by Recursion](http://lintcode.com/en/problem/print-numbers-by-recursion/)| [C++](./C++/print-numbers-by-recursion.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 273|    |-|375|[Clone Binary Tree](http://lintcode.com/en/problem/clone-binary-tree/)| [C++](./C++/clone-binary-tree.cpp)| _O(n)_ | _O(h)_ | Easy | | |
| 274|    |-|378|[Convert Binary Search Tree to Doubly Linked List](http://lintcode.com/en/problem/convert-binary-search-tree-to-doubly-linked-list/)| [C++](./C++/convert-binary-search-tree-to-doubly-linked-list.cpp)| _O(n)_ | _O(h)_ | Medium | | |
| 275|    |-|439|[Segment Tree Build II](http://lintcode.com/en/problem/segmemt-tree-build-ii/)| [C++](./C++/segment-tree-build-ii.cpp)| _O(n)_ | _O(h)_ | Medium | | Segment Tree, BST |
| 276|    |-|453|[Flatten Binary Tree to Linked List](http://lintcode.com/en/problem/flatten-binary-tree-to-linked-list/)|[C++](./C++/flatten-binary-tree-to-linked-list.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 277|    |-|469| [Identical Binary Tree](http://lintcode.com/en/problem/problems/identical-binary-tree/)     | [C++](./C++/identical-binary-tree.cpp)     | _O(n)_       | _O(h)_       | Easy         |||
| 278|    |-|532|[Reverse Pairs](http://lintcode.com/en/problem/reverse-pairs/)| [C++](./C++/reverse-pairs.cpp)| _O(nlogn)_ | _O(n)_ | Medium | variant of [Count of Smaller Number before itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/) | BIT, Merge Sort |
| 279|    |-|535|[House Robber III](http://lintcode.com/en/problem/house-robber-iii/)| [C++](./C++/house-robber-iii.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
|    | 249|+
|    | 250|+| #   | Title                                                                                                                                                            | Solution                                                                        | Time                                                    | Space     | Difficulty | Tag                                                                                                                       | Note               |
|    | 251|+| --- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------- | --------- | ---------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------ |
|    | 252|+| 22  | [Flatten List](http://lintcode.com/en/problem/flatten-list/)                                                                                                     | [C++](./C++/flatten-list.cpp)                                                   | *O(n)*                                                  | *O(h)*    | Easy       |                                                                                                                           |                    |
|    | 253|+| 72  | [Construct Binary Tree from Inorder and Postorder Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-inorder-and-postorder-traversal/)         | [C++](./C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp)     | *O(n)*                                                  | *O(n)*    | Medium     | LeetCode, EPI                                                                                                             |                    |
|    | 254|+| 73  | [Construct Binary Tree from Preorder and Inorder Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-preorder-and-inorder-traversal/)           | [C++](./C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp)      | *O(n)*                                                  | *O(n)*    | Medium     | LeetCode, EPI                                                                                                             |                    |
|    | 255|+| 93  | [Balanced Binary Tree](http://lintcode.com/en/problem/balanced-binary-tree/)                                                                                     | [C++](./C++/balanced-binary-tree.cpp)                                           | *O(n)*                                                  | *O(h)*    | Easy       | LeetCode                                                                                                                  |                    |
|    | 256|+| 94  | [Binary Tree Maximum Path Sum](http://lintcode.com/en/problem/binary-tree-maximum-path-sum/)                                                                     | [C++](./C++/binary-tree-maximum-path-sum.cpp)                                   | *O(n)*                                                  | *O(h)*    | Medium     | LeetCode                                                                                                                  |                    |
|    | 257|+| 95  | [Validate Binary Search Tree](http://lintcode.com/en/problem/validate-binary-search-tree/)                                                                       | [C++](./C++/validate-binary-search-tree.cpp)                                    | *O(n)*                                                  | *O(h)*    | Medium     | LeetCode                                                                                                                  |                    |
|    | 258|+| 97  | [Maximum Depth of Binary Tree](http://lintcode.com/en/problem/maximum-depth-of-binary-tree/)                                                                     | [C++](./C++/maximum-depth-of-binary-tree.cpp)                                   | *O(n)*                                                  | *O(h)*    | Easy       | LeetCode                                                                                                                  |                    |
|    | 259|+| 131 | [Building Outline](http://lintcode.com/en/problem/building-outline/)                                                                                             | [C++](./C++/building-outline.cpp) [Python](./Python/building-outline.py)        | *O(nlogn)*                                              | *O(n)*    | Hard       | EPI                                                                                                                       | Sort, BST          |
|    | 260|+| 140 | [Fast Power](http://lintcode.com/en/problem/fast-power/)                                                                                                         | [C++](./C++/fast-power.cpp)                                                     | *O(logn)*                                               | *O(1)*    | Medium     |                                                                                                                           |                    |
|    | 261|+| 155 | [Minimum Depth of Binary Tree](http://lintcode.com/en/problem/minimum-depth-of-binary-tree/)                                                                     | [C++](./C++/minimum-depth-of-binary-tree.cpp)                                   | *O(n)*                                                  | *O(h)*    | Easy       | LeetCode                                                                                                                  |                    |
|    | 262|+| 164 | [Unique Binary Search Trees II](http://lintcode.com/en/problem/unique-binary-search-trees-ii/)                                                                   | [C++](./C++/unique-binary-search-trees-ii.cpp)                                  | *O(n \* 4^n / n^(3/2))*                                 | *O(n)*    | Medium     | LeetCode                                                                                                                  |                    |
|    | 263|+| 177 | [Convert Sorted Array to Binary Search Tree With Minimal Height](http://lintcode.com/en/problem/convert-sorted-array-to-binary-search-tree-with-minimal-height/) | [C++](./C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp) | *O(n)*                                                  | *O(logn)* | Easy       | LeetCode                                                                                                                  |                    |
|    | 264|+| 201 | [Segment Tree Build](http://lintcode.com/en/problem/segment-tree-build/)                                                                                         | [C++](./C++/segment-tree-build.cpp)                                             | *O(n)*                                                  | *O(h)*    | Medium     |                                                                                                                           | Segment Tree, BST  |
|    | 265|+| 202 | [Segment Tree Query](http://lintcode.com/en/problem/segment-tree-query/)                                                                                         | [C++](./C++/segment-tree-query.cpp)                                             | *O(h)*                                                  | *O(h)*    | Medium     |                                                                                                                           | Segment Tree, BST  |
|    | 266|+| 203 | [Segment Tree Modify](http://lintcode.com/en/problem/segment-tree-modify/)                                                                                       | [C++](./C++/segment-tree-modify.cpp)                                            | *O(h)*                                                  | *O(h)*    | Medium     |                                                                                                                           | Segment Tree, BST  |
|    | 267|+| 205 | [Interval Minimum Number](http://lintcode.com/en/problem/interval-minimum-number/)                                                                               | [C++](./C++/interval-minimum-number.cpp)                                        | build tree: *O(n)*, query: *(h)*                        | *O(h)*    | Hard       |                                                                                                                           | Segment Tree, BST  |
|    | 268|+| 206 | [Interval Sum](http://lintcode.com/en/problem/interval-sum/)                                                                                                     | [C++](./C++/interval-sum.cpp)                                                   | build tree: *O(n)*, query: *O(logn)*                    | *O(n)*    | Hard       |                                                                                                                           | Segment Tree, BIT  |
|    | 269|+| 207 | [Interval Sum II](http://lintcode.com/en/problem/interval-sum-ii/)                                                                                               | [C++](./C++/interval-sum-ii.cpp)                                                | build tree: *O(n)*, query: *O(logn)*, modify: *O(logn)* | *O(n)*    | Hard       |                                                                                                                           | Segment Tree, BIT  |
|    | 270|+| 245 | [Subtree](http://lintcode.com/en/problem/subtree/)                                                                                                               | [C++](./C++/subtree.cpp)                                                        | *O(m \* n)*                                             | *O(1)*    | Easy       |                                                                                                                           | `Morris Traversal` |
|    | 271|+| 247 | [Segment Tree Query II](http://lintcode.com/en/problem/segment-tree-query-ii/)                                                                                   | [C++](./C++/segment-tree-query-ii.cpp)                                          | *O(h)*                                                  | *O(h)*    | Hard       |                                                                                                                           | Segment Tree, BST  |
|    | 272|+| 248 | [Count of Smaller Number](http://lintcode.com/en/problem/count-of-smaller-number/)                                                                               | [C++](./C++/count-of-smaller-number.cpp)                                        | build tree: *O(n)*, query: *O(logn)*                    | *O(h)*    | Medium     |                                                                                                                           | Segment Tree, BST  |
|    | 273|+| 371 | [Print Numbers by Recursion](http://lintcode.com/en/problem/print-numbers-by-recursion/)                                                                         | [C++](./C++/print-numbers-by-recursion.cpp)                                     | *O(n)*                                                  | *O(n)*    | Medium     |                                                                                                                           |                    |
|    | 274|+| 375 | [Clone Binary Tree](http://lintcode.com/en/problem/clone-binary-tree/)                                                                                           | [C++](./C++/clone-binary-tree.cpp)                                              | *O(n)*                                                  | *O(h)*    | Easy       |                                                                                                                           |                    |
|    | 275|+| 378 | [Convert Binary Search Tree to Doubly Linked List](http://lintcode.com/en/problem/convert-binary-search-tree-to-doubly-linked-list/)                             | [C++](./C++/convert-binary-search-tree-to-doubly-linked-list.cpp)               | *O(n)*                                                  | *O(h)*    | Medium     |                                                                                                                           |                    |
|    | 276|+| 439 | [Segment Tree Build II](http://lintcode.com/en/problem/segmemt-tree-build-ii/)                                                                                   | [C++](./C++/segment-tree-build-ii.cpp)                                          | *O(n)*                                                  | *O(h)*    | Medium     |                                                                                                                           | Segment Tree, BST  |
|    | 277|+| 453 | [Flatten Binary Tree to Linked List](http://lintcode.com/en/problem/flatten-binary-tree-to-linked-list/)                                                         | [C++](./C++/flatten-binary-tree-to-linked-list.cpp)                             | *O(n)*                                                  | *O(h)*    | Easy       | LeetCode                                                                                                                  |                    |
|    | 278|+| 469 | [Identical Binary Tree](http://lintcode.com/en/problem/problems/identical-binary-tree/)                                                                          | [C++](./C++/identical-binary-tree.cpp)                                          | *O(n)*                                                  | *O(h)*    | Easy       |                                                                                                                           |                    |
|    | 279|+| 532 | [Reverse Pairs](http://lintcode.com/en/problem/reverse-pairs/)                                                                                                   | [C++](./C++/reverse-pairs.cpp)                                                  | *O(nlogn)*                                              | *O(n)*    | Medium     | variant of [Count of Smaller Number before itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/) | BIT, Merge Sort    |
|    | 280|+| 535 | [House Robber III](http://lintcode.com/en/problem/house-robber-iii/)                                                                                             | [C++](./C++/house-robber-iii.cpp)                                               | *O(n)*                                                  | *O(h)*    | Medium     | LeetCode                                                                                                                  |                    |
| 280| 281| 
| 281| 282| ## Binary Search
| 282| 283| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 279| 279| |535|[House Robber III](http://lintcode.com/en/problem/house-robber-iii/)| [C++](./C++/house-robber-iii.cpp)| _O(n)_ | _O(h)_ | Medium | LeetCode | |
| 280| 280| 
| 281| 281| ## Binary Search
| 282|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 283|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 284|    |-|14|[First Position of Target](http://lintcode.com/en/problem/first-position-of-target/)| [C++](./C++/first-position-of-target.cpp)| _O(logn)_ | _O(1)_ | Easy | | |
| 285|    |-|28|[Search a 2D Matrix](http://lintcode.com/en/problem/search-a-2d-matrix/)| [C++](./C++/search-a-2d-matrix.cpp)| _O(logm + logn)_ | _O(1)_ | Easy | LeetCode | |
| 286|    |-|60|[Search Insert Position](http://lintcode.com/en/problem/search-insert-position/)| [C++](./C++/search-insert-position.cpp)| _O(logn)_ | _O(1)_ | Easy | LeetCode | |
| 287|    |-|61|[Search for a Range](http://lintcode.com/en/problem/search-for-a-range/)| [C++](./C++/search-for-a-range.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 288|    |-|62|[Search in Rotated Sorted Array](http://lintcode.com/en/problem/search-in-rotated-sorted-array/)| [C++](./C++/search-in-rotated-sorted-array.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 289|    |-|63|[Search in Rotated Sorted Array II](http://lintcode.com/en/problem/search-in-rotated-sorted-array-ii/)| [C++](./C++/search-in-rotated-sorted-array-ii.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 290|    |-|65|[Median of two Sorted Arrays](http://lintcode.com/en/problem/median-of-two-sorted-arrays/)| [C++](./C++/median-of-two-sorted-arrays.cpp)| _O(log(min(m, n)))_ | _O(1)_ | Hard | LeetCode, EPI | Tricky |
| 291|    |-|74|[First Bad Version](http://lintcode.com/en/problem/first-bad-version/)| [C++](./C++/first-bad-version.cpp)| _O(logn)_ | _O(1)_ | Medium | | |
| 292|    |-|75|[Find Peak Element](http://lintcode.com/en/problem/find-peak-element/)| [C++](./C++/find-peak-element.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 293|    |-|76|[Longest Increasing Subsequence](http://lintcode.com/en/problem/longest-increasing-subsequence/)| [C++](./C++/longest-increasing-subsequence.cpp)| _O(nlogn)_ | _O(n)_ | Medium | CTCI | |
| 294|    |-|141|[Sqrt(x)](http://lintcode.com/en/problem/sqrtx/)| [C++](./C++/sqrtx.cpp)| _O(logn)_ | _O(1)_ | Easy | LeetCode | |
| 295|    |-|159|[Find Minimum in Rotated Sorted Array](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array/)| [C++](./C++/find-minimum-in-rotated-sorted-array.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 296|    |-|160|[Find Minimum in Rotated Sorted Array II](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array-ii/)| [C++](./C++/find-minimum-in-rotated-sorted-array-ii.cpp)| _O(logn)_ | _O(1)_ | Medium | LeetCode | |
| 297|    |-|183|[Wood Cut](http://lintcode.com/en/problem/wood-cut/)| [C++](./C++/wood-cut.cpp)| _O(nlogL)_ | _O(1)_ | Medium | | |
| 298|    |-|390|[Find Peak Element II](http://lintcode.com/en/problem/find-peak-element-ii/)| [C++](./C++/find-peak-element-ii.cpp) [Java](./Java/find-peak-element-ii.java) [Python](./Python/find-peak-element-ii.py)| _O(m + n)_ | _O(1)_ | Hard | | |
| 299|    |-|437|[Copy Books](http://lintcode.com/en/problem/copy-books/)| [C++](./C++/copy-books.cpp) | _O(nlogp)_ | _O(1)_ | Hard | UVa 714 | |
|    | 282|+
|    | 283|+| #   | Title                                                                                                              | Solution                                                                                                                  | Time                | Space  | Difficulty | Tag           | Note   |
|    | 284|+| --- | ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------- | ------------------- | ------ | ---------- | ------------- | ------ |
|    | 285|+| 14  | [First Position of Target](http://lintcode.com/en/problem/first-position-of-target/)                               | [C++](./C++/first-position-of-target.cpp)                                                                                 | *O(logn)*           | *O(1)* | Easy       |               |        |
|    | 286|+| 28  | [Search a 2D Matrix](http://lintcode.com/en/problem/search-a-2d-matrix/)                                           | [C++](./C++/search-a-2d-matrix.cpp)                                                                                       | *O(logm + logn)*    | *O(1)* | Easy       | LeetCode      |        |
|    | 287|+| 60  | [Search Insert Position](http://lintcode.com/en/problem/search-insert-position/)                                   | [C++](./C++/search-insert-position.cpp)                                                                                   | *O(logn)*           | *O(1)* | Easy       | LeetCode      |        |
|    | 288|+| 61  | [Search for a Range](http://lintcode.com/en/problem/search-for-a-range/)                                           | [C++](./C++/search-for-a-range.cpp)                                                                                       | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 289|+| 62  | [Search in Rotated Sorted Array](http://lintcode.com/en/problem/search-in-rotated-sorted-array/)                   | [C++](./C++/search-in-rotated-sorted-array.cpp)                                                                           | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 290|+| 63  | [Search in Rotated Sorted Array II](http://lintcode.com/en/problem/search-in-rotated-sorted-array-ii/)             | [C++](./C++/search-in-rotated-sorted-array-ii.cpp)                                                                        | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 291|+| 65  | [Median of two Sorted Arrays](http://lintcode.com/en/problem/median-of-two-sorted-arrays/)                         | [C++](./C++/median-of-two-sorted-arrays.cpp)                                                                              | *O(log(min(m, n)))* | *O(1)* | Hard       | LeetCode, EPI | Tricky |
|    | 292|+| 74  | [First Bad Version](http://lintcode.com/en/problem/first-bad-version/)                                             | [C++](./C++/first-bad-version.cpp)                                                                                        | *O(logn)*           | *O(1)* | Medium     |               |        |
|    | 293|+| 75  | [Find Peak Element](http://lintcode.com/en/problem/find-peak-element/)                                             | [C++](./C++/find-peak-element.cpp)                                                                                        | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 294|+| 76  | [Longest Increasing Subsequence](http://lintcode.com/en/problem/longest-increasing-subsequence/)                   | [C++](./C++/longest-increasing-subsequence.cpp)                                                                           | *O(nlogn)*          | *O(n)* | Medium     | CTCI          |        |
|    | 295|+| 141 | [Sqrt(x)](http://lintcode.com/en/problem/sqrtx/)                                                                   | [C++](./C++/sqrtx.cpp)                                                                                                    | *O(logn)*           | *O(1)* | Easy       | LeetCode      |        |
|    | 296|+| 159 | [Find Minimum in Rotated Sorted Array](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array/)       | [C++](./C++/find-minimum-in-rotated-sorted-array.cpp)                                                                     | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 297|+| 160 | [Find Minimum in Rotated Sorted Array II](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array-ii/) | [C++](./C++/find-minimum-in-rotated-sorted-array-ii.cpp)                                                                  | *O(logn)*           | *O(1)* | Medium     | LeetCode      |        |
|    | 298|+| 183 | [Wood Cut](http://lintcode.com/en/problem/wood-cut/)                                                               | [C++](./C++/wood-cut.cpp)                                                                                                 | *O(nlogL)*          | *O(1)* | Medium     |               |        |
|    | 299|+| 390 | [Find Peak Element II](http://lintcode.com/en/problem/find-peak-element-ii/)                                       | [C++](./C++/find-peak-element-ii.cpp) [Java](./Java/find-peak-element-ii.java) [Python](./Python/find-peak-element-ii.py) | *O(m + n)*          | *O(1)* | Hard       |               |        |
|    | 300|+| 437 | [Copy Books](http://lintcode.com/en/problem/copy-books/)                                                           | [C++](./C++/copy-books.cpp)                                                                                               | *O(nlogp)*          | *O(1)* | Hard       | UVa 714       |        |
| 300| 301| 
| 301| 302| ## Breadth-First Search
| 302| 303| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 299| 299| |437|[Copy Books](http://lintcode.com/en/problem/copy-books/)| [C++](./C++/copy-books.cpp) | _O(nlogp)_ | _O(1)_ | Hard | UVa 714 | |
| 300| 300| 
| 301| 301| ## Breadth-First Search
| 302|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 303|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 304|    |-|69|[Binary Tree Level Order Traversal](http://lintcode.com/en/problem/binary-tree-level-order-traversal/)| [C++](./C++/binary-tree-level-order-traversal.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | BFS |
| 305|    |-|70|[Binary Tree Level Order Traversal II](http://lintcode.com/en/problem/binary-tree-level-order-traversal-ii/)| [C++](./C++/binary-tree-level-order-traversal-ii.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | BFS |
| 306|    |-|71|[Binary Tree Zigzag Level Order Traversal](http://lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/)| [C++](./C++/binary-tree-zigzag-level-order-traversal.cpp)| _O(n)_ | _O(n)_ | Medium | LeetCode | BFS |
| 307|    |-|120|[Word Ladder](http://lintcode.com/en/problem/word-ladder/)| [C++](./C++/word-ladder.cpp)| _O(n * d)_ | _O(d)_ | Medium | LeetCode | BFS |
| 308|    |-|121|[Word Ladder II](http://lintcode.com/en/problem/word-ladder-ii/)| [C++](./C++/word-ladder-ii.cpp)| _O(n * d)_ | _O(d)_ | Hard | LeetCode | BFS, Back Trace |
| 309|    |-|127|[Topological Sorting](http://lintcode.com/en/problem/topological-sorting/)| [C++](./C++/topological-sorting.cpp)| _O(\|V\|+\|E\|)_ | _O(\|E\|)_ | Medium | | DFS, BFS |
| 310|    |-|137|[Clone Graph](http://lintcode.com/en/problem/clone-graph/)| [C++](./C++/clone-graph.cpp)| _O(\|V\|+\|E\|)_ | _O(\|V\|)_ | Medium | | BFS |
| 311|    |-|176|[Route Between Two Nodes in Graph](http://lintcode.com/en/problem/route-between-two-nodes-in-graph/)| [C++](./C++/route-between-two-nodes-in-graph.cpp)| _O(n)_ | _O(n)_ | Medium | | DFS, BFS |
| 312|    |-|178| [Graph Valid Tree](http://lintcode.com/en/problem/graph-valid-tree/)| [C++](./C++/graph-valid-tree.cpp) | _O(\|V\| + \|E\|)_          | _O(\|V\| + \|E\|)_          | Medium         | LeetCode ||
| 313|    |-|431|[Find the Connected Component in the Undirected Graph](http://lintcode.com/en/problem/find-the-connected-component-in-the-undirected-graph/)| [C++](./C++/find-the-connected-component-in-the-undirected-graph.cpp)| _O(n)_ | _O(n)_ | Medium | | BFS |
| 314|    |-|477|[Surrounded Regions](http://lintcode.com/en/problem/surrounded-regions/)|[C++](./C++/surrounded-regions.cpp)| _O(m * n)_ | _O(m + n)_ | Medium         | LeetCode ||
|    | 302|+
|    | 303|+| #   | Title                                                                                                                                        | Solution                                                              | Time               | Space              | Difficulty | Tag      | Note            |
|    | 304|+| --- | -------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------------------ | ------------------ | ---------- | -------- | --------------- |
|    | 305|+| 69  | [Binary Tree Level Order Traversal](http://lintcode.com/en/problem/binary-tree-level-order-traversal/)                                       | [C++](./C++/binary-tree-level-order-traversal.cpp)                    | *O(n)*             | *O(n)*             | Medium     | LeetCode | BFS             |
|    | 306|+| 70  | [Binary Tree Level Order Traversal II](http://lintcode.com/en/problem/binary-tree-level-order-traversal-ii/)                                 | [C++](./C++/binary-tree-level-order-traversal-ii.cpp)                 | *O(n)*             | *O(n)*             | Medium     | LeetCode | BFS             |
|    | 307|+| 71  | [Binary Tree Zigzag Level Order Traversal](http://lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/)                         | [C++](./C++/binary-tree-zigzag-level-order-traversal.cpp)             | *O(n)*             | *O(n)*             | Medium     | LeetCode | BFS             |
|    | 308|+| 120 | [Word Ladder](http://lintcode.com/en/problem/word-ladder/)                                                                                   | [C++](./C++/word-ladder.cpp)                                          | *O(n \* d)*        | *O(d)*             | Medium     | LeetCode | BFS             |
|    | 309|+| 121 | [Word Ladder II](http://lintcode.com/en/problem/word-ladder-ii/)                                                                             | [C++](./C++/word-ladder-ii.cpp)                                       | *O(n \* d)*        | *O(d)*             | Hard       | LeetCode | BFS, Back Trace |
|    | 310|+| 127 | [Topological Sorting](http://lintcode.com/en/problem/topological-sorting/)                                                                   | [C++](./C++/topological-sorting.cpp)                                  | *O(\|V\|+\|E\|)*   | *O(\|E\|)*         | Medium     |          | DFS, BFS        |
|    | 311|+| 137 | [Clone Graph](http://lintcode.com/en/problem/clone-graph/)                                                                                   | [C++](./C++/clone-graph.cpp)                                          | *O(\|V\|+\|E\|)*   | *O(\|V\|)*         | Medium     |          | BFS             |
|    | 312|+| 176 | [Route Between Two Nodes in Graph](http://lintcode.com/en/problem/route-between-two-nodes-in-graph/)                                         | [C++](./C++/route-between-two-nodes-in-graph.cpp)                     | *O(n)*             | *O(n)*             | Medium     |          | DFS, BFS        |
|    | 313|+| 178 | [Graph Valid Tree](http://lintcode.com/en/problem/graph-valid-tree/)                                                                         | [C++](./C++/graph-valid-tree.cpp)                                     | *O(\|V\| + \|E\|)* | *O(\|V\| + \|E\|)* | Medium     | LeetCode |                 |
|    | 314|+| 431 | [Find the Connected Component in the Undirected Graph](http://lintcode.com/en/problem/find-the-connected-component-in-the-undirected-graph/) | [C++](./C++/find-the-connected-component-in-the-undirected-graph.cpp) | *O(n)*             | *O(n)*             | Medium     |          | BFS             |
|    | 315|+| 477 | [Surrounded Regions](http://lintcode.com/en/problem/surrounded-regions/)                                                                     | [C++](./C++/surrounded-regions.cpp)                                   | *O(m \* n)*        | *O(m + n)*         | Medium     | LeetCode |                 |
| 315| 316| 
| 316| 317| ## Depth-First Search
| 317| 318| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 314| 314| |477|[Surrounded Regions](http://lintcode.com/en/problem/surrounded-regions/)|[C++](./C++/surrounded-regions.cpp)| _O(m * n)_ | _O(m + n)_ | Medium         | LeetCode ||
| 315| 315| 
| 316| 316| ## Depth-First Search
| 317|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 318|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 319|    |-|90|[K Sum II](http://lintcode.com/en/problem/k-sum-ii/)| [C++](./C++/k-sum-ii.cpp)| _O(k * C(n, k))_ | _O(k)_ | Medium | | |
| 320|    |-|376|[Binary Tree Path Sum](http://lintcode.com/en/problem/binary-tree-path-sum/)| [C++](./C++/binary-tree-path-sum.cpp)| _O(n)_ | _O(h)_ | Easy | LeetCode | |
| 321|    |-|433|[Number of Islands](http://lintcode.com/en/problem/number-of-islands/)| [C++](./C++/number-of-islands.cpp)| _O(m * n)_ | _O(m * n)_ | Easy | LeetCode | DFS |
| 322|    |-|480| [Binary Tree Paths](http://lintcode.com/en/problem/binary-tree-paths/) | [C++](./C++/binary-tree-paths.cpp) | _O(n * h)_ | _O(h)_ | Easy         | LeetCode ||
|    | 317|+
|    | 318|+| #   | Title                                                                        | Solution                              | Time              | Space       | Difficulty | Tag      | Note |
|    | 319|+| --- | ---------------------------------------------------------------------------- | ------------------------------------- | ----------------- | ----------- | ---------- | -------- | ---- |
|    | 320|+| 90  | [K Sum II](http://lintcode.com/en/problem/k-sum-ii/)                         | [C++](./C++/k-sum-ii.cpp)             | *O(k \* C(n, k))* | *O(k)*      | Medium     |          |      |
|    | 321|+| 376 | [Binary Tree Path Sum](http://lintcode.com/en/problem/binary-tree-path-sum/) | [C++](./C++/binary-tree-path-sum.cpp) | *O(n)*            | *O(h)*      | Easy       | LeetCode |      |
|    | 322|+| 433 | [Number of Islands](http://lintcode.com/en/problem/number-of-islands/)       | [C++](./C++/number-of-islands.cpp)    | *O(m \* n)*       | *O(m \* n)* | Easy       | LeetCode | DFS  |
|    | 323|+| 480 | [Binary Tree Paths](http://lintcode.com/en/problem/binary-tree-paths/)       | [C++](./C++/binary-tree-paths.cpp)    | *O(n \* h)*       | *O(h)*      | Easy       | LeetCode |      |
| 323| 324| 
| 324| 325| ## Backtracking
| 325| 326| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 322| 322| |480| [Binary Tree Paths](http://lintcode.com/en/problem/binary-tree-paths/) | [C++](./C++/binary-tree-paths.cpp) | _O(n * h)_ | _O(h)_ | Easy         | LeetCode ||
| 323| 323| 
| 324| 324| ## Backtracking
| 325|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 326|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 327|    |-|15|[Permutations](http://lintcode.com/en/problem/permutations/)| [C++](./C++/permutations.cpp)| _O(n * n!)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 328|    |-|16|[Permutations II](http://lintcode.com/en/problem/permutations-ii/)| [C++](./C++/permutations-ii.cpp)| _O(n * n!)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 329|    |-|17|[Subsets](http://lintcode.com/en/problem/subsets/)| [C++](./C++/subsets.cpp)| _O(n * 2^n)_ | _O(1)_ | Medium | LeetCode | |
| 330|    |-|18|[Subsets II](http://lintcode.com/en/problem/subsets-ii/)| [C++](./C++/subsets-ii.cpp)| _O(n * 2^n)_ | _O(1)_ | Medium | LeetCode | |
| 331|    |-|33|[N-Queens](http://lintcode.com/en/problem/n-queens/)| [C++](./C++/n-queens.cpp)| _O(n * n!)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 332|    |-|34|[N-Queens II](http://lintcode.com/en/problem/n-queens-ii/)| [C++](./C++/n-queens-ii.cpp)| _O(n * n!)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 333|    |-|123|[Word Search](http://lintcode.com/en/problem/word-search/)| [C++](./C++/word-search.cpp)| _O(m * n * l)_ | _O(l)_ | Medium | LeetCode | |
| 334|    |-|132|[Word Search II](http://lintcode.com/en/problem/word-search-ii/)| [C++](./C++/word-search-ii.cpp)| _O(m * n * l)_ | _O(l)_ | Hard | | Trie, DFS |
| 335|    |-|135|[Combination Sum](http://lintcode.com/en/problem/combination-sum/)| [C++](./C++/combination-sum.cpp)| _O(k * n^k)_ | _O(k)_ | Medium | LeetCode | DFS |
| 336|    |-|136|[Palindrome Partitioning](http://lintcode.com/en/problem/palindrome-partitioning/)| [C++](./C++/palindrome-partitioning.cpp)| _O(2^n)_ | _O(n)_ | Easy | LeetCode, EPI | |
| 337|    |-|152|[Combinations](http://lintcode.com/en/problem/combinations/)| [C++](./C++/combinations.cpp)| _O(k * n^k)_ | _O(k)_ | Medium | LeetCode, EPI | |
| 338|    |-|153|[Combination Sum II](http://lintcode.com/en/problem/combination-sum-ii/)| [C++](./C++/combination-sum-ii.cpp)| _O(k * C(n, k))_ | _O(k)_ | Medium | LeetCode | DFS |
| 339|    |-|425|[Letter Combinations of a Phone Number](http://lintcode.com/en/problem/letter-combinations-of-a-phone-number/) | [C++](./C++/letter-combinations-of-a-phone-number.cpp)| _O(n * 4^n)_ | _O(n)_ | Medium | LeetCode | |
| 340|    |-|426| [Restore IP Addresses](http://lintcode.com/en/problem/restore-ip-addresses/) | [C++](./C++/restore-ip-addresses.cpp) | _O(1)_ | _O(1)_ | Medium         | LeetCode ||[C++](./C++/letter-combinations-of-a-phone-number.cpp)| _O(n * 4^n)_ | _O(n)_ | Medium | LeetCode | |
| 341|    |-|427| [Generate Parentheses](http://lintcode.com/en/problem/generate-parentheses/)| [C++](./C++/generate-parentheses.cpp)| _O(4^n / n^(3/2))_ | _O(n)_   | Medium         | LeetCode ||
|    | 325|+
|    | 326|+| #   | Title                                                                                                          | Solution                                               | Time               | Space  | Difficulty | Tag           | Note      |                                                        |               |        |        |          |     |
|    | 327|+| --- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ | ------------------ | ------ | ---------- | ------------- | --------- | ------------------------------------------------------ | ------------- | ------ | ------ | -------- | --- |
|    | 328|+| 15  | [Permutations](http://lintcode.com/en/problem/permutations/)                                                   | [C++](./C++/permutations.cpp)                          | *O(n \* n!)*       | *O(n)* | Medium     | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 329|+| 16  | [Permutations II](http://lintcode.com/en/problem/permutations-ii/)                                             | [C++](./C++/permutations-ii.cpp)                       | *O(n \* n!)*       | *O(n)* | Medium     | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 330|+| 17  | [Subsets](http://lintcode.com/en/problem/subsets/)                                                             | [C++](./C++/subsets.cpp)                               | *O(n \* 2^n)*      | *O(1)* | Medium     | LeetCode      |           |                                                        |               |        |        |          |     |
|    | 331|+| 18  | [Subsets II](http://lintcode.com/en/problem/subsets-ii/)                                                       | [C++](./C++/subsets-ii.cpp)                            | *O(n \* 2^n)*      | *O(1)* | Medium     | LeetCode      |           |                                                        |               |        |        |          |     |
|    | 332|+| 33  | [N-Queens](http://lintcode.com/en/problem/n-queens/)                                                           | [C++](./C++/n-queens.cpp)                              | *O(n \* n!)*       | *O(n)* | Medium     | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 333|+| 34  | [N-Queens II](http://lintcode.com/en/problem/n-queens-ii/)                                                     | [C++](./C++/n-queens-ii.cpp)                           | *O(n \* n!)*       | *O(n)* | Medium     | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 334|+| 123 | [Word Search](http://lintcode.com/en/problem/word-search/)                                                     | [C++](./C++/word-search.cpp)                           | *O(m * n * l)*     | *O(l)* | Medium     | LeetCode      |           |                                                        |               |        |        |          |     |
|    | 335|+| 132 | [Word Search II](http://lintcode.com/en/problem/word-search-ii/)                                               | [C++](./C++/word-search-ii.cpp)                        | *O(m * n * l)*     | *O(l)* | Hard       |               | Trie, DFS |                                                        |               |        |        |          |     |
|    | 336|+| 135 | [Combination Sum](http://lintcode.com/en/problem/combination-sum/)                                             | [C++](./C++/combination-sum.cpp)                       | *O(k \* n^k)*      | *O(k)* | Medium     | LeetCode      | DFS       |                                                        |               |        |        |          |     |
|    | 337|+| 136 | [Palindrome Partitioning](http://lintcode.com/en/problem/palindrome-partitioning/)                             | [C++](./C++/palindrome-partitioning.cpp)               | *O(2^n)*           | *O(n)* | Easy       | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 338|+| 152 | [Combinations](http://lintcode.com/en/problem/combinations/)                                                   | [C++](./C++/combinations.cpp)                          | *O(k \* n^k)*      | *O(k)* | Medium     | LeetCode, EPI |           |                                                        |               |        |        |          |     |
|    | 339|+| 153 | [Combination Sum II](http://lintcode.com/en/problem/combination-sum-ii/)                                       | [C++](./C++/combination-sum-ii.cpp)                    | *O(k \* C(n, k))*  | *O(k)* | Medium     | LeetCode      | DFS       |                                                        |               |        |        |          |     |
|    | 340|+| 425 | [Letter Combinations of a Phone Number](http://lintcode.com/en/problem/letter-combinations-of-a-phone-number/) | [C++](./C++/letter-combinations-of-a-phone-number.cpp) | *O(n \* 4^n)*      | *O(n)* | Medium     | LeetCode      |           |                                                        |               |        |        |          |     |
|    | 341|+| 426 | [Restore IP Addresses](http://lintcode.com/en/problem/restore-ip-addresses/)                                   | [C++](./C++/restore-ip-addresses.cpp)                  | *O(1)*             | *O(1)* | Medium     | LeetCode      |           | [C++](./C++/letter-combinations-of-a-phone-number.cpp) | *O(n \* 4^n)* | *O(n)* | Medium | LeetCode |     |
|    | 342|+| 427 | [Generate Parentheses](http://lintcode.com/en/problem/generate-parentheses/)                                   | [C++](./C++/generate-parentheses.cpp)                  | *O(4^n / n^(3/2))* | *O(n)* | Medium     | LeetCode      |           |                                                        |               |        |        |          |     |
| 342| 343| 
| 343| 344| ## Binary Search Trees
| 344| 345| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 341| 341| |427| [Generate Parentheses](http://lintcode.com/en/problem/generate-parentheses/)| [C++](./C++/generate-parentheses.cpp)| _O(4^n / n^(3/2))_ | _O(n)_   | Medium         | LeetCode ||
| 342| 342| 
| 343| 343| ## Binary Search Trees
| 344|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 345|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 346|    |-|11|[Search Range in Binary Search Tree](http://lintcode.com/en/problem/search-range-in-binary-search-tree/)| [C++](./C++/search-range-in-binary-search-tree.cpp)| _O(n)_ | _O(h)_ | Medium | EPI | |
| 347|    |-|86|[Binary Search Tree Iterator](http://lintcode.com/en/problem/binary-search-tree-iterator/)| [C++](./C++/binary-search-tree-iterator.cpp)| _O(1)_ | _O(h)_ | Hard | LeetCode | |
| 348|    |-|87|[Remove Node in Binary Search Tree](http://lintcode.com/en/problem/remove-node-in-binary-search-tree/)| [C++](./C++/remove-node-in-binary-search-tree.cpp)| _O(h)_ | _O(h)_ | Hard | | |
| 349|    |-|249|[Count of Smaller Number before itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/)| [C++](./C++/count-of-smaller-number-before-itself.cpp)| _O(nlogn)_ | _O(n)_ | Hard | | BST, BIT, Divide and Conquer, Merge Sort |
| 350|    |-|360|[Sliding Window Median](http://lintcode.com/en/problem/sliding-window-median/)| [C++](./C++/sliding-window-median.cpp)| _O(nlogw)_ | _O(w)_ | Hard | | BST, Tricky |
| 351|    |-|391|[Number of Airplanes in the Sky](http://lintcode.com/en/problem/number-of-airplanes-in-the-sky/)| [C++](./C++/number-of-airplanes-in-the-sky.cpp)| _O(nlogn)_ | _O(n)_ | Easy | | BST, Heap |
| 352|    |-|401|[Kth Smallest Number in Sorted Matrix](http://lintcode.com/en/problem/kth-smallest-number-in-sorted-matrix/)| [C++](./C++/kth-smallest-number-in-sorted-matrix.cpp)| _O(klog(min(m, n, k)))_ | _O(min(m, n, k))_ | Medium | | BST, Heap |
|    | 344|+
|    | 345|+| #   | Title                                                                                                          | Solution                                               | Time                    | Space             | Difficulty | Tag      | Note                                     |
|    | 346|+| --- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ | ----------------------- | ----------------- | ---------- | -------- | ---------------------------------------- |
|    | 347|+| 11  | [Search Range in Binary Search Tree](http://lintcode.com/en/problem/search-range-in-binary-search-tree/)       | [C++](./C++/search-range-in-binary-search-tree.cpp)    | *O(n)*                  | *O(h)*            | Medium     | EPI      |                                          |
|    | 348|+| 86  | [Binary Search Tree Iterator](http://lintcode.com/en/problem/binary-search-tree-iterator/)                     | [C++](./C++/binary-search-tree-iterator.cpp)           | *O(1)*                  | *O(h)*            | Hard       | LeetCode |                                          |
|    | 349|+| 87  | [Remove Node in Binary Search Tree](http://lintcode.com/en/problem/remove-node-in-binary-search-tree/)         | [C++](./C++/remove-node-in-binary-search-tree.cpp)     | *O(h)*                  | *O(h)*            | Hard       |          |                                          |
|    | 350|+| 249 | [Count of Smaller Number before itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/) | [C++](./C++/count-of-smaller-number-before-itself.cpp) | *O(nlogn)*              | *O(n)*            | Hard       |          | BST, BIT, Divide and Conquer, Merge Sort |
|    | 351|+| 360 | [Sliding Window Median](http://lintcode.com/en/problem/sliding-window-median/)                                 | [C++](./C++/sliding-window-median.cpp)                 | *O(nlogw)*              | *O(w)*            | Hard       |          | BST, Tricky                              |
|    | 352|+| 391 | [Number of Airplanes in the Sky](http://lintcode.com/en/problem/number-of-airplanes-in-the-sky/)               | [C++](./C++/number-of-airplanes-in-the-sky.cpp)        | *O(nlogn)*              | *O(n)*            | Easy       |          | BST, Heap                                |
|    | 353|+| 401 | [Kth Smallest Number in Sorted Matrix](http://lintcode.com/en/problem/kth-smallest-number-in-sorted-matrix/)   | [C++](./C++/kth-smallest-number-in-sorted-matrix.cpp)  | *O(klog(min(m, n, k)))* | *O(min(m, n, k))* | Medium     |          | BST, Heap                                |
| 353| 354| 
| 354| 355| ## Dynamic Programming
| 355| 356| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 352| 352| |401|[Kth Smallest Number in Sorted Matrix](http://lintcode.com/en/problem/kth-smallest-number-in-sorted-matrix/)| [C++](./C++/kth-smallest-number-in-sorted-matrix.cpp)| _O(klog(min(m, n, k)))_ | _O(min(m, n, k))_ | Medium | | BST, Heap |
| 353| 353| 
| 354| 354| ## Dynamic Programming
| 355|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 356|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 357|    |-|20|[Dices Sum](http://lintcode.com/en/problem/dices-sum/)| [C++](./C++/dices-sum.cpp)| _O(n^2)_ | _O(n)_ | Hard | | |
| 358|    |-|29|[Interleaving String](http://lintcode.com/en/problem/interleaving-string/)| [C++](./C++/interleaving-string.cpp)| _O(m * n)_ | _O(min(m, n))_ | Medium | EPI | |
| 359|    |-|43|[Maximum Subarray III](http://lintcode.com/en/problem/maximum-subarray-iii/)| [C++](./C++/maximum-subarray-iii.cpp)| _O(k * n)_ | _O(k * n)_ | Hard | | |
| 360|    |-|77|[Longest Common Subsequence](http://lintcode.com/en/problem/longest-common-subsequence/)| [C++](./C++/longest-common-subsequence.cpp)| _O(m * n)_ | _O(min(m, n))_ | Medium | | |
| 361|    |-|79|[Longest Common Substring](http://lintcode.com/en/problem/longest-common-substring/)| [C++](./C++/longest-common-substring.cpp)| _O(m * n)_ | _O(min(m, n))_ | Medium | | |
| 362|    |-|89|[K Sum](http://lintcode.com/en/problem/k-sum/)| [C++](./C++/k-sum.cpp)| _O(k * n * t)_ | _O(n * t)_ | Hard | | |
| 363|    |-|91|[Minimum Adjustment Cost](http://lintcode.com/en/problem/minimum-adjustment-cost/)| [C++](./C++/minimum-adjustment-cost.cpp)| _O(k * n * t)_ | _O(k)_ | Medium | | |
| 364|    |-|92|[Backpack](http://lintcode.com/en/problem/backpack/)| [C++](./C++/backpack.cpp)| _O(m * n)_ | _O(m)_ | Easy | | |
| 365|    |-|107|[Word Break](http://lintcode.com/en/problem/word-break/)| [C++](./C++/word-break.cpp)| _O(n * l^2)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 366|    |-|108|[Palindrome Partitioning II](http://lintcode.com/en/problem/palindrome-partitioning-ii/)| [C++](./C++/palindrome-partitioning-ii.cpp)| _O(n^2)_ | _O(n)_ | Medium | LeetCode, EPI | |
| 367|    |-|109|[Triangle](http://lintcode.com/en/problem/triangle/)| [C++](./C++/triangle.cpp)| _O(n)_ | _O(n)_ | Easy | LeetCode, EPI | |
| 368|    |-|110|[Minimum Path Sum](http://lintcode.com/en/problem/minimum-path-sum/)| [C++](./C++/minimum-path-sum.cpp)| _O(m * n)_ | _O(min(m, n))_ | Easy | LeetCode, EPI | |
| 369|    |-|111|[Climbing Stairs](http://lintcode.com/en/problem/climbing-stairs/)| [C++](./C++/climbing-stairs.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 370|    |-|115|[Unique Paths II](http://lintcode.com/en/problem/unique-paths-ii/)| [C++](./C++/unique-paths-ii.cpp)| _O(m * n)_ | _O(min(m, n))_ | Easy | LeetCode, CTCI | DP, Math |
| 371|    |-|118|[Distinct Subsequences](http://lintcode.com/en/problem/distinct-subsequences/)| [C++](./C++/distinct-subsequences.cpp)| _O(m * n)_ | _O(m)_ | Medium | LeetCode | DP |
| 372|    |-|119|[Edit Distance](http://lintcode.com/en/problem/edit-distance/)| [C++](./C++/edit-distance.cpp)| _O(m * n)_ | _O(min(m, n))_ | Medium | LeetCode, CTCI | DP |
| 373|    |-|125|[Backpack II](http://lintcode.com/en/problem/backpack-ii/)| [C++](./C++/backpack-ii.cpp)| _O(m * n)_ | _O(m)_ | Medium | | |
| 374|    |-|149|[Best Time to Buy and Sell Stock](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock/)| [C++](./C++/best-time-to-buy-and-sell-stock.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 375|    |-|150|[Best Time to Buy and Sell Stock II](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-ii/)| [C++](./C++/best-time-to-buy-and-sell-stock-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 376|    |-|151|[Best Time to Buy and Sell Stock III](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iii/)| [C++](./C++/best-time-to-buy-and-sell-stock-iii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode, EPI | |
| 377|    |-|154|[Regular Expression Matching](http://lintcode.com/en/problem/regular-expression-matching/)| [C++](./C++/regular-expression-matching.cpp)| _O(m * n)_ | _O(m)_ | Hard | LeetCode | DP, Recursion |
| 378|    |-|168|[Burst Balloons](http://lintcode.com/en/problem/burst-balloons/)| [C++](./C++/burst-balloons.cpp)| _O(n^3)_ | _O(n^2)_ | Medium | LeetCode | |
| 379|    |-|191|[Maximum Product Subarray](http://lintcode.com/en/problem/maximum-product-subarray/)| [C++](./C++/maximum-product-subarray.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 380|    |-|392|[House Robber](http://lintcode.com/en/problem/house-robber/)| [C++](./C++/house-robber.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 381|    |-|393|[Best Time to Buy and Sell Stock IV](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iv/)| [C++](./C++/best-time-to-buy-and-sell-stock-iv.cpp)| _O(k * n)_ | _O(k)_ | Hard | LeetCode, EPI | |
| 382|    |-|395|[Coins in a Line II](http://lintcode.com/en/problem/coins-in-a-line-ii/)| [C++](./C++/coins-in-a-line-ii.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 383|    |-|396|[Coins in a Line III](http://lintcode.com/en/problem/coins-in-a-line-iii/)| [C++](./C++/coins-in-a-line-iii.cpp)| _O(n^2)_ | _O(n)_ | Hard | | |
| 384|    |-|397|[Longest Increasing Continuous subsequence](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence/)| [C++](./C++/longest-increasing-continuous-subsequence.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 385|    |-|398|[Longest Increasing Continuous subsequence II](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/)| [C++](./C++/longest-increasing-continuous-subsequence-ii.cpp)| _O(m * n)_ | _O(m * n)_ | Hard | | |
| 386|    |-|403|[Continuous Subarray Sum II](http://lintcode.com/en/problem/continuous-subarray-sum-ii/)| [C++](./C++/continuous-subarray-sum-ii.cpp)| _O(n)_ | _O(1)_ | Medium | EPI | |
| 387|    |-|430|[Scramble String](http://lintcode.com/en/problem/scramble-string/)| [C++](./C++/scramble-string.cpp)| _O(n^4)_ | _O(n^3)_ | Hard | LeetCode | |
| 388|    |-|435|[Post Office Problem](http://lintcode.com/en/problem/post-office-problem/)| [C++](./C++/post-office-problem.cpp)| _O(k * n^2)_ | _O(n)_ | Hard | PKU 1160 | |
| 389|    |-|436|[Maximal Square](http://lintcode.com/en/problem/maximal-square/)| [C++](./C++/maximal-square.cpp)| _O(m * n)_ | _O(n)_ | Medium | LeetCode | |
| 390|    |-|512|[Decode Ways](http://lintcode.com/en/problem/decode-ways/)| [C++](./C++/decode-ways.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 391|    |-|513|[Perfect Squares](http://lintcode.com/en/problem/perfect-squares/)| [C++](./C++/perfect-squares.cpp)| _O(n * sqrt(n))_ | _O(n)_ | Medium | LeetCode | |
| 392|    |-|514|[Paint Fence](http://lintcode.com/en/problem/paint-fence/)| [C++](./C++/paint-fence.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 393|    |-|515|[Paint House](http://lintcode.com/en/problem/paint-house/)| [C++](./C++/paint-house.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 394|    |-|516|[Paint House II](http://lintcode.com/en/problem/paint-house-ii/)| [C++](./C++/paint-house-ii.cpp)| _O(n * k)_ | _O(k)_ | Hard | LeetCode | |
| 395|    |-|534|[House Robber II](http://lintcode.com/en/problem/house-robber-ii/)| [C++](./C++/house-robber-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 396|    |-|564|[Backpack VI](http://lintcode.com/en/problem/backpack-vi/)| [C++](./C++/backpack-vi.cpp)| _O(n * t)_ | _O(t)_ | Medium | | |
|    | 355|+
|    | 356|+| #   | Title                                                                                                                        | Solution                                                      | Time              | Space          | Difficulty | Tag            | Note          |
|    | 357|+| --- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ----------------- | -------------- | ---------- | -------------- | ------------- |
|    | 358|+| 20  | [Dices Sum](http://lintcode.com/en/problem/dices-sum/)                                                                       | [C++](./C++/dices-sum.cpp)                                    | *O(n^2)*          | *O(n)*         | Hard       |                |               |
|    | 359|+| 29  | [Interleaving String](http://lintcode.com/en/problem/interleaving-string/)                                                   | [C++](./C++/interleaving-string.cpp)                          | *O(m \* n)*       | *O(min(m, n))* | Medium     | EPI            |               |
|    | 360|+| 43  | [Maximum Subarray III](http://lintcode.com/en/problem/maximum-subarray-iii/)                                                 | [C++](./C++/maximum-subarray-iii.cpp)                         | *O(k \* n)*       | *O(k \* n)*    | Hard       |                |               |
|    | 361|+| 77  | [Longest Common Subsequence](http://lintcode.com/en/problem/longest-common-subsequence/)                                     | [C++](./C++/longest-common-subsequence.cpp)                   | *O(m \* n)*       | *O(min(m, n))* | Medium     |                |               |
|    | 362|+| 79  | [Longest Common Substring](http://lintcode.com/en/problem/longest-common-substring/)                                         | [C++](./C++/longest-common-substring.cpp)                     | *O(m \* n)*       | *O(min(m, n))* | Medium     |                |               |
|    | 363|+| 89  | [K Sum](http://lintcode.com/en/problem/k-sum/)                                                                               | [C++](./C++/k-sum.cpp)                                        | *O(k * n * t)*    | *O(n \* t)*    | Hard       |                |               |
|    | 364|+| 91  | [Minimum Adjustment Cost](http://lintcode.com/en/problem/minimum-adjustment-cost/)                                           | [C++](./C++/minimum-adjustment-cost.cpp)                      | *O(k * n * t)*    | *O(k)*         | Medium     |                |               |
|    | 365|+| 92  | [Backpack](http://lintcode.com/en/problem/backpack/)                                                                         | [C++](./C++/backpack.cpp)                                     | *O(m \* n)*       | *O(m)*         | Easy       |                |               |
|    | 366|+| 107 | [Word Break](http://lintcode.com/en/problem/word-break/)                                                                     | [C++](./C++/word-break.cpp)                                   | *O(n \* l^2)*     | *O(n)*         | Medium     | LeetCode, EPI  |               |
|    | 367|+| 108 | [Palindrome Partitioning II](http://lintcode.com/en/problem/palindrome-partitioning-ii/)                                     | [C++](./C++/palindrome-partitioning-ii.cpp)                   | *O(n^2)*          | *O(n)*         | Medium     | LeetCode, EPI  |               |
|    | 368|+| 109 | [Triangle](http://lintcode.com/en/problem/triangle/)                                                                         | [C++](./C++/triangle.cpp)                                     | *O(n)*            | *O(n)*         | Easy       | LeetCode, EPI  |               |
|    | 369|+| 110 | [Minimum Path Sum](http://lintcode.com/en/problem/minimum-path-sum/)                                                         | [C++](./C++/minimum-path-sum.cpp)                             | *O(m \* n)*       | *O(min(m, n))* | Easy       | LeetCode, EPI  |               |
|    | 370|+| 111 | [Climbing Stairs](http://lintcode.com/en/problem/climbing-stairs/)                                                           | [C++](./C++/climbing-stairs.cpp)                              | *O(n)*            | *O(1)*         | Easy       | LeetCode       |               |
|    | 371|+| 115 | [Unique Paths II](http://lintcode.com/en/problem/unique-paths-ii/)                                                           | [C++](./C++/unique-paths-ii.cpp)                              | *O(m \* n)*       | *O(min(m, n))* | Easy       | LeetCode, CTCI | DP, Math      |
|    | 372|+| 118 | [Distinct Subsequences](http://lintcode.com/en/problem/distinct-subsequences/)                                               | [C++](./C++/distinct-subsequences.cpp)                        | *O(m \* n)*       | *O(m)*         | Medium     | LeetCode       | DP            |
|    | 373|+| 119 | [Edit Distance](http://lintcode.com/en/problem/edit-distance/)                                                               | [C++](./C++/edit-distance.cpp)                                | *O(m \* n)*       | *O(min(m, n))* | Medium     | LeetCode, CTCI | DP            |
|    | 374|+| 125 | [Backpack II](http://lintcode.com/en/problem/backpack-ii/)                                                                   | [C++](./C++/backpack-ii.cpp)                                  | *O(m \* n)*       | *O(m)*         | Medium     |                |               |
|    | 375|+| 149 | [Best Time to Buy and Sell Stock](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock/)                           | [C++](./C++/best-time-to-buy-and-sell-stock.cpp)              | *O(n)*            | *O(1)*         | Medium     | LeetCode, EPI  |               |
|    | 376|+| 150 | [Best Time to Buy and Sell Stock II](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-ii/)                     | [C++](./C++/best-time-to-buy-and-sell-stock-ii.cpp)           | *O(n)*            | *O(1)*         | Medium     | LeetCode, EPI  |               |
|    | 377|+| 151 | [Best Time to Buy and Sell Stock III](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iii/)                   | [C++](./C++/best-time-to-buy-and-sell-stock-iii.cpp)          | *O(n)*            | *O(1)*         | Medium     | LeetCode, EPI  |               |
|    | 378|+| 154 | [Regular Expression Matching](http://lintcode.com/en/problem/regular-expression-matching/)                                   | [C++](./C++/regular-expression-matching.cpp)                  | *O(m \* n)*       | *O(m)*         | Hard       | LeetCode       | DP, Recursion |
|    | 379|+| 168 | [Burst Balloons](http://lintcode.com/en/problem/burst-balloons/)                                                             | [C++](./C++/burst-balloons.cpp)                               | *O(n^3)*          | *O(n^2)*       | Medium     | LeetCode       |               |
|    | 380|+| 191 | [Maximum Product Subarray](http://lintcode.com/en/problem/maximum-product-subarray/)                                         | [C++](./C++/maximum-product-subarray.cpp)                     | *O(n)*            | *O(1)*         | Medium     | LeetCode       |               |
|    | 381|+| 392 | [House Robber](http://lintcode.com/en/problem/house-robber/)                                                                 | [C++](./C++/house-robber.cpp)                                 | *O(n)*            | *O(1)*         | Medium     | LeetCode       |               |
|    | 382|+| 393 | [Best Time to Buy and Sell Stock IV](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iv/)                     | [C++](./C++/best-time-to-buy-and-sell-stock-iv.cpp)           | *O(k \* n)*       | *O(k)*         | Hard       | LeetCode, EPI  |               |
|    | 383|+| 395 | [Coins in a Line II](http://lintcode.com/en/problem/coins-in-a-line-ii/)                                                     | [C++](./C++/coins-in-a-line-ii.cpp)                           | *O(n)*            | *O(1)*         | Medium     |                |               |
|    | 384|+| 396 | [Coins in a Line III](http://lintcode.com/en/problem/coins-in-a-line-iii/)                                                   | [C++](./C++/coins-in-a-line-iii.cpp)                          | *O(n^2)*          | *O(n)*         | Hard       |                |               |
|    | 385|+| 397 | [Longest Increasing Continuous subsequence](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence/)       | [C++](./C++/longest-increasing-continuous-subsequence.cpp)    | *O(n)*            | *O(1)*         | Easy       |                |               |
|    | 386|+| 398 | [Longest Increasing Continuous subsequence II](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/) | [C++](./C++/longest-increasing-continuous-subsequence-ii.cpp) | *O(m \* n)*       | *O(m \* n)*    | Hard       |                |               |
|    | 387|+| 403 | [Continuous Subarray Sum II](http://lintcode.com/en/problem/continuous-subarray-sum-ii/)                                     | [C++](./C++/continuous-subarray-sum-ii.cpp)                   | *O(n)*            | *O(1)*         | Medium     | EPI            |               |
|    | 388|+| 430 | [Scramble String](http://lintcode.com/en/problem/scramble-string/)                                                           | [C++](./C++/scramble-string.cpp)                              | *O(n^4)*          | *O(n^3)*       | Hard       | LeetCode       |               |
|    | 389|+| 435 | [Post Office Problem](http://lintcode.com/en/problem/post-office-problem/)                                                   | [C++](./C++/post-office-problem.cpp)                          | *O(k \* n^2)*     | *O(n)*         | Hard       | PKU 1160       |               |
|    | 390|+| 436 | [Maximal Square](http://lintcode.com/en/problem/maximal-square/)                                                             | [C++](./C++/maximal-square.cpp)                               | *O(m \* n)*       | *O(n)*         | Medium     | LeetCode       |               |
|    | 391|+| 512 | [Decode Ways](http://lintcode.com/en/problem/decode-ways/)                                                                   | [C++](./C++/decode-ways.cpp)                                  | *O(n)*            | *O(1)*         | Medium     | LeetCode       |               |
|    | 392|+| 513 | [Perfect Squares](http://lintcode.com/en/problem/perfect-squares/)                                                           | [C++](./C++/perfect-squares.cpp)                              | *O(n \* sqrt(n))* | *O(n)*         | Medium     | LeetCode       |               |
|    | 393|+| 514 | [Paint Fence](http://lintcode.com/en/problem/paint-fence/)                                                                   | [C++](./C++/paint-fence.cpp)                                  | *O(n)*            | *O(1)*         | Easy       | LeetCode       |               |
|    | 394|+| 515 | [Paint House](http://lintcode.com/en/problem/paint-house/)                                                                   | [C++](./C++/paint-house.cpp)                                  | *O(n)*            | *O(1)*         | Medium     | LeetCode       |               |
|    | 395|+| 516 | [Paint House II](http://lintcode.com/en/problem/paint-house-ii/)                                                             | [C++](./C++/paint-house-ii.cpp)                               | *O(n \* k)*       | *O(k)*         | Hard       | LeetCode       |               |
|    | 396|+| 534 | [House Robber II](http://lintcode.com/en/problem/house-robber-ii/)                                                           | [C++](./C++/house-robber-ii.cpp)                              | *O(n)*            | *O(1)*         | Medium     | LeetCode       |               |
|    | 397|+| 564 | [Backpack VI](http://lintcode.com/en/problem/backpack-vi/)                                                                   | [C++](./C++/backpack-vi.cpp)                                  | *O(n \* t)*       | *O(t)*         | Medium     |                |               |
| 397| 398| 
| 398| 399| ## Greedy
| 399| 400| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 396| 396| |564|[Backpack VI](http://lintcode.com/en/problem/backpack-vi/)| [C++](./C++/backpack-vi.cpp)| _O(n * t)_ | _O(t)_ | Medium | | |
| 397| 397| 
| 398| 398| ## Greedy
| 399|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 400|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 401|    |-|41|[Maximum Subarray](http://lintcode.com/en/problem/maximum-subarray/)| [C++](./C++/maximum-subarray.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 402|    |-|42|[Maximum Subarray II](http://lintcode.com/en/problem/maximum-subarray-ii/)| [C++](./C++/maximum-subarray-ii.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 403|    |-|44|[Minimum Subarray](http://lintcode.com/en/problem/minimum-subarray/)| [C++](./C++/minimum-subarray.cpp)| _O(n)_ | _O(1)_ | Easy | | |
| 404|    |-|45|[Maximum Subarray Difference](http://lintcode.com/en/problem/maximum-subarray-difference/)| [C++](./C++/maximum-subarray-difference.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 405|    |-|116|[Jump Game](http://lintcode.com/en/problem/jump-game/)| [C++](./C++/jump-game.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 406|    |-|117|[Jump Game II](http://lintcode.com/en/problem/jump-game-ii/)| [C++](./C++/jump-game-ii.cpp)| _O(n)_ | _O(1)_ | Medium | LeetCode | |
| 407|    |-|182|[Delete Digits](http://lintcode.com/en/problem/delete-digits/)| [C++](./C++/delete-digits.cpp)| _O(n)_ | _O(n)_ | Medium | | |
| 408|    |-|187|[Gas Station](http://lintcode.com/en/problem/gas-station/)| [C++](./C++/gas-station.cpp)| _O(n)_ | _O(1)_ | Easy | LeetCode | |
| 409|    |-|192|[Wildcard Matching](http://lintcode.com/en/problem/wildcard-matching/)| [C++](./C++/wildcard-matching.cpp)| _O(m + n)_ | _O(1)_ | Hard | LeetCode | Greedy, DP, Recursion |
| 410|    |-|402|[Continuous Subarray Sum](http://lintcode.com/en/problem/continuous-subarray-sum/)| [C++](./C++/continuous-subarray-sum.cpp)| _O(n)_ | _O(1)_ | Medium | EPI | |
| 411|    |-|412|[Candy](http://lintcode.com/en/problem/candy/)| [C++](./C++/candy.cpp)| _O(n)_ | _O(n)_ | Hard | LeetCode | Greedy |
| 412|    |-|552| [Create Maximum Number](http://lintcode.com/en/problem/create-maximum-number/)| [C++](./C++/create-maximum-number.cpp) | _O(k * (m + n + k))_ ~ _O(k * (m + n + k^2))_| _O(m + n + k^2)_ | Hard | LeetCode | Greedy, DP|
|    | 399|+
|    | 400|+| #   | Title                                                                                      | Solution                                     | Time                                            | Space            | Difficulty | Tag      | Note                  |
|    | 401|+| --- | ------------------------------------------------------------------------------------------ | -------------------------------------------- | ----------------------------------------------- | ---------------- | ---------- | -------- | --------------------- |
|    | 402|+| 41  | [Maximum Subarray](http://lintcode.com/en/problem/maximum-subarray/)                       | [C++](./C++/maximum-subarray.cpp)            | *O(n)*                                          | *O(1)*           | Easy       | LeetCode |                       |
|    | 403|+| 42  | [Maximum Subarray II](http://lintcode.com/en/problem/maximum-subarray-ii/)                 | [C++](./C++/maximum-subarray-ii.cpp)         | *O(n)*                                          | *O(n)*           | Medium     |          |                       |
|    | 404|+| 44  | [Minimum Subarray](http://lintcode.com/en/problem/minimum-subarray/)                       | [C++](./C++/minimum-subarray.cpp)            | *O(n)*                                          | *O(1)*           | Easy       |          |                       |
|    | 405|+| 45  | [Maximum Subarray Difference](http://lintcode.com/en/problem/maximum-subarray-difference/) | [C++](./C++/maximum-subarray-difference.cpp) | *O(n)*                                          | *O(n)*           | Medium     |          |                       |
|    | 406|+| 116 | [Jump Game](http://lintcode.com/en/problem/jump-game/)                                     | [C++](./C++/jump-game.cpp)                   | *O(n)*                                          | *O(1)*           | Medium     | LeetCode |                       |
|    | 407|+| 117 | [Jump Game II](http://lintcode.com/en/problem/jump-game-ii/)                               | [C++](./C++/jump-game-ii.cpp)                | *O(n)*                                          | *O(1)*           | Medium     | LeetCode |                       |
|    | 408|+| 182 | [Delete Digits](http://lintcode.com/en/problem/delete-digits/)                             | [C++](./C++/delete-digits.cpp)               | *O(n)*                                          | *O(n)*           | Medium     |          |                       |
|    | 409|+| 187 | [Gas Station](http://lintcode.com/en/problem/gas-station/)                                 | [C++](./C++/gas-station.cpp)                 | *O(n)*                                          | *O(1)*           | Easy       | LeetCode |                       |
|    | 410|+| 192 | [Wildcard Matching](http://lintcode.com/en/problem/wildcard-matching/)                     | [C++](./C++/wildcard-matching.cpp)           | *O(m + n)*                                      | *O(1)*           | Hard       | LeetCode | Greedy, DP, Recursion |
|    | 411|+| 402 | [Continuous Subarray Sum](http://lintcode.com/en/problem/continuous-subarray-sum/)         | [C++](./C++/continuous-subarray-sum.cpp)     | *O(n)*                                          | *O(1)*           | Medium     | EPI      |                       |
|    | 412|+| 412 | [Candy](http://lintcode.com/en/problem/candy/)                                             | [C++](./C++/candy.cpp)                       | *O(n)*                                          | *O(n)*           | Hard       | LeetCode | Greedy                |
|    | 413|+| 552 | [Create Maximum Number](http://lintcode.com/en/problem/create-maximum-number/)             | [C++](./C++/create-maximum-number.cpp)       | *O(k \* (m + n + k))* ~ *O(k \* (m + n + k^2))* | *O(m + n + k^2)* | Hard       | LeetCode | Greedy, DP            |
| 413| 414| 
| 414| 415| ## OO Design
| 415| 416| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 412| 412| |552| [Create Maximum Number](http://lintcode.com/en/problem/create-maximum-number/)| [C++](./C++/create-maximum-number.cpp) | _O(k * (m + n + k))_ ~ _O(k * (m + n + k^2))_| _O(m + n + k^2)_ | Hard | LeetCode | Greedy, DP|
| 413| 413| 
| 414| 414| ## OO Design
| 415|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 416|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 417|    |-|204|[Singleton](http://lintcode.com/en/problem/singleton/)| [C++](./C++/singleton.cpp)| _O(1)_ | _O(1)_ | Easy | | |
| 418|    |-|208|[Assignment Operator Overloading (C++ Only)](http://lintcode.com/en/problem/assignment-operator-overloading-c-only/)| [C++](./C++/assignment-operator-overloading-c-only.cpp)| _O(n)_ | _O(1)_ | Medium | | |
| 419|    |-|496|[Toy Factory](http://www.lintcode.com/en/problem/toy-factory/)| [C++](./C++/toy-factory.cpp)| _O(1)_ | _O(1)_ | Easy | | |
| 420|    |-|497|[Shape Factory](http://www.lintcode.com/en/problem/shape-factory/)| [C++](./C++/shape-factory.cpp)| _O(1)_ | _O(1)_ | Easy | | |
| 421|    |-|498|[Parking Lot](http://www.lintcode.com/en/problem/parking-lot/)| [C++](./C++/parking-lot.cpp)| _O(n * m * k)_ | _O(n * m * k)_ | Hard | CTCI | OO Design, Pimpl Idiom, Smart Pointer |
|    | 415|+
|    | 416|+| #   | Title                                                                                                                | Solution                                                | Time           | Space          | Difficulty | Tag  | Note                                  |
|    | 417|+| --- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | -------------- | -------------- | ---------- | ---- | ------------------------------------- |
|    | 418|+| 204 | [Singleton](http://lintcode.com/en/problem/singleton/)                                                               | [C++](./C++/singleton.cpp)                              | *O(1)*         | *O(1)*         | Easy       |      |                                       |
|    | 419|+| 208 | [Assignment Operator Overloading (C++ Only)](http://lintcode.com/en/problem/assignment-operator-overloading-c-only/) | [C++](./C++/assignment-operator-overloading-c-only.cpp) | *O(n)*         | *O(1)*         | Medium     |      |                                       |
|    | 420|+| 496 | [Toy Factory](http://www.lintcode.com/en/problem/toy-factory/)                                                       | [C++](./C++/toy-factory.cpp)                            | *O(1)*         | *O(1)*         | Easy       |      |                                       |
|    | 421|+| 497 | [Shape Factory](http://www.lintcode.com/en/problem/shape-factory/)                                                   | [C++](./C++/shape-factory.cpp)                          | *O(1)*         | *O(1)*         | Easy       |      |                                       |
|    | 422|+| 498 | [Parking Lot](http://www.lintcode.com/en/problem/parking-lot/)                                                       | [C++](./C++/parking-lot.cpp)                            | *O(n * m * k)* | *O(n * m * k)* | Hard       | CTCI | OO Design, Pimpl Idiom, Smart Pointer |
| 422| 423| 
| 423| 424| ## System Design
| 424| 425| | # | Title | Solution | Time | Space | Difficulty | Tag | Note |
|    | [NORMAL] MarkdownBear:
|    | The text does not comply to the set style.
|----|    | /app/README.md
|    |++++| /app/README.md
| 421| 421| |498|[Parking Lot](http://www.lintcode.com/en/problem/parking-lot/)| [C++](./C++/parking-lot.cpp)| _O(n * m * k)_ | _O(n * m * k)_ | Hard | CTCI | OO Design, Pimpl Idiom, Smart Pointer |
| 422| 422| 
| 423| 423| ## System Design
| 424|    |-| # | Title | Solution | Time | Space | Difficulty | Tag | Note |
| 425|    |-|---| ----- | -------- | ---- | ----- | ---------- | --- | ---- |
| 426|    |-|501|[Mini Twitter](http://www.lintcode.com/en/problem/mini-twitter/)| [C++](./C++/mini-twitter.cpp)| _O(klogu)_ | _O(t + f)_ | Medium | | |
|    | 424|+
|    | 425|+| #   | Title                                                            | Solution                      | Time       | Space      | Difficulty | Tag | Note |
|    | 426|+| --- | ---------------------------------------------------------------- | ----------------------------- | ---------- | ---------- | ---------- | --- | ---- |
|    | 427|+| 501 | [Mini Twitter](http://www.lintcode.com/en/problem/mini-twitter/) | [C++](./C++/mini-twitter.cpp) | *O(klogu)* | *O(t + f)* | Medium     |     |      |

README.md
|   1| #•[LintCode](http://www.lintcode.com/en/problem/)•![Language](https://img.shields.io/badge/language-C++%2011-orange.svg)•[![License](https://img.shields.io/badge/license-MIT-blue.svg)](./LICENSE.md)•![Progress](https://img.shields.io/badge/progress-289%20%2F%20289-ff69b4.svg)
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (276 > 79)

README.md
|   3| Up•to•date•(2016-08-22),•there•are•`289`•problems•on•[LintCode•Online•Judge](http://lintcode.com/).
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (99 > 79)

README.md
|   6| For•more•problems•and•solutions,•you•can•see•my•[LeetCode](https://github.com/kamyu104/LeetCode)•repository.
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (108 > 79)

README.md
|   7| I'll•keep•updating•for•full•summary•and•better•solutions.•Stay•tuned•for•updates.
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (81 > 79)

README.md
|  24| *•[Breadth-First•Search](https://github.com/kamyu104/LintCode#breadth-first-search)
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (83 > 79)

README.md
|  27| *•[Binary•Search•Trees](https://github.com/kamyu104/LintCode#binary-search-trees)
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (81 > 79)

README.md
|  28| *•[Dynamic•Programming](https://github.com/kamyu104/LintCode#dynamic-programming)
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (81 > 79)

README.md
|  36| |1|[A•+•B•Problem](http://lintcode.com/en/problem/a-b-problem/)|•[C++](./C++/a-b-problem.cpp)|•_O(1)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (125 > 79)

README.md
|  37| |82|[Single•Number](http://lintcode.com/en/problem/single-number/)|•[C++](./C++/single-number.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (136 > 79)

README.md
|  38| |83|[Single•Number•II](http://lintcode.com/en/problem/single-number-ii/)|•[C++](./C++/single-number-ii.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
|  39| |84|[Single•Number•III](http://lintcode.com/en/problem/single-number-iii/)|•[C++](./C++/single-number-iii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (147 > 79)

README.md
|  40| |142|[O(1)•Check•Power•of•2](http://lintcode.com/en/problem/o1-check-power-of-2/)|•[C++](./C++/o1-check-power-of-2.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
|  41| |179|[Update•Bits](http://lintcode.com/en/problem/update-bits/)|•[C++](./C++/update-bits.cpp)|•_O(1)_•|•_O(1)_•|•Medium•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (130 > 79)

README.md
|  42| |181|[Flip•Bits](http://lintcode.com/en/problem/flip-bits/)|•[C++](./C++/flip-bits.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (122 > 79)

README.md
|  43| |196|[Find•the•Missing•Number](http://lintcode.com/en/problem/find-the-missing-number/)|•[C++](./C++/find-the-missing-number.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
|  44| |365|[Count•1•in•Binary](http://lintcode.com/en/problem/count-1-in-binary/)|•[C++](./C++/count-1-in-binary.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
|  49| |6|[Merge•Sorted•Array](http://lintcode.com/en/problem/merge-sorted-array/)|•[C++](./C++/merge-sorted-array.cpp)|•_O(m•+•n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (168 > 79)

README.md
|  50| |8|[Rotate•String](http://lintcode.com/en/problem/rotate-string/)|•[C++](./C++/rotate-string.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (136 > 79)

README.md
|  51| |9|[Fizz•Buzz](http://lintcode.com/en/problem/fizz-buzz/)|•[C++](./C++/fizz-buzz.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (115 > 79)

README.md
|  52| |30|[Insert•Interval](http://lintcode.com/en/problem/insert-interval/)|•[C++](./C++/insert-interval.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
|  53| |31|[Partition•Array](http://lintcode.com/en/problem/partition-array/)|•[C++](./C++/partition-array.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
|  54| |32|[Minimum•Window•Substring](http://lintcode.com/en/problem/minimum-window-substring/)|•[C++](./C++/minimum-window-substring.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (172 > 79)

README.md
|  55| |38|[Search•a•2D•Matrix•II](http://lintcode.com/en/problem/search-a-2d-matrix-ii/)|•[C++](./C++/search-a-2d-matrix-ii.cpp)|•_O(m•+•n)_•|•_O(1)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
|  56| |39|[Recover•Rotated•Sorted•Array](http://lintcode.com/en/problem/recover-rotated-sorted-array/)|•[C++](./C++/recover-rotated-sorted-array.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (173 > 79)

README.md
|  57| |46|[Majority•Number](http://lintcode.com/en/problem/majority-number/)|•[C++](./C++/majority-number.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (143 > 79)

README.md
|  58| |47|[Majority•Number•II](http://lintcode.com/en/problem/majority-number/)|•[C++](./C++/majority-number-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
|  59| |48|[Majority•Number•III](http://lintcode.com/en/problem/majority-number-iii/)|•[C++](./C++/majority-number-iii.cpp)|•_O(n)_•|•_O(k)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (152 > 79)

README.md
|  60| |49|[Sort•Letters•by•Case](http://lintcode.com/en/problem/sort-letters-by-case/)|•[C++](./C++/sort-letters-by-case.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
|  61| |50|[Product•of•Array•Exclude•Itself](http://lintcode.com/en/problem/product-of-array-exclude-itself/)|•[C++](./C++/product-of-array-exclude-itself.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (182 > 79)

README.md
|  62| |51|[Previous•Permutation](http://lintcode.com/en/problem/previous-permutation/)|•[C++](./C++/previous-permutation.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (151 > 79)

README.md
|  63| |52|[Next•Permutation](http://lintcode.com/en/problem/next-permutation/)|•[C++](./C++/next-permutation.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
|  64| |57|[3•Sum](http://lintcode.com/en/problem/3-sum/)|•[C++](./C++/3-sum.cpp)|•_O(n^2)_•|•_O(1)_•|•Medium•|•LeetCode•|•Two•Pointers,•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (136 > 79)

README.md
|  65| |58|[4•Sum](http://lintcode.com/en/problem/4-sum/)|•[C++](./C++/4-sum.cpp)|•_O(n^3)_•|•_O(1)_•|•Medium•|•LeetCode•|•Hash•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (122 > 79)

README.md
|  66| |59|[3•Sum•Closest](http://lintcode.com/en/problem/3-sum-closest/)|•[C++](./C++/3-sum-closest.cpp)|•_O(n^2)_•|•_O(1)_•|•Medium•|•LeetCode•|•Two•Pointers,•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (160 > 79)

README.md
|  67| |64|[Merge•Sorted•Array•II](http://lintcode.com/en/problem/merge-sorted-array-ii/)|•[C++](./C++/merge-sorted-array-ii.cpp)|•_O(m•+•n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (178 > 79)

README.md
|  68| |100|[Remove•Duplicates•from•Sorted•Array](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array/)|•[C++](./C++/remove-duplicates-from-sorted-array.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (217 > 79)

README.md
|  69| |101|[Remove•Duplicates•from•Sorted•Array•II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-array-ii/)|•[C++](./C++/remove-duplicates-from-sorted-array-ii.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (226 > 79)

README.md
|  70| |133|[Longest•Words](http://lintcode.com/en/problem/longest-words/)|•[C++](./C++/longest-words.cpp)|•_O(n)_•|•_O(n)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (129 > 79)

README.md
|  71| |144|[Interleaving•Positive•and•Negative•Numbers](http://lintcode.com/en/problem/interleaving-positive-and-negative-numbers/)|•[C++](./C++/interleaving-positive-and-negative-numbers.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (231 > 79)

README.md
|  72| |161|[Rotate•Image](http://lintcode.com/en/problem/rotate-image/)|•[C++](./C++/rotate-image.cpp)|•_O(n^2)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (139 > 79)

README.md
|  73| |162|[Set•Matrix•Zeroes](http://lintcode.com/en/problem/set-matrix-zeroes/)|•[C++](./C++/set-matrix-zeroes.cpp)|•_O(m•*•n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (156 > 79)

README.md
|  74| |172|[Remove•Element](http://lintcode.com/en/problem/remove-element/)|•[C++](./C++/remove-element.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (154 > 79)

README.md
|  75| |185|[Matrix•Zigzag•Traversal](http://lintcode.com/en/problem/matrix-zigzag-traversal/)|•[C++](./C++/matrix-zigzag-traversal.cpp)|•_O(m•*•n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (163 > 79)

README.md
|  76| |189|[First•Missing•Positive](http://lintcode.com/en/problem/first-missing-positive/)|•[C++](./C++/first-missing-positive.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•Hash•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (175 > 79)

README.md
|  77| |190|[Next•Permutation•II](http://lintcode.com/en/problem/next-permutation-ii/)|•[C++](./C++/next-permutation-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (158 > 79)

README.md
|  78| |200|[Longest•Palindromic•Substring](http://lintcode.com/en/problem/longest-palindromic-substring/)|•[C++](./C++/longest-palindromic-substring.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•`Manacher's•Algorithm`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (211 > 79)

README.md
|  79| |363|[Trapping•Rain•Water](http://lintcode.com/en/problem/trapping-rain-water/)|•[C++](./C++/trapping-rain-water.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•Two•Pointers,•Tricky•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (179 > 79)

README.md
|  80| |373|[Partition•Array•by•Odd•and•Even](http://lintcode.com/en/problem/partition-array-by-odd-and-even/)|•[C++](./C++/partition-array-by-odd-and-even.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (196 > 79)

README.md
|  81| |374|•[Spiral•Matrix](http://lintcode.com/en/problem/spiral-matrix/)•|•[C++](./C++/spiral-matrix.cpp)•|•_O(m•*•n)_••••|•_O(1)_•••••••••|•Medium•••••••••|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (166 > 79)

README.md
|  82| |381|•[Spiral•Matrix•II](http://lintcode.com/en/problem/spiral-matrix-ii/)•|•[C++](./C++/spiral-matrix-ii.cpp)•|•_O(n^2)_•|•_O(1)_••••••|•Medium•••••••••|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (167 > 79)

README.md
|  83| |382|[Triangle•Count](http://lintcode.com/en/problem/triangle-count/)|•[C++](./C++/triangle-count.cpp)|•_O(n^2)_•|•_O(1)_•|•Medium•|•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
|  84| |383|[Container•With•Most•Water](http://lintcode.com/en/problem/container-with-most-water/)|•[C++](./C++/container-with-most-water.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (194 > 79)

README.md
|  85| |388|[Permutation•Sequence](http://lintcode.com/en/problem/permutation-sequence/)|•[C++](./C++/permutation-sequence.cpp)|•_O(n^2)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (163 > 79)

README.md
|  86| |389|[Valid•Sudoku](http://lintcode.com/en/problem/valid-sudoku/)|•[C++](./C++/valid-sudoku.cpp)|•_O(9^2)_•|•_O(9)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (137 > 79)

README.md
|  87| |404|[Subarray•Sum•II](http://lintcode.com/en/problem/subarray-sum-ii/)|•[C++](./C++/subarray-sum-ii.cpp)|•_O(nlogn)_•|•_O(n)_•|•Hard•|•|•Two•Pointers,•Binary•Search•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (167 > 79)

README.md
|  88| |405|[Submatrix•Sum](http://lintcode.com/en/problem/submatrix-sum/)|•[C++](./C++/submatrix-sum.cpp)|•_O(m•*•n^2)_•|•_O(m)_•|•Hard•|•|•Hash•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (140 > 79)

README.md
|  89| |406|[Minimum•Size•Subarray•Sum](http://lintcode.com/en/problem/minimum-size-subarray-sum/)|•[C++](./C++/minimum-size-subarray-sum.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•Two•Pointers,•Binary•Search•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (204 > 79)

README.md
|  90| |539|[Move•Zeroes](http://lintcode.com/en/problem/move-zeroes/)|•[C++](./C++/move-zeroes.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•Two•Pointers•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (145 > 79)

README.md
|  95| |13|[strStr](http://lintcode.com/en/problem/strstr/)|[C++](./C++/strstr.cpp)|•_O(n•+•k)_•|•_O(k)_•|•Easy•|•LeetCode•|•`KMP•Algorithm`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (135 > 79)

README.md
|  96| |53|[Reverse•Words•in•a•String](http://lintcode.com/en/problem/reverse-words-in-a-string/)|[C++](./C++/reverse-words-in-a-string.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (177 > 79)

README.md
|  97| |54|[String•to•Integer(atoi)](http://lintcode.com/en/problem/string-to-integeratoi/)|[C++](./C++/string-to-integeratoi.cpp)|•_O(n)_•|•_O(1)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
|  98| |55|[Compare•Strings](http://lintcode.com/en/problem/compare-strings/)|[C++](./C++/compare-strings.cpp)|•_O(n)_•|•_O(c)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (133 > 79)

README.md
|  99| |78|[Longest•Common•Prefix](http://lintcode.com/en/problem/longest-common-prefix/)|[C++](./C++/longest-common-prefix.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (153 > 79)

README.md
| 100| |157|[Unique•Characters](http://lintcode.com/en/problem/unique-characters/)|[C++](./C++/unique-characters.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (145 > 79)

README.md
| 101| |158|[Two•Strings•Are•Anagrams](http://lintcode.com/en/problem/two-strings-are-anagrams/)|[C++](./C++/two-strings-are-anagrams.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 102| |171|[Anagrams](http://lintcode.com/en/problem/anagrams/)|[C++](./C++/anagrams.cpp)|•_O(n•*•klogk)_•|•_O(m)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (135 > 79)

README.md
| 103| |212|[Space•Replacement](http://lintcode.com/en/problem/space-replacement/)|[C++](./C++/space-replacement.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (140 > 79)

README.md
| 104| |407|[Plus•One](http://lintcode.com/en/problem/plus-one.cpp/)|[C++](./C++/plus-one.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (126 > 79)

README.md
| 105| |408|[Add•Binary](http://lintcode.com/en/problem/add-binary/)|[C++](./C++/add-binary.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (128 > 79)

README.md
| 106| |415|[Valid•Palindrome](http://lintcode.com/en/problem/valid-palindrome/)|[C++](./C++/valid-palindrome.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 107| |417|[Valid•Number](http://lintcode.com/en/problem/valid-number/)|[C++](./C++/valid-number.cpp)|•_O(n)_•|•_O(1)_•|•Hard•|•LeetCode•|•Automata•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (143 > 79)

README.md
| 108| |420|[Count•and•Say](http://lintcode.com/en/problem/count-and-say/)|[C++](./C++/count-and-say.cpp)|•_O(n•*•2^n)_•|•_O(2^n)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (145 > 79)

README.md
| 109| |422|[Length•of•Last•Word](http://lintcode.com/en/problem/length-of-last-word/)|[C++](./C++/length-of-last-word.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (155 > 79)

README.md
| 110| |524|[Left•Pad](http://lintcode.com/en/problem/left-pad/)|[C++](./C++/left-pad.cpp)|•_O(p•+•n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (126 > 79)

README.md
| 115| |16|[Merge•Two•Sorted•Lists](http://lintcode.com/en/problem/merge-two-sorted-lists/)|[C++](./C++/merge-two-sorted-lists.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (168 > 79)

README.md
| 116| |35|[Reverse•Linked•List](http://lintcode.com/en/problem/reverse-linked-list/)|[C++](./C++/reverse-linked-list.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (159 > 79)

README.md
| 117| |36|[Reverse•Linked•List•II](http://lintcode.com/en/problem/reverse-linked-list-ii/)|[C++](./C++/reverse-linked-list-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 118| |96|[Partition•List](http://lintcode.com/en/problem/partition-list/)|[C++](./C++/partition-list.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (139 > 79)

README.md
| 119| |98|[Sort•List](http://lintcode.com/en/problem/sort-list/)|[C++](./C++/sort-list.cpp)|•_O(nlogn)_•|•_O(logn)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (138 > 79)

README.md
| 120| |99|[Reorder•List](http://lintcode.com/en/problem/reorder-list/)|[C++](./C++/reorder-list.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (135 > 79)

README.md
| 121| |102|[Linked•List•Cycle](http://lintcode.com/en/problem/linked-list-cycle/)|[C++](./C++/linked-list-cycle.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (151 > 79)

README.md
| 122| |103|[Linked•List•Cycle•II](http://lintcode.com/en/problem/linked-list-cycle-ii/)|[C++](./C++/linked-list-cycle-ii.cpp)|•_O(n)_•|•_O(1)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (158 > 79)

README.md
| 123| |104|[Merge•k•Sorted•Lists](http://lintcode.com/en/problem/merge-k-sorted-lists/)|•[C++](./C++/merge-k-sorted-lists.cpp)|•_O(n•*•logk)_•|•_O(1)_•|•Medium•|•LeetCode•|•Heap,•Divide•and•Conquer•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (193 > 79)

README.md
| 124| |105|[Copy•List•with•Random•Pointer](http://lintcode.com/en/problem/copy-list-with-random-pointer/)|[C++](./C++/copy-list-with-random-pointer.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (187 > 79)

README.md
| 125| |106|[Convert•Sorted•List•to•Binary•Search•Tree](http://lintcode.com/en/problem/convert-sorted-list-to-binary-search-tree/)|[C++](./C++/convert-sorted-list-to-binary-search-tree.cpp)|•_O(n)_•|•_O(logn)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (231 > 79)

README.md
| 126| |112|[Remove•Duplicates•from•Sorted•List](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list/)|[C++](./C++/remove-duplicates-from-sorted-list.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (205 > 79)

README.md
| 127| |113|[Remove•Duplicates•from•Sorted•List•II](http://lintcode.com/en/problem/remove-duplicates-from-sorted-list-ii/)|[C++](./C++/remove-duplicates-from-sorted-list-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (216 > 79)

README.md
| 128| |166|[Nth•to•Last•Node•in•List](http://lintcode.com/en/problem/nth-to-last-node-in-list/)|[C++](./C++/nth-to-last-node-in-list.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 129| |167|[Two•Lists•Sum](http://lintcode.com/en/problem/two-lists-sum/)|[C++](./C++/two-lists-sum.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (137 > 79)

README.md
| 130| |170|[Rotate•List](http://lintcode.com/en/problem/rotate-list/)|[C++](./C++/rotate-list.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (133 > 79)

README.md
| 131| |173|[Insertion•Sort•List](http://lintcode.com/en/problem/insertion-sort-list/)|[C++](./C++/insertion-sort-list.cpp)|•_O(n^2)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (157 > 79)

README.md
| 132| |174|[Remove•Nth•Node•From•End•of•List](http://lintcode.com/en/problem/remove-nth-node-from-end-of-list/)|[C++](./C++/remove-nth-node-from-end-of-list.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (194 > 79)

README.md
| 133| |223|[Palindrome•Linked•List](http://lintcode.com/en/problem/palindrome-linked-list/)|[C++](./C++/palindrome-linked-list.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (166 > 79)

README.md
| 134| |372|[Delete•Node•in•the•Middle•of•Singly•Linked•List](http://lintcode.com/en/problem/delete-node-in-the-middle-of-singly-linked-list/)|[C++](./C++/delete-node-in-the-middle-of-singly-linked-list.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (235 > 79)

README.md
| 135| |380|[Intersection•of•Two•Linked•Lists](http://lintcode.com/en/problem/intersection-of-two-linked-lists/)|[C++](./C++/intersection-of-two-linked-lists.cpp)|•_O(m•+•n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (198 > 79)

README.md
| 136| |450|[Reverse•Nodes•in•k-Group](http://lintcode.com/en/problem/reverse-nodes-in-k-group/)|[C++](./C++/reverse-nodes-in-k-group.cpp)|•_O(n)_•|•_O(1)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 137| |451|[Swap•Nodes•in•Pairs](http://lintcode.com/en/problem/swap-nodes-in-pairs/)|[C++](./C++/swap-nodes-in-pairs.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (155 > 79)

README.md
| 138| |452|[Remove•Linked•List•Elements](http://lintcode.com/en/problem/remove-linked-list-elements/)|[C++](./C++/remove-linked-list-elements.cpp)|•_O(n)_•|•_O(1)_•|•Naive•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (180 > 79)

README.md
| 139| |511|[Swap•Two•Nodes•in•Linked•List](http://lintcode.com/en/problem/swap-two-nodes-in-linked-list/)|[C++](./C++/swap-two-nodes-in-linked-list.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (178 > 79)

README.md
| 144| |7|[Binary•Tree•Serialization](http://lintcode.com/en/problem/binary-tree-serialization/)|•[C++](./C++/binary-tree-serialization.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (165 > 79)

README.md
| 145| |85|[Insert•Node•in•a•Binary•Search•Tree](http://lintcode.com/en/problem/insert-node-in-a-binary-search-tree/)|•[C++](./C++/insert-node-in-a-binary-search-tree.cpp)|•_O(h)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (194 > 79)

README.md
| 146| |88|[Lowest•Common•Ancestor](http://lintcode.com/en/problem/lowest-common-ancestor/)|•[C++](./C++/lowest-common-ancestor.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 147| |175|[Invert•Binary•Tree](http://lintcode.com/en/problem/invert-binary-tree/)|•[C++](./C++/invert-binary-tree.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (153 > 79)

README.md
| 148| |442|[Implement•Trie](http://lintcode.com/en/problem/implement-trie/)|•[C++](./C++/implement-trie.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•Trie•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
| 153| |12|[Min•Stack](http://lintcode.com/en/problem/min-stack/)|•[C++](./C++/min-stack.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (132 > 79)

README.md
| 154| |40|[Implement•Queue•by•Two•Stacks](http://lintcode.com/en/problem/implement-queue-by-two-stacks/)|•[C++](./C++/implement-queue-by-two-stacks.cpp)|•_O(1),•amortized_•|•_O(n)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (193 > 79)

README.md
| 155| |66|[Binary•Tree•Preorder•Traversal](http://lintcode.com/en/problem/binary-tree-preorder-traversal/)|•[C++](./C++/binary-tree-preorder-traversal.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•`Morris•Traversal`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (212 > 79)

README.md
| 156| |67|[Binary•Tree•Inorder•Traversal](http://lintcode.com/en/problem/binary-tree-inorder-traversal/)|•[C++](./C++/binary-tree-inorder-traversal.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•`Morris•Traversal`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (209 > 79)

README.md
| 157| |68|[Binary•Tree•Postorder•Traversal](http://lintcode.com/en/problem/binary-tree-postorder-traversal/)|•[C++](./C++/binary-tree-postorder-traversal.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•`Morris•Traversal`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (215 > 79)

README.md
| 158| |122|[Largest•Rectangle•in•Histogram](http://lintcode.com/en/problem/largest-rectangle-in-histogram/)|•[C++](./C++/largest-rectangle-in-histogram.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•LeetCode,•EPI•|•Ascending•Stack•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (210 > 79)

README.md
| 159| |126|[Max•Tree](http://lintcode.com/en/problem/max-tree/)|•[C++](./C++/max-tree.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•|•Descending•Stack•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (131 > 79)

README.md
| 160| |367|[Expression•Tree•Build](http://lintcode.com/en/problem/expression-tree-build/)|•[C++](./C++/expression-tree-build.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (153 > 79)

README.md
| 161| |368|[Expression•Evaluation](http://lintcode.com/en/problem/expression-evaluation/)|•[C++](./C++/expression-evaluation.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (153 > 79)

README.md
| 162| |369|[Convert•Expression•to•Polish•Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-notation/)|•[C++](./C++/convert-expression-to-polish-notation.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (202 > 79)

README.md
| 163| |370|[Convert•Expression•to•Reverse•Polish•Notation](http://lintcode.com/en/problem/convert-expression-to-reverse-polish-notation/)|•[C++](./C++/convert-expression-to-reverse-polish-notation.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (225 > 79)

README.md
| 164| |421|[Simplify•Path](http://lintcode.com/en/problem/simplify-path/)|•[C++](./C++/simplify-path.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (140 > 79)

README.md
| 165| |423|[Valid•Parentheses](http://lintcode.com/en/problem/valid-parentheses.cpp/)|•[C++](./C++/valid-parentheses.cpp.cpp)|•_O(n)_•|•_O(n)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (158 > 79)

README.md
| 166| |424|[Evaluate•Reverse•Polish•Notation](http://lintcode.com/en/problem/evaluate-reverse-polish-notation/)|•[C++](./C++/evaluate-reverse-polish-notation.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (197 > 79)

README.md
| 167| |473|[Add•and•Search•Word](http://lintcode.com/en/problem/add-and-search-word/)|•[C++](./C++/add-and-search-word.cpp)|•_O(min(n,•h))_•|•_O(min(n,•h)_•|•Medium•|•LeetCode•|•Trie•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (178 > 79)

README.md
| 168| |510|[Maximal•Rectangle](http://lintcode.com/en/problem/maximal-rectangle/)|•[C++](./C++/maximal-rectangle.cpp)|•_O(m•*•n)_•|•_O(n)_•|•Hard•|•LeetCode•|•Ascending•Stack•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 169| |528|[Flatten•Nested•List•Iterator](http://lintcode.com/en/problem/flatten-nested-list-iterator/)|•[C++](./C++/flatten-nested-list-iterator.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (185 > 79)

README.md
| 174| |362|[Sliding•Window•Maximum](http://lintcode.com/en/problem/sliding-window-maximum/)|•[C++](./C++/sliding-window-maximum.cpp)|•_O(n)_•|•_O(k)_•|•Hard•|•EPI•|•Deque,•Tricky•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (174 > 79)

README.md
| 179| |4|[Ugly•Number•II](http://lintcode.com/en/problem/ugly-number-ii/)|•[C++](./C++/ugly-number-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•CTCI•|•BST,•Heap•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (147 > 79)

README.md
| 180| |81|[Data•Stream•Median](http://lintcode.com/en/problem/data-stream-median/)|•[C++](./C++/data-stream-median.cpp)|•_O(nlogn)_•|•_O(n)_•|•Hard•|•EPI•|•BST,•Heap•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 181| |130|[Heapify](http://lintcode.com/en/problem/heapify/)|•[C++](./C++/heapify.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (113 > 79)

README.md
| 182| |364|[Trapping•Rain•Water•II](http://lintcode.com/en/problem/trapping-rain-water-ii/)|•[C++](./C++/trapping-rain-water-ii.cpp)|•_O(m•*•n•*•(logm•+•logn))_•|•_O(m•*•n)_•|•Hard•|•|•BFS,•Heap,•Tricky•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (198 > 79)

README.md
| 183| |518|[Super•Ugly•Number](http://lintcode.com/en/problem/super-ugly-number/)|•[C++](./C++/super-ugly-number.cpp)|•_O(n•*•k)_•|•_O(n•+•k)_•|•Medium•|•LeetCode•|•BST,•Heap•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 188| |56|[2•Sum](http://lintcode.com/en/problem/2-sum/)|•[C++](./C++/2-sum.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (115 > 79)

README.md
| 189| |124|[Longest•Consecutive•Sequence](http://lintcode.com/en/problem/longest-consecutive-sequence/)|•[C++](./C++/longest-consecutive-sequence.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (190 > 79)

README.md
| 190| |128|[Hash•Function](http://lintcode.com/en/problem/hash-function/)|•[C++](./C++/hash-function.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (129 > 79)

README.md
| 191| |129|[Rehashing](http://lintcode.com/en/problem/rehashing/)|•[C++](./C++/rehashing.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (119 > 79)

README.md
| 192| |138|[Subarray•Sum](http://lintcode.com/en/problem/subarray-sum/)|•[C++](./C++/subarray-sum.cpp)|•_O(n)_•|•_O(n)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (126 > 79)

README.md
| 193| |186|[Max•Points•on•a•Line](http://lintcode.com/en/problem/max-points-on-a-line/)|•[C++](./C++/max-points-on-a-line.cpp)|•_O(n^2)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (163 > 79)

README.md
| 194| |211|[String•Permutation](http://lintcode.com/en/problem/string-permutation/)|•[C++](./C++/string-permutation.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (144 > 79)

README.md
| 195| |384|[Longest•Substring•Without•Repeating•Characters](http://lintcode.com/en/problem/longest-substring-without-repeating-characters/)|•[C++](./C++/longest-substring-without-repeating-characters.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (244 > 79)

README.md
| 196| |386|[Longest•Substring•with•At•Most•K•Distinct•Characters](http://lintcode.com/en/problem/longest-substring-with-at-most-k-distinct-characters/)|•[C++](./C++/longest-substring-with-at-most-k-distinct-characters.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (248 > 79)

README.md
| 197| |432|[Find•the•Weak•Connected•Component•in•the•Directed•Graph](http://lintcode.com/en/problem/find-the-weak-connected-component-in-the-directed-graph/)|•[C++](./C++/find-the-weak-connected-component-in-the-directed-graph.cpp)|•_O(nlogn)_•|•_O(n)_•|•Medium•|•|•Union•Find•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (272 > 79)

README.md
| 198| |434|[Number•of•Islands•II](http://lintcode.com/en/problem/number-of-islands-ii/)|•[C++](./C++/number-of-islands-ii.cpp)|•_O(k)_•|•_O(k)_•|•Hard•|•|•Union•Find•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 199| |488|•[Happy•Number](http://lintcode.com/en/problem/happy-number/)••••••|•[C++](./C++/happy-number.cpp)•••|•_O(k)_••|•_O(k)_••••••••••|•Easy••••••••••|•LeetCode•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
| 200| 547|•[Intersection•of•Two•Arrays](http://lintcode.com/en/problem/intersection-of-two-arrays/)•|•[C++](./C++/intersection-of-two-arrays.cpp)•|•_O(m•+•n)_•|•_O(min(m,•n))_•|•Easy•••••••••|•EPI,•LeetCode•|•Two•Pointers,•Binary•Search
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (230 > 79)

README.md
| 201| 548|•[Intersection•of•Two•Arrays•II](http://lintcode.com/en/problem/intersection-of-two-arrays-ii/)•|•[C++](./C++/intersection-of-two-arrays-ii.cpp)•|•_O(m•+•n)_•|•_O(min(m,•n))_•|•Easy•••••••••|•EPI,•LeetCode•|•Two•Pointers,•Binary•Search
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (239 > 79)

README.md
| 206| |134|[LRU•Cache](http://lintcode.com/en/problem/lru-cache/)|•[C++](./C++/lru-cache.cpp)|•_O(1)_•|•_O(k)_•|•Hard•|•LeetCode,•EPI•|•List,•Hash•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (142 > 79)

README.md
| 211| |2|[Trailing•Zeros](http://lintcode.com/en/problem/trailing-zeros/)|•[C++](./C++/trailing-zeros.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (139 > 79)

README.md
| 212| |3|[Digit•Counts](http://lintcode.com/en/problem/digit-counts/)|•[C++](./C++/digit-counts.cpp)|•_O(1)_•|•_O(1)_•|•Medium•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (131 > 79)

README.md
| 213| |114|[Unique•Paths](http://lintcode.com/en/problem/unique-paths/)|•[C++](./C++/unique-paths.cpp)|•_O(min(m,•n))_•|•_O(1)_•|•Easy•|•LeetCode,•CTCI•|•DP,•Math•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (158 > 79)

README.md
| 214| |163|[Unique•Binary•Search•Trees](http://lintcode.com/en/problem/unique-binary-search-trees/)|•[C++](./C++/unique-binary-search-trees.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•CTCI•|•DP,•Math,•`Catalan•Number`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (202 > 79)

README.md
| 215| |180|[Binary•Represention](http://lintcode.com/en/problem/delete-digits/)|•[C++](./C++/binary-representation.cpp)|•_O(1)_•|•_O(1)_•|•Hard•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
| 216| |197|[Permutation•Index](http://lintcode.com/en/problem/permutation-index/)|•[C++](./C++/permutation-index.cpp)|•_O(n^2)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (143 > 79)

README.md
| 217| |198|[Permutation•Index•II](http://lintcode.com/en/problem/permutation-index-ii/)|•[C++](./C++/permutation-index-ii.cpp)|•_O(n^2)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (154 > 79)

README.md
| 218| |394|[Coins•in•a•Line](http://lintcode.com/en/problem/coins-in-a-line/)|•[C++](./C++/coins-in-a-line.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (135 > 79)

README.md
| 219| |411|[Gray•Code](http://lintcode.com/en/problem/gray-code/)|•[C++](./C++/gray-code.cpp)|•_O(2^n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (130 > 79)

README.md
| 220| |413|[Reverse•Integer](http://lintcode.com/en/problem/reverse-integer/)|•[C++](./C++/reverse-integer.cpp)|•_O(1)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 221| |414|[Divide•Two•Integer](http://lintcode.com/en/problem/divide-two-integers/)|•[C++](./C++/divide-two-integers.cpp)|•_O(1)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (157 > 79)

README.md
| 222| |418|[Integer•to•Roman](http://lintcode.com/en/problem/integer-to-roman/)|•[C++](./C++/integer-to-roman.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
| 223| |419|[Roman•to•Integer](http://lintcode.com/en/problem/roman-to-integer/)|•[C++](./C++/roman-to-integer.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
| 224| |428|•[Pow(x,•n)](http://lintcode.com/en/problem/powx-n/)•••••|•[C++](./C++/powx-n.cpp)•••••|•_O(1)_•••••••|•_O(1)_•••••••|•Medium•••••••••|•LeetCode•||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (152 > 79)

README.md
| 225| |445|[Cosine•Similarity](http://lintcode.com/en/problem/cosine-similarity/)|•[C++](./C++/cosine-similarity.cpp)•[Python](./Python/cosine-similarity.py)•|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (182 > 79)

README.md
| 226| |517|[Ugly•Number](http://lintcode.com/en/problem/ugly-number/)|•[C++](./C++/ugly-number.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•CTCI,•LeetCode•|••|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (139 > 79)

README.md
| 231| |5|[Kth•Largest•Element](http://lintcode.com/en/problem/kth-largest-element/)|•[C++](./C++/kth-largest-element.cpp)|•_O(n)_•~•_O(n^2)_•|•_O(1)_•|•Medium•|•EPI•|•Two•Pointers,•Quick•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (187 > 79)

README.md
| 232| |80|[Median](http://lintcode.com/en/problem/median/)|•[C++](./C++/median.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (111 > 79)

README.md
| 233| |139|[Subarray•Sum•Closest](http://lintcode.com/en/problem/subarray-sum-closest/)|•[C++](./C++/subarray-sum-closest.cpp)|•_O(nlogn)_•|•_O(n)_•|•Medium•|•|•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 234| |143|[Sort•Colors•II](http://lintcode.com/en/problem/sort-colors-ii/)|•[C++](./C++/sort-colors-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 235| |148|[Sort•Colors](http://lintcode.com/en/problem/sort-colors/)|•[C++](./C++/sort-colors.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 236| |156|[Merge•Intervals](http://lintcode.com/en/problem/merge-intervals/)|•[C++](./C++/merge-intervals.cpp)|•_O(nlogn)_•|•_O(1)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (153 > 79)

README.md
| 237| |184|[Largest•Number](http://lintcode.com/en/problem/largest-number/)|•[C++](./C++/largest-number.cpp)|•_O(nlogn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (147 > 79)

README.md
| 238| |366|[Fibonacci](http://lintcode.com/en/problem/fibonacci/)|•[C++](./C++/fibonacci.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (117 > 79)

README.md
| 239| |379|[Reorder•array•to•construct•the•minimum•number](http://lintcode.com/en/problem/reorder-array-to-construct-the-minimum-number/)|•[C++](./C++/reorder-array-to-construct-the-minimum-number.cpp)|•_O(nlogn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (240 > 79)

README.md
| 240| |387|[The•Smallest•Difference](http://lintcode.com/en/problem/the-smallest-difference/)|•[C++](./C++/the-smallest-difference.cpp)|•_O(max(m,•n)•*•log(min(m,•n)))_•|•_O(1)_•|•Medium•|•|•Two•Pointers,•Binary•Search•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (214 > 79)

README.md
| 241| |399|[Nuts•&•Bolts•Problem](http://lintcode.com/en/problem/nuts-bolts-problem/)|•[C++](./C++/nuts-bolts-problem.cpp)|•_O(nlogn)_•|•_O(logn)_•|•Medium•|•|•Quick•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (166 > 79)

README.md
| 242| |400|[Maximum•Gap](http://lintcode.com/en/problem/maximum-gap/)|•[C++](./C++/maximum-gap.cpp)•[Python](./Python/maximum-gap.py)|•_O(n)_•|•_O(n)_•|•Hard•|•LeetCode•|•Bucket•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (178 > 79)

README.md
| 243| |463|[Sort•Integers](http://lintcode.com/en/problem/sort-integers/)|•[C++](./C++/sort-integers.cpp)|•_O(n^2)_•|•_O(1)_•|•Easy•|•|•Insertion•Sort,•Selection•Sort,•Bubble•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (175 > 79)

README.md
| 244| |464|[Sort•Integers•II](http://lintcode.com/en/problem/sort-integers-ii/)|•[C++](./C++/sort-integers-ii.cpp)|•_O(nlogn)_•|•_O(n)_•|•Easy•|•|•Merge•Sort,•Heap•Sort,•Quick•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (176 > 79)

README.md
| 245| |507|[Wiggle•Sort•II](http://lintcode.com/en/problem/wiggle-sort-ii/)|•[C++](./C++/wiggle-sort-ii.cpp)|••_O(n)_•on•average•|•_O(1)_•|•Medium•|•LeetCode•|•Tri•Partition•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (169 > 79)

README.md
| 246| |508|[Wiggle•Sort](http://lintcode.com/en/problem/wiggle-sort/)|•[C++](./C++/wiggle-sort.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 251| |22|[Flatten•List](http://lintcode.com/en/problem/flatten-list/)|•[C++](./C++/flatten-list.cpp)|•_O(n)_•|•_O(h)_•|•Easy•||•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (124 > 79)

README.md
| 252| |72|[Construct•Binary•Tree•from•Inorder•and•Postorder•Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-inorder-and-postorder-traversal/)|•[C++](./C++/construct-binary-tree-from-inorder-and-postorder-traversal.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (279 > 79)

README.md
| 253| |73|[Construct•Binary•Tree•from•Preorder•and•Inorder•Traversal](http://lintcode.com/en/problem/construct-binary-tree-from-preorder-and-inorder-traversal/)|•[C++](./C++/construct-binary-tree-from-preorder-and-inorder-traversal.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (276 > 79)

README.md
| 254| |93|[Balanced•Binary•Tree](http://lintcode.com/en/problem/balanced-binary-tree/)|•[C++](./C++/balanced-binary-tree.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (158 > 79)

README.md
| 255| |94|[Binary•Tree•Maximum•Path•Sum](http://lintcode.com/en/problem/binary-tree-maximum-path-sum/)|•[C++](./C++/binary-tree-maximum-path-sum.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (184 > 79)

README.md
| 256| |95|[Validate•Binary•Search•Tree](http://lintcode.com/en/problem/validate-binary-search-tree/)|•[C++](./C++/validate-binary-search-tree.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (181 > 79)

README.md
| 257| |97|[Maximum•Depth•of•Binary•Tree](http://lintcode.com/en/problem/maximum-depth-of-binary-tree/)|•[C++](./C++/maximum-depth-of-binary-tree.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (182 > 79)

README.md
| 258| |131|[Building•Outline](http://lintcode.com/en/problem/building-outline/)|•[C++](./C++/building-outline.cpp)•[Python](./Python/building-outline.py)|•_O(nlogn)_•|•_O(n)_•|•Hard•|•EPI•|•Sort,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (195 > 79)

README.md
| 259| |140|[Fast•Power](http://lintcode.com/en/problem/fast-power/)|•[C++](./C++/fast-power.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (125 > 79)

README.md
| 260| |155|[Minimum•Depth•of•Binary•Tree](http://lintcode.com/en/problem/minimum-depth-of-binary-tree/)|•[C++](./C++/minimum-depth-of-binary-tree.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (183 > 79)

README.md
| 261| |164|[Unique•Binary•Search•Trees•II](http://lintcode.com/en/problem/unique-binary-search-trees-ii/)|•[C++](./C++/unique-binary-search-trees-ii.cpp)|•_O(n•*•4^n•/•n^(3/2))_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (204 > 79)

README.md
| 262| |177|[Convert•Sorted•Array•to•Binary•Search•Tree•With•Minimal•Height](http://lintcode.com/en/problem/convert-sorted-array-to-binary-search-tree-with-minimal-height/)|•[C++](./C++/convert-sorted-array-to-binary-search-tree-with-minimal-height.cpp)|•_O(n)_•|•_O(logn)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (288 > 79)

README.md
| 263| |201|[Segment•Tree•Build](http://lintcode.com/en/problem/segment-tree-build/)|•[C++](./C++/segment-tree-build.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 264| |202|[Segment•Tree•Query](http://lintcode.com/en/problem/segment-tree-query/)|•[C++](./C++/segment-tree-query.cpp)|•_O(h)_•|•_O(h)_•|•Medium•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 265| |203|[Segment•Tree•Modify](http://lintcode.com/en/problem/segment-tree-modify/)|•[C++](./C++/segment-tree-modify.cpp)|•_O(h)_•|•_O(h)_•|•Medium•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (167 > 79)

README.md
| 266| |205|[Interval•Minimum•Number](http://lintcode.com/en/problem/interval-minimum-number/)|•[C++](./C++/interval-minimum-number.cpp)|•build•tree:•_O(n)_,•query:•_(h)_•|•_O(h)_•|•Hard•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (203 > 79)

README.md
| 267| |206|[Interval•Sum](http://lintcode.com/en/problem/interval-sum/)|•[C++](./C++/interval-sum.cpp)|•build•tree:•_O(n)_,•query:•_O(logn)_•|•_O(n)_•|•Hard•|•|•Segment•Tree,•BIT•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (174 > 79)

README.md
| 268| |207|[Interval•Sum•II](http://lintcode.com/en/problem/interval-sum-ii/)|•[C++](./C++/interval-sum-ii.cpp)|•build•tree:•_O(n)_,•query:•_O(logn)_,•modify:•_O(logn)_•|•_O(n)_•|•Hard•|•|•Segment•Tree,•BIT•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (202 > 79)

README.md
| 269| |245|[Subtree](http://lintcode.com/en/problem/subtree/)|•[C++](./C++/subtree.cpp)|•_O(m•*•n)_•|•_O(1)_•|•Easy•|•|•`Morris•Traversal`•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 270| |247|[Segment•Tree•Query•II](http://lintcode.com/en/problem/segment-tree-query-ii/)|•[C++](./C++/segment-tree-query-ii.cpp)|•_O(h)_•|•_O(h)_•|•Hard•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (171 > 79)

README.md
| 271| |248|[Count•of•Smaller•Number](http://lintcode.com/en/problem/count-of-smaller-number/)|•[C++](./C++/count-of-smaller-number.cpp)|•build•tree:•_O(n)_,•query:•_O(logn)_•|•_O(h)_•|•Medium•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (209 > 79)

README.md
| 272| |371|[Print•Numbers•by•Recursion](http://lintcode.com/en/problem/print-numbers-by-recursion/)|•[C++](./C++/print-numbers-by-recursion.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (170 > 79)

README.md
| 273| |375|[Clone•Binary•Tree](http://lintcode.com/en/problem/clone-binary-tree/)|•[C++](./C++/clone-binary-tree.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (141 > 79)

README.md
| 274| |378|[Convert•Binary•Search•Tree•to•Doubly•Linked•List](http://lintcode.com/en/problem/convert-binary-search-tree-to-doubly-linked-list/)|•[C++](./C++/convert-binary-search-tree-to-doubly-linked-list.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (236 > 79)

README.md
| 275| |439|[Segment•Tree•Build•II](http://lintcode.com/en/problem/segmemt-tree-build-ii/)|•[C++](./C++/segment-tree-build-ii.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•|•Segment•Tree,•BST•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (173 > 79)

README.md
| 276| |453|[Flatten•Binary•Tree•to•Linked•List](http://lintcode.com/en/problem/flatten-binary-tree-to-linked-list/)|[C++](./C++/flatten-binary-tree-to-linked-list.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (200 > 79)

README.md
| 277| |469|•[Identical•Binary•Tree](http://lintcode.com/en/problem/problems/identical-binary-tree/)•••••|•[C++](./C++/identical-binary-tree.cpp)•••••|•_O(n)_•••••••|•_O(h)_•••••••|•Easy•••••••••|||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (191 > 79)

README.md
| 278| |532|[Reverse•Pairs](http://lintcode.com/en/problem/reverse-pairs/)|•[C++](./C++/reverse-pairs.cpp)|•_O(nlogn)_•|•_O(n)_•|•Medium•|•variant•of•[Count•of•Smaller•Number•before•itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/)•|•BIT,•Merge•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (273 > 79)

README.md
| 279| |535|[House•Robber•III](http://lintcode.com/en/problem/house-robber-iii/)|•[C++](./C++/house-robber-iii.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
| 284| |14|[First•Position•of•Target](http://lintcode.com/en/problem/first-position-of-target/)|•[C++](./C++/first-position-of-target.cpp)|•_O(logn)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 285| |28|[Search•a•2D•Matrix](http://lintcode.com/en/problem/search-a-2d-matrix/)|•[C++](./C++/search-a-2d-matrix.cpp)|•_O(logm•+•logn)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
| 286| |60|[Search•Insert•Position](http://lintcode.com/en/problem/search-insert-position/)|•[C++](./C++/search-insert-position.cpp)|•_O(logn)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (167 > 79)

README.md
| 287| |61|[Search•for•a•Range](http://lintcode.com/en/problem/search-for-a-range/)|•[C++](./C++/search-for-a-range.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (157 > 79)

README.md
| 288| |62|[Search•in•Rotated•Sorted•Array](http://lintcode.com/en/problem/search-in-rotated-sorted-array/)|•[C++](./C++/search-in-rotated-sorted-array.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (193 > 79)

README.md
| 289| |63|[Search•in•Rotated•Sorted•Array•II](http://lintcode.com/en/problem/search-in-rotated-sorted-array-ii/)|•[C++](./C++/search-in-rotated-sorted-array-ii.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (202 > 79)

README.md
| 290| |65|[Median•of•two•Sorted•Arrays](http://lintcode.com/en/problem/median-of-two-sorted-arrays/)|•[C++](./C++/median-of-two-sorted-arrays.cpp)|•_O(log(min(m,•n)))_•|•_O(1)_•|•Hard•|•LeetCode,•EPI•|•Tricky•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (204 > 79)

README.md
| 291| |74|[First•Bad•Version](http://lintcode.com/en/problem/first-bad-version/)|•[C++](./C++/first-bad-version.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (145 > 79)

README.md
| 292| |75|[Find•Peak•Element](http://lintcode.com/en/problem/find-peak-element/)|•[C++](./C++/find-peak-element.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (154 > 79)

README.md
| 293| |76|[Longest•Increasing•Subsequence](http://lintcode.com/en/problem/longest-increasing-subsequence/)|•[C++](./C++/longest-increasing-subsequence.cpp)|•_O(nlogn)_•|•_O(n)_•|•Medium•|•CTCI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (190 > 79)

README.md
| 294| |141|[Sqrt(x)](http://lintcode.com/en/problem/sqrtx/)|•[C++](./C++/sqrtx.cpp)|•_O(logn)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (119 > 79)

README.md
| 295| |159|[Find•Minimum•in•Rotated•Sorted•Array](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array/)|•[C++](./C++/find-minimum-in-rotated-sorted-array.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (212 > 79)

README.md
| 296| |160|[Find•Minimum•in•Rotated•Sorted•Array•II](http://lintcode.com/en/problem/find-minimum-in-rotated-sorted-array-ii/)|•[C++](./C++/find-minimum-in-rotated-sorted-array-ii.cpp)|•_O(logn)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (221 > 79)

README.md
| 297| |183|[Wood•Cut](http://lintcode.com/en/problem/wood-cut/)|•[C++](./C++/wood-cut.cpp)|•_O(nlogL)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (120 > 79)

README.md
| 298| |390|[Find•Peak•Element•II](http://lintcode.com/en/problem/find-peak-element-ii/)|•[C++](./C++/find-peak-element-ii.cpp)•[Java](./Java/find-peak-element-ii.java)•[Python](./Python/find-peak-element-ii.py)|•_O(m•+•n)_•|•_O(1)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (238 > 79)

README.md
| 299| |437|[Copy•Books](http://lintcode.com/en/problem/copy-books/)|•[C++](./C++/copy-books.cpp)•|•_O(nlogp)_•|•_O(1)_•|•Hard•|•UVa•714•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (133 > 79)

README.md
| 304| |69|[Binary•Tree•Level•Order•Traversal](http://lintcode.com/en/problem/binary-tree-level-order-traversal/)|•[C++](./C++/binary-tree-level-order-traversal.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (203 > 79)

README.md
| 305| |70|[Binary•Tree•Level•Order•Traversal•II](http://lintcode.com/en/problem/binary-tree-level-order-traversal-ii/)|•[C++](./C++/binary-tree-level-order-traversal-ii.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (212 > 79)

README.md
| 306| |71|[Binary•Tree•Zigzag•Level•Order•Traversal](http://lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/)|•[C++](./C++/binary-tree-zigzag-level-order-traversal.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•LeetCode•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (224 > 79)

README.md
| 307| |120|[Word•Ladder](http://lintcode.com/en/problem/word-ladder/)|•[C++](./C++/word-ladder.cpp)|•_O(n•*•d)_•|•_O(d)_•|•Medium•|•LeetCode•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (142 > 79)

README.md
| 308| |121|[Word•Ladder•II](http://lintcode.com/en/problem/word-ladder-ii/)|•[C++](./C++/word-ladder-ii.cpp)|•_O(n•*•d)_•|•_O(d)_•|•Hard•|•LeetCode•|•BFS,•Back•Trace•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 309| |127|[Topological•Sorting](http://lintcode.com/en/problem/topological-sorting/)|•[C++](./C++/topological-sorting.cpp)|•_O(\|V\|+\|E\|)_•|•_O(\|E\|)_•|•Medium•|•|•DFS,•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (172 > 79)

README.md
| 310| |137|[Clone•Graph](http://lintcode.com/en/problem/clone-graph/)|•[C++](./C++/clone-graph.cpp)|•_O(\|V\|+\|E\|)_•|•_O(\|V\|)_•|•Medium•|•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (143 > 79)

README.md
| 311| |176|[Route•Between•Two•Nodes•in•Graph](http://lintcode.com/en/problem/route-between-two-nodes-in-graph/)|•[C++](./C++/route-between-two-nodes-in-graph.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•DFS,•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (197 > 79)

README.md
| 312| |178|•[Graph•Valid•Tree](http://lintcode.com/en/problem/graph-valid-tree/)|•[C++](./C++/graph-valid-tree.cpp)•|•_O(\|V\|•+•\|E\|)_••••••••••|•_O(\|V\|•+•\|E\|)_••••••••••|•Medium•••••••••|•LeetCode•||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (200 > 79)

README.md
| 313| |431|[Find•the•Connected•Component•in•the•Undirected•Graph](http://lintcode.com/en/problem/find-the-connected-component-in-the-undirected-graph/)|•[C++](./C++/find-the-connected-component-in-the-undirected-graph.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•BFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (252 > 79)

README.md
| 314| |477|[Surrounded•Regions](http://lintcode.com/en/problem/surrounded-regions/)|[C++](./C++/surrounded-regions.cpp)|•_O(m•*•n)_•|•_O(m•+•n)_•|•Medium•••••••••|•LeetCode•||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (169 > 79)

README.md
| 319| |90|[K•Sum•II](http://lintcode.com/en/problem/k-sum-ii/)|•[C++](./C++/k-sum-ii.cpp)|•_O(k•*•C(n,•k))_•|•_O(k)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (125 > 79)

README.md
| 320| |376|[Binary•Tree•Path•Sum](http://lintcode.com/en/problem/binary-tree-path-sum/)|•[C++](./C++/binary-tree-path-sum.cpp)|•_O(n)_•|•_O(h)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (159 > 79)

README.md
| 321| |433|[Number•of•Islands](http://lintcode.com/en/problem/number-of-islands/)|•[C++](./C++/number-of-islands.cpp)|•_O(m•*•n)_•|•_O(m•*•n)_•|•Easy•|•LeetCode•|•DFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
| 322| |480|•[Binary•Tree•Paths](http://lintcode.com/en/problem/binary-tree-paths/)•|•[C++](./C++/binary-tree-paths.cpp)•|•_O(n•*•h)_•|•_O(h)_•|•Easy•••••••••|•LeetCode•||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 327| |15|[Permutations](http://lintcode.com/en/problem/permutations/)|•[C++](./C++/permutations.cpp)|•_O(n•*•n!)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 328| |16|[Permutations•II](http://lintcode.com/en/problem/permutations-ii/)|•[C++](./C++/permutations-ii.cpp)|•_O(n•*•n!)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (155 > 79)

README.md
| 329| |17|[Subsets](http://lintcode.com/en/problem/subsets/)|•[C++](./C++/subsets.cpp)|•_O(n•*•2^n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (127 > 79)

README.md
| 330| |18|[Subsets•II](http://lintcode.com/en/problem/subsets-ii/)|•[C++](./C++/subsets-ii.cpp)|•_O(n•*•2^n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (136 > 79)

README.md
| 331| |33|[N-Queens](http://lintcode.com/en/problem/n-queens/)|•[C++](./C++/n-queens.cpp)|•_O(n•*•n!)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 332| |34|[N-Queens•II](http://lintcode.com/en/problem/n-queens-ii/)|•[C++](./C++/n-queens-ii.cpp)|•_O(n•*•n!)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (143 > 79)

README.md
| 333| |123|[Word•Search](http://lintcode.com/en/problem/word-search/)|•[C++](./C++/word-search.cpp)|•_O(m•*•n•*•l)_•|•_O(l)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (142 > 79)

README.md
| 334| |132|[Word•Search•II](http://lintcode.com/en/problem/word-search-ii/)|•[C++](./C++/word-search-ii.cpp)|•_O(m•*•n•*•l)_•|•_O(l)_•|•Hard•|•|•Trie,•DFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (150 > 79)

README.md
| 335| |135|[Combination•Sum](http://lintcode.com/en/problem/combination-sum/)|•[C++](./C++/combination-sum.cpp)|•_O(k•*•n^k)_•|•_O(k)_•|•Medium•|•LeetCode•|•DFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (156 > 79)

README.md
| 336| |136|[Palindrome•Partitioning](http://lintcode.com/en/problem/palindrome-partitioning/)|•[C++](./C++/palindrome-partitioning.cpp)|•_O(2^n)_•|•_O(n)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (175 > 79)

README.md
| 337| |152|[Combinations](http://lintcode.com/en/problem/combinations/)|•[C++](./C++/combinations.cpp)|•_O(k•*•n^k)_•|•_O(k)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
| 338| |153|[Combination•Sum•II](http://lintcode.com/en/problem/combination-sum-ii/)|•[C++](./C++/combination-sum-ii.cpp)|•_O(k•*•C(n,•k))_•|•_O(k)_•|•Medium•|•LeetCode•|•DFS•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (169 > 79)

README.md
| 339| |425|[Letter•Combinations•of•a•Phone•Number](http://lintcode.com/en/problem/letter-combinations-of-a-phone-number/)•|•[C++](./C++/letter-combinations-of-a-phone-number.cpp)|•_O(n•*•4^n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (219 > 79)

README.md
| 340| |426|•[Restore•IP•Addresses](http://lintcode.com/en/problem/restore-ip-addresses/)•|•[C++](./C++/restore-ip-addresses.cpp)•|•_O(1)_•|•_O(1)_•|•Medium•••••••••|•LeetCode•||[C++](./C++/letter-combinations-of-a-phone-number.cpp)|•_O(n•*•4^n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (272 > 79)

README.md
| 341| |427|•[Generate•Parentheses](http://lintcode.com/en/problem/generate-parentheses/)|•[C++](./C++/generate-parentheses.cpp)|•_O(4^n•/•n^(3/2))_•|•_O(n)_•••|•Medium•••••••••|•LeetCode•||
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (183 > 79)

README.md
| 346| |11|[Search•Range•in•Binary•Search•Tree](http://lintcode.com/en/problem/search-range-in-binary-search-tree/)|•[C++](./C++/search-range-in-binary-search-tree.cpp)|•_O(n)_•|•_O(h)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (197 > 79)

README.md
| 347| |86|[Binary•Search•Tree•Iterator](http://lintcode.com/en/problem/binary-search-tree-iterator/)|•[C++](./C++/binary-search-tree-iterator.cpp)|•_O(1)_•|•_O(h)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (179 > 79)

README.md
| 348| |87|[Remove•Node•in•Binary•Search•Tree](http://lintcode.com/en/problem/remove-node-in-binary-search-tree/)|•[C++](./C++/remove-node-in-binary-search-tree.cpp)|•_O(h)_•|•_O(h)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (188 > 79)

README.md
| 349| |249|[Count•of•Smaller•Number•before•itself](http://lintcode.com/en/problem/count-of-smaller-number-before-itself/)|•[C++](./C++/count-of-smaller-number-before-itself.cpp)|•_O(nlogn)_•|•_O(n)_•|•Hard•|•|•BST,•BIT,•Divide•and•Conquer,•Merge•Sort•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (246 > 79)

README.md
| 350| |360|[Sliding•Window•Median](http://lintcode.com/en/problem/sliding-window-median/)|•[C++](./C++/sliding-window-median.cpp)|•_O(nlogw)_•|•_O(w)_•|•Hard•|•|•BST,•Tricky•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (169 > 79)

README.md
| 351| |391|[Number•of•Airplanes•in•the•Sky](http://lintcode.com/en/problem/number-of-airplanes-in-the-sky/)|•[C++](./C++/number-of-airplanes-in-the-sky.cpp)|•_O(nlogn)_•|•_O(n)_•|•Easy•|•|•BST,•Heap•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (194 > 79)

README.md
| 352| |401|[Kth•Smallest•Number•in•Sorted•Matrix](http://lintcode.com/en/problem/kth-smallest-number-in-sorted-matrix/)|•[C++](./C++/kth-smallest-number-in-sorted-matrix.cpp)|•_O(klog(min(m,•n,•k)))_•|•_O(min(m,•n,•k))_•|•Medium•|•|•BST,•Heap•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (238 > 79)

README.md
| 357| |20|[Dices•Sum](http://lintcode.com/en/problem/dices-sum/)|•[C++](./C++/dices-sum.cpp)|•_O(n^2)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (118 > 79)

README.md
| 358| |29|[Interleaving•String](http://lintcode.com/en/problem/interleaving-string/)|•[C++](./C++/interleaving-string.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 359| |43|[Maximum•Subarray•III](http://lintcode.com/en/problem/maximum-subarray-iii/)|•[C++](./C++/maximum-subarray-iii.cpp)|•_O(k•*•n)_•|•_O(k•*•n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (157 > 79)

README.md
| 360| |77|[Longest•Common•Subsequence](http://lintcode.com/en/problem/longest-common-subsequence/)|•[C++](./C++/longest-common-subsequence.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (181 > 79)

README.md
| 361| |79|[Longest•Common•Substring](http://lintcode.com/en/problem/longest-common-substring/)|•[C++](./C++/longest-common-substring.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (175 > 79)

README.md
| 362| |89|[K•Sum](http://lintcode.com/en/problem/k-sum/)|•[C++](./C++/k-sum.cpp)|•_O(k•*•n•*•t)_•|•_O(n•*•t)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (116 > 79)

README.md
| 363| |91|[Minimum•Adjustment•Cost](http://lintcode.com/en/problem/minimum-adjustment-cost/)|•[C++](./C++/minimum-adjustment-cost.cpp)|•_O(k•*•n•*•t)_•|•_O(k)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (168 > 79)

README.md
| 364| |92|[Backpack](http://lintcode.com/en/problem/backpack/)|•[C++](./C++/backpack.cpp)|•_O(m•*•n)_•|•_O(m)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (117 > 79)

README.md
| 365| |107|[Word•Break](http://lintcode.com/en/problem/word-break/)|•[C++](./C++/word-break.cpp)|•_O(n•*•l^2)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (142 > 79)

README.md
| 366| |108|[Palindrome•Partitioning•II](http://lintcode.com/en/problem/palindrome-partitioning-ii/)|•[C++](./C++/palindrome-partitioning-ii.cpp)|•_O(n^2)_•|•_O(n)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (186 > 79)

README.md
| 367| |109|[Triangle](http://lintcode.com/en/problem/triangle/)|•[C++](./C++/triangle.cpp)|•_O(n)_•|•_O(n)_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (128 > 79)

README.md
| 368| |110|[Minimum•Path•Sum](http://lintcode.com/en/problem/minimum-path-sum/)|•[C++](./C++/minimum-path-sum.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Easy•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (164 > 79)

README.md
| 369| |111|[Climbing•Stairs](http://lintcode.com/en/problem/climbing-stairs/)|•[C++](./C++/climbing-stairs.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (144 > 79)

README.md
| 370| |115|[Unique•Paths•II](http://lintcode.com/en/problem/unique-paths-ii/)|•[C++](./C++/unique-paths-ii.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Easy•|•LeetCode,•CTCI•|•DP,•Math•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (171 > 79)

README.md
| 371| |118|[Distinct•Subsequences](http://lintcode.com/en/problem/distinct-subsequences/)|•[C++](./C++/distinct-subsequences.cpp)|•_O(m•*•n)_•|•_O(m)_•|•Medium•|•LeetCode•|•DP•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (171 > 79)

README.md
| 372| |119|[Edit•Distance](http://lintcode.com/en/problem/edit-distance/)|•[C++](./C++/edit-distance.cpp)|•_O(m•*•n)_•|•_O(min(m,•n))_•|•Medium•|•LeetCode,•CTCI•|•DP•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (161 > 79)

README.md
| 373| |125|[Backpack•II](http://lintcode.com/en/problem/backpack-ii/)|•[C++](./C++/backpack-ii.cpp)|•_O(m•*•n)_•|•_O(m)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (129 > 79)

README.md
| 374| |149|[Best•Time•to•Buy•and•Sell•Stock](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock/)|•[C++](./C++/best-time-to-buy-and-sell-stock.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (199 > 79)

README.md
| 375| |150|[Best•Time•to•Buy•and•Sell•Stock•II](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-ii/)|•[C++](./C++/best-time-to-buy-and-sell-stock-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (208 > 79)

README.md
| 376| |151|[Best•Time•to•Buy•and•Sell•Stock•III](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iii/)|•[C++](./C++/best-time-to-buy-and-sell-stock-iii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (211 > 79)

README.md
| 377| |154|[Regular•Expression•Matching](http://lintcode.com/en/problem/regular-expression-matching/)|•[C++](./C++/regular-expression-matching.cpp)|•_O(m•*•n)_•|•_O(m)_•|•Hard•|•LeetCode•|•DP,•Recursion•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (198 > 79)

README.md
| 378| |168|[Burst•Balloons](http://lintcode.com/en/problem/burst-balloons/)|•[C++](./C++/burst-balloons.cpp)|•_O(n^3)_•|•_O(n^2)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (147 > 79)

README.md
| 379| |191|[Maximum•Product•Subarray](http://lintcode.com/en/problem/maximum-product-subarray/)|•[C++](./C++/maximum-product-subarray.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (173 > 79)

README.md
| 380| |392|[House•Robber](http://lintcode.com/en/problem/house-robber/)|•[C++](./C++/house-robber.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (137 > 79)

README.md
| 381| |393|[Best•Time•to•Buy•and•Sell•Stock•IV](http://lintcode.com/en/problem/best-time-to-buy-and-sell-stock-iv/)|•[C++](./C++/best-time-to-buy-and-sell-stock-iv.cpp)|•_O(k•*•n)_•|•_O(k)_•|•Hard•|•LeetCode,•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (210 > 79)

README.md
| 382| |395|[Coins•in•a•Line•II](http://lintcode.com/en/problem/coins-in-a-line-ii/)|•[C++](./C++/coins-in-a-line-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 383| |396|[Coins•in•a•Line•III](http://lintcode.com/en/problem/coins-in-a-line-iii/)|•[C++](./C++/coins-in-a-line-iii.cpp)|•_O(n^2)_•|•_O(n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (149 > 79)

README.md
| 384| |397|[Longest•Increasing•Continuous•subsequence](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence/)|•[C++](./C++/longest-increasing-continuous-subsequence.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (213 > 79)

README.md
| 385| |398|[Longest•Increasing•Continuous•subsequence•II](http://lintcode.com/en/problem/longest-increasing-continuous-subsequence-ii/)|•[C++](./C++/longest-increasing-continuous-subsequence-ii.cpp)|•_O(m•*•n)_•|•_O(m•*•n)_•|•Hard•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (230 > 79)

README.md
| 386| |403|[Continuous•Subarray•Sum•II](http://lintcode.com/en/problem/continuous-subarray-sum-ii/)|•[C++](./C++/continuous-subarray-sum-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (174 > 79)

README.md
| 387| |430|[Scramble•String](http://lintcode.com/en/problem/scramble-string/)|•[C++](./C++/scramble-string.cpp)|•_O(n^4)_•|•_O(n^3)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
| 388| |435|[Post•Office•Problem](http://lintcode.com/en/problem/post-office-problem/)|•[C++](./C++/post-office-problem.cpp)|•_O(k•*•n^2)_•|•_O(n)_•|•Hard•|•PKU•1160•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (162 > 79)

README.md
| 389| |436|[Maximal•Square](http://lintcode.com/en/problem/maximal-square/)|•[C++](./C++/maximal-square.cpp)|•_O(m•*•n)_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (147 > 79)

README.md
| 390| |512|[Decode•Ways](http://lintcode.com/en/problem/decode-ways/)|•[C++](./C++/decode-ways.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 391| |513|[Perfect•Squares](http://lintcode.com/en/problem/perfect-squares/)|•[C++](./C++/perfect-squares.cpp)|•_O(n•*•sqrt(n))_•|•_O(n)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (156 > 79)

README.md
| 392| |514|[Paint•Fence](http://lintcode.com/en/problem/paint-fence/)|•[C++](./C++/paint-fence.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (132 > 79)

README.md
| 393| |515|[Paint•House](http://lintcode.com/en/problem/paint-house/)|•[C++](./C++/paint-house.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (134 > 79)

README.md
| 394| |516|[Paint•House•II](http://lintcode.com/en/problem/paint-house-ii/)|•[C++](./C++/paint-house-ii.cpp)|•_O(n•*•k)_•|•_O(k)_•|•Hard•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (145 > 79)

README.md
| 395| |534|[House•Robber•II](http://lintcode.com/en/problem/house-robber-ii/)|•[C++](./C++/house-robber-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 396| |564|[Backpack•VI](http://lintcode.com/en/problem/backpack-vi/)|•[C++](./C++/backpack-vi.cpp)|•_O(n•*•t)_•|•_O(t)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (129 > 79)

README.md
| 401| |41|[Maximum•Subarray](http://lintcode.com/en/problem/maximum-subarray/)|•[C++](./C++/maximum-subarray.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (146 > 79)

README.md
| 402| |42|[Maximum•Subarray•II](http://lintcode.com/en/problem/maximum-subarray-ii/)|•[C++](./C++/maximum-subarray-ii.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (148 > 79)

README.md
| 403| |44|[Minimum•Subarray](http://lintcode.com/en/problem/minimum-subarray/)|•[C++](./C++/minimum-subarray.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (137 > 79)

README.md
| 404| |45|[Maximum•Subarray•Difference](http://lintcode.com/en/problem/maximum-subarray-difference/)|•[C++](./C++/maximum-subarray-difference.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (172 > 79)

README.md
| 405| |116|[Jump•Game](http://lintcode.com/en/problem/jump-game/)|•[C++](./C++/jump-game.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (128 > 79)

README.md
| 406| |117|[Jump•Game•II](http://lintcode.com/en/problem/jump-game-ii/)|•[C++](./C++/jump-game-ii.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (137 > 79)

README.md
| 407| |182|[Delete•Digits](http://lintcode.com/en/problem/delete-digits/)|•[C++](./C++/delete-digits.cpp)|•_O(n)_•|•_O(n)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (131 > 79)

README.md
| 408| |187|[Gas•Station](http://lintcode.com/en/problem/gas-station/)|•[C++](./C++/gas-station.cpp)|•_O(n)_•|•_O(1)_•|•Easy•|•LeetCode•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (132 > 79)

README.md
| 409| |192|[Wildcard•Matching](http://lintcode.com/en/problem/wildcard-matching/)|•[C++](./C++/wildcard-matching.cpp)|•_O(m•+•n)_•|•_O(1)_•|•Hard•|•LeetCode•|•Greedy,•DP,•Recursion•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (176 > 79)

README.md
| 410| |402|[Continuous•Subarray•Sum](http://lintcode.com/en/problem/continuous-subarray-sum/)|•[C++](./C++/continuous-subarray-sum.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•EPI•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (165 > 79)

README.md
| 411| |412|[Candy](http://lintcode.com/en/problem/candy/)|•[C++](./C++/candy.cpp)|•_O(n)_•|•_O(n)_•|•Hard•|•LeetCode•|•Greedy•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (121 > 79)

README.md
| 412| |552|•[Create•Maximum•Number](http://lintcode.com/en/problem/create-maximum-number/)|•[C++](./C++/create-maximum-number.cpp)•|•_O(k•*•(m•+•n•+•k))_•~•_O(k•*•(m•+•n•+•k^2))_|•_O(m•+•n•+•k^2)_•|•Hard•|•LeetCode•|•Greedy,•DP|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (222 > 79)

README.md
| 417| |204|[Singleton](http://lintcode.com/en/problem/singleton/)|•[C++](./C++/singleton.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (117 > 79)

README.md
| 418| |208|[Assignment•Operator•Overloading•(C++•Only)](http://lintcode.com/en/problem/assignment-operator-overloading-c-only/)|•[C++](./C++/assignment-operator-overloading-c-only.cpp)|•_O(n)_•|•_O(1)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (210 > 79)

README.md
| 419| |496|[Toy•Factory](http://www.lintcode.com/en/problem/toy-factory/)|•[C++](./C++/toy-factory.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (127 > 79)

README.md
| 420| |497|[Shape•Factory](http://www.lintcode.com/en/problem/shape-factory/)|•[C++](./C++/shape-factory.cpp)|•_O(1)_•|•_O(1)_•|•Easy•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (133 > 79)

README.md
| 421| |498|[Parking•Lot](http://www.lintcode.com/en/problem/parking-lot/)|•[C++](./C++/parking-lot.cpp)|•_O(n•*•m•*•k)_•|•_O(n•*•m•*•k)_•|•Hard•|•CTCI•|•OO•Design,•Pimpl•Idiom,•Smart•Pointer•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (186 > 79)

README.md
| 426| |501|[Mini•Twitter](http://www.lintcode.com/en/problem/mini-twitter/)|•[C++](./C++/mini-twitter.cpp)|•_O(klogu)_•|•_O(t•+•f)_•|•Medium•|•|•|
|    | [NORMAL] LineLengthBear:
|    | Line is longer than allowed. (140 > 79)
